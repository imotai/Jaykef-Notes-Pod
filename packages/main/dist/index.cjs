"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
var require$$1 = require("electron");
var require$$1$1 = require("path");
var require$$2 = require("url");
var require$$0$2 = require("fs");
var require$$0 = require("constants");
var require$$0$1 = require("stream");
var require$$4 = require("util");
var require$$5 = require("assert");
var require$$0$3 = require("events");
var require$$0$4 = require("crypto");
var require$$1$2 = require("string_decoder");
var require$$4$1 = require("fs/promises");
var require$$1$3 = require("os");
var require$$1$4 = require("child_process");
var require$$2$1 = require("zlib");
var require$$3$1 = require("http");
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
function _interopNamespace(e) {
  if (e && e.__esModule)
    return e;
  var n = { __proto__: null, [Symbol.toStringTag]: "Module" };
  if (e) {
    Object.keys(e).forEach(function(k) {
      if (k !== "default") {
        var d2 = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}
var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
var require$$1__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$2);
var require$$0__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
var require$$4__default = /* @__PURE__ */ _interopDefaultLegacy(require$$4);
var require$$5__default = /* @__PURE__ */ _interopDefaultLegacy(require$$5);
var require$$0__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$3);
var require$$0__default$4 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$4);
var require$$1__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$2);
var require$$4__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$4$1);
var require$$1__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$3);
var require$$1__default$4 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$4);
var require$$2__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$1);
var require$$3__default = /* @__PURE__ */ _interopDefaultLegacy(require$$3$1);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
class NonError extends Error {
  constructor(message) {
    super(NonError._prepareSuperMessage(message));
    Object.defineProperty(this, "name", {
      value: "NonError",
      configurable: true,
      writable: true
    });
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, NonError);
    }
  }
  static _prepareSuperMessage(message) {
    try {
      return JSON.stringify(message);
    } catch {
      return String(message);
    }
  }
}
const commonProperties = [
  { property: "name", enumerable: false },
  { property: "message", enumerable: false },
  { property: "stack", enumerable: false },
  { property: "code", enumerable: true }
];
const isCalled = Symbol(".toJSON called");
const toJSON = (from) => {
  from[isCalled] = true;
  const json2 = from.toJSON();
  delete from[isCalled];
  return json2;
};
const destroyCircular = ({
  from,
  seen,
  to_,
  forceEnumerable,
  maxDepth,
  depth
}) => {
  const to = to_ || (Array.isArray(from) ? [] : {});
  seen.push(from);
  if (depth >= maxDepth) {
    return to;
  }
  if (typeof from.toJSON === "function" && from[isCalled] !== true) {
    return toJSON(from);
  }
  for (const [key, value] of Object.entries(from)) {
    if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
      to[key] = "[object Buffer]";
      continue;
    }
    if (typeof value === "function") {
      continue;
    }
    if (!value || typeof value !== "object") {
      to[key] = value;
      continue;
    }
    if (!seen.includes(from[key])) {
      depth++;
      to[key] = destroyCircular({
        from: from[key],
        seen: seen.slice(),
        forceEnumerable,
        maxDepth,
        depth
      });
      continue;
    }
    to[key] = "[Circular]";
  }
  for (const { property, enumerable } of commonProperties) {
    if (typeof from[property] === "string") {
      Object.defineProperty(to, property, {
        value: from[property],
        enumerable: forceEnumerable ? true : enumerable,
        configurable: true,
        writable: true
      });
    }
  }
  return to;
};
const serializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (typeof value === "object" && value !== null) {
    return destroyCircular({
      from: value,
      seen: [],
      forceEnumerable: true,
      maxDepth,
      depth: 0
    });
  }
  if (typeof value === "function") {
    return `[Function: ${value.name || "anonymous"}]`;
  }
  return value;
};
const deserializeError$2 = (value, options = {}) => {
  const { maxDepth = Number.POSITIVE_INFINITY } = options;
  if (value instanceof Error) {
    return value;
  }
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    const newError = new Error();
    destroyCircular({
      from: value,
      seen: [],
      to_: newError,
      maxDepth,
      depth: 0
    });
    return newError;
  }
  return new NonError(value);
};
var serializeError_1 = {
  serializeError: serializeError$2,
  deserializeError: deserializeError$2
};
var util$6 = {};
const getUniqueId = () => `${Date.now()}-${Math.random()}`;
const getSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
const getRendererSendChannel = (channel) => `%better-ipc-send-channel-${channel}`;
util$6.currentWindowChannel = "%better-ipc-current-window";
util$6.getSendChannel = getSendChannel;
util$6.getRendererSendChannel = getRendererSendChannel;
util$6.getResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
util$6.getRendererResponseChannels = (channel) => {
  const id2 = getUniqueId();
  return {
    sendChannel: getRendererSendChannel(channel),
    dataChannel: `%better-ipc-response-data-channel-${channel}-${id2}`,
    errorChannel: `%better-ipc-response-error-channel-${channel}-${id2}`
  };
};
const electron$1 = require$$1__default["default"];
const { serializeError: serializeError$1, deserializeError: deserializeError$1 } = serializeError_1;
const util$5 = util$6;
const { ipcRenderer: ipcRenderer$1 } = electron$1;
const ipc$1 = Object.create(ipcRenderer$1 || {});
ipc$1.callMain = (channel, data) => new Promise((resolve2, reject) => {
  const { sendChannel, dataChannel, errorChannel } = util$5.getResponseChannels(channel);
  const cleanup = () => {
    ipcRenderer$1.off(dataChannel, onData);
    ipcRenderer$1.off(errorChannel, onError);
  };
  const onData = (_event, result) => {
    cleanup();
    resolve2(result);
  };
  const onError = (_event, error2) => {
    cleanup();
    reject(deserializeError$1(error2));
  };
  ipcRenderer$1.once(dataChannel, onData);
  ipcRenderer$1.once(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  ipcRenderer$1.send(sendChannel, completeData);
});
ipc$1.answerMain = (channel, callback) => {
  const sendChannel = util$5.getRendererSendChannel(channel);
  const listener = async (_event, data) => {
    const { dataChannel, errorChannel, userData } = data;
    try {
      ipcRenderer$1.send(dataChannel, await callback(userData));
    } catch (error2) {
      ipcRenderer$1.send(errorChannel, serializeError$1(error2));
    }
  };
  ipcRenderer$1.on(sendChannel, listener);
  return () => {
    ipcRenderer$1.off(sendChannel, listener);
  };
};
const electron = require$$1__default["default"];
const { serializeError, deserializeError } = serializeError_1;
const util$4 = util$6;
const { ipcMain: ipcMain$2, BrowserWindow } = electron;
const ipc = Object.create(ipcMain$2 || {});
ipc.callRenderer = (browserWindow, channel, data) => new Promise((resolve2, reject) => {
  if (!browserWindow) {
    throw new Error("Browser window required");
  }
  const { sendChannel, dataChannel, errorChannel } = util$4.getRendererResponseChannels(channel);
  const cleanup = () => {
    ipcMain$2.off(dataChannel, onData);
    ipcMain$2.off(errorChannel, onError);
  };
  const onData = (event, result) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      resolve2(result);
    }
  };
  const onError = (event, error2) => {
    const window2 = BrowserWindow.fromWebContents(event.sender);
    if (window2.id === browserWindow.id) {
      cleanup();
      reject(deserializeError(error2));
    }
  };
  ipcMain$2.on(dataChannel, onData);
  ipcMain$2.on(errorChannel, onError);
  const completeData = {
    dataChannel,
    errorChannel,
    userData: data
  };
  if (browserWindow.webContents) {
    browserWindow.webContents.send(sendChannel, completeData);
  }
});
ipc.callFocusedRenderer = async (...args) => {
  const focusedWindow = BrowserWindow.getFocusedWindow();
  if (!focusedWindow) {
    throw new Error("No browser window in focus");
  }
  return ipc.callRenderer(focusedWindow, ...args);
};
ipc.answerRenderer = (browserWindowOrChannel, channelOrCallback, callbackOrNothing) => {
  let window2;
  let channel;
  let callback;
  if (callbackOrNothing === void 0) {
    channel = browserWindowOrChannel;
    callback = channelOrCallback;
  } else {
    window2 = browserWindowOrChannel;
    channel = channelOrCallback;
    callback = callbackOrNothing;
    if (!window2) {
      throw new Error("Browser window required");
    }
  }
  const sendChannel = util$4.getSendChannel(channel);
  const listener = async (event, data) => {
    const browserWindow = BrowserWindow.fromWebContents(event.sender);
    if (window2 && window2.id !== browserWindow.id) {
      return;
    }
    const send = (channel2, data2) => {
      if (!(browserWindow && browserWindow.isDestroyed())) {
        event.sender.send(channel2, data2);
      }
    };
    const { dataChannel, errorChannel, userData } = data;
    try {
      send(dataChannel, await callback(userData, browserWindow));
    } catch (error2) {
      send(errorChannel, serializeError(error2));
    }
  };
  ipcMain$2.on(sendChannel, listener);
  return () => {
    ipcMain$2.off(sendChannel, listener);
  };
};
ipc.sendToRenderers = (channel, data) => {
  for (const browserWindow of BrowserWindow.getAllWindows()) {
    if (browserWindow.webContents) {
      browserWindow.webContents.send(channel, data);
    }
  }
};
var main$2 = ipc;
var ipcMain$1;
if (process.type === "renderer")
  ;
else {
  ipcMain$1 = main$2;
}
var fs$m = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function")
      fn.apply(this, args);
    else {
      return new Promise((resolve2, reject) => {
        fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve2(res));
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function")
      return fn.apply(this, args);
    else
      fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
  }, "name", { value: fn.name });
};
var constants$2 = require$$0__default["default"];
var origCwd = process.cwd;
var cwd = null;
var platform = process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d2) {
    cwd = null;
    chdir.call(process, d2);
  };
  if (Object.setPrototypeOf)
    Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$3;
function patch$3(fs2) {
  if (constants$2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (!fs2.lchmod) {
    fs2.lchmod = function(path2, mode, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (!fs2.lchown) {
    fs2.lchown = function(path2, uid, gid, cb) {
      if (cb)
        process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = function(fs$rename) {
      return function(from, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb)
            cb(er);
        });
      };
    }(fs2.rename);
  }
  fs2.read = function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf)
      Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs3) {
    fs3.lchmod = function(path2, mode, callback) {
      fs3.open(path2, constants$2.O_WRONLY | constants$2.O_SYMLINK, mode, function(err, fd) {
        if (err) {
          if (callback)
            callback(err);
          return;
        }
        fs3.fchmod(fd, mode, function(err2) {
          fs3.close(fd, function(err22) {
            if (callback)
              callback(err2 || err22);
          });
        });
      });
    };
    fs3.lchmodSync = function(path2, mode) {
      var fd = fs3.openSync(path2, constants$2.O_WRONLY | constants$2.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs3.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs3.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs3.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs3) {
    if (constants$2.hasOwnProperty("O_SYMLINK")) {
      fs3.lutimes = function(path2, at, mt, cb) {
        fs3.open(path2, constants$2.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb)
              cb(er);
            return;
          }
          fs3.futimes(fd, at, mt, function(er2) {
            fs3.close(fd, function(er22) {
              if (cb)
                cb(er2 || er22);
            });
          });
        });
      };
      fs3.lutimesSync = function(path2, at, mt) {
        var fd = fs3.openSync(path2, constants$2.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs3.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs3.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs3.closeSync(fd);
          }
        }
        return ret;
      };
    } else {
      fs3.lutimes = function(_a, _b, _c, cb) {
        if (cb)
          process.nextTick(cb);
      };
      fs3.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig)
      return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er))
          er = null;
        if (cb)
          cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er))
          throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig)
      return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        if (cb)
          cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig)
      return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats.uid < 0)
        stats.uid += 4294967296;
      if (stats.gid < 0)
        stats.gid += 4294967296;
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$0__default$1["default"].Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream,
    WriteStream
  };
  function ReadStream(path2, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(path2, options);
    Stream.call(this);
    var self2 = this;
    this.path = path2;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.encoding)
      this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self2._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self2.emit("error", err);
        self2.readable = false;
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2._read();
    });
  }
  function WriteStream(path2, options) {
    if (!(this instanceof WriteStream))
      return new WriteStream(path2, options);
    Stream.call(this);
    this.path = path2;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf(obj) };
  else
    var copy2 = Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$l = require$$0__default$2["default"];
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$3 = require$$4__default["default"];
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop() {
}
function publishQueue(context, queue2) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$9 = noop;
if (util$3.debuglog)
  debug$9 = util$3.debuglog("gfs4");
else if (/\bgfs4\b/i.test(""))
  debug$9 = function() {
    var m2 = util$3.format.apply(util$3, arguments);
    m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
    console.error(m2);
  };
if (!fs$l[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$l, queue);
  fs$l.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$l, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$l.close);
  fs$l.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$l, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$l.closeSync);
  if (/\bgfs4\b/i.test("")) {
    process.on("exit", function() {
      debug$9(fs$l[gracefulQueue]);
      require$$5__default["default"].equal(fs$l[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$l[gracefulQueue]);
}
var gracefulFs = patch$2(clone(fs$l));
function patch$2(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch$2;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path2, options, cb);
    function go$readFile(path3, options2, cb2, startTime) {
      return fs$readFile(path3, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path2, data, options, cb);
    function go$writeFile(path3, data2, options2, cb2, startTime) {
      return fs$writeFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path2, data, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path2, data, options, cb);
    function go$appendFile(path3, data2, options2, cb2, startTime) {
      return fs$appendFile(path3, data2, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src, dest, flags, cb);
    function go$copyFile(src2, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src2, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  function readdir(path2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readdir(path2, options, cb);
    function go$readdir(path3, options2, cb2, startTime) {
      return fs$readdir(path3, options2, function(err, files) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readdir, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (files && files.sort)
            files.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files);
        }
      });
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream;
    },
    set: function(val) {
      ReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream(path2, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path2, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path2, options) {
    return new fs2.ReadStream(path2, options);
  }
  function createWriteStream(path2, options) {
    return new fs2.WriteStream(path2, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path2, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path2, flags, mode, cb);
    function go$open(path3, flags2, mode2, cb2, startTime) {
      return fs$open(path3, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$9("ENQUEUE", elem[0].name, elem[1]);
  fs$l[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i2 = 0; i2 < fs$l[gracefulQueue].length; ++i2) {
    if (fs$l[gracefulQueue][i2].length > 2) {
      fs$l[gracefulQueue][i2][3] = now;
      fs$l[gracefulQueue][i2][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$l[gracefulQueue].length === 0)
    return;
  var elem = fs$l[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$9("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$9("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$9("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$l[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.realpath.native = u2(fs2.realpath.native);
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve2) => {
      return fs2.exists(filename, resolve2);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve2, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve2, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err)
          return reject(err);
        resolve2({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  if (typeof fs2.writev === "function") {
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.writev(fd, buffers, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
  }
})(fs$m);
var makeDir$1 = {};
var utils$1 = {};
const path$q = require$$1__default$1["default"];
utils$1.checkPath = function checkPath2(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$q.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$k = fs$m;
const { checkPath } = utils$1;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number")
    return options;
  return __spreadValues(__spreadValues({}, defaults2), options).mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath(dir);
  return fs$k.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath(dir);
  return fs$k.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$a = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$a(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const fs$j = gracefulFs;
function utimesMillis$1(path2, atime, mtime, callback) {
  fs$j.open(path2, "r+", (err, fd) => {
    if (err)
      return callback(err);
    fs$j.futimes(fd, atime, mtime, (futimesErr) => {
      fs$j.close(fd, (closeErr) => {
        if (callback)
          callback(futimesErr || closeErr);
      });
    });
  });
}
function utimesMillisSync$1(path2, atime, mtime) {
  const fd = fs$j.openSync(path2, "r+");
  fs$j.futimesSync(fd, atime, mtime);
  return fs$j.closeSync(fd);
}
var utimes = {
  utimesMillis: utimesMillis$1,
  utimesMillisSync: utimesMillisSync$1
};
const fs$i = fs$m;
const path$p = require$$1__default$1["default"];
const util$2 = require$$4__default["default"];
function getStats$2(src, dest, opts2) {
  const statFunc = opts2.dereference ? (file2) => fs$i.stat(file2, { bigint: true }) : (file2) => fs$i.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT")
        return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src, dest, opts2) {
  let destStat;
  const statFunc = opts2.dereference ? (file2) => fs$i.statSync(file2, { bigint: true }) : (file2) => fs$i.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT")
      return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
function checkPaths(src, dest, funcName, opts2, cb) {
  util$2.callbackify(getStats$2)(src, dest, opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    if (destStat) {
      if (areIdentical$2(srcStat, destStat)) {
        const srcBaseName = path$p.basename(src);
        const destBaseName = path$p.basename(dest);
        if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true });
        }
        return cb(new Error("Source and destination must not be the same."));
      }
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
      }
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return cb(null, { srcStat, destStat });
  });
}
function checkPathsSync(src, dest, funcName, opts2) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts2);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$p.basename(src);
      const destBaseName = path$p.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkParentPaths(src, srcStat, dest, funcName, cb) {
  const srcParent = path$p.resolve(path$p.dirname(src));
  const destParent = path$p.resolve(path$p.dirname(dest));
  if (destParent === srcParent || destParent === path$p.parse(destParent).root)
    return cb();
  fs$i.stat(destParent, { bigint: true }, (err, destStat) => {
    if (err) {
      if (err.code === "ENOENT")
        return cb();
      return cb(err);
    }
    if (areIdentical$2(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)));
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb);
  });
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
  const srcParent = path$p.resolve(path$p.dirname(src));
  const destParent = path$p.resolve(path$p.dirname(dest));
  if (destParent === srcParent || destParent === path$p.parse(destParent).root)
    return;
  let destStat;
  try {
    destStat = fs$i.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT")
      return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName));
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src, dest) {
  const srcArr = path$p.resolve(src).split(path$p.sep).filter((i2) => i2);
  const destArr = path$p.resolve(dest).split(path$p.sep).filter((i2) => i2);
  return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
}
function errMsg(src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$h = gracefulFs;
const path$o = require$$1__default$1["default"];
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$3 = stat$4;
function copySync$2(src, dest, opts2) {
  if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  const { srcStat, destStat } = stat$3.checkPathsSync(src, dest, "copy", opts2);
  stat$3.checkParentPathsSync(src, srcStat, dest, "copy");
  return handleFilterAndCopy(destStat, src, dest, opts2);
}
function handleFilterAndCopy(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  const destParent = path$o.dirname(dest);
  if (!fs$h.existsSync(destParent))
    mkdirsSync$1(destParent);
  return getStats$1(destStat, src, dest, opts2);
}
function startCopy$1(destStat, src, dest, opts2) {
  if (opts2.filter && !opts2.filter(src, dest))
    return;
  return getStats$1(destStat, src, dest, opts2);
}
function getStats$1(destStat, src, dest, opts2) {
  const statSync = opts2.dereference ? fs$h.statSync : fs$h.lstatSync;
  const srcStat = statSync(src);
  if (srcStat.isDirectory())
    return onDir$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
    return onFile$1(srcStat, destStat, src, dest, opts2);
  else if (srcStat.isSymbolicLink())
    return onLink$1(destStat, src, dest, opts2);
  else if (srcStat.isSocket())
    throw new Error(`Cannot copy a socket file: ${src}`);
  else if (srcStat.isFIFO())
    throw new Error(`Cannot copy a FIFO pipe: ${src}`);
  throw new Error(`Unknown file: ${src}`);
}
function onFile$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return copyFile$1(srcStat, src, dest, opts2);
  return mayCopyFile$1(srcStat, src, dest, opts2);
}
function mayCopyFile$1(srcStat, src, dest, opts2) {
  if (opts2.overwrite) {
    fs$h.unlinkSync(dest);
    return copyFile$1(srcStat, src, dest, opts2);
  } else if (opts2.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile$1(srcStat, src, dest, opts2) {
  fs$h.copyFileSync(src, dest);
  if (opts2.preserveTimestamps)
    handleTimestamps(srcStat.mode, src, dest);
  return setDestMode$1(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src, dest) {
  if (fileIsNotWritable$1(srcMode))
    makeFileWritable$1(dest, srcMode);
  return setDestTimestamps$1(src, dest);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return setDestMode$1(dest, srcMode | 128);
}
function setDestMode$1(dest, srcMode) {
  return fs$h.chmodSync(dest, srcMode);
}
function setDestTimestamps$1(src, dest) {
  const updatedSrcStat = fs$h.statSync(src);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir$1(srcStat, destStat, src, dest, opts2) {
  if (!destStat)
    return mkDirAndCopy$1(srcStat.mode, src, dest, opts2);
  return copyDir$1(src, dest, opts2);
}
function mkDirAndCopy$1(srcMode, src, dest, opts2) {
  fs$h.mkdirSync(dest);
  copyDir$1(src, dest, opts2);
  return setDestMode$1(dest, srcMode);
}
function copyDir$1(src, dest, opts2) {
  fs$h.readdirSync(src).forEach((item) => copyDirItem$1(item, src, dest, opts2));
}
function copyDirItem$1(item, src, dest, opts2) {
  const srcItem = path$o.join(src, item);
  const destItem = path$o.join(dest, item);
  const { destStat } = stat$3.checkPathsSync(srcItem, destItem, "copy", opts2);
  return startCopy$1(destStat, srcItem, destItem, opts2);
}
function onLink$1(destStat, src, dest, opts2) {
  let resolvedSrc = fs$h.readlinkSync(src);
  if (opts2.dereference) {
    resolvedSrc = path$o.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$h.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$h.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN")
        return fs$h.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts2.dereference) {
      resolvedDest = path$o.resolve(process.cwd(), resolvedDest);
    }
    if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (fs$h.statSync(dest).isDirectory() && stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink$1(resolvedSrc, dest);
  }
}
function copyLink$1(resolvedSrc, dest) {
  fs$h.unlinkSync(dest);
  return fs$h.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$2;
var copySync$1 = {
  copySync: copySync_1
};
const u$9 = universalify$1.fromPromise;
const fs$g = fs$m;
function pathExists$8(path2) {
  return fs$g.access(path2).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$9(pathExists$8),
  pathExistsSync: fs$g.existsSync
};
const fs$f = gracefulFs;
const path$n = require$$1__default$1["default"];
const mkdirs$1 = mkdirs$2.mkdirs;
const pathExists$7 = pathExists_1.pathExists;
const utimesMillis = utimes.utimesMillis;
const stat$2 = stat$4;
function copy$2(src, dest, opts2, cb) {
  if (typeof opts2 === "function" && !cb) {
    cb = opts2;
    opts2 = {};
  } else if (typeof opts2 === "function") {
    opts2 = { filter: opts2 };
  }
  cb = cb || function() {
  };
  opts2 = opts2 || {};
  opts2.clobber = "clobber" in opts2 ? !!opts2.clobber : true;
  opts2.overwrite = "overwrite" in opts2 ? !!opts2.overwrite : opts2.clobber;
  if (opts2.preserveTimestamps && process.arch === "ia32") {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
  }
  stat$2.checkPaths(src, dest, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, destStat } = stats;
    stat$2.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
      if (err2)
        return cb(err2);
      if (opts2.filter)
        return handleFilter(checkParentDir, destStat, src, dest, opts2, cb);
      return checkParentDir(destStat, src, dest, opts2, cb);
    });
  });
}
function checkParentDir(destStat, src, dest, opts2, cb) {
  const destParent = path$n.dirname(dest);
  pathExists$7(destParent, (err, dirExists) => {
    if (err)
      return cb(err);
    if (dirExists)
      return getStats(destStat, src, dest, opts2, cb);
    mkdirs$1(destParent, (err2) => {
      if (err2)
        return cb(err2);
      return getStats(destStat, src, dest, opts2, cb);
    });
  });
}
function handleFilter(onInclude, destStat, src, dest, opts2, cb) {
  Promise.resolve(opts2.filter(src, dest)).then((include) => {
    if (include)
      return onInclude(destStat, src, dest, opts2, cb);
    return cb();
  }, (error2) => cb(error2));
}
function startCopy(destStat, src, dest, opts2, cb) {
  if (opts2.filter)
    return handleFilter(getStats, destStat, src, dest, opts2, cb);
  return getStats(destStat, src, dest, opts2, cb);
}
function getStats(destStat, src, dest, opts2, cb) {
  const stat2 = opts2.dereference ? fs$f.stat : fs$f.lstat;
  stat2(src, (err, srcStat) => {
    if (err)
      return cb(err);
    if (srcStat.isDirectory())
      return onDir(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
      return onFile(srcStat, destStat, src, dest, opts2, cb);
    else if (srcStat.isSymbolicLink())
      return onLink(destStat, src, dest, opts2, cb);
    else if (srcStat.isSocket())
      return cb(new Error(`Cannot copy a socket file: ${src}`));
    else if (srcStat.isFIFO())
      return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
    return cb(new Error(`Unknown file: ${src}`));
  });
}
function onFile(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return copyFile(srcStat, src, dest, opts2, cb);
  return mayCopyFile(srcStat, src, dest, opts2, cb);
}
function mayCopyFile(srcStat, src, dest, opts2, cb) {
  if (opts2.overwrite) {
    fs$f.unlink(dest, (err) => {
      if (err)
        return cb(err);
      return copyFile(srcStat, src, dest, opts2, cb);
    });
  } else if (opts2.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`));
  } else
    return cb();
}
function copyFile(srcStat, src, dest, opts2, cb) {
  fs$f.copyFile(src, dest, (err) => {
    if (err)
      return cb(err);
    if (opts2.preserveTimestamps)
      return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
    return setDestMode(dest, srcStat.mode, cb);
  });
}
function handleTimestampsAndMode(srcMode, src, dest, cb) {
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, (err) => {
      if (err)
        return cb(err);
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    });
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 128, cb);
}
function setDestTimestampsAndMode(srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, (err) => {
    if (err)
      return cb(err);
    return setDestMode(dest, srcMode, cb);
  });
}
function setDestMode(dest, srcMode, cb) {
  return fs$f.chmod(dest, srcMode, cb);
}
function setDestTimestamps(src, dest, cb) {
  fs$f.stat(src, (err, updatedSrcStat) => {
    if (err)
      return cb(err);
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
  });
}
function onDir(srcStat, destStat, src, dest, opts2, cb) {
  if (!destStat)
    return mkDirAndCopy(srcStat.mode, src, dest, opts2, cb);
  return copyDir(src, dest, opts2, cb);
}
function mkDirAndCopy(srcMode, src, dest, opts2, cb) {
  fs$f.mkdir(dest, (err) => {
    if (err)
      return cb(err);
    copyDir(src, dest, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return setDestMode(dest, srcMode, cb);
    });
  });
}
function copyDir(src, dest, opts2, cb) {
  fs$f.readdir(src, (err, items2) => {
    if (err)
      return cb(err);
    return copyDirItems(items2, src, dest, opts2, cb);
  });
}
function copyDirItems(items2, src, dest, opts2, cb) {
  const item = items2.pop();
  if (!item)
    return cb();
  return copyDirItem(items2, item, src, dest, opts2, cb);
}
function copyDirItem(items2, item, src, dest, opts2, cb) {
  const srcItem = path$n.join(src, item);
  const destItem = path$n.join(dest, item);
  stat$2.checkPaths(srcItem, destItem, "copy", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { destStat } = stats;
    startCopy(destStat, srcItem, destItem, opts2, (err2) => {
      if (err2)
        return cb(err2);
      return copyDirItems(items2, src, dest, opts2, cb);
    });
  });
}
function onLink(destStat, src, dest, opts2, cb) {
  fs$f.readlink(src, (err, resolvedSrc) => {
    if (err)
      return cb(err);
    if (opts2.dereference) {
      resolvedSrc = path$n.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
      return fs$f.symlink(resolvedSrc, dest, cb);
    } else {
      fs$f.readlink(dest, (err2, resolvedDest) => {
        if (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs$f.symlink(resolvedSrc, dest, cb);
          return cb(err2);
        }
        if (opts2.dereference) {
          resolvedDest = path$n.resolve(process.cwd(), resolvedDest);
        }
        if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
        }
        if (destStat.isDirectory() && stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
        }
        return copyLink(resolvedSrc, dest, cb);
      });
    }
  });
}
function copyLink(resolvedSrc, dest, cb) {
  fs$f.unlink(dest, (err) => {
    if (err)
      return cb(err);
    return fs$f.symlink(resolvedSrc, dest, cb);
  });
}
var copy_1 = copy$2;
const u$8 = universalify$1.fromCallback;
var copy$1 = {
  copy: u$8(copy_1)
};
const fs$e = gracefulFs;
const path$m = require$$1__default$1["default"];
const assert = require$$5__default["default"];
const isWindows = process.platform === "win32";
function defaults$1(options) {
  const methods = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ];
  methods.forEach((m2) => {
    options[m2] = options[m2] || fs$e[m2];
    m2 = m2 + "Sync";
    options[m2] = options[m2] || fs$e[m2];
  });
  options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf$1(p, options, cb) {
  let busyTries = 0;
  if (typeof options === "function") {
    cb = options;
    options = {};
  }
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
  assert(options, "rimraf: invalid options argument provided");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  defaults$1(options);
  rimraf_(p, options, function CB(er) {
    if (er) {
      if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
        busyTries++;
        const time = busyTries * 100;
        return setTimeout(() => rimraf_(p, options, CB), time);
      }
      if (er.code === "ENOENT")
        er = null;
    }
    cb(er);
  });
}
function rimraf_(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.lstat(p, (er, st) => {
    if (er && er.code === "ENOENT") {
      return cb(null);
    }
    if (er && er.code === "EPERM" && isWindows) {
      return fixWinEPERM(p, options, er, cb);
    }
    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb);
    }
    options.unlink(p, (er2) => {
      if (er2) {
        if (er2.code === "ENOENT") {
          return cb(null);
        }
        if (er2.code === "EPERM") {
          return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
        }
        if (er2.code === "EISDIR") {
          return rmdir(p, options, er2, cb);
        }
      }
      return cb(er2);
    });
  });
}
function fixWinEPERM(p, options, er, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.chmod(p, 438, (er2) => {
    if (er2) {
      cb(er2.code === "ENOENT" ? null : er);
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === "ENOENT" ? null : er);
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb);
        } else {
          options.unlink(p, cb);
        }
      });
    }
  });
}
function fixWinEPERMSync(p, options, er) {
  let stats;
  assert(p);
  assert(options);
  try {
    options.chmodSync(p, 438);
  } catch (er2) {
    if (er2.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  try {
    stats = options.statSync(p);
  } catch (er3) {
    if (er3.code === "ENOENT") {
      return;
    } else {
      throw er;
    }
  }
  if (stats.isDirectory()) {
    rmdirSync(p, options, er);
  } else {
    options.unlinkSync(p);
  }
}
function rmdir(p, options, originalEr, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.rmdir(p, (er) => {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
      rmkids(p, options, cb);
    } else if (er && er.code === "ENOTDIR") {
      cb(originalEr);
    } else {
      cb(er);
    }
  });
}
function rmkids(p, options, cb) {
  assert(p);
  assert(options);
  assert(typeof cb === "function");
  options.readdir(p, (er, files) => {
    if (er)
      return cb(er);
    let n = files.length;
    let errState;
    if (n === 0)
      return options.rmdir(p, cb);
    files.forEach((f) => {
      rimraf$1(path$m.join(p, f), options, (er2) => {
        if (errState) {
          return;
        }
        if (er2)
          return cb(errState = er2);
        if (--n === 0) {
          options.rmdir(p, cb);
        }
      });
    });
  });
}
function rimrafSync(p, options) {
  let st;
  options = options || {};
  defaults$1(options);
  assert(p, "rimraf: missing path");
  assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
  assert(options, "rimraf: missing options");
  assert.strictEqual(typeof options, "object", "rimraf: options should be object");
  try {
    st = options.lstatSync(p);
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    }
    if (er.code === "EPERM" && isWindows) {
      fixWinEPERMSync(p, options, er);
    }
  }
  try {
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null);
    } else {
      options.unlinkSync(p);
    }
  } catch (er) {
    if (er.code === "ENOENT") {
      return;
    } else if (er.code === "EPERM") {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
    } else if (er.code !== "EISDIR") {
      throw er;
    }
    rmdirSync(p, options, er);
  }
}
function rmdirSync(p, options, originalEr) {
  assert(p);
  assert(options);
  try {
    options.rmdirSync(p);
  } catch (er) {
    if (er.code === "ENOTDIR") {
      throw originalEr;
    } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
      rmkidsSync(p, options);
    } else if (er.code !== "ENOENT") {
      throw er;
    }
  }
}
function rmkidsSync(p, options) {
  assert(p);
  assert(options);
  options.readdirSync(p).forEach((f) => rimrafSync(path$m.join(p, f), options));
  if (isWindows) {
    const startTime = Date.now();
    do {
      try {
        const ret = options.rmdirSync(p, options);
        return ret;
      } catch {
      }
    } while (Date.now() - startTime < 500);
  } else {
    const ret = options.rmdirSync(p, options);
    return ret;
  }
}
var rimraf_1 = rimraf$1;
rimraf$1.sync = rimrafSync;
const fs$d = gracefulFs;
const u$7 = universalify$1.fromCallback;
const rimraf = rimraf_1;
function remove$2(path2, callback) {
  if (fs$d.rm)
    return fs$d.rm(path2, { recursive: true, force: true }, callback);
  rimraf(path2, callback);
}
function removeSync$1(path2) {
  if (fs$d.rmSync)
    return fs$d.rmSync(path2, { recursive: true, force: true });
  rimraf.sync(path2);
}
var remove_1 = {
  remove: u$7(remove$2),
  removeSync: removeSync$1
};
const u$6 = universalify$1.fromPromise;
const fs$c = fs$m;
const path$l = require$$1__default$1["default"];
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$6(async function emptyDir2(dir) {
  let items2;
  try {
    items2 = await fs$c.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items2.map((item) => remove$1.remove(path$l.join(dir, item))));
});
function emptyDirSync(dir) {
  let items2;
  try {
    items2 = fs$c.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items2.forEach((item) => {
    item = path$l.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$5 = universalify$1.fromCallback;
const path$k = require$$1__default$1["default"];
const fs$b = gracefulFs;
const mkdir$2 = mkdirs$2;
function createFile(file2, callback) {
  function makeFile() {
    fs$b.writeFile(file2, "", (err) => {
      if (err)
        return callback(err);
      callback();
    });
  }
  fs$b.stat(file2, (err, stats) => {
    if (!err && stats.isFile())
      return callback();
    const dir = path$k.dirname(file2);
    fs$b.stat(dir, (err2, stats2) => {
      if (err2) {
        if (err2.code === "ENOENT") {
          return mkdir$2.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        }
        return callback(err2);
      }
      if (stats2.isDirectory())
        makeFile();
      else {
        fs$b.readdir(dir, (err3) => {
          if (err3)
            return callback(err3);
        });
      }
    });
  });
}
function createFileSync(file2) {
  let stats;
  try {
    stats = fs$b.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile())
    return;
  const dir = path$k.dirname(file2);
  try {
    if (!fs$b.statSync(dir).isDirectory()) {
      fs$b.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT")
      mkdir$2.mkdirsSync(dir);
    else
      throw err;
  }
  fs$b.writeFileSync(file2, "");
}
var file$1 = {
  createFile: u$5(createFile),
  createFileSync
};
const u$4 = universalify$1.fromCallback;
const path$j = require$$1__default$1["default"];
const fs$a = gracefulFs;
const mkdir$1 = mkdirs$2;
const pathExists$6 = pathExists_1.pathExists;
const { areIdentical: areIdentical$1 } = stat$4;
function createLink(srcpath, dstpath, callback) {
  function makeLink(srcpath2, dstpath2) {
    fs$a.link(srcpath2, dstpath2, (err) => {
      if (err)
        return callback(err);
      callback(null);
    });
  }
  fs$a.lstat(dstpath, (_, dstStat) => {
    fs$a.lstat(srcpath, (err, srcStat) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        return callback(err);
      }
      if (dstStat && areIdentical$1(srcStat, dstStat))
        return callback(null);
      const dir = path$j.dirname(dstpath);
      pathExists$6(dir, (err2, dirExists) => {
        if (err2)
          return callback(err2);
        if (dirExists)
          return makeLink(srcpath, dstpath);
        mkdir$1.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          makeLink(srcpath, dstpath);
        });
      });
    });
  });
}
function createLinkSync(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$a.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$a.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat))
      return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$j.dirname(dstpath);
  const dirExists = fs$a.existsSync(dir);
  if (dirExists)
    return fs$a.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$a.linkSync(srcpath, dstpath);
}
var link$1 = {
  createLink: u$4(createLink),
  createLinkSync
};
const path$i = require$$1__default$1["default"];
const fs$9 = gracefulFs;
const pathExists$5 = pathExists_1.pathExists;
function symlinkPaths$1(srcpath, dstpath, callback) {
  if (path$i.isAbsolute(srcpath)) {
    return fs$9.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        return callback(err);
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      });
    });
  } else {
    const dstdir = path$i.dirname(dstpath);
    const relativeToDst = path$i.join(dstdir, srcpath);
    return pathExists$5(relativeToDst, (err, exists) => {
      if (err)
        return callback(err);
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        });
      } else {
        return fs$9.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path$i.relative(dstdir, srcpath)
          });
        });
      }
    });
  }
}
function symlinkPathsSync$1(srcpath, dstpath) {
  let exists;
  if (path$i.isAbsolute(srcpath)) {
    exists = fs$9.existsSync(srcpath);
    if (!exists)
      throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  } else {
    const dstdir = path$i.dirname(dstpath);
    const relativeToDst = path$i.join(dstdir, srcpath);
    exists = fs$9.existsSync(relativeToDst);
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      };
    } else {
      exists = fs$9.existsSync(srcpath);
      if (!exists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path$i.relative(dstdir, srcpath)
      };
    }
  }
}
var symlinkPaths_1 = {
  symlinkPaths: symlinkPaths$1,
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$8 = gracefulFs;
function symlinkType$1(srcpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  if (type2)
    return callback(null, type2);
  fs$8.lstat(srcpath, (err, stats) => {
    if (err)
      return callback(null, "file");
    type2 = stats && stats.isDirectory() ? "dir" : "file";
    callback(null, type2);
  });
}
function symlinkTypeSync$1(srcpath, type2) {
  let stats;
  if (type2)
    return type2;
  try {
    stats = fs$8.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: symlinkType$1,
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromCallback;
const path$h = require$$1__default$1["default"];
const fs$7 = fs$m;
const _mkdirs = mkdirs$2;
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = symlinkPaths_1;
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = symlinkType_1;
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists$4 = pathExists_1.pathExists;
const { areIdentical } = stat$4;
function createSymlink(srcpath, dstpath, type2, callback) {
  callback = typeof type2 === "function" ? type2 : callback;
  type2 = typeof type2 === "function" ? false : type2;
  fs$7.lstat(dstpath, (err, stats) => {
    if (!err && stats.isSymbolicLink()) {
      Promise.all([
        fs$7.stat(srcpath),
        fs$7.stat(dstpath)
      ]).then(([srcStat, dstStat]) => {
        if (areIdentical(srcStat, dstStat))
          return callback(null);
        _createSymlink(srcpath, dstpath, type2, callback);
      });
    } else
      _createSymlink(srcpath, dstpath, type2, callback);
  });
}
function _createSymlink(srcpath, dstpath, type2, callback) {
  symlinkPaths(srcpath, dstpath, (err, relative) => {
    if (err)
      return callback(err);
    srcpath = relative.toDst;
    symlinkType(relative.toCwd, type2, (err2, type3) => {
      if (err2)
        return callback(err2);
      const dir = path$h.dirname(dstpath);
      pathExists$4(dir, (err3, dirExists) => {
        if (err3)
          return callback(err3);
        if (dirExists)
          return fs$7.symlink(srcpath, dstpath, type3, callback);
        mkdirs(dir, (err4) => {
          if (err4)
            return callback(err4);
          fs$7.symlink(srcpath, dstpath, type3, callback);
        });
      });
    });
  });
}
function createSymlinkSync(srcpath, dstpath, type2) {
  let stats;
  try {
    stats = fs$7.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$7.statSync(srcpath);
    const dstStat = fs$7.statSync(dstpath);
    if (areIdentical(srcStat, dstStat))
      return;
  }
  const relative = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative.toDst;
  type2 = symlinkTypeSync(relative.toCwd, type2);
  const dir = path$h.dirname(dstpath);
  const exists = fs$7.existsSync(dir);
  if (exists)
    return fs$7.symlinkSync(srcpath, dstpath, type2);
  mkdirsSync(dir);
  return fs$7.symlinkSync(srcpath, dstpath, type2);
}
var symlink$1 = {
  createSymlink: u$3(createSymlink),
  createSymlinkSync
};
const file = file$1;
const link = link$1;
const symlink = symlink$1;
var ensure = {
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
};
function stringify$4(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content))
    content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils = { stringify: stringify$4, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0__default$2["default"];
}
const universalify = universalify$1;
const { stringify: stringify$3, stripBom } = utils;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data = await universalify.fromCallback(fs2.readFile)(file2, options);
  data = stripBom(data);
  let obj;
  try {
    obj = JSON.parse(data, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile$1 = universalify.fromPromise(_readFile);
function readFileSync$1(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile$1 = universalify.fromPromise(_writeFile);
function writeFileSync$1(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$3(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile: readFile$1,
  readFileSync: readFileSync$1,
  writeFile: writeFile$1,
  writeFileSync: writeFileSync$1
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromCallback;
const fs$6 = gracefulFs;
const path$g = require$$1__default$1["default"];
const mkdir = mkdirs$2;
const pathExists$3 = pathExists_1.pathExists;
function outputFile$1(file2, data, encoding, callback) {
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = "utf8";
  }
  const dir = path$g.dirname(file2);
  pathExists$3(dir, (err, itDoes) => {
    if (err)
      return callback(err);
    if (itDoes)
      return fs$6.writeFile(file2, data, encoding, callback);
    mkdir.mkdirs(dir, (err2) => {
      if (err2)
        return callback(err2);
      fs$6.writeFile(file2, data, encoding, callback);
    });
  });
}
function outputFileSync$1(file2, ...args) {
  const dir = path$g.dirname(file2);
  if (fs$6.existsSync(dir)) {
    return fs$6.writeFileSync(file2, ...args);
  }
  mkdir.mkdirsSync(dir);
  fs$6.writeFileSync(file2, ...args);
}
var output = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$2 } = utils;
const { outputFile } = output;
async function outputJson(file2, data, options = {}) {
  const str2 = stringify$2(data, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify: stringify$1 } = utils;
const { outputFileSync } = output;
function outputJsonSync(file2, data, options) {
  const str2 = stringify$1(data, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json$1 = jsonFile;
const fs$5 = gracefulFs;
const path$f = require$$1__default$1["default"];
const copySync = copySync$1.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat$1 = stat$4;
function moveSync$1(src, dest, opts2) {
  opts2 = opts2 || {};
  const overwrite = opts2.overwrite || opts2.clobber || false;
  const { srcStat, isChangingCase = false } = stat$1.checkPathsSync(src, dest, "move", opts2);
  stat$1.checkParentPathsSync(src, srcStat, dest, "move");
  if (!isParentRoot$1(dest))
    mkdirpSync(path$f.dirname(dest));
  return doRename$1(src, dest, overwrite, isChangingCase);
}
function isParentRoot$1(dest) {
  const parent = path$f.dirname(dest);
  const parsedPath = path$f.parse(parent);
  return parsedPath.root === parent;
}
function doRename$1(src, dest, overwrite, isChangingCase) {
  if (isChangingCase)
    return rename$1(src, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename$1(src, dest, overwrite);
  }
  if (fs$5.existsSync(dest))
    throw new Error("dest already exists.");
  return rename$1(src, dest, overwrite);
}
function rename$1(src, dest, overwrite) {
  try {
    fs$5.renameSync(src, dest);
  } catch (err) {
    if (err.code !== "EXDEV")
      throw err;
    return moveAcrossDevice$1(src, dest, overwrite);
  }
}
function moveAcrossDevice$1(src, dest, overwrite) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copySync(src, dest, opts2);
  return removeSync(src);
}
var moveSync_1 = moveSync$1;
var moveSync = {
  moveSync: moveSync_1
};
const fs$4 = gracefulFs;
const path$e = require$$1__default$1["default"];
const copy = copy$1.copy;
const remove = remove_1.remove;
const mkdirp = mkdirs$2.mkdirp;
const pathExists$2 = pathExists_1.pathExists;
const stat = stat$4;
function move$1(src, dest, opts2, cb) {
  if (typeof opts2 === "function") {
    cb = opts2;
    opts2 = {};
  }
  const overwrite = opts2.overwrite || opts2.clobber || false;
  stat.checkPaths(src, dest, "move", opts2, (err, stats) => {
    if (err)
      return cb(err);
    const { srcStat, isChangingCase = false } = stats;
    stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
      if (err2)
        return cb(err2);
      if (isParentRoot(dest))
        return doRename(src, dest, overwrite, isChangingCase, cb);
      mkdirp(path$e.dirname(dest), (err3) => {
        if (err3)
          return cb(err3);
        return doRename(src, dest, overwrite, isChangingCase, cb);
      });
    });
  });
}
function isParentRoot(dest) {
  const parent = path$e.dirname(dest);
  const parsedPath = path$e.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src, dest, overwrite, isChangingCase, cb) {
  if (isChangingCase)
    return rename(src, dest, overwrite, cb);
  if (overwrite) {
    return remove(dest, (err) => {
      if (err)
        return cb(err);
      return rename(src, dest, overwrite, cb);
    });
  }
  pathExists$2(dest, (err, destExists) => {
    if (err)
      return cb(err);
    if (destExists)
      return cb(new Error("dest already exists."));
    return rename(src, dest, overwrite, cb);
  });
}
function rename(src, dest, overwrite, cb) {
  fs$4.rename(src, dest, (err) => {
    if (!err)
      return cb();
    if (err.code !== "EXDEV")
      return cb(err);
    return moveAcrossDevice(src, dest, overwrite, cb);
  });
}
function moveAcrossDevice(src, dest, overwrite, cb) {
  const opts2 = {
    overwrite,
    errorOnExist: true
  };
  copy(src, dest, opts2, (err) => {
    if (err)
      return cb(err);
    return remove(src, cb);
  });
}
var move_1 = move$1;
const u = universalify$1.fromCallback;
var move = {
  move: u(move_1)
};
var lib = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, fs$m), copySync$1), copy$1), empty), ensure), json$1), mkdirs$2), moveSync), move), output), pathExists_1), remove_1);
var main$1 = {};
var out = {};
var CancellationToken$1 = {};
Object.defineProperty(CancellationToken$1, "__esModule", { value: true });
CancellationToken$1.CancellationError = CancellationToken$1.CancellationToken = void 0;
const events_1$1 = require$$0__default$3["default"];
class CancellationToken extends events_1$1.EventEmitter {
  constructor(parent) {
    super();
    this.parentCancelHandler = null;
    this._parent = null;
    this._cancelled = false;
    if (parent != null) {
      this.parent = parent;
    }
  }
  get cancelled() {
    return this._cancelled || this._parent != null && this._parent.cancelled;
  }
  set parent(value) {
    this.removeParentCancelHandler();
    this._parent = value;
    this.parentCancelHandler = () => this.cancel();
    this._parent.onCancel(this.parentCancelHandler);
  }
  cancel() {
    this._cancelled = true;
    this.emit("cancel");
  }
  onCancel(handler) {
    if (this.cancelled) {
      handler();
    } else {
      this.once("cancel", handler);
    }
  }
  createPromise(callback) {
    if (this.cancelled) {
      return Promise.reject(new CancellationError());
    }
    const finallyHandler = () => {
      if (cancelHandler != null) {
        try {
          this.removeListener("cancel", cancelHandler);
          cancelHandler = null;
        } catch (ignore) {
        }
      }
    };
    let cancelHandler = null;
    return new Promise((resolve2, reject) => {
      let addedCancelHandler = null;
      cancelHandler = () => {
        try {
          if (addedCancelHandler != null) {
            addedCancelHandler();
            addedCancelHandler = null;
          }
        } finally {
          reject(new CancellationError());
        }
      };
      if (this.cancelled) {
        cancelHandler();
        return;
      }
      this.onCancel(cancelHandler);
      callback(resolve2, reject, (callback2) => {
        addedCancelHandler = callback2;
      });
    }).then((it) => {
      finallyHandler();
      return it;
    }).catch((e) => {
      finallyHandler();
      throw e;
    });
  }
  removeParentCancelHandler() {
    const parent = this._parent;
    if (parent != null && this.parentCancelHandler != null) {
      parent.removeListener("cancel", this.parentCancelHandler);
      this.parentCancelHandler = null;
    }
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners();
      this._parent = null;
    }
  }
}
CancellationToken$1.CancellationToken = CancellationToken;
class CancellationError extends Error {
  constructor() {
    super("cancelled");
  }
}
CancellationToken$1.CancellationError = CancellationError;
var httpExecutor = {};
var browser = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type2 = typeof val;
  if (type2 === "string" && val.length > 0) {
    return parse$c(val);
  } else if (type2 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse$c(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str2);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type2 = (match[2] || "ms").toLowerCase();
  switch (type2) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
function setup(env2) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy;
  Object.keys(env2).forEach((key) => {
    createDebug[key] = env2[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend3;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend3(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i2 = 0; i2 < len; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i2;
    let len;
    for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
      if (createDebug.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
      if (createDebug.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$6 = setup;
(function(module, exports) {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load2;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  module.exports = common$6(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
})(browser, browser.exports);
var ProgressCallbackTransform$1 = {};
Object.defineProperty(ProgressCallbackTransform$1, "__esModule", { value: true });
ProgressCallbackTransform$1.ProgressCallbackTransform = void 0;
const stream_1$3 = require$$0__default$1["default"];
class ProgressCallbackTransform extends stream_1$3.Transform {
  constructor(total, cancellationToken, onProgress) {
    super();
    this.total = total;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.total) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.total * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    callback(null);
  }
}
ProgressCallbackTransform$1.ProgressCallbackTransform = ProgressCallbackTransform;
Object.defineProperty(httpExecutor, "__esModule", { value: true });
httpExecutor.safeStringifyJson = httpExecutor.configureRequestOptions = httpExecutor.safeGetHeader = httpExecutor.DigestTransform = httpExecutor.configureRequestUrl = httpExecutor.configureRequestOptionsFromUrl = httpExecutor.HttpExecutor = httpExecutor.parseJson = httpExecutor.HttpError = httpExecutor.createHttpError = void 0;
const crypto_1$3 = require$$0__default$4["default"];
const debug_1$2 = browser.exports;
const fs_1$7 = require$$0__default$2["default"];
const stream_1$2 = require$$0__default$1["default"];
const url_1$6 = require$$2__default["default"];
const CancellationToken_1 = CancellationToken$1;
const index_1$2 = out;
const ProgressCallbackTransform_1 = ProgressCallbackTransform$1;
const debug$8 = debug_1$2.default("electron-builder");
function createHttpError(response, description2 = null) {
  return new HttpError(response.statusCode || -1, `${response.statusCode} ${response.statusMessage}` + (description2 == null ? "" : "\n" + JSON.stringify(description2, null, "  ")) + "\nHeaders: " + safeStringifyJson(response.headers), description2);
}
httpExecutor.createHttpError = createHttpError;
const HTTP_STATUS_CODES = new Map([
  [429, "Too many requests"],
  [400, "Bad request"],
  [403, "Forbidden"],
  [404, "Not found"],
  [405, "Method not allowed"],
  [406, "Not acceptable"],
  [408, "Request timeout"],
  [413, "Request entity too large"],
  [500, "Internal server error"],
  [502, "Bad gateway"],
  [503, "Service unavailable"],
  [504, "Gateway timeout"],
  [505, "HTTP version not supported"]
]);
class HttpError extends Error {
  constructor(statusCode, message = `HTTP error: ${HTTP_STATUS_CODES.get(statusCode) || statusCode}`, description2 = null) {
    super(message);
    this.statusCode = statusCode;
    this.description = description2;
    this.name = "HttpError";
    this.code = `HTTP_ERROR_${statusCode}`;
  }
  isServerError() {
    return this.statusCode >= 500 && this.statusCode <= 599;
  }
}
httpExecutor.HttpError = HttpError;
function parseJson(result) {
  return result.then((it) => it == null || it.length === 0 ? null : JSON.parse(it));
}
httpExecutor.parseJson = parseJson;
class HttpExecutor {
  constructor() {
    this.maxRedirects = 10;
  }
  request(options, cancellationToken = new CancellationToken_1.CancellationToken(), data) {
    configureRequestOptions(options);
    const json2 = data == null ? void 0 : JSON.stringify(data);
    const encodedData = json2 ? Buffer.from(json2) : void 0;
    if (encodedData != null) {
      debug$8(json2);
      const _a = options, { headers } = _a, opts2 = __objRest(_a, ["headers"]);
      options = __spreadValues({
        method: "post",
        headers: __spreadValues({
          "Content-Type": "application/json",
          "Content-Length": encodedData.length
        }, headers)
      }, opts2);
    }
    return this.doApiRequest(options, cancellationToken, (it) => {
      it.end(encodedData);
    });
  }
  doApiRequest(options, cancellationToken, requestProcessor, redirectCount = 0) {
    if (debug$8.enabled) {
      debug$8(`Request: ${safeStringifyJson(options)}`);
    }
    return cancellationToken.createPromise((resolve2, reject, onCancel) => {
      const request = this.createRequest(options, (response) => {
        try {
          this.handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor);
        } catch (e) {
          reject(e);
        }
      });
      this.addErrorAndTimeoutHandlers(request, reject);
      this.addRedirectHandlers(request, options, reject, redirectCount, (options2) => {
        this.doApiRequest(options2, cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      });
      requestProcessor(request, reject);
      onCancel(() => request.abort());
    });
  }
  addRedirectHandlers(request, options, reject, redirectCount, handler) {
  }
  addErrorAndTimeoutHandlers(request, reject) {
    this.addTimeOutHandler(request, reject);
    request.on("error", reject);
    request.on("aborted", () => {
      reject(new Error("Request has been aborted by the server"));
    });
  }
  handleResponse(response, options, cancellationToken, resolve2, reject, redirectCount, requestProcessor) {
    var _a;
    if (debug$8.enabled) {
      debug$8(`Response: ${response.statusCode} ${response.statusMessage}, request options: ${safeStringifyJson(options)}`);
    }
    if (response.statusCode === 404) {
      reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`));
      return;
    } else if (response.statusCode === 204) {
      resolve2();
      return;
    }
    const code2 = (_a = response.statusCode) !== null && _a !== void 0 ? _a : 0;
    const shouldRedirect = code2 >= 300 && code2 < 400;
    const redirectUrl = safeGetHeader(response, "location");
    if (shouldRedirect && redirectUrl != null) {
      if (redirectCount > this.maxRedirects) {
        reject(this.createMaxRedirectError());
        return;
      }
      this.doApiRequest(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options), cancellationToken, requestProcessor, redirectCount).then(resolve2).catch(reject);
      return;
    }
    response.setEncoding("utf8");
    let data = "";
    response.on("error", reject);
    response.on("data", (chunk) => data += chunk);
    response.on("end", () => {
      try {
        if (response.statusCode != null && response.statusCode >= 400) {
          const contentType = safeGetHeader(response, "content-type");
          const isJson = contentType != null && (Array.isArray(contentType) ? contentType.find((it) => it.includes("json")) != null : contentType.includes("json"));
          reject(createHttpError(response, `method: ${options.method || "GET"} url: ${options.protocol || "https:"}//${options.hostname}${options.port ? `:${options.port}` : ""}${options.path}

          Data:
          ${isJson ? JSON.stringify(JSON.parse(data)) : data}
          `));
        } else {
          resolve2(data.length === 0 ? null : data);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
  async downloadToBuffer(url, options) {
    return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
      let result = null;
      const requestOptions = {
        headers: options.headers || void 0,
        redirect: "manual"
      };
      configureRequestUrl(url, requestOptions);
      configureRequestOptions(requestOptions);
      this.doDownload(requestOptions, {
        destination: null,
        options,
        onCancel,
        callback: (error2) => {
          if (error2 == null) {
            resolve2(result);
          } else {
            reject(error2);
          }
        },
        responseHandler: (response, callback) => {
          const contentLength = safeGetHeader(response, "content-length");
          let position = -1;
          if (contentLength != null) {
            const size = parseInt(contentLength, 10);
            if (size > 0) {
              if (size > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              result = Buffer.alloc(size);
              position = 0;
            }
          }
          response.on("data", (chunk) => {
            if (position !== -1) {
              chunk.copy(result, position);
              position += chunk.length;
            } else if (result == null) {
              result = chunk;
            } else {
              if (result.length > 524288e3) {
                callback(new Error("Maximum allowed size is 500 MB"));
                return;
              }
              result = Buffer.concat([result, chunk]);
            }
          });
          response.on("end", () => {
            if (result != null && position !== -1 && position !== result.length) {
              callback(new Error(`Received data length ${position} is not equal to expected ${result.length}`));
            } else {
              callback(null);
            }
          });
        }
      }, 0);
    });
  }
  doDownload(requestOptions, options, redirectCount) {
    const request = this.createRequest(requestOptions, (response) => {
      if (response.statusCode >= 400) {
        options.callback(new Error(`Cannot download "${requestOptions.protocol || "https:"}//${requestOptions.hostname}${requestOptions.path}", status ${response.statusCode}: ${response.statusMessage}`));
        return;
      }
      response.on("error", options.callback);
      const redirectUrl = safeGetHeader(response, "location");
      if (redirectUrl != null) {
        if (redirectCount < this.maxRedirects) {
          this.doDownload(HttpExecutor.prepareRedirectUrlOptions(redirectUrl, requestOptions), options, redirectCount++);
        } else {
          options.callback(this.createMaxRedirectError());
        }
        return;
      }
      if (options.responseHandler == null) {
        configurePipes(options, response);
      } else {
        options.responseHandler(response, options.callback);
      }
    });
    this.addErrorAndTimeoutHandlers(request, options.callback);
    this.addRedirectHandlers(request, requestOptions, options.callback, redirectCount, (requestOptions2) => {
      this.doDownload(requestOptions2, options, redirectCount++);
    });
    request.end();
  }
  createMaxRedirectError() {
    return new Error(`Too many redirects (> ${this.maxRedirects})`);
  }
  addTimeOutHandler(request, callback) {
    request.on("socket", (socket) => {
      socket.setTimeout(60 * 1e3, () => {
        request.abort();
        callback(new Error("Request timed out"));
      });
    });
  }
  static prepareRedirectUrlOptions(redirectUrl, options) {
    const newOptions = configureRequestOptionsFromUrl(redirectUrl, __spreadValues({}, options));
    const headers = newOptions.headers;
    if (headers === null || headers === void 0 ? void 0 : headers.authorization) {
      const parsedNewUrl = new url_1$6.URL(redirectUrl);
      if (parsedNewUrl.hostname.endsWith(".amazonaws.com") || parsedNewUrl.searchParams.has("X-Amz-Credential")) {
        delete headers.authorization;
      }
    }
    return newOptions;
  }
  static retryOnServerError(task, maxRetries = 3) {
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return task();
      } catch (e) {
        if (attemptNumber < maxRetries && (e instanceof HttpError && e.isServerError() || e.code === "EPIPE")) {
          continue;
        }
        throw e;
      }
    }
  }
}
httpExecutor.HttpExecutor = HttpExecutor;
function configureRequestOptionsFromUrl(url, options) {
  const result = configureRequestOptions(options);
  configureRequestUrl(new url_1$6.URL(url), result);
  return result;
}
httpExecutor.configureRequestOptionsFromUrl = configureRequestOptionsFromUrl;
function configureRequestUrl(url, options) {
  options.protocol = url.protocol;
  options.hostname = url.hostname;
  if (url.port) {
    options.port = url.port;
  } else if (options.port) {
    delete options.port;
  }
  options.path = url.pathname + url.search;
}
httpExecutor.configureRequestUrl = configureRequestUrl;
class DigestTransform extends stream_1$2.Transform {
  constructor(expected, algorithm = "sha512", encoding = "base64") {
    super();
    this.expected = expected;
    this.algorithm = algorithm;
    this.encoding = encoding;
    this._actual = null;
    this.isValidateOnEnd = true;
    this.digester = crypto_1$3.createHash(algorithm);
  }
  get actual() {
    return this._actual;
  }
  _transform(chunk, encoding, callback) {
    this.digester.update(chunk);
    callback(null, chunk);
  }
  _flush(callback) {
    this._actual = this.digester.digest(this.encoding);
    if (this.isValidateOnEnd) {
      try {
        this.validate();
      } catch (e) {
        callback(e);
        return;
      }
    }
    callback(null);
  }
  validate() {
    if (this._actual == null) {
      throw index_1$2.newError("Not finished yet", "ERR_STREAM_NOT_FINISHED");
    }
    if (this._actual !== this.expected) {
      throw index_1$2.newError(`${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`, "ERR_CHECKSUM_MISMATCH");
    }
    return null;
  }
}
httpExecutor.DigestTransform = DigestTransform;
function checkSha2(sha2Header, sha2, callback) {
  if (sha2Header != null && sha2 != null && sha2Header !== sha2) {
    callback(new Error(`checksum mismatch: expected ${sha2} but got ${sha2Header} (X-Checksum-Sha2 header)`));
    return false;
  }
  return true;
}
function safeGetHeader(response, headerKey) {
  const value = response.headers[headerKey];
  if (value == null) {
    return null;
  } else if (Array.isArray(value)) {
    return value.length === 0 ? null : value[value.length - 1];
  } else {
    return value;
  }
}
httpExecutor.safeGetHeader = safeGetHeader;
function configurePipes(options, response) {
  if (!checkSha2(safeGetHeader(response, "X-Checksum-Sha2"), options.options.sha2, options.callback)) {
    return;
  }
  const streams = [];
  if (options.options.onProgress != null) {
    const contentLength = safeGetHeader(response, "content-length");
    if (contentLength != null) {
      streams.push(new ProgressCallbackTransform_1.ProgressCallbackTransform(parseInt(contentLength, 10), options.options.cancellationToken, options.options.onProgress));
    }
  }
  const sha512 = options.options.sha512;
  if (sha512 != null) {
    streams.push(new DigestTransform(sha512, "sha512", sha512.length === 128 && !sha512.includes("+") && !sha512.includes("Z") && !sha512.includes("=") ? "hex" : "base64"));
  } else if (options.options.sha2 != null) {
    streams.push(new DigestTransform(options.options.sha2, "sha256", "hex"));
  }
  const fileOut = fs_1$7.createWriteStream(options.destination);
  streams.push(fileOut);
  let lastStream = response;
  for (const stream of streams) {
    stream.on("error", (error2) => {
      if (!options.options.cancellationToken.cancelled) {
        options.callback(error2);
      }
    });
    lastStream = lastStream.pipe(stream);
  }
  fileOut.on("finish", () => {
    fileOut.close(options.callback);
  });
}
function configureRequestOptions(options, token, method) {
  if (method != null) {
    options.method = method;
  }
  options.headers = __spreadValues({}, options.headers);
  const headers = options.headers;
  if (token != null) {
    headers.authorization = token.startsWith("Basic") || token.startsWith("Bearer") ? token : `token ${token}`;
  }
  if (headers["User-Agent"] == null) {
    headers["User-Agent"] = "electron-builder";
  }
  if (method == null || method === "GET" || headers["Cache-Control"] == null) {
    headers["Cache-Control"] = "no-cache";
  }
  if (options.protocol == null && process.versions.electron != null) {
    options.protocol = "https:";
  }
  return options;
}
httpExecutor.configureRequestOptions = configureRequestOptions;
function safeStringifyJson(data, skippedNames) {
  return JSON.stringify(data, (name, value) => {
    if (name.endsWith("Authorization") || name.endsWith("authorization") || name.endsWith("Password") || name.endsWith("PASSWORD") || name.endsWith("Token") || name.includes("password") || name.includes("token") || skippedNames != null && skippedNames.has(name)) {
      return "<stripped sensitive data>";
    }
    return value;
  }, 2);
}
httpExecutor.safeStringifyJson = safeStringifyJson;
var publishOptions = {};
Object.defineProperty(publishOptions, "__esModule", { value: true });
publishOptions.getS3LikeProviderBaseUrl = publishOptions.githubUrl = void 0;
function githubUrl(options, defaultHost = "github.com") {
  return `${options.protocol || "https"}://${options.host || defaultHost}`;
}
publishOptions.githubUrl = githubUrl;
function getS3LikeProviderBaseUrl(configuration) {
  const provider = configuration.provider;
  if (provider === "s3") {
    return s3Url(configuration);
  }
  if (provider === "spaces") {
    return spacesUrl(configuration);
  }
  throw new Error(`Not supported provider: ${provider}`);
}
publishOptions.getS3LikeProviderBaseUrl = getS3LikeProviderBaseUrl;
function s3Url(options) {
  let url;
  if (options.endpoint != null) {
    url = `${options.endpoint}/${options.bucket}`;
  } else if (options.bucket.includes(".")) {
    if (options.region == null) {
      throw new Error(`Bucket name "${options.bucket}" includes a dot, but S3 region is missing`);
    }
    if (options.region === "us-east-1") {
      url = `https://s3.amazonaws.com/${options.bucket}`;
    } else {
      url = `https://s3-${options.region}.amazonaws.com/${options.bucket}`;
    }
  } else if (options.region === "cn-north-1") {
    url = `https://${options.bucket}.s3.${options.region}.amazonaws.com.cn`;
  } else {
    url = `https://${options.bucket}.s3.amazonaws.com`;
  }
  return appendPath(url, options.path);
}
function appendPath(url, p) {
  if (p != null && p.length > 0) {
    if (!p.startsWith("/")) {
      url += "/";
    }
    url += p;
  }
  return url;
}
function spacesUrl(options) {
  if (options.name == null) {
    throw new Error(`name is missing`);
  }
  if (options.region == null) {
    throw new Error(`region is missing`);
  }
  return appendPath(`https://${options.name}.${options.region}.digitaloceanspaces.com`, options.path);
}
var rfc2253Parser = {};
Object.defineProperty(rfc2253Parser, "__esModule", { value: true });
rfc2253Parser.parseDn = void 0;
function parseDn(seq2) {
  let quoted = false;
  let key = null;
  let token = "";
  let nextNonSpace = 0;
  seq2 = seq2.trim();
  const result = new Map();
  for (let i2 = 0; i2 <= seq2.length; i2++) {
    if (i2 === seq2.length) {
      if (key !== null) {
        result.set(key, token);
      }
      break;
    }
    const ch = seq2[i2];
    if (quoted) {
      if (ch === '"') {
        quoted = false;
        continue;
      }
    } else {
      if (ch === '"') {
        quoted = true;
        continue;
      }
      if (ch === "\\") {
        i2++;
        const ord = parseInt(seq2.slice(i2, i2 + 2), 16);
        if (Number.isNaN(ord)) {
          token += seq2[i2];
        } else {
          i2++;
          token += String.fromCharCode(ord);
        }
        continue;
      }
      if (key === null && ch === "=") {
        key = token;
        token = "";
        continue;
      }
      if (ch === "," || ch === ";" || ch === "+") {
        if (key !== null) {
          result.set(key, token);
        }
        key = null;
        token = "";
        continue;
      }
    }
    if (ch === " " && !quoted) {
      if (token.length === 0) {
        continue;
      }
      if (i2 > nextNonSpace) {
        let j = i2;
        while (seq2[j] === " ") {
          j++;
        }
        nextNonSpace = j;
      }
      if (nextNonSpace >= seq2.length || seq2[nextNonSpace] === "," || seq2[nextNonSpace] === ";" || key === null && seq2[nextNonSpace] === "=" || key !== null && seq2[nextNonSpace] === "+") {
        i2 = nextNonSpace - 1;
        continue;
      }
    }
    token += ch;
  }
  return result;
}
rfc2253Parser.parseDn = parseDn;
var uuid = {};
Object.defineProperty(uuid, "__esModule", { value: true });
uuid.nil = uuid.UUID = void 0;
const crypto_1$2 = require$$0__default$4["default"];
const index_1$1 = out;
const invalidName = "options.name must be either a string or a Buffer";
const randomHost = crypto_1$2.randomBytes(16);
randomHost[0] = randomHost[0] | 1;
const hex2byte = {};
const byte2hex = [];
for (let i2 = 0; i2 < 256; i2++) {
  const hex = (i2 + 256).toString(16).substr(1);
  hex2byte[hex] = i2;
  byte2hex[i2] = hex;
}
class UUID {
  constructor(uuid2) {
    this.ascii = null;
    this.binary = null;
    const check = UUID.check(uuid2);
    if (!check) {
      throw new Error("not a UUID");
    }
    this.version = check.version;
    if (check.format === "ascii") {
      this.ascii = uuid2;
    } else {
      this.binary = uuid2;
    }
  }
  static v5(name, namespace) {
    return uuidNamed(name, "sha1", 80, namespace);
  }
  toString() {
    if (this.ascii == null) {
      this.ascii = stringify(this.binary);
    }
    return this.ascii;
  }
  inspect() {
    return `UUID v${this.version} ${this.toString()}`;
  }
  static check(uuid2, offset = 0) {
    if (typeof uuid2 === "string") {
      uuid2 = uuid2.toLowerCase();
      if (!/^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(uuid2)) {
        return false;
      }
      if (uuid2 === "00000000-0000-0000-0000-000000000000") {
        return { version: void 0, variant: "nil", format: "ascii" };
      }
      return {
        version: (hex2byte[uuid2[14] + uuid2[15]] & 240) >> 4,
        variant: getVariant((hex2byte[uuid2[19] + uuid2[20]] & 224) >> 5),
        format: "ascii"
      };
    }
    if (Buffer.isBuffer(uuid2)) {
      if (uuid2.length < offset + 16) {
        return false;
      }
      let i2 = 0;
      for (; i2 < 16; i2++) {
        if (uuid2[offset + i2] !== 0) {
          break;
        }
      }
      if (i2 === 16) {
        return { version: void 0, variant: "nil", format: "binary" };
      }
      return {
        version: (uuid2[offset + 6] & 240) >> 4,
        variant: getVariant((uuid2[offset + 8] & 224) >> 5),
        format: "binary"
      };
    }
    throw index_1$1.newError("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
  }
  static parse(input) {
    const buffer = Buffer.allocUnsafe(16);
    let j = 0;
    for (let i2 = 0; i2 < 16; i2++) {
      buffer[i2] = hex2byte[input[j++] + input[j++]];
      if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
        j += 1;
      }
    }
    return buffer;
  }
}
uuid.UUID = UUID;
UUID.OID = UUID.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8");
function getVariant(bits) {
  switch (bits) {
    case 0:
    case 1:
    case 3:
      return "ncs";
    case 4:
    case 5:
      return "rfc4122";
    case 6:
      return "microsoft";
    default:
      return "future";
  }
}
var UuidEncoding;
(function(UuidEncoding2) {
  UuidEncoding2[UuidEncoding2["ASCII"] = 0] = "ASCII";
  UuidEncoding2[UuidEncoding2["BINARY"] = 1] = "BINARY";
  UuidEncoding2[UuidEncoding2["OBJECT"] = 2] = "OBJECT";
})(UuidEncoding || (UuidEncoding = {}));
function uuidNamed(name, hashMethod, version, namespace, encoding = UuidEncoding.ASCII) {
  const hash = crypto_1$2.createHash(hashMethod);
  const nameIsNotAString = typeof name !== "string";
  if (nameIsNotAString && !Buffer.isBuffer(name)) {
    throw index_1$1.newError(invalidName, "ERR_INVALID_UUID_NAME");
  }
  hash.update(namespace);
  hash.update(name);
  const buffer = hash.digest();
  let result;
  switch (encoding) {
    case UuidEncoding.BINARY:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = buffer;
      break;
    case UuidEncoding.OBJECT:
      buffer[6] = buffer[6] & 15 | version;
      buffer[8] = buffer[8] & 63 | 128;
      result = new UUID(buffer);
      break;
    default:
      result = byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6] & 15 | version] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8] & 63 | 128] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
      break;
  }
  return result;
}
function stringify(buffer) {
  return byte2hex[buffer[0]] + byte2hex[buffer[1]] + byte2hex[buffer[2]] + byte2hex[buffer[3]] + "-" + byte2hex[buffer[4]] + byte2hex[buffer[5]] + "-" + byte2hex[buffer[6]] + byte2hex[buffer[7]] + "-" + byte2hex[buffer[8]] + byte2hex[buffer[9]] + "-" + byte2hex[buffer[10]] + byte2hex[buffer[11]] + byte2hex[buffer[12]] + byte2hex[buffer[13]] + byte2hex[buffer[14]] + byte2hex[buffer[15]];
}
uuid.nil = new UUID("00000000-0000-0000-0000-000000000000");
var xml = {};
var sax$1 = {};
(function(exports) {
  (function(sax2) {
    sax2.parser = function(strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax2.SAXParser = SAXParser;
    sax2.SAXStream = SAXStream;
    sax2.createStream = createStream;
    sax2.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script"
    ];
    sax2.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace"
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = "";
      parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, "onready");
    }
    if (!Object.create) {
      Object.create = function(o) {
        function F() {
        }
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function(o) {
        var a = [];
        for (var i2 in o)
          if (o.hasOwnProperty(i2))
            a.push(i2);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        var len = parser[buffers[i2]].length;
        if (len > maxAllowed) {
          switch (buffers[i2]) {
            case "textNode":
              closeText(parser);
              break;
            case "cdata":
              emitNode(parser, "oncdata", parser.cdata);
              parser.cdata = "";
              break;
            case "script":
              emitNode(parser, "onscript", parser.script);
              parser.script = "";
              break;
            default:
              error2(parser, "Max buffer length exceeded: " + buffers[i2]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m2 + parser.position;
    }
    function clearBuffers(parser) {
      for (var i2 = 0, l = buffers.length; i2 < l; i2++) {
        parser[buffers[i2]] = "";
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== "") {
        emitNode(parser, "oncdata", parser.cdata);
        parser.cdata = "";
      }
      if (parser.script !== "") {
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
    }
    SAXParser.prototype = {
      end: function() {
        end(this);
      },
      write,
      resume: function() {
        this.error = null;
        return this;
      },
      close: function() {
        return this.write(null);
      },
      flush: function() {
        flushBuffers(this);
      }
    };
    var Stream2;
    try {
      Stream2 = require$$0__default$1["default"].Stream;
    } catch (ex) {
      Stream2 = function() {
      };
    }
    var streamWraps = sax2.EVENTS.filter(function(ev) {
      return ev !== "error" && ev !== "end";
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream2.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function() {
        me.emit("end");
      };
      this._parser.onerror = function(er) {
        me.emit("error", er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function(ev) {
        Object.defineProperty(me, "on" + ev, {
          get: function() {
            return me._parser["on" + ev];
          },
          set: function(h2) {
            if (!h2) {
              me.removeAllListeners(ev);
              me._parser["on" + ev] = h2;
              return h2;
            }
            me.on(ev, h2);
          },
          enumerable: true,
          configurable: false
        });
      });
    }
    SAXStream.prototype = Object.create(Stream2.prototype, {
      constructor: {
        value: SAXStream
      }
    });
    SAXStream.prototype.write = function(data) {
      if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
        if (!this._decoder) {
          var SD = require$$1__default$2["default"].StringDecoder;
          this._decoder = new SD("utf8");
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit("data", data);
      return true;
    };
    SAXStream.prototype.end = function(chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
      var me = this;
      if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser["on" + ev] = function() {
          var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream2.prototype.on.call(me, ev, handler);
    };
    var CDATA = "[CDATA[";
    var DOCTYPE = "DOCTYPE";
    var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
    var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace2(c) {
      return c === " " || c === "\n" || c === "\r" || c === "	";
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === ">" || isWhitespace2(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax2.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++
    };
    sax2.XML_ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'"
    };
    sax2.ENTITIES = {
      "amp": "&",
      "gt": ">",
      "lt": "<",
      "quot": '"',
      "apos": "'",
      "AElig": 198,
      "Aacute": 193,
      "Acirc": 194,
      "Agrave": 192,
      "Aring": 197,
      "Atilde": 195,
      "Auml": 196,
      "Ccedil": 199,
      "ETH": 208,
      "Eacute": 201,
      "Ecirc": 202,
      "Egrave": 200,
      "Euml": 203,
      "Iacute": 205,
      "Icirc": 206,
      "Igrave": 204,
      "Iuml": 207,
      "Ntilde": 209,
      "Oacute": 211,
      "Ocirc": 212,
      "Ograve": 210,
      "Oslash": 216,
      "Otilde": 213,
      "Ouml": 214,
      "THORN": 222,
      "Uacute": 218,
      "Ucirc": 219,
      "Ugrave": 217,
      "Uuml": 220,
      "Yacute": 221,
      "aacute": 225,
      "acirc": 226,
      "aelig": 230,
      "agrave": 224,
      "aring": 229,
      "atilde": 227,
      "auml": 228,
      "ccedil": 231,
      "eacute": 233,
      "ecirc": 234,
      "egrave": 232,
      "eth": 240,
      "euml": 235,
      "iacute": 237,
      "icirc": 238,
      "igrave": 236,
      "iuml": 239,
      "ntilde": 241,
      "oacute": 243,
      "ocirc": 244,
      "ograve": 242,
      "oslash": 248,
      "otilde": 245,
      "ouml": 246,
      "szlig": 223,
      "thorn": 254,
      "uacute": 250,
      "ucirc": 251,
      "ugrave": 249,
      "uuml": 252,
      "yacute": 253,
      "yuml": 255,
      "copy": 169,
      "reg": 174,
      "nbsp": 160,
      "iexcl": 161,
      "cent": 162,
      "pound": 163,
      "curren": 164,
      "yen": 165,
      "brvbar": 166,
      "sect": 167,
      "uml": 168,
      "ordf": 170,
      "laquo": 171,
      "not": 172,
      "shy": 173,
      "macr": 175,
      "deg": 176,
      "plusmn": 177,
      "sup1": 185,
      "sup2": 178,
      "sup3": 179,
      "acute": 180,
      "micro": 181,
      "para": 182,
      "middot": 183,
      "cedil": 184,
      "ordm": 186,
      "raquo": 187,
      "frac14": 188,
      "frac12": 189,
      "frac34": 190,
      "iquest": 191,
      "times": 215,
      "divide": 247,
      "OElig": 338,
      "oelig": 339,
      "Scaron": 352,
      "scaron": 353,
      "Yuml": 376,
      "fnof": 402,
      "circ": 710,
      "tilde": 732,
      "Alpha": 913,
      "Beta": 914,
      "Gamma": 915,
      "Delta": 916,
      "Epsilon": 917,
      "Zeta": 918,
      "Eta": 919,
      "Theta": 920,
      "Iota": 921,
      "Kappa": 922,
      "Lambda": 923,
      "Mu": 924,
      "Nu": 925,
      "Xi": 926,
      "Omicron": 927,
      "Pi": 928,
      "Rho": 929,
      "Sigma": 931,
      "Tau": 932,
      "Upsilon": 933,
      "Phi": 934,
      "Chi": 935,
      "Psi": 936,
      "Omega": 937,
      "alpha": 945,
      "beta": 946,
      "gamma": 947,
      "delta": 948,
      "epsilon": 949,
      "zeta": 950,
      "eta": 951,
      "theta": 952,
      "iota": 953,
      "kappa": 954,
      "lambda": 955,
      "mu": 956,
      "nu": 957,
      "xi": 958,
      "omicron": 959,
      "pi": 960,
      "rho": 961,
      "sigmaf": 962,
      "sigma": 963,
      "tau": 964,
      "upsilon": 965,
      "phi": 966,
      "chi": 967,
      "psi": 968,
      "omega": 969,
      "thetasym": 977,
      "upsih": 978,
      "piv": 982,
      "ensp": 8194,
      "emsp": 8195,
      "thinsp": 8201,
      "zwnj": 8204,
      "zwj": 8205,
      "lrm": 8206,
      "rlm": 8207,
      "ndash": 8211,
      "mdash": 8212,
      "lsquo": 8216,
      "rsquo": 8217,
      "sbquo": 8218,
      "ldquo": 8220,
      "rdquo": 8221,
      "bdquo": 8222,
      "dagger": 8224,
      "Dagger": 8225,
      "bull": 8226,
      "hellip": 8230,
      "permil": 8240,
      "prime": 8242,
      "Prime": 8243,
      "lsaquo": 8249,
      "rsaquo": 8250,
      "oline": 8254,
      "frasl": 8260,
      "euro": 8364,
      "image": 8465,
      "weierp": 8472,
      "real": 8476,
      "trade": 8482,
      "alefsym": 8501,
      "larr": 8592,
      "uarr": 8593,
      "rarr": 8594,
      "darr": 8595,
      "harr": 8596,
      "crarr": 8629,
      "lArr": 8656,
      "uArr": 8657,
      "rArr": 8658,
      "dArr": 8659,
      "hArr": 8660,
      "forall": 8704,
      "part": 8706,
      "exist": 8707,
      "empty": 8709,
      "nabla": 8711,
      "isin": 8712,
      "notin": 8713,
      "ni": 8715,
      "prod": 8719,
      "sum": 8721,
      "minus": 8722,
      "lowast": 8727,
      "radic": 8730,
      "prop": 8733,
      "infin": 8734,
      "ang": 8736,
      "and": 8743,
      "or": 8744,
      "cap": 8745,
      "cup": 8746,
      "int": 8747,
      "there4": 8756,
      "sim": 8764,
      "cong": 8773,
      "asymp": 8776,
      "ne": 8800,
      "equiv": 8801,
      "le": 8804,
      "ge": 8805,
      "sub": 8834,
      "sup": 8835,
      "nsub": 8836,
      "sube": 8838,
      "supe": 8839,
      "oplus": 8853,
      "otimes": 8855,
      "perp": 8869,
      "sdot": 8901,
      "lceil": 8968,
      "rceil": 8969,
      "lfloor": 8970,
      "rfloor": 8971,
      "lang": 9001,
      "rang": 9002,
      "loz": 9674,
      "spades": 9824,
      "clubs": 9827,
      "hearts": 9829,
      "diams": 9830
    };
    Object.keys(sax2.ENTITIES).forEach(function(key) {
      var e = sax2.ENTITIES[key];
      var s3 = typeof e === "number" ? String.fromCharCode(e) : e;
      sax2.ENTITIES[key] = s3;
    });
    for (var s2 in sax2.STATE) {
      sax2.STATE[sax2.STATE[s2]] = s2;
    }
    S = sax2.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode)
        closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode)
        emit(parser, "ontext", parser.textNode);
      parser.textNode = "";
    }
    function textopts(opt, text) {
      if (opt.trim)
        text = text.trim();
      if (opt.normalize)
        text = text.replace(/\s+/g, " ");
      return text;
    }
    function error2(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, "onerror", er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, "Unclosed root tag");
      if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
        error2(parser, "Unexpected end");
      }
      closeText(parser);
      parser.c = "";
      parser.closed = true;
      emit(parser, "onend");
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
        throw new Error("bad call to strictFail");
      }
      if (parser.strict) {
        error2(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict)
        parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = parser.tag = { name: parser.tagName, attributes: {} };
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, "onopentagstart", tag);
    }
    function qname(name, attribute) {
      var i2 = name.indexOf(":");
      var qualName = i2 < 0 ? ["", name] : name.split(":");
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === "xmlns") {
        prefix = "xmlns";
        local = "";
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
        parser.attribName = parser.attribValue = "";
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === "xmlns") {
          if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
            strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
          } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
            strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, "onattribute", {
          name: parser.attribName,
          value: parser.attribValue
        });
      }
      parser.attribName = parser.attribValue = "";
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || "";
        if (tag.prefix && !tag.uri) {
          strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            emitNode(parser, "onopennamespace", {
              prefix: p,
              uri: tag.ns[p]
            });
          });
        }
        for (var i2 = 0, l = parser.attribList.length; i2 < l; i2++) {
          var nv = parser.attribList[i2];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === "" ? "" : tag.ns[prefix] || "";
          var a = {
            name,
            value,
            prefix,
            local,
            uri
          };
          if (prefix && prefix !== "xmlns" && !uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, "onattribute", a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, "onopentag", parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = "";
      }
      parser.attribName = parser.attribValue = "";
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, "Weird empty close tag.");
        parser.textNode += "</>";
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== "script") {
          parser.script += "</" + parser.tagName + ">";
          parser.tagName = "";
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, "onscript", parser.script);
        parser.script = "";
      }
      var t2 = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t2--) {
        var close = parser.tags[t2];
        if (close.name !== closeTo) {
          strictFail(parser, "Unexpected close tag");
        } else {
          break;
        }
      }
      if (t2 < 0) {
        strictFail(parser, "Unmatched closing tag: " + parser.tagName);
        parser.textNode += "</" + parser.tagName + ">";
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s3 = parser.tags.length;
      while (s3-- > t2) {
        var tag = parser.tag = parser.tags.pop();
        parser.tagName = parser.tag.name;
        emitNode(parser, "onclosetag", parser.tagName);
        var x = {};
        for (var i2 in tag.ns) {
          x[i2] = tag.ns[i2];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function(p) {
            var n = tag.ns[p];
            emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
          });
        }
      }
      if (t2 === 0)
        parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = "";
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = "";
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === "#") {
        if (entity.charAt(1) === "x") {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, "");
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, "Invalid character entity");
        return "&" + parser.entity + ";";
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === "<") {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace2(c)) {
        strictFail(parser, "Non-whitespace before first tag.");
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i2) {
      var result = "";
      if (i2 < chunk.length) {
        result = chunk.charAt(i2);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error2(parser, "Cannot write after close. Assign an onready handler.");
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      var i2 = 0;
      var c = "";
      while (true) {
        c = charAt(chunk, i2++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === "\n") {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === "\uFEFF") {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i2 - 1;
              while (c && c !== "<" && c !== "&") {
                c = charAt(chunk, i2++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i2 - 1);
            }
            if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace2(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, "Text data outside of root node.");
              }
              if (c === "&") {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === "<") {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === "/") {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += "<" + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === "!") {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = "";
            } else if (isWhitespace2(c))
              ;
            else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === "/") {
              parser.state = S.CLOSE_TAG;
              parser.tagName = "";
            } else if (c === "?") {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = "";
            } else {
              strictFail(parser, "Unencoded <");
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(" ") + c;
              }
              parser.textNode += "<" + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, "onopencdata");
              parser.state = S.CDATA;
              parser.sgmlDecl = "";
              parser.cdata = "";
            } else if (parser.sgmlDecl + c === "--") {
              parser.state = S.COMMENT;
              parser.comment = "";
              parser.sgmlDecl = "";
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(parser, "Inappropriately located doctype declaration");
              }
              parser.doctype = "";
              parser.sgmlDecl = "";
            } else if (c === ">") {
              emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
              parser.sgmlDecl = "";
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = "";
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === ">") {
              parser.state = S.TEXT;
              emitNode(parser, "ondoctype", parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === "[") {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = "";
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === "]") {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = "";
            }
            continue;
          case S.COMMENT:
            if (c === "-") {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === "-") {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, "oncomment", parser.comment);
              }
              parser.comment = "";
            } else {
              parser.comment += "-" + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== ">") {
              strictFail(parser, "Malformed comment");
              parser.comment += "--" + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === "]") {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === "]") {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += "]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === ">") {
              if (parser.cdata) {
                emitNode(parser, "oncdata", parser.cdata);
              }
              emitNode(parser, "onclosecdata");
              parser.cdata = "";
              parser.state = S.TEXT;
            } else if (c === "]") {
              parser.cdata += "]";
            } else {
              parser.cdata += "]]" + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace2(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace2(c)) {
              continue;
            } else if (c === "?") {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === ">") {
              emitNode(parser, "onprocessinginstruction", {
                name: parser.procInstName,
                body: parser.procInstBody
              });
              parser.procInstName = parser.procInstBody = "";
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += "?" + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace2(c)) {
                  strictFail(parser, "Invalid character in tag name");
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === ">") {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(parser, "Forward-slash in opening tag not followed by >");
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace2(c)) {
              continue;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === ">") {
              strictFail(parser, "Attribute without value");
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace2(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === "=") {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace2(c)) {
              continue;
            } else {
              strictFail(parser, "Attribute without value");
              parser.tag.attributes[parser.attribName] = "";
              parser.attribValue = "";
              emitNode(parser, "onattribute", {
                name: parser.attribName,
                value: ""
              });
              parser.attribName = "";
              if (c === ">") {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace2(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, "Unquoted attribute value");
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = "";
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace2(c)) {
              parser.state = S.ATTRIB;
            } else if (c === ">") {
              openTag(parser);
            } else if (c === "/") {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, "No whitespace between attributes");
              parser.attribName = c;
              parser.attribValue = "";
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, "Invalid attribute name");
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === "&") {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === ">") {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace2(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += "</" + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, "Invalid tagname in closing tag.");
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === ">") {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += "</" + parser.tagName;
              parser.tagName = "";
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace2(c)) {
                strictFail(parser, "Invalid tagname in closing tag");
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace2(c)) {
              continue;
            }
            if (c === ">") {
              closeTag(parser);
            } else {
              strictFail(parser, "Invalid characters in closing tag");
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = "textNode";
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = "attribValue";
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = "attribValue";
                break;
            }
            if (c === ";") {
              parser[buffer] += parseEntity(parser);
              parser.entity = "";
              parser.state = returnState;
            } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
              parser.entity += c;
            } else {
              strictFail(parser, "Invalid character in entity name");
              parser[buffer] += "&" + parser.entity + c;
              parser.entity = "";
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, "Unknown state: " + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function() {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function() {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return "";
          }
          var result = "";
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
              throw RangeError("Invalid code point: " + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = codePoint % 1024 + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, "fromCodePoint", {
            value: fromCodePoint,
            configurable: true,
            writable: true
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(exports);
})(sax$1);
Object.defineProperty(xml, "__esModule", { value: true });
xml.parseXml = xml.XElement = void 0;
const sax = sax$1;
const index_1 = out;
class XElement {
  constructor(name) {
    this.name = name;
    this.value = "";
    this.attributes = null;
    this.isCData = false;
    this.elements = null;
    if (!name) {
      throw index_1.newError("Element name cannot be empty", "ERR_XML_ELEMENT_NAME_EMPTY");
    }
    if (!isValidName(name)) {
      throw index_1.newError(`Invalid element name: ${name}`, "ERR_XML_ELEMENT_INVALID_NAME");
    }
  }
  attribute(name) {
    const result = this.attributes === null ? null : this.attributes[name];
    if (result == null) {
      throw index_1.newError(`No attribute "${name}"`, "ERR_XML_MISSED_ATTRIBUTE");
    }
    return result;
  }
  removeAttribute(name) {
    if (this.attributes !== null) {
      delete this.attributes[name];
    }
  }
  element(name, ignoreCase = false, errorIfMissed = null) {
    const result = this.elementOrNull(name, ignoreCase);
    if (result === null) {
      throw index_1.newError(errorIfMissed || `No element "${name}"`, "ERR_XML_MISSED_ELEMENT");
    }
    return result;
  }
  elementOrNull(name, ignoreCase = false) {
    if (this.elements === null) {
      return null;
    }
    for (const element of this.elements) {
      if (isNameEquals(element, name, ignoreCase)) {
        return element;
      }
    }
    return null;
  }
  getElements(name, ignoreCase = false) {
    if (this.elements === null) {
      return [];
    }
    return this.elements.filter((it) => isNameEquals(it, name, ignoreCase));
  }
  elementValueOrEmpty(name, ignoreCase = false) {
    const element = this.elementOrNull(name, ignoreCase);
    return element === null ? "" : element.value;
  }
}
xml.XElement = XElement;
const NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
function isValidName(name) {
  return NAME_REG_EXP.test(name);
}
function isNameEquals(element, name, ignoreCase) {
  const elementName = element.name;
  return elementName === name || ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase();
}
function parseXml(data) {
  let rootElement = null;
  const parser = sax.parser(true, {});
  const elements = [];
  parser.onopentag = (saxElement) => {
    const element = new XElement(saxElement.name);
    element.attributes = saxElement.attributes;
    if (rootElement === null) {
      rootElement = element;
    } else {
      const parent = elements[elements.length - 1];
      if (parent.elements == null) {
        parent.elements = [];
      }
      parent.elements.push(element);
    }
    elements.push(element);
  };
  parser.onclosetag = () => {
    elements.pop();
  };
  parser.ontext = (text) => {
    if (elements.length > 0) {
      elements[elements.length - 1].value = text;
    }
  };
  parser.oncdata = (cdata) => {
    const element = elements[elements.length - 1];
    element.value = cdata;
    element.isCData = true;
  };
  parser.onerror = (err) => {
    throw err;
  };
  parser.write(data);
  return rootElement;
}
xml.parseXml = parseXml;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.newError = exports.asArray = exports.CURRENT_APP_PACKAGE_FILE_NAME = exports.CURRENT_APP_INSTALLER_FILE_NAME = exports.XElement = exports.parseXml = exports.ProgressCallbackTransform = exports.UUID = exports.parseDn = exports.githubUrl = exports.getS3LikeProviderBaseUrl = exports.configureRequestUrl = exports.parseJson = exports.safeStringifyJson = exports.configureRequestOptionsFromUrl = exports.configureRequestOptions = exports.safeGetHeader = exports.DigestTransform = exports.HttpExecutor = exports.createHttpError = exports.HttpError = exports.CancellationError = exports.CancellationToken = void 0;
  var CancellationToken_12 = CancellationToken$1;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationToken;
  } });
  Object.defineProperty(exports, "CancellationError", { enumerable: true, get: function() {
    return CancellationToken_12.CancellationError;
  } });
  var httpExecutor_12 = httpExecutor;
  Object.defineProperty(exports, "HttpError", { enumerable: true, get: function() {
    return httpExecutor_12.HttpError;
  } });
  Object.defineProperty(exports, "createHttpError", { enumerable: true, get: function() {
    return httpExecutor_12.createHttpError;
  } });
  Object.defineProperty(exports, "HttpExecutor", { enumerable: true, get: function() {
    return httpExecutor_12.HttpExecutor;
  } });
  Object.defineProperty(exports, "DigestTransform", { enumerable: true, get: function() {
    return httpExecutor_12.DigestTransform;
  } });
  Object.defineProperty(exports, "safeGetHeader", { enumerable: true, get: function() {
    return httpExecutor_12.safeGetHeader;
  } });
  Object.defineProperty(exports, "configureRequestOptions", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestOptions;
  } });
  Object.defineProperty(exports, "configureRequestOptionsFromUrl", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestOptionsFromUrl;
  } });
  Object.defineProperty(exports, "safeStringifyJson", { enumerable: true, get: function() {
    return httpExecutor_12.safeStringifyJson;
  } });
  Object.defineProperty(exports, "parseJson", { enumerable: true, get: function() {
    return httpExecutor_12.parseJson;
  } });
  Object.defineProperty(exports, "configureRequestUrl", { enumerable: true, get: function() {
    return httpExecutor_12.configureRequestUrl;
  } });
  var publishOptions_1 = publishOptions;
  Object.defineProperty(exports, "getS3LikeProviderBaseUrl", { enumerable: true, get: function() {
    return publishOptions_1.getS3LikeProviderBaseUrl;
  } });
  Object.defineProperty(exports, "githubUrl", { enumerable: true, get: function() {
    return publishOptions_1.githubUrl;
  } });
  var rfc2253Parser_1 = rfc2253Parser;
  Object.defineProperty(exports, "parseDn", { enumerable: true, get: function() {
    return rfc2253Parser_1.parseDn;
  } });
  var uuid_1 = uuid;
  Object.defineProperty(exports, "UUID", { enumerable: true, get: function() {
    return uuid_1.UUID;
  } });
  var ProgressCallbackTransform_12 = ProgressCallbackTransform$1;
  Object.defineProperty(exports, "ProgressCallbackTransform", { enumerable: true, get: function() {
    return ProgressCallbackTransform_12.ProgressCallbackTransform;
  } });
  var xml_1 = xml;
  Object.defineProperty(exports, "parseXml", { enumerable: true, get: function() {
    return xml_1.parseXml;
  } });
  Object.defineProperty(exports, "XElement", { enumerable: true, get: function() {
    return xml_1.XElement;
  } });
  exports.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe";
  exports.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z";
  function asArray(v) {
    if (v == null) {
      return [];
    } else if (Array.isArray(v)) {
      return v;
    } else {
      return [v];
    }
  }
  exports.asArray = asArray;
  function newError(message, code2) {
    const error2 = new Error(message);
    error2.code = code2;
    return error2;
  }
  exports.newError = newError;
})(out);
var AppUpdater$1 = {};
var jsYaml = {};
var loader$1 = {};
var common$5 = {};
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source2) {
  var index, length, key, sourceKeys;
  if (source2) {
    sourceKeys = Object.keys(source2);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source2[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
common$5.isNothing = isNothing;
common$5.isObject = isObject;
common$5.toArray = toArray;
common$5.repeat = repeat;
common$5.isNegativeZero = isNegativeZero;
common$5.extend = extend;
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$4(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$4.prototype = Object.create(Error.prototype);
YAMLException$4.prototype.constructor = YAMLException$4;
YAMLException$4.prototype.toString = function toString2(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$4;
var common$4 = common$5;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
  };
}
function padStart(string, max) {
  return common$4.repeat(" ", max - string.length) + string;
}
function makeSnippet$1(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options.linesBefore; i2++) {
    if (foundLineNo - i2 < 0)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo - i2], lineEnds[foundLineNo - i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]), maxLineLength);
    result = common$4.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common$4.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common$4.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length)
      break;
    line = getLine(mark.buffer, lineStarts[foundLineNo + i2], lineEnds[foundLineNo + i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]), maxLineLength);
    result += common$4.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet$1;
var YAMLException$3 = exception;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$e(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException$3('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException$3('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type$2 = Type$e;
var YAMLException$2 = exception;
var Type$d = type$2;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof Type$d) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new YAMLException$2("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type2.loadKind && type2.loadKind !== "scalar") {
      throw new YAMLException$2("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type2.multi) {
      throw new YAMLException$2("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type2) {
    if (!(type2 instanceof Type$d)) {
      throw new YAMLException$2("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema$2 = Schema$1;
var Type$c = type$2;
var str = new Type$c("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var Type$b = type$2;
var seq = new Type$b("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var Type$a = type$2;
var map = new Type$a("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var Schema = schema$2;
var failsafe = new Schema({
  explicit: [
    str,
    seq,
    map
  ]
});
var Type$9 = type$2;
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new Type$9("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
var Type$8 = type$2;
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new Type$8("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
var common$3 = common$5;
var Type$7 = type$2;
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common$3.isNegativeZero(object));
}
var int = new Type$7("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var common$2 = common$5;
var Type$6 = type$2;
var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common$2.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common$2.isNegativeZero(object));
}
var float = new Type$6("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core$3 = json;
var Type$5 = type$2;
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new Type$5("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
var Type$4 = type$2;
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type$4("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var Type$3 = type$2;
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code2, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new Type$3("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var Type$2 = type$2;
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type$2("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var Type$1 = type$2;
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new Type$1("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var Type = type$2;
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core$3.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var common$1 = common$5;
var YAMLException$1 = exception;
var makeSnippet = snippet;
var DEFAULT_SCHEMA$1 = _default;
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
  return c === 10 || c === 13;
}
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || DEFAULT_SCHEMA$1;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = makeSnippet(mark);
  return new YAMLException$1(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major2, minor2;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major2 = parseInt(match[1], 10);
    minor2 = parseInt(match[2], 10);
    if (major2 !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor2 < 2;
    if (minor2 !== 1 && minor2 !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source2, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common$1.isObject(source2)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source2);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source2[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common$1.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common$1.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common$1.repeat("\n", emptyLines);
      }
    } else {
      state.result += common$1.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll(input, iterator2, options) {
  if (iterator2 !== null && typeof iterator2 === "object" && typeof options === "undefined") {
    options = iterator2;
    iterator2 = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator2 !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator2(documents[index]);
  }
}
function load(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException$1("expected a single document in the stream, but found more");
}
loader$1.loadAll = loadAll;
loader$1.load = load;
var dumper$1 = {};
var common = common$5;
var YAMLException = exception;
var DEFAULT_SCHEMA = _default;
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null)
    return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || DEFAULT_SCHEMA;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
}
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new YAMLException("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i2];
      if (char >= 65536)
        result += string[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new YAMLException("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new YAMLException("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new YAMLException("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
dumper$1.dump = dump;
var loader = loader$1;
var dumper = dumper$1;
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
jsYaml.Type = type$2;
jsYaml.Schema = schema$2;
jsYaml.FAILSAFE_SCHEMA = failsafe;
jsYaml.JSON_SCHEMA = json;
jsYaml.CORE_SCHEMA = core$3;
jsYaml.DEFAULT_SCHEMA = _default;
jsYaml.load = loader.load;
jsYaml.loadAll = loader.loadAll;
jsYaml.dump = dumper.dump;
jsYaml.YAMLException = exception;
jsYaml.types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
jsYaml.safeLoad = renamed("safeLoad", "load");
jsYaml.safeLoadAll = renamed("safeLoadAll", "loadAll");
jsYaml.safeDump = renamed("safeDump", "dump");
var main = {};
Object.defineProperty(main, "__esModule", { value: true });
main.Lazy = void 0;
class Lazy {
  constructor(creator) {
    this._value = null;
    this.creator = creator;
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) {
      return this._value;
    }
    const result = this.creator();
    this.value = result;
    return result;
  }
  set value(value) {
    this._value = value;
    this.creator = null;
  }
}
main.Lazy = Lazy;
var re$b = { exports: {} };
const SEMVER_SPEC_VERSION$1 = "2.0.0";
const MAX_LENGTH$5 = 256;
const MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH$1 = 16;
var constants$1 = {
  SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$1,
  MAX_LENGTH: MAX_LENGTH$5,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
  MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$1
};
const debug$7 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1$1 = debug$7;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants$1;
  const debug2 = debug_1$1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$b, re$b.exports);
const opts$1 = ["includePrerelease", "loose", "rtl"];
const parseOptions$9 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts$1.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1$1 = parseOptions$9;
const numeric$1 = /^[0-9]+$/;
const compareIdentifiers$3 = (a, b) => {
  const anum = numeric$1.test(a);
  const bnum = numeric$1.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers$1 = (a, b) => compareIdentifiers$3(b, a);
var identifiers$1 = {
  compareIdentifiers: compareIdentifiers$3,
  rcompareIdentifiers: rcompareIdentifiers$1
};
const debug$6 = debug_1$1;
const { MAX_LENGTH: MAX_LENGTH$4, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$2 } = constants$1;
const { re: re$a, t: t$9 } = re$b.exports;
const parseOptions$8 = parseOptions_1$1;
const { compareIdentifiers: compareIdentifiers$2 } = identifiers$1;
class SemVer$t {
  constructor(version, options) {
    options = parseOptions$8(options);
    if (version instanceof SemVer$t) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$4) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$4} characters`);
    }
    debug$6("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$a[t$9.LOOSE] : re$a[t$9.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$6("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$t)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$t(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$t)) {
      other = new SemVer$t(other, this.options);
    }
    return compareIdentifiers$2(this.major, other.major) || compareIdentifiers$2(this.minor, other.minor) || compareIdentifiers$2(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$t)) {
      other = new SemVer$t(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug$6("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers$2(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$t)) {
      other = new SemVer$t(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug$6("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers$2(a, b);
      }
    } while (++i2);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$4 = SemVer$t;
const { MAX_LENGTH: MAX_LENGTH$3 } = constants$1;
const { re: re$9, t: t$8 } = re$b.exports;
const SemVer$s = semver$4;
const parseOptions$7 = parseOptions_1$1;
const parse$b = (version, options) => {
  options = parseOptions$7(options);
  if (version instanceof SemVer$s) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH$3) {
    return null;
  }
  const r = options.loose ? re$9[t$8.LOOSE] : re$9[t$8.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$s(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1$1 = parse$b;
const parse$a = parse_1$1;
const valid$3 = (version, options) => {
  const v = parse$a(version, options);
  return v ? v.version : null;
};
var valid_1$1 = valid$3;
const parse$9 = parse_1$1;
const clean$1 = (version, options) => {
  const s2 = parse$9(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1$1 = clean$1;
const SemVer$r = semver$4;
const inc$1 = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$r(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1$1 = inc$1;
const SemVer$q = semver$4;
const compare$l = (a, b, loose) => new SemVer$q(a, loose).compare(new SemVer$q(b, loose));
var compare_1$1 = compare$l;
const compare$k = compare_1$1;
const eq$5 = (a, b, loose) => compare$k(a, b, loose) === 0;
var eq_1$1 = eq$5;
const parse$8 = parse_1$1;
const eq$4 = eq_1$1;
const diff$1 = (version1, version2) => {
  if (eq$4(version1, version2)) {
    return null;
  } else {
    const v1 = parse$8(version1);
    const v2 = parse$8(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1$1 = diff$1;
const SemVer$p = semver$4;
const major$1 = (a, loose) => new SemVer$p(a, loose).major;
var major_1$1 = major$1;
const SemVer$o = semver$4;
const minor$1 = (a, loose) => new SemVer$o(a, loose).minor;
var minor_1$1 = minor$1;
const SemVer$n = semver$4;
const patch$1 = (a, loose) => new SemVer$n(a, loose).patch;
var patch_1$1 = patch$1;
const parse$7 = parse_1$1;
const prerelease$1 = (version, options) => {
  const parsed = parse$7(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1$1 = prerelease$1;
const compare$j = compare_1$1;
const rcompare$1 = (a, b, loose) => compare$j(b, a, loose);
var rcompare_1$1 = rcompare$1;
const compare$i = compare_1$1;
const compareLoose$1 = (a, b) => compare$i(a, b, true);
var compareLoose_1$1 = compareLoose$1;
const SemVer$m = semver$4;
const compareBuild$5 = (a, b, loose) => {
  const versionA = new SemVer$m(a, loose);
  const versionB = new SemVer$m(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1$1 = compareBuild$5;
const compareBuild$4 = compareBuild_1$1;
const sort$1 = (list, loose) => list.sort((a, b) => compareBuild$4(a, b, loose));
var sort_1$1 = sort$1;
const compareBuild$3 = compareBuild_1$1;
const rsort$1 = (list, loose) => list.sort((a, b) => compareBuild$3(b, a, loose));
var rsort_1$1 = rsort$1;
const compare$h = compare_1$1;
const gt$7 = (a, b, loose) => compare$h(a, b, loose) > 0;
var gt_1$1 = gt$7;
const compare$g = compare_1$1;
const lt$5 = (a, b, loose) => compare$g(a, b, loose) < 0;
var lt_1$1 = lt$5;
const compare$f = compare_1$1;
const neq$3 = (a, b, loose) => compare$f(a, b, loose) !== 0;
var neq_1$1 = neq$3;
const compare$e = compare_1$1;
const gte$5 = (a, b, loose) => compare$e(a, b, loose) >= 0;
var gte_1$1 = gte$5;
const compare$d = compare_1$1;
const lte$5 = (a, b, loose) => compare$d(a, b, loose) <= 0;
var lte_1$1 = lte$5;
const eq$3 = eq_1$1;
const neq$2 = neq_1$1;
const gt$6 = gt_1$1;
const gte$4 = gte_1$1;
const lt$4 = lt_1$1;
const lte$4 = lte_1$1;
const cmp$3 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq$3(a, b, loose);
    case "!=":
      return neq$2(a, b, loose);
    case ">":
      return gt$6(a, b, loose);
    case ">=":
      return gte$4(a, b, loose);
    case "<":
      return lt$4(a, b, loose);
    case "<=":
      return lte$4(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1$1 = cmp$3;
const SemVer$l = semver$4;
const parse$6 = parse_1$1;
const { re: re$8, t: t$7 } = re$b.exports;
const coerce$1 = (version, options) => {
  if (version instanceof SemVer$l) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$8[t$7.COERCE]);
  } else {
    let next;
    while ((next = re$8[t$7.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$8[t$7.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$8[t$7.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse$6(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1$1 = coerce$1;
var iterator = function(Yallist2) {
  Yallist2.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value;
    }
  };
};
var yallist = Yallist$1;
Yallist$1.Node = Node;
Yallist$1.create = Yallist$1;
function Yallist$1(list) {
  var self2 = this;
  if (!(self2 instanceof Yallist$1)) {
    self2 = new Yallist$1();
  }
  self2.tail = null;
  self2.head = null;
  self2.length = 0;
  if (list && typeof list.forEach === "function") {
    list.forEach(function(item) {
      self2.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
      self2.push(arguments[i2]);
    }
  }
  return self2;
}
Yallist$1.prototype.removeNode = function(node) {
  if (node.list !== this) {
    throw new Error("removing node which does not belong to this list");
  }
  var next = node.next;
  var prev = node.prev;
  if (next) {
    next.prev = prev;
  }
  if (prev) {
    prev.next = next;
  }
  if (node === this.head) {
    this.head = next;
  }
  if (node === this.tail) {
    this.tail = prev;
  }
  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};
Yallist$1.prototype.unshiftNode = function(node) {
  if (node === this.head) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var head = this.head;
  node.list = this;
  node.next = head;
  if (head) {
    head.prev = node;
  }
  this.head = node;
  if (!this.tail) {
    this.tail = node;
  }
  this.length++;
};
Yallist$1.prototype.pushNode = function(node) {
  if (node === this.tail) {
    return;
  }
  if (node.list) {
    node.list.removeNode(node);
  }
  var tail = this.tail;
  node.list = this;
  node.prev = tail;
  if (tail) {
    tail.next = node;
  }
  this.tail = node;
  if (!this.head) {
    this.head = node;
  }
  this.length++;
};
Yallist$1.prototype.push = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    push(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.unshift = function() {
  for (var i2 = 0, l = arguments.length; i2 < l; i2++) {
    unshift(this, arguments[i2]);
  }
  return this.length;
};
Yallist$1.prototype.pop = function() {
  if (!this.tail) {
    return void 0;
  }
  var res = this.tail.value;
  this.tail = this.tail.prev;
  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.shift = function() {
  if (!this.head) {
    return void 0;
  }
  var res = this.head.value;
  this.head = this.head.next;
  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }
  this.length--;
  return res;
};
Yallist$1.prototype.forEach = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.head, i2 = 0; walker !== null; i2++) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.next;
  }
};
Yallist$1.prototype.forEachReverse = function(fn, thisp) {
  thisp = thisp || this;
  for (var walker = this.tail, i2 = this.length - 1; walker !== null; i2--) {
    fn.call(thisp, walker.value, i2, this);
    walker = walker.prev;
  }
};
Yallist$1.prototype.get = function(n) {
  for (var i2 = 0, walker = this.head; walker !== null && i2 < n; i2++) {
    walker = walker.next;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.getReverse = function(n) {
  for (var i2 = 0, walker = this.tail; walker !== null && i2 < n; i2++) {
    walker = walker.prev;
  }
  if (i2 === n && walker !== null) {
    return walker.value;
  }
};
Yallist$1.prototype.map = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }
  return res;
};
Yallist$1.prototype.mapReverse = function(fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist$1();
  for (var walker = this.tail; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }
  return res;
};
Yallist$1.prototype.reduce = function(fn, initial) {
  var acc;
  var walker = this.head;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = 0; walker !== null; i2++) {
    acc = fn(acc, walker.value, i2);
    walker = walker.next;
  }
  return acc;
};
Yallist$1.prototype.reduceReverse = function(fn, initial) {
  var acc;
  var walker = this.tail;
  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError("Reduce of empty list with no initial value");
  }
  for (var i2 = this.length - 1; walker !== null; i2--) {
    acc = fn(acc, walker.value, i2);
    walker = walker.prev;
  }
  return acc;
};
Yallist$1.prototype.toArray = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.head; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.next;
  }
  return arr;
};
Yallist$1.prototype.toArrayReverse = function() {
  var arr = new Array(this.length);
  for (var i2 = 0, walker = this.tail; walker !== null; i2++) {
    arr[i2] = walker.value;
    walker = walker.prev;
  }
  return arr;
};
Yallist$1.prototype.slice = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < from; i2++) {
    walker = walker.next;
  }
  for (; walker !== null && i2 < to; i2++, walker = walker.next) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.sliceReverse = function(from, to) {
  to = to || this.length;
  if (to < 0) {
    to += this.length;
  }
  from = from || 0;
  if (from < 0) {
    from += this.length;
  }
  var ret = new Yallist$1();
  if (to < from || to < 0) {
    return ret;
  }
  if (from < 0) {
    from = 0;
  }
  if (to > this.length) {
    to = this.length;
  }
  for (var i2 = this.length, walker = this.tail; walker !== null && i2 > to; i2--) {
    walker = walker.prev;
  }
  for (; walker !== null && i2 > from; i2--, walker = walker.prev) {
    ret.push(walker.value);
  }
  return ret;
};
Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1;
  }
  if (start < 0) {
    start = this.length + start;
  }
  for (var i2 = 0, walker = this.head; walker !== null && i2 < start; i2++) {
    walker = walker.next;
  }
  var ret = [];
  for (var i2 = 0; walker && i2 < deleteCount; i2++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }
  if (walker === null) {
    walker = this.tail;
  }
  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }
  for (var i2 = 0; i2 < nodes.length; i2++) {
    walker = insert(this, walker, nodes[i2]);
  }
  return ret;
};
Yallist$1.prototype.reverse = function() {
  var head = this.head;
  var tail = this.tail;
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }
  this.head = tail;
  this.tail = head;
  return this;
};
function insert(self2, node, value) {
  var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
  if (inserted.next === null) {
    self2.tail = inserted;
  }
  if (inserted.prev === null) {
    self2.head = inserted;
  }
  self2.length++;
  return inserted;
}
function push(self2, item) {
  self2.tail = new Node(item, self2.tail, null, self2);
  if (!self2.head) {
    self2.head = self2.tail;
  }
  self2.length++;
}
function unshift(self2, item) {
  self2.head = new Node(item, null, self2.head, self2);
  if (!self2.tail) {
    self2.tail = self2.head;
  }
  self2.length++;
}
function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }
  this.list = list;
  this.value = value;
  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }
  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}
try {
  iterator(Yallist$1);
} catch (er) {
}
const Yallist = yallist;
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = () => 1;
class LRUCache {
  constructor(options) {
    if (typeof options === "number")
      options = { max: options };
    if (!options)
      options = {};
    if (options.max && (typeof options.max !== "number" || options.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[MAX] = options.max || Infinity;
    const lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  }
  set max(mL) {
    if (typeof mL !== "number" || mL < 0)
      throw new TypeError("max must be a non-negative number");
    this[MAX] = mL || Infinity;
    trim(this);
  }
  get max() {
    return this[MAX];
  }
  set allowStale(allowStale) {
    this[ALLOW_STALE] = !!allowStale;
  }
  get allowStale() {
    return this[ALLOW_STALE];
  }
  set maxAge(mA) {
    if (typeof mA !== "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[MAX_AGE] = mA;
    trim(this);
  }
  get maxAge() {
    return this[MAX_AGE];
  }
  set lengthCalculator(lC) {
    if (typeof lC !== "function")
      lC = naiveLength;
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC;
      this[LENGTH] = 0;
      this[LRU_LIST].forEach((hit) => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
        this[LENGTH] += hit.length;
      });
    }
    trim(this);
  }
  get lengthCalculator() {
    return this[LENGTH_CALCULATOR];
  }
  get length() {
    return this[LENGTH];
  }
  get itemCount() {
    return this[LRU_LIST].length;
  }
  rforEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].tail; walker !== null; ) {
      const prev = walker.prev;
      forEachStep(this, fn, walker, thisp);
      walker = prev;
    }
  }
  forEach(fn, thisp) {
    thisp = thisp || this;
    for (let walker = this[LRU_LIST].head; walker !== null; ) {
      const next = walker.next;
      forEachStep(this, fn, walker, thisp);
      walker = next;
    }
  }
  keys() {
    return this[LRU_LIST].toArray().map((k) => k.key);
  }
  values() {
    return this[LRU_LIST].toArray().map((k) => k.value);
  }
  reset() {
    if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
      this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
    }
    this[CACHE] = new Map();
    this[LRU_LIST] = new Yallist();
    this[LENGTH] = 0;
  }
  dump() {
    return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
      k: hit.key,
      v: hit.value,
      e: hit.now + (hit.maxAge || 0)
    }).toArray().filter((h2) => h2);
  }
  dumpLru() {
    return this[LRU_LIST];
  }
  set(key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE];
    if (maxAge && typeof maxAge !== "number")
      throw new TypeError("maxAge must be a number");
    const now = maxAge ? Date.now() : 0;
    const len = this[LENGTH_CALCULATOR](value, key);
    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key));
        return false;
      }
      const node = this[CACHE].get(key);
      const item = node.value;
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value);
      }
      item.now = now;
      item.maxAge = maxAge;
      item.value = value;
      this[LENGTH] += len - item.length;
      item.length = len;
      this.get(key);
      trim(this);
      return true;
    }
    const hit = new Entry(key, value, len, now, maxAge);
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value);
      return false;
    }
    this[LENGTH] += hit.length;
    this[LRU_LIST].unshift(hit);
    this[CACHE].set(key, this[LRU_LIST].head);
    trim(this);
    return true;
  }
  has(key) {
    if (!this[CACHE].has(key))
      return false;
    const hit = this[CACHE].get(key).value;
    return !isStale(this, hit);
  }
  get(key) {
    return get(this, key, true);
  }
  peek(key) {
    return get(this, key, false);
  }
  pop() {
    const node = this[LRU_LIST].tail;
    if (!node)
      return null;
    del(this, node);
    return node.value;
  }
  del(key) {
    del(this, this[CACHE].get(key));
  }
  load(arr) {
    this.reset();
    const now = Date.now();
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l];
      const expiresAt = hit.e || 0;
      if (expiresAt === 0)
        this.set(hit.k, hit.v);
      else {
        const maxAge = expiresAt - now;
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge);
        }
      }
    }
  }
  prune() {
    this[CACHE].forEach((value, key) => get(this, key, false));
  }
}
const get = (self2, key, doUse) => {
  const node = self2[CACHE].get(key);
  if (node) {
    const hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        return void 0;
    } else {
      if (doUse) {
        if (self2[UPDATE_AGE_ON_GET])
          node.value.now = Date.now();
        self2[LRU_LIST].unshiftNode(node);
      }
    }
    return hit.value;
  }
};
const isStale = (self2, hit) => {
  if (!hit || !hit.maxAge && !self2[MAX_AGE])
    return false;
  const diff2 = Date.now() - hit.now;
  return hit.maxAge ? diff2 > hit.maxAge : self2[MAX_AGE] && diff2 > self2[MAX_AGE];
};
const trim = (self2) => {
  if (self2[LENGTH] > self2[MAX]) {
    for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
      const prev = walker.prev;
      del(self2, walker);
      walker = prev;
    }
  }
};
const del = (self2, node) => {
  if (node) {
    const hit = node.value;
    if (self2[DISPOSE])
      self2[DISPOSE](hit.key, hit.value);
    self2[LENGTH] -= hit.length;
    self2[CACHE].delete(hit.key);
    self2[LRU_LIST].removeNode(node);
  }
};
class Entry {
  constructor(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  }
}
const forEachStep = (self2, fn, node, thisp) => {
  let hit = node.value;
  if (isStale(self2, hit)) {
    del(self2, node);
    if (!self2[ALLOW_STALE])
      hit = void 0;
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self2);
};
var lruCache = LRUCache;
class Range$l {
  constructor(range2, options) {
    options = parseOptions$6(options);
    if (range2 instanceof Range$l) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$l(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$7) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range2}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet$1(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny$1(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    const memoOpts = Object.keys(this.options).join(",");
    const memoKey = `parseRange:${memoOpts}:${range2}`;
    const cached = cache$1.get(memoKey);
    if (cached)
      return cached;
    const loose = this.options.loose;
    const hr = loose ? re$7[t$6.HYPHENRANGELOOSE] : re$7[t$6.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace$1(this.options.includePrerelease));
    debug$5("hyphen replace", range2);
    range2 = range2.replace(re$7[t$6.COMPARATORTRIM], comparatorTrimReplace$1);
    debug$5("comparator trim", range2, re$7[t$6.COMPARATORTRIM]);
    range2 = range2.replace(re$7[t$6.TILDETRIM], tildeTrimReplace$1);
    range2 = range2.replace(re$7[t$6.CARETTRIM], caretTrimReplace$1);
    range2 = range2.split(/\s+/).join(" ");
    const compRe = loose ? re$7[t$6.COMPARATORLOOSE] : re$7[t$6.COMPARATOR];
    const rangeList = range2.split(" ").map((comp) => parseComparator$1(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0$1(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$7(comp, this.options));
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet$1(comp))
        return [comp];
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    const result = [...rangeMap.values()];
    cache$1.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$l)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable$1(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable$1(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$k(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i2 = 0; i2 < this.set.length; i2++) {
      if (testSet$1(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range$1 = Range$l;
const LRU$1 = lruCache;
const cache$1 = new LRU$1({ max: 1e3 });
const parseOptions$6 = parseOptions_1$1;
const Comparator$7 = comparator$1;
const debug$5 = debug_1$1;
const SemVer$k = semver$4;
const {
  re: re$7,
  t: t$6,
  comparatorTrimReplace: comparatorTrimReplace$1,
  tildeTrimReplace: tildeTrimReplace$1,
  caretTrimReplace: caretTrimReplace$1
} = re$b.exports;
const isNullSet$1 = (c) => c.value === "<0.0.0-0";
const isAny$1 = (c) => c.value === "";
const isSatisfiable$1 = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator$1 = (comp, options) => {
  debug$5("comp", comp, options);
  comp = replaceCarets$1(comp, options);
  debug$5("caret", comp);
  comp = replaceTildes$1(comp, options);
  debug$5("tildes", comp);
  comp = replaceXRanges$1(comp, options);
  debug$5("xrange", comp);
  comp = replaceStars$1(comp, options);
  debug$5("stars", comp);
  return comp;
};
const isX$1 = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes$1 = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde$1(comp2, options);
}).join(" ");
const replaceTilde$1 = (comp, options) => {
  const r = options.loose ? re$7[t$6.TILDELOOSE] : re$7[t$6.TILDE];
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$5("tilde", comp, _, M, m2, p, pr);
    let ret;
    if (isX$1(M)) {
      ret = "";
    } else if (isX$1(m2)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX$1(p)) {
      ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
    } else if (pr) {
      debug$5("replaceTilde pr", pr);
      ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
    } else {
      ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
    }
    debug$5("tilde return", ret);
    return ret;
  });
};
const replaceCarets$1 = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret$1(comp2, options);
}).join(" ");
const replaceCaret$1 = (comp, options) => {
  debug$5("caret", comp, options);
  const r = options.loose ? re$7[t$6.CARETLOOSE] : re$7[t$6.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$5("caret", comp, _, M, m2, p, pr);
    let ret;
    if (isX$1(M)) {
      ret = "";
    } else if (isX$1(m2)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX$1(p)) {
      if (M === "0") {
        ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$5("replaceCaret pr", pr);
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$5("no pr");
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$5("caret return", ret);
    return ret;
  });
};
const replaceXRanges$1 = (comp, options) => {
  debug$5("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange$1(comp2, options);
  }).join(" ");
};
const replaceXRange$1 = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$7[t$6.XRANGELOOSE] : re$7[t$6.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
    debug$5("xRange", comp, ret, gtlt, M, m2, p, pr);
    const xM = isX$1(M);
    const xm = xM || isX$1(m2);
    const xp = xm || isX$1(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m2 = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m2 = 0;
          p = 0;
        } else {
          m2 = +m2 + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m2 = +m2 + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = `${gtlt + M}.${m2}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
    }
    debug$5("xRange return", ret);
    return ret;
  });
};
const replaceStars$1 = (comp, options) => {
  debug$5("replaceStars", comp, options);
  return comp.trim().replace(re$7[t$6.STAR], "");
};
const replaceGTE0$1 = (comp, options) => {
  debug$5("replaceGTE0", comp, options);
  return comp.trim().replace(re$7[options.includePrerelease ? t$6.GTE0PRE : t$6.GTE0], "");
};
const hyphenReplace$1 = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX$1(fM)) {
    from = "";
  } else if (isX$1(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX$1(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX$1(tM)) {
    to = "";
  } else if (isX$1(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX$1(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet$1 = (set2, version, options) => {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (!set2[i2].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i2 = 0; i2 < set2.length; i2++) {
      debug$5(set2[i2].semver);
      if (set2[i2].semver === Comparator$7.ANY) {
        continue;
      }
      if (set2[i2].semver.prerelease.length > 0) {
        const allowed = set2[i2].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$5 = Symbol("SemVer ANY");
class Comparator$6 {
  static get ANY() {
    return ANY$5;
  }
  constructor(comp, options) {
    options = parseOptions$5(options);
    if (comp instanceof Comparator$6) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug$4("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$5) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug$4("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re$6[t$5.COMPARATORLOOSE] : re$6[t$5.COMPARATOR];
    const m2 = comp.match(r);
    if (!m2) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY$5;
    } else {
      this.semver = new SemVer$j(m2[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug$4("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$5 || version === ANY$5) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$j(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp$2(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$6)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$k(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$k(this.value, options).test(comp.semver);
    }
    const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    const oppositeDirectionsLessThan = cmp$2(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    const oppositeDirectionsGreaterThan = cmp$2(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
}
var comparator$1 = Comparator$6;
const parseOptions$5 = parseOptions_1$1;
const { re: re$6, t: t$5 } = re$b.exports;
const cmp$2 = cmp_1$1;
const debug$4 = debug_1$1;
const SemVer$j = semver$4;
const Range$k = range$1;
const Range$j = range$1;
const satisfies$7 = (version, range2, options) => {
  try {
    range2 = new Range$j(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1$1 = satisfies$7;
const Range$i = range$1;
const toComparators$1 = (range2, options) => new Range$i(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1$1 = toComparators$1;
const SemVer$i = semver$4;
const Range$h = range$1;
const maxSatisfying$1 = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$h(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$i(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1$1 = maxSatisfying$1;
const SemVer$h = semver$4;
const Range$g = range$1;
const minSatisfying$1 = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$g(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$h(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1$1 = minSatisfying$1;
const SemVer$g = semver$4;
const Range$f = range$1;
const gt$5 = gt_1$1;
const minVersion$1 = (range2, loose) => {
  range2 = new Range$f(range2, loose);
  let minver = new SemVer$g("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$g("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$g(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$5(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$5(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1$1 = minVersion$1;
const Range$e = range$1;
const validRange$1 = (range2, options) => {
  try {
    return new Range$e(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid$2 = validRange$1;
const SemVer$f = semver$4;
const Comparator$5 = comparator$1;
const { ANY: ANY$4 } = Comparator$5;
const Range$d = range$1;
const satisfies$6 = satisfies_1$1;
const gt$4 = gt_1$1;
const lt$3 = lt_1$1;
const lte$3 = lte_1$1;
const gte$3 = gte_1$1;
const outside$5 = (version, range2, hilo, options) => {
  version = new SemVer$f(version, options);
  range2 = new Range$d(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt$4;
      ltefn = lte$3;
      ltfn = lt$3;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt$3;
      ltefn = gte$3;
      ltfn = gt$4;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$6(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$4) {
        comparator2 = new Comparator$5(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1$1 = outside$5;
const outside$4 = outside_1$1;
const gtr$1 = (version, range2, options) => outside$4(version, range2, ">", options);
var gtr_1$1 = gtr$1;
const outside$3 = outside_1$1;
const ltr$1 = (version, range2, options) => outside$3(version, range2, "<", options);
var ltr_1$1 = ltr$1;
const Range$c = range$1;
const intersects$1 = (r1, r2, options) => {
  r1 = new Range$c(r1, options);
  r2 = new Range$c(r2, options);
  return r1.intersects(r2);
};
var intersects_1$1 = intersects$1;
const satisfies$5 = satisfies_1$1;
const compare$c = compare_1$1;
var simplify$1 = (versions, range2, options) => {
  const set2 = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$c(a, b, options));
  for (const version of v) {
    const included = satisfies$5(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set2.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set2.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set2) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range$b = range$1;
const Comparator$4 = comparator$1;
const { ANY: ANY$3 } = Comparator$4;
const satisfies$4 = satisfies_1$1;
const compare$b = compare_1$1;
const subset$1 = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range$b(sub, options);
  dom = new Range$b(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset$1(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset$1 = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY$3) {
    if (dom.length === 1 && dom[0].semver === ANY$3)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator$4(">=0.0.0-0")];
    else
      sub = [new Comparator$4(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY$3) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator$4(">=0.0.0")];
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT$1(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT$1(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare$b(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies$4(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies$4(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies$4(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT$1(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies$4(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT$1(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies$4(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT$1 = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare$b(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT$1 = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare$b(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1$1 = subset$1;
const internalRe$1 = re$b.exports;
var semver$3 = {
  re: internalRe$1.re,
  src: internalRe$1.src,
  tokens: internalRe$1.t,
  SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
  SemVer: semver$4,
  compareIdentifiers: identifiers$1.compareIdentifiers,
  rcompareIdentifiers: identifiers$1.rcompareIdentifiers,
  parse: parse_1$1,
  valid: valid_1$1,
  clean: clean_1$1,
  inc: inc_1$1,
  diff: diff_1$1,
  major: major_1$1,
  minor: minor_1$1,
  patch: patch_1$1,
  prerelease: prerelease_1$1,
  compare: compare_1$1,
  rcompare: rcompare_1$1,
  compareLoose: compareLoose_1$1,
  compareBuild: compareBuild_1$1,
  sort: sort_1$1,
  rsort: rsort_1$1,
  gt: gt_1$1,
  lt: lt_1$1,
  eq: eq_1$1,
  neq: neq_1$1,
  gte: gte_1$1,
  lte: lte_1$1,
  cmp: cmp_1$1,
  coerce: coerce_1$1,
  Comparator: comparator$1,
  Range: range$1,
  satisfies: satisfies_1$1,
  toComparators: toComparators_1$1,
  maxSatisfying: maxSatisfying_1$1,
  minSatisfying: minSatisfying_1$1,
  minVersion: minVersion_1$1,
  validRange: valid$2,
  outside: outside_1$1,
  gtr: gtr_1$1,
  ltr: ltr_1$1,
  intersects: intersects_1$1,
  simplifyRange: simplify$1,
  subset: subset_1$1
};
var DownloadedUpdateHelper$1 = {};
var lodash_isequal = { exports: {} };
(function(module, exports) {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var MAX_SAFE_INTEGER2 = 9007199254740991;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto2 = Object.prototype;
  var coreJsData = root2["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto2.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array2 = root2.Uint8Array, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root2, "DataView"), Map2 = getNative(root2, "Map"), Promise2 = getNative(root2, "Promise"), Set2 = getNative(root2, "Set"), WeakMap2 = getNative(root2, "WeakMap"), nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString2(value);
  }
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern2 = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag2:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER2 : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  function objectToString2(value) {
    return nativeObjectToString.call(value);
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isEqual2(value, other) {
    return baseIsEqual(value, other);
  }
  function isFunction(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = isEqual2;
})(lodash_isequal, lodash_isequal.exports);
Object.defineProperty(DownloadedUpdateHelper$1, "__esModule", { value: true });
DownloadedUpdateHelper$1.createTempUpdateFile = DownloadedUpdateHelper$1.DownloadedUpdateHelper = void 0;
const crypto_1$1 = require$$0__default$4["default"];
const fs_1$6 = require$$0__default$2["default"];
const isEqual = lodash_isequal.exports;
const fs_extra_1$6 = lib;
const path$d = require$$1__default$1["default"];
class DownloadedUpdateHelper {
  constructor(cacheDir) {
    this.cacheDir = cacheDir;
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    this._downloadedFileInfo = null;
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return path$d.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(updateFile, updateInfo, fileInfo, logger) {
    if (this.versionInfo != null && this.file === updateFile && this.fileInfo != null) {
      if (isEqual(this.versionInfo, updateInfo) && isEqual(this.fileInfo.info, fileInfo.info) && await fs_extra_1$6.pathExists(updateFile)) {
        return updateFile;
      } else {
        return null;
      }
    }
    const cachedUpdateFile = await this.getValidCachedUpdateFile(fileInfo, logger);
    if (cachedUpdateFile === null) {
      return null;
    }
    logger.info(`Update has already been downloaded to ${updateFile}).`);
    this._file = cachedUpdateFile;
    return cachedUpdateFile;
  }
  async setDownloadedFile(downloadedFile, packageFile, versionInfo, fileInfo, updateFileName, isSaveCache) {
    this._file = downloadedFile;
    this._packageFile = packageFile;
    this.versionInfo = versionInfo;
    this.fileInfo = fileInfo;
    this._downloadedFileInfo = {
      fileName: updateFileName,
      sha512: fileInfo.info.sha512,
      isAdminRightsRequired: fileInfo.info.isAdminRightsRequired === true
    };
    if (isSaveCache) {
      await fs_extra_1$6.outputJson(this.getUpdateInfoFile(), this._downloadedFileInfo);
    }
  }
  async clear() {
    this._file = null;
    this._packageFile = null;
    this.versionInfo = null;
    this.fileInfo = null;
    await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await fs_extra_1$6.emptyDir(this.cacheDirForPendingUpdate);
    } catch (ignore) {
    }
  }
  async getValidCachedUpdateFile(fileInfo, logger) {
    var _a;
    const updateInfoFilePath = this.getUpdateInfoFile();
    const doesUpdateInfoFileExist = await fs_extra_1$6.pathExists(updateInfoFilePath);
    if (!doesUpdateInfoFileExist) {
      return null;
    }
    let cachedInfo;
    try {
      cachedInfo = await fs_extra_1$6.readJson(updateInfoFilePath);
    } catch (error2) {
      let message = `No cached update info available`;
      if (error2.code !== "ENOENT") {
        await this.cleanCacheDirForPendingUpdate();
        message += ` (error on read: ${error2.message})`;
      }
      logger.info(message);
      return null;
    }
    const isCachedInfoFileNameValid = (_a = (cachedInfo === null || cachedInfo === void 0 ? void 0 : cachedInfo.fileName) !== null) !== null && _a !== void 0 ? _a : false;
    if (!isCachedInfoFileNameValid) {
      logger.warn(`Cached update info is corrupted: no fileName, directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    if (fileInfo.info.sha512 !== cachedInfo.sha512) {
      logger.info(`Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${cachedInfo.sha512}, expected: ${fileInfo.info.sha512}. Directory for cached update will be cleaned`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    const updateFile = path$d.join(this.cacheDirForPendingUpdate, cachedInfo.fileName);
    if (!await fs_extra_1$6.pathExists(updateFile)) {
      logger.info("Cached update file doesn't exist");
      return null;
    }
    const sha512 = await hashFile(updateFile);
    if (fileInfo.info.sha512 !== sha512) {
      logger.warn(`Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${sha512}, expected: ${fileInfo.info.sha512}`);
      await this.cleanCacheDirForPendingUpdate();
      return null;
    }
    this._downloadedFileInfo = cachedInfo;
    return updateFile;
  }
  getUpdateInfoFile() {
    return path$d.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
DownloadedUpdateHelper$1.DownloadedUpdateHelper = DownloadedUpdateHelper;
function hashFile(file2, algorithm = "sha512", encoding = "base64", options) {
  return new Promise((resolve2, reject) => {
    const hash = crypto_1$1.createHash(algorithm);
    hash.on("error", reject).setEncoding(encoding);
    fs_1$6.createReadStream(file2, __spreadProps(__spreadValues({}, options), { highWaterMark: 1024 * 1024 })).on("error", reject).on("end", () => {
      hash.end();
      resolve2(hash.read());
    }).pipe(hash, { end: false });
  });
}
async function createTempUpdateFile(name, cacheDir, log) {
  let nameCounter = 0;
  let result = path$d.join(cacheDir, name);
  for (let i2 = 0; i2 < 3; i2++) {
    try {
      await fs_extra_1$6.unlink(result);
      return result;
    } catch (e) {
      if (e.code === "ENOENT") {
        return result;
      }
      log.warn(`Error on remove temp update file: ${e}`);
      result = path$d.join(cacheDir, `${nameCounter++}-${name}`);
    }
  }
  return result;
}
DownloadedUpdateHelper$1.createTempUpdateFile = createTempUpdateFile;
var ElectronAppAdapter$1 = {};
var AppAdapter = {};
Object.defineProperty(AppAdapter, "__esModule", { value: true });
AppAdapter.getAppCacheDir = void 0;
const path$c = require$$1__default$1["default"];
const os_1 = require$$1__default$3["default"];
function getAppCacheDir() {
  const homedir2 = os_1.homedir();
  let result;
  if (process.platform === "win32") {
    result = process.env["LOCALAPPDATA"] || path$c.join(homedir2, "AppData", "Local");
  } else if (process.platform === "darwin") {
    result = path$c.join(homedir2, "Library", "Application Support", "Caches");
  } else {
    result = process.env["XDG_CACHE_HOME"] || path$c.join(homedir2, ".cache");
  }
  return result;
}
AppAdapter.getAppCacheDir = getAppCacheDir;
Object.defineProperty(ElectronAppAdapter$1, "__esModule", { value: true });
ElectronAppAdapter$1.ElectronAppAdapter = void 0;
const path$b = require$$1__default$1["default"];
const AppAdapter_1 = AppAdapter;
class ElectronAppAdapter {
  constructor(app2 = require$$1__default["default"].app) {
    this.app = app2;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === true;
  }
  get appUpdateConfigPath() {
    return this.isPackaged ? path$b.join(process.resourcesPath, "app-update.yml") : path$b.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return AppAdapter_1.getAppCacheDir();
  }
  quit() {
    this.app.quit();
  }
  onQuit(handler) {
    this.app.once("quit", (_, exitCode) => handler(exitCode));
  }
}
ElectronAppAdapter$1.ElectronAppAdapter = ElectronAppAdapter;
var electronHttpExecutor = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ElectronHttpExecutor = exports.getNetSession = exports.NET_SESSION_NAME = void 0;
  const builder_util_runtime_12 = out;
  exports.NET_SESSION_NAME = "electron-updater";
  function getNetSession() {
    return require$$1__default["default"].session.fromPartition(exports.NET_SESSION_NAME, {
      cache: false
    });
  }
  exports.getNetSession = getNetSession;
  class ElectronHttpExecutor extends builder_util_runtime_12.HttpExecutor {
    constructor(proxyLoginCallback) {
      super();
      this.proxyLoginCallback = proxyLoginCallback;
      this.cachedSession = null;
    }
    async download(url, destination, options) {
      return await options.cancellationToken.createPromise((resolve2, reject, onCancel) => {
        const requestOptions = {
          headers: options.headers || void 0,
          redirect: "manual"
        };
        builder_util_runtime_12.configureRequestUrl(url, requestOptions);
        builder_util_runtime_12.configureRequestOptions(requestOptions);
        this.doDownload(requestOptions, {
          destination,
          options,
          onCancel,
          callback: (error2) => {
            if (error2 == null) {
              resolve2(destination);
            } else {
              reject(error2);
            }
          },
          responseHandler: null
        }, 0);
      });
    }
    createRequest(options, callback) {
      if (options.headers && options.headers.Host) {
        options.host = options.headers.Host;
        delete options.headers.Host;
      }
      if (this.cachedSession == null) {
        this.cachedSession = getNetSession();
      }
      const request = require$$1__default["default"].net.request(__spreadProps(__spreadValues({}, options), {
        session: this.cachedSession
      }));
      request.on("response", callback);
      if (this.proxyLoginCallback != null) {
        request.on("login", this.proxyLoginCallback);
      }
      return request;
    }
    addRedirectHandlers(request, options, reject, redirectCount, handler) {
      request.on("redirect", (statusCode, method, redirectUrl) => {
        request.abort();
        if (redirectCount > this.maxRedirects) {
          reject(this.createMaxRedirectError());
        } else {
          handler(builder_util_runtime_12.HttpExecutor.prepareRedirectUrlOptions(redirectUrl, options));
        }
      });
    }
  }
  exports.ElectronHttpExecutor = ElectronHttpExecutor;
})(electronHttpExecutor);
var GenericProvider$1 = {};
var util$1 = {};
var INFINITY = 1 / 0;
var symbolTag = "[object Symbol]";
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var objectProto = Object.prototype;
var objectToString = objectProto.toString;
var Symbol$1 = root.Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function escapeRegExp$1(string) {
  string = toString(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
var lodash_escaperegexp = escapeRegExp$1;
Object.defineProperty(util$1, "__esModule", { value: true });
util$1.blockmapFiles = util$1.getChannelFilename = util$1.newUrlFromBase = util$1.newBaseUrl = void 0;
const url_1$5 = require$$2__default["default"];
const escapeRegExp = lodash_escaperegexp;
function newBaseUrl(url) {
  const result = new url_1$5.URL(url);
  if (!result.pathname.endsWith("/")) {
    result.pathname += "/";
  }
  return result;
}
util$1.newBaseUrl = newBaseUrl;
function newUrlFromBase(pathname, baseUrl, addRandomQueryToAvoidCaching = false) {
  const result = new url_1$5.URL(pathname, baseUrl);
  const search = baseUrl.search;
  if (search != null && search.length !== 0) {
    result.search = search;
  } else if (addRandomQueryToAvoidCaching) {
    result.search = `noCache=${Date.now().toString(32)}`;
  }
  return result;
}
util$1.newUrlFromBase = newUrlFromBase;
function getChannelFilename(channel) {
  return `${channel}.yml`;
}
util$1.getChannelFilename = getChannelFilename;
function blockmapFiles(baseUrl, oldVersion, newVersion) {
  const newBlockMapUrl = newUrlFromBase(`${baseUrl.pathname}.blockmap`, baseUrl);
  const oldBlockMapUrl = newUrlFromBase(`${baseUrl.pathname.replace(new RegExp(escapeRegExp(newVersion), "g"), oldVersion)}.blockmap`, baseUrl);
  return [oldBlockMapUrl, newBlockMapUrl];
}
util$1.blockmapFiles = blockmapFiles;
var Provider$1 = {};
Object.defineProperty(Provider$1, "__esModule", { value: true });
Provider$1.resolveFiles = Provider$1.getFileList = Provider$1.parseUpdateInfo = Provider$1.findFile = Provider$1.Provider = void 0;
const builder_util_runtime_1$e = out;
const js_yaml_1$2 = jsYaml;
const util_1$w = util$1;
class Provider {
  constructor(runtimeOptions) {
    this.runtimeOptions = runtimeOptions;
    this.requestHeaders = null;
    this.executor = runtimeOptions.executor;
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== false;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const arch = process.env["TEST_UPDATER_ARCH"] || process.arch;
      const archSuffix = arch === "x64" ? "" : `-${arch}`;
      return "-linux" + archSuffix;
    } else {
      return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
    }
  }
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(channel) {
    return `${channel}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  httpRequest(url, headers, cancellationToken) {
    return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
  }
  createRequestOptions(url, headers) {
    const result = {};
    if (this.requestHeaders == null) {
      if (headers != null) {
        result.headers = headers;
      }
    } else {
      result.headers = headers == null ? this.requestHeaders : __spreadValues(__spreadValues({}, this.requestHeaders), headers);
    }
    builder_util_runtime_1$e.configureRequestUrl(url, result);
    return result;
  }
}
Provider$1.Provider = Provider;
function findFile(files, extension, not2) {
  if (files.length === 0) {
    throw builder_util_runtime_1$e.newError("No files provided", "ERR_UPDATER_NO_FILES_PROVIDED");
  }
  const result = files.find((it) => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
  if (result != null) {
    return result;
  } else if (not2 == null) {
    return files[0];
  } else {
    return files.find((fileInfo) => !not2.some((ext) => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
  }
}
Provider$1.findFile = findFile;
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
  if (rawData == null) {
    throw builder_util_runtime_1$e.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  let result;
  try {
    result = js_yaml_1$2.load(rawData);
  } catch (e) {
    throw builder_util_runtime_1$e.newError(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`, "ERR_UPDATER_INVALID_UPDATE_INFO");
  }
  return result;
}
Provider$1.parseUpdateInfo = parseUpdateInfo;
function getFileList(updateInfo) {
  const files = updateInfo.files;
  if (files != null && files.length > 0) {
    return files;
  }
  if (updateInfo.path != null) {
    return [
      {
        url: updateInfo.path,
        sha2: updateInfo.sha2,
        sha512: updateInfo.sha512
      }
    ];
  } else {
    throw builder_util_runtime_1$e.newError(`No files provided: ${builder_util_runtime_1$e.safeStringifyJson(updateInfo)}`, "ERR_UPDATER_NO_FILES_PROVIDED");
  }
}
Provider$1.getFileList = getFileList;
function resolveFiles(updateInfo, baseUrl, pathTransformer = (p) => p) {
  const files = getFileList(updateInfo);
  const result = files.map((fileInfo) => {
    if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
      throw builder_util_runtime_1$e.newError(`Update info doesn't contain nor sha256 neither sha512 checksum: ${builder_util_runtime_1$e.safeStringifyJson(fileInfo)}`, "ERR_UPDATER_NO_CHECKSUM");
    }
    return {
      url: util_1$w.newUrlFromBase(pathTransformer(fileInfo.url), baseUrl),
      info: fileInfo
    };
  });
  const packages = updateInfo.packages;
  const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
  if (packageInfo != null) {
    result[0].packageInfo = __spreadProps(__spreadValues({}, packageInfo), {
      path: util_1$w.newUrlFromBase(pathTransformer(packageInfo.path), baseUrl).href
    });
  }
  return result;
}
Provider$1.resolveFiles = resolveFiles;
Object.defineProperty(GenericProvider$1, "__esModule", { value: true });
GenericProvider$1.GenericProvider = void 0;
const builder_util_runtime_1$d = out;
const util_1$v = util$1;
const Provider_1$7 = Provider$1;
class GenericProvider extends Provider_1$7.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(runtimeOptions);
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = util_1$v.newBaseUrl(this.configuration.url);
  }
  get channel() {
    const result = this.updater.channel || this.configuration.channel;
    return result == null ? this.getDefaultChannelName() : this.getCustomChannelName(result);
  }
  async getLatestVersion() {
    const channelFile = util_1$v.getChannelFilename(this.channel);
    const channelUrl = util_1$v.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    for (let attemptNumber = 0; ; attemptNumber++) {
      try {
        return Provider_1$7.parseUpdateInfo(await this.httpRequest(channelUrl), channelFile, channelUrl);
      } catch (e) {
        if (e instanceof builder_util_runtime_1$d.HttpError && e.statusCode === 404) {
          throw builder_util_runtime_1$d.newError(`Cannot find channel "${channelFile}" update info: ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
        } else if (e.code === "ECONNREFUSED") {
          if (attemptNumber < 3) {
            await new Promise((resolve2, reject) => {
              try {
                setTimeout(resolve2, 1e3 * attemptNumber);
              } catch (e2) {
                reject(e2);
              }
            });
            continue;
          }
        }
        throw e;
      }
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$7.resolveFiles(updateInfo, this.baseUrl);
  }
}
GenericProvider$1.GenericProvider = GenericProvider;
var providerFactory = {};
var BintrayProvider$1 = {};
var bintray = {};
Object.defineProperty(bintray, "__esModule", { value: true });
bintray.BintrayClient = void 0;
const httpExecutor_1 = httpExecutor;
class BintrayClient {
  constructor(options, httpExecutor2, cancellationToken, apiKey) {
    this.httpExecutor = httpExecutor2;
    this.cancellationToken = cancellationToken;
    this.requestHeaders = null;
    if (options.owner == null) {
      throw new Error("owner is not specified");
    }
    if (options.package == null) {
      throw new Error("package is not specified");
    }
    this.repo = options.repo || "generic";
    this.packageName = options.package;
    this.owner = options.owner;
    this.user = options.user || options.owner;
    this.component = options.component || null;
    this.distribution = options.distribution || "stable";
    this.auth = apiKey == null ? null : `Basic ${Buffer.from(`${this.user}:${apiKey}`).toString("base64")}`;
    this.basePath = `/packages/${this.owner}/${this.repo}/${this.packageName}`;
  }
  setRequestHeaders(value) {
    this.requestHeaders = value;
  }
  bintrayRequest(path2, auth, data = null, cancellationToken, method) {
    return httpExecutor_1.parseJson(this.httpExecutor.request(httpExecutor_1.configureRequestOptions({ hostname: "api.bintray.com", path: path2, headers: this.requestHeaders || void 0 }, auth, method), cancellationToken, data));
  }
  getVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken);
  }
  getVersionFiles(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}/files`, this.auth, null, this.cancellationToken);
  }
  createVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions`, this.auth, {
      name: version
    }, this.cancellationToken);
  }
  deleteVersion(version) {
    return this.bintrayRequest(`${this.basePath}/versions/${version}`, this.auth, null, this.cancellationToken, "DELETE");
  }
}
bintray.BintrayClient = BintrayClient;
Object.defineProperty(BintrayProvider$1, "__esModule", { value: true });
BintrayProvider$1.BintrayProvider = void 0;
const builder_util_runtime_1$c = out;
const bintray_1 = bintray;
const url_1$4 = require$$2__default["default"];
const util_1$u = util$1;
const Provider_1$6 = Provider$1;
class BintrayProvider extends Provider_1$6.Provider {
  constructor(configuration, runtimeOptions) {
    super(runtimeOptions);
    this.client = new bintray_1.BintrayClient(configuration, runtimeOptions.executor, new builder_util_runtime_1$c.CancellationToken());
    this.baseUrl = util_1$u.newBaseUrl(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}`);
  }
  setRequestHeaders(value) {
    super.setRequestHeaders(value);
    this.client.setRequestHeaders(value);
  }
  async getLatestVersion() {
    try {
      const data = await this.client.getVersion("_latest");
      const channelFilename = util_1$u.getChannelFilename(this.getDefaultChannelName());
      const files = await this.client.getVersionFiles(data.name);
      const channelFile = files.find((it) => it.name.endsWith(`_${channelFilename}`) || it.name.endsWith(`-${channelFilename}`));
      if (channelFile == null) {
        throw builder_util_runtime_1$c.newError(`Cannot find channel file "${channelFilename}", existing files:
${files.map((it) => JSON.stringify(it, null, 2)).join(",\n")}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      const channelFileUrl = new url_1$4.URL(`https://dl.bintray.com/${this.client.owner}/${this.client.repo}/${channelFile.name}`);
      return Provider_1$6.parseUpdateInfo(await this.httpRequest(channelFileUrl), channelFilename, channelFileUrl);
    } catch (e) {
      if ("statusCode" in e && e.statusCode === 404) {
        throw builder_util_runtime_1$c.newError(`No latest version, please ensure that user, package and repository correctly configured. Or at least one version is published. ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
      }
      throw e;
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$6.resolveFiles(updateInfo, this.baseUrl);
  }
}
BintrayProvider$1.BintrayProvider = BintrayProvider;
var GitHubProvider$1 = {};
Object.defineProperty(GitHubProvider$1, "__esModule", { value: true });
GitHubProvider$1.computeReleaseNotes = GitHubProvider$1.GitHubProvider = GitHubProvider$1.BaseGitHubProvider = void 0;
const builder_util_runtime_1$b = out;
const semver$2 = semver$3;
const url_1$3 = require$$2__default["default"];
const util_1$t = util$1;
const Provider_1$5 = Provider$1;
const hrefRegExp = /\/tag\/([^/]+)$/;
class BaseGitHubProvider extends Provider_1$5.Provider {
  constructor(options, defaultHost, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.options = options;
    this.baseUrl = util_1$t.newBaseUrl(builder_util_runtime_1$b.githubUrl(options, defaultHost));
    const apiHost = defaultHost === "github.com" ? "api.github.com" : defaultHost;
    this.baseApiUrl = util_1$t.newBaseUrl(builder_util_runtime_1$b.githubUrl(options, apiHost));
  }
  computeGithubBasePath(result) {
    const host = this.options.host;
    return host != null && host !== "github.com" && host !== "api.github.com" ? `/api/v3${result}` : result;
  }
}
GitHubProvider$1.BaseGitHubProvider = BaseGitHubProvider;
class GitHubProvider extends BaseGitHubProvider {
  constructor(options, updater, runtimeOptions) {
    super(options, "github.com", runtimeOptions);
    this.options = options;
    this.updater = updater;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$b.CancellationToken();
    const feedXml = await this.httpRequest(util_1$t.newUrlFromBase(`${this.basePath}.atom`, this.baseUrl), {
      accept: "application/xml, application/atom+xml, text/xml, */*"
    }, cancellationToken);
    const feed = builder_util_runtime_1$b.parseXml(feedXml);
    let latestRelease = feed.element("entry", false, `No published versions on GitHub`);
    let tag;
    try {
      if (this.updater.allowPrerelease) {
        tag = hrefRegExp.exec(latestRelease.element("link").attribute("href"))[1];
      } else {
        tag = await this.getLatestTagName(cancellationToken);
        for (const element of feed.getElements("entry")) {
          if (hrefRegExp.exec(element.element("link").attribute("href"))[1] === tag) {
            latestRelease = element;
            break;
          }
        }
      }
    } catch (e) {
      throw builder_util_runtime_1$b.newError(`Cannot parse releases feed: ${e.stack || e.message},
XML:
${feedXml}`, "ERR_UPDATER_INVALID_RELEASE_FEED");
    }
    if (tag == null) {
      throw builder_util_runtime_1$b.newError(`No published versions on GitHub`, "ERR_UPDATER_NO_PUBLISHED_VERSIONS");
    }
    const channelFile = util_1$t.getChannelFilename(this.getDefaultChannelName());
    const channelFileUrl = util_1$t.newUrlFromBase(this.getBaseDownloadPath(tag, channelFile), this.baseUrl);
    const requestOptions = this.createRequestOptions(channelFileUrl);
    let rawData;
    try {
      rawData = await this.executor.request(requestOptions, cancellationToken);
    } catch (e) {
      if (!this.updater.allowPrerelease && e instanceof builder_util_runtime_1$b.HttpError && e.statusCode === 404) {
        throw builder_util_runtime_1$b.newError(`Cannot find ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    const result = Provider_1$5.parseUpdateInfo(rawData, channelFile, channelFileUrl);
    if (result.releaseName == null) {
      result.releaseName = latestRelease.elementValueOrEmpty("title");
    }
    if (result.releaseNotes == null) {
      result.releaseNotes = computeReleaseNotes(this.updater.currentVersion, this.updater.fullChangelog, feed, latestRelease);
    }
    return __spreadValues({
      tag
    }, result);
  }
  async getLatestTagName(cancellationToken) {
    const options = this.options;
    const url = options.host == null || options.host === "github.com" ? util_1$t.newUrlFromBase(`${this.basePath}/latest`, this.baseUrl) : new url_1$3.URL(`${this.computeGithubBasePath(`/repos/${options.owner}/${options.repo}/releases`)}/latest`, this.baseApiUrl);
    try {
      const rawData = await this.httpRequest(url, { Accept: "application/json" }, cancellationToken);
      if (rawData == null) {
        return null;
      }
      const releaseInfo = JSON.parse(rawData);
      return releaseInfo.tag_name;
    } catch (e) {
      throw builder_util_runtime_1$b.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(updateInfo) {
    return Provider_1$5.resolveFiles(updateInfo, this.baseUrl, (p) => this.getBaseDownloadPath(updateInfo.tag, p.replace(/ /g, "-")));
  }
  getBaseDownloadPath(tag, fileName) {
    return `${this.basePath}/download/${tag}/${fileName}`;
  }
}
GitHubProvider$1.GitHubProvider = GitHubProvider;
function getNoteValue(parent) {
  const result = parent.elementValueOrEmpty("content");
  return result === "No content." ? "" : result;
}
function computeReleaseNotes(currentVersion, isFullChangelog, feed, latestRelease) {
  if (!isFullChangelog) {
    return getNoteValue(latestRelease);
  }
  const releaseNotes = [];
  for (const release of feed.getElements("entry")) {
    const versionRelease = /\/tag\/v?([^/]+)$/.exec(release.element("link").attribute("href"))[1];
    if (semver$2.lt(currentVersion, versionRelease)) {
      releaseNotes.push({
        version: versionRelease,
        note: getNoteValue(release)
      });
    }
  }
  return releaseNotes.sort((a, b) => semver$2.rcompare(a.version, b.version));
}
GitHubProvider$1.computeReleaseNotes = computeReleaseNotes;
var KeygenProvider$1 = {};
Object.defineProperty(KeygenProvider$1, "__esModule", { value: true });
KeygenProvider$1.KeygenProvider = void 0;
const builder_util_runtime_1$a = out;
const util_1$s = util$1;
const Provider_1$4 = Provider$1;
class KeygenProvider extends Provider_1$4.Provider {
  constructor(configuration, updater, runtimeOptions) {
    super(__spreadProps(__spreadValues({}, runtimeOptions), {
      isUseMultipleRangeRequest: false
    }));
    this.configuration = configuration;
    this.updater = updater;
    this.baseUrl = util_1$s.newBaseUrl(`https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts`);
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$a.CancellationToken();
    const channelFile = util_1$s.getChannelFilename(this.getCustomChannelName(this.channel));
    const channelUrl = util_1$s.newUrlFromBase(channelFile, this.baseUrl, this.updater.isAddNoCacheQuery);
    try {
      const updateInfo = await this.httpRequest(channelUrl, {
        Accept: "application/vnd.api+json"
      }, cancellationToken);
      return Provider_1$4.parseUpdateInfo(updateInfo, channelFile, channelUrl);
    } catch (e) {
      throw builder_util_runtime_1$a.newError(`Unable to find latest version on ${this.toString()}, please ensure release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  resolveFiles(updateInfo) {
    return Provider_1$4.resolveFiles(updateInfo, this.baseUrl);
  }
  toString() {
    const { account, product, platform: platform2 } = this.configuration;
    return `Keygen (account: ${account}, product: ${product}, platform: ${platform2}, channel: ${this.channel})`;
  }
}
KeygenProvider$1.KeygenProvider = KeygenProvider;
var PrivateGitHubProvider$1 = {};
Object.defineProperty(PrivateGitHubProvider$1, "__esModule", { value: true });
PrivateGitHubProvider$1.PrivateGitHubProvider = void 0;
const builder_util_runtime_1$9 = out;
const js_yaml_1$1 = jsYaml;
const path$a = require$$1__default$1["default"];
const url_1$2 = require$$2__default["default"];
const util_1$r = util$1;
const GitHubProvider_1$1 = GitHubProvider$1;
const Provider_1$3 = Provider$1;
class PrivateGitHubProvider extends GitHubProvider_1$1.BaseGitHubProvider {
  constructor(options, updater, token, runtimeOptions) {
    super(options, "api.github.com", runtimeOptions);
    this.updater = updater;
    this.token = token;
  }
  createRequestOptions(url, headers) {
    const result = super.createRequestOptions(url, headers);
    result.redirect = "manual";
    return result;
  }
  async getLatestVersion() {
    const cancellationToken = new builder_util_runtime_1$9.CancellationToken();
    const channelFile = util_1$r.getChannelFilename(this.getDefaultChannelName());
    const releaseInfo = await this.getLatestVersionInfo(cancellationToken);
    const asset = releaseInfo.assets.find((it) => it.name === channelFile);
    if (asset == null) {
      throw builder_util_runtime_1$9.newError(`Cannot find ${channelFile} in the release ${releaseInfo.html_url || releaseInfo.name}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
    }
    const url = new url_1$2.URL(asset.url);
    let result;
    try {
      result = js_yaml_1$1.load(await this.httpRequest(url, this.configureHeaders("application/octet-stream"), cancellationToken));
    } catch (e) {
      if (e instanceof builder_util_runtime_1$9.HttpError && e.statusCode === 404) {
        throw builder_util_runtime_1$9.newError(`Cannot find ${channelFile} in the latest release artifacts (${url}): ${e.stack || e.message}`, "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND");
      }
      throw e;
    }
    result.assets = releaseInfo.assets;
    return result;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(accept) {
    return {
      accept,
      authorization: `token ${this.token}`
    };
  }
  async getLatestVersionInfo(cancellationToken) {
    const allowPrerelease = this.updater.allowPrerelease;
    let basePath = this.basePath;
    if (!allowPrerelease) {
      basePath = `${basePath}/latest`;
    }
    const url = util_1$r.newUrlFromBase(basePath, this.baseUrl);
    try {
      const version = JSON.parse(await this.httpRequest(url, this.configureHeaders("application/vnd.github.v3+json"), cancellationToken));
      if (allowPrerelease) {
        return version.find((it) => it.prerelease) || version[0];
      } else {
        return version;
      }
    } catch (e) {
      throw builder_util_runtime_1$9.newError(`Unable to find latest version on GitHub (${url}), please ensure a production release exists: ${e.stack || e.message}`, "ERR_UPDATER_LATEST_VERSION_NOT_FOUND");
    }
  }
  get basePath() {
    return this.computeGithubBasePath(`/repos/${this.options.owner}/${this.options.repo}/releases`);
  }
  resolveFiles(updateInfo) {
    return Provider_1$3.getFileList(updateInfo).map((it) => {
      const name = path$a.posix.basename(it.url).replace(/ /g, "-");
      const asset = updateInfo.assets.find((it2) => it2 != null && it2.name === name);
      if (asset == null) {
        throw builder_util_runtime_1$9.newError(`Cannot find asset "${name}" in: ${JSON.stringify(updateInfo.assets, null, 2)}`, "ERR_UPDATER_ASSET_NOT_FOUND");
      }
      return {
        url: new url_1$2.URL(asset.url),
        info: it
      };
    });
  }
}
PrivateGitHubProvider$1.PrivateGitHubProvider = PrivateGitHubProvider;
Object.defineProperty(providerFactory, "__esModule", { value: true });
providerFactory.createClient = providerFactory.isUrlProbablySupportMultiRangeRequests = void 0;
const builder_util_runtime_1$8 = out;
const BintrayProvider_1 = BintrayProvider$1;
const GenericProvider_1$1 = GenericProvider$1;
const GitHubProvider_1 = GitHubProvider$1;
const KeygenProvider_1 = KeygenProvider$1;
const PrivateGitHubProvider_1 = PrivateGitHubProvider$1;
function isUrlProbablySupportMultiRangeRequests(url) {
  return !url.includes("s3.amazonaws.com");
}
providerFactory.isUrlProbablySupportMultiRangeRequests = isUrlProbablySupportMultiRangeRequests;
function createClient(data, updater, runtimeOptions) {
  if (typeof data === "string") {
    throw builder_util_runtime_1$8.newError("Please pass PublishConfiguration object", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
  }
  const provider = data.provider;
  switch (provider) {
    case "github": {
      const githubOptions = data;
      const token = (githubOptions.private ? process.env["GH_TOKEN"] || process.env["GITHUB_TOKEN"] : null) || githubOptions.token;
      if (token == null) {
        return new GitHubProvider_1.GitHubProvider(githubOptions, updater, runtimeOptions);
      } else {
        return new PrivateGitHubProvider_1.PrivateGitHubProvider(githubOptions, updater, token, runtimeOptions);
      }
    }
    case "keygen":
      return new KeygenProvider_1.KeygenProvider(data, updater, runtimeOptions);
    case "s3":
    case "spaces":
      return new GenericProvider_1$1.GenericProvider({
        provider: "generic",
        url: builder_util_runtime_1$8.getS3LikeProviderBaseUrl(data),
        channel: data.channel || null
      }, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: false
      }));
    case "generic": {
      const options = data;
      return new GenericProvider_1$1.GenericProvider(options, updater, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: options.useMultipleRangeRequest !== false && isUrlProbablySupportMultiRangeRequests(options.url)
      }));
    }
    case "bintray":
      return new BintrayProvider_1.BintrayProvider(data, runtimeOptions);
    case "custom": {
      const options = data;
      const constructor = options.updateProvider;
      if (!constructor) {
        throw builder_util_runtime_1$8.newError("Custom provider not specified", "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION");
      }
      return new constructor(options, updater, runtimeOptions);
    }
    default:
      throw builder_util_runtime_1$8.newError(`Unsupported provider: ${provider}`, "ERR_UPDATER_UNSUPPORTED_PROVIDER");
  }
}
providerFactory.createClient = createClient;
Object.defineProperty(AppUpdater$1, "__esModule", { value: true });
AppUpdater$1.NoOpLogger = AppUpdater$1.AppUpdater = void 0;
const builder_util_runtime_1$7 = out;
const crypto_1 = require$$0__default$4["default"];
const events_1 = require$$0__default$3["default"];
const fs_extra_1$5 = lib;
const promises_1 = require$$4__default$1["default"];
const js_yaml_1 = jsYaml;
const lazy_val_1 = main;
const path$9 = require$$1__default$1["default"];
const semver_1 = semver$3;
const DownloadedUpdateHelper_1 = DownloadedUpdateHelper$1;
const ElectronAppAdapter_1 = ElectronAppAdapter$1;
const electronHttpExecutor_1 = electronHttpExecutor;
const GenericProvider_1 = GenericProvider$1;
const main_1$2 = main$1;
const providerFactory_1 = providerFactory;
class AppUpdater extends events_1.EventEmitter {
  constructor(options, app2) {
    super();
    this.autoDownload = true;
    this.autoInstallOnAppQuit = true;
    this.allowPrerelease = false;
    this.fullChangelog = false;
    this.allowDowngrade = false;
    this._channel = null;
    this.downloadedUpdateHelper = null;
    this.requestHeaders = null;
    this._logger = console;
    this.signals = new main_1$2.UpdaterSignal(this);
    this._appUpdateConfigPath = null;
    this.clientPromise = null;
    this.stagingUserIdPromise = new lazy_val_1.Lazy(() => this.getOrCreateStagingUserId());
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
    this.checkForUpdatesPromise = null;
    this.updateInfoAndProvider = null;
    this._testOnlyOptions = null;
    this.on("error", (error2) => {
      this._logger.error(`Error: ${error2.stack || error2.message}`);
    });
    if (app2 == null) {
      this.app = new ElectronAppAdapter_1.ElectronAppAdapter();
      this.httpExecutor = new electronHttpExecutor_1.ElectronHttpExecutor((authInfo, callback) => this.emit("login", authInfo, callback));
    } else {
      this.app = app2;
      this.httpExecutor = null;
    }
    const currentVersionString = this.app.version;
    const currentVersion = semver_1.parse(currentVersionString);
    if (currentVersion == null) {
      throw builder_util_runtime_1$7.newError(`App version is not a valid semver version: "${currentVersionString}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    this.currentVersion = currentVersion;
    this.allowPrerelease = hasPrereleaseComponents(currentVersion);
    if (options != null) {
      this.setFeedURL(options);
      if (typeof options !== "string" && options.requestHeaders) {
        this.requestHeaders = options.requestHeaders;
      }
    }
  }
  get channel() {
    return this._channel;
  }
  set channel(value) {
    if (this._channel != null) {
      if (typeof value !== "string") {
        throw builder_util_runtime_1$7.newError(`Channel must be a string, but got: ${value}`, "ERR_UPDATER_INVALID_CHANNEL");
      } else if (value.length === 0) {
        throw builder_util_runtime_1$7.newError(`Channel must be not an empty string`, "ERR_UPDATER_INVALID_CHANNEL");
      }
    }
    this._channel = value;
    this.allowDowngrade = true;
  }
  addAuthHeader(token) {
    this.requestHeaders = Object.assign({}, this.requestHeaders, {
      authorization: token
    });
  }
  get netSession() {
    return electronHttpExecutor_1.getNetSession();
  }
  get logger() {
    return this._logger;
  }
  set logger(value) {
    this._logger = value == null ? new NoOpLogger() : value;
  }
  set updateConfigPath(value) {
    this.clientPromise = null;
    this._appUpdateConfigPath = value;
    this.configOnDisk = new lazy_val_1.Lazy(() => this.loadUpdateConfig());
  }
  getFeedURL() {
    return "Deprecated. Do not use it.";
  }
  setFeedURL(options) {
    const runtimeOptions = this.createProviderRuntimeOptions();
    let provider;
    if (typeof options === "string") {
      provider = new GenericProvider_1.GenericProvider({ provider: "generic", url: options }, this, __spreadProps(__spreadValues({}, runtimeOptions), {
        isUseMultipleRangeRequest: providerFactory_1.isUrlProbablySupportMultiRangeRequests(options)
      }));
    } else {
      provider = providerFactory_1.createClient(options, this, runtimeOptions);
    }
    this.clientPromise = Promise.resolve(provider);
  }
  checkForUpdates() {
    let checkForUpdatesPromise = this.checkForUpdatesPromise;
    if (checkForUpdatesPromise != null) {
      this._logger.info("Checking for update (already in progress)");
      return checkForUpdatesPromise;
    }
    const nullizePromise = () => this.checkForUpdatesPromise = null;
    this._logger.info("Checking for update");
    checkForUpdatesPromise = this.doCheckForUpdates().then((it) => {
      nullizePromise();
      return it;
    }).catch((e) => {
      nullizePromise();
      this.emit("error", e, `Cannot check for updates: ${(e.stack || e).toString()}`);
      throw e;
    });
    this.checkForUpdatesPromise = checkForUpdatesPromise;
    return checkForUpdatesPromise;
  }
  isUpdaterActive() {
    if (!this.app.isPackaged) {
      this._logger.info("Skip checkForUpdatesAndNotify because application is not packed");
      return false;
    }
    return true;
  }
  checkForUpdatesAndNotify(downloadNotification) {
    if (!this.isUpdaterActive()) {
      return Promise.resolve(null);
    }
    return this.checkForUpdates().then((it) => {
      const downloadPromise = it.downloadPromise;
      if (downloadPromise == null) {
        if (this._logger.debug != null) {
          this._logger.debug("checkForUpdatesAndNotify called, downloadPromise is null");
        }
        return it;
      }
      void downloadPromise.then(() => {
        const notificationContent = AppUpdater.formatDownloadNotification(it.updateInfo.version, this.app.name, downloadNotification);
        new require$$1__default["default"].Notification(notificationContent).show();
      });
      return it;
    });
  }
  static formatDownloadNotification(version, appName, downloadNotification) {
    if (downloadNotification == null) {
      downloadNotification = {
        title: "A new update is ready to install",
        body: `{appName} version {version} has been downloaded and will be automatically installed on exit`
      };
    }
    downloadNotification = {
      title: downloadNotification.title.replace("{appName}", appName).replace("{version}", version),
      body: downloadNotification.body.replace("{appName}", appName).replace("{version}", version)
    };
    return downloadNotification;
  }
  async isStagingMatch(updateInfo) {
    const rawStagingPercentage = updateInfo.stagingPercentage;
    let stagingPercentage = rawStagingPercentage;
    if (stagingPercentage == null) {
      return true;
    }
    stagingPercentage = parseInt(stagingPercentage, 10);
    if (isNaN(stagingPercentage)) {
      this._logger.warn(`Staging percentage is NaN: ${rawStagingPercentage}`);
      return true;
    }
    stagingPercentage = stagingPercentage / 100;
    const stagingUserId = await this.stagingUserIdPromise.value;
    const val = builder_util_runtime_1$7.UUID.parse(stagingUserId).readUInt32BE(12);
    const percentage = val / 4294967295;
    this._logger.info(`Staging percentage: ${stagingPercentage}, percentage: ${percentage}, user id: ${stagingUserId}`);
    return percentage < stagingPercentage;
  }
  computeFinalHeaders(headers) {
    if (this.requestHeaders != null) {
      Object.assign(headers, this.requestHeaders);
    }
    return headers;
  }
  async isUpdateAvailable(updateInfo) {
    const latestVersion = semver_1.parse(updateInfo.version);
    if (latestVersion == null) {
      throw builder_util_runtime_1$7.newError(`This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${updateInfo.version}"`, "ERR_UPDATER_INVALID_VERSION");
    }
    const currentVersion = this.currentVersion;
    if (semver_1.eq(latestVersion, currentVersion)) {
      return false;
    }
    const isStagingMatch = await this.isStagingMatch(updateInfo);
    if (!isStagingMatch) {
      return false;
    }
    const isLatestVersionNewer = semver_1.gt(latestVersion, currentVersion);
    const isLatestVersionOlder = semver_1.lt(latestVersion, currentVersion);
    if (isLatestVersionNewer) {
      return true;
    }
    return this.allowDowngrade && isLatestVersionOlder;
  }
  async getUpdateInfoAndProvider() {
    await this.app.whenReady();
    if (this.clientPromise == null) {
      this.clientPromise = this.configOnDisk.value.then((it) => providerFactory_1.createClient(it, this, this.createProviderRuntimeOptions()));
    }
    const client = await this.clientPromise;
    const stagingUserId = await this.stagingUserIdPromise.value;
    client.setRequestHeaders(this.computeFinalHeaders({ "x-user-staging-id": stagingUserId }));
    return {
      info: await client.getLatestVersion(),
      provider: client
    };
  }
  createProviderRuntimeOptions() {
    return {
      isUseMultipleRangeRequest: true,
      platform: this._testOnlyOptions == null ? process.platform : this._testOnlyOptions.platform,
      executor: this.httpExecutor
    };
  }
  async doCheckForUpdates() {
    this.emit("checking-for-update");
    const result = await this.getUpdateInfoAndProvider();
    const updateInfo = result.info;
    if (!await this.isUpdateAvailable(updateInfo)) {
      this._logger.info(`Update for version ${this.currentVersion} is not available (latest version: ${updateInfo.version}, downgrade is ${this.allowDowngrade ? "allowed" : "disallowed"}).`);
      this.emit("update-not-available", updateInfo);
      return {
        versionInfo: updateInfo,
        updateInfo
      };
    }
    this.updateInfoAndProvider = result;
    this.onUpdateAvailable(updateInfo);
    const cancellationToken = new builder_util_runtime_1$7.CancellationToken();
    return {
      versionInfo: updateInfo,
      updateInfo,
      cancellationToken,
      downloadPromise: this.autoDownload ? this.downloadUpdate(cancellationToken) : null
    };
  }
  onUpdateAvailable(updateInfo) {
    this._logger.info(`Found version ${updateInfo.version} (url: ${builder_util_runtime_1$7.asArray(updateInfo.files).map((it) => it.url).join(", ")})`);
    this.emit("update-available", updateInfo);
  }
  downloadUpdate(cancellationToken = new builder_util_runtime_1$7.CancellationToken()) {
    const updateInfoAndProvider = this.updateInfoAndProvider;
    if (updateInfoAndProvider == null) {
      const error2 = new Error("Please check update first");
      this.dispatchError(error2);
      return Promise.reject(error2);
    }
    this._logger.info(`Downloading update from ${builder_util_runtime_1$7.asArray(updateInfoAndProvider.info.files).map((it) => it.url).join(", ")}`);
    const errorHandler = (e) => {
      if (!(e instanceof builder_util_runtime_1$7.CancellationError)) {
        try {
          this.dispatchError(e);
        } catch (nestedError) {
          this._logger.warn(`Cannot dispatch error event: ${nestedError.stack || nestedError}`);
        }
      }
      return e;
    };
    try {
      return this.doDownloadUpdate({
        updateInfoAndProvider,
        requestHeaders: this.computeRequestHeaders(updateInfoAndProvider.provider),
        cancellationToken
      }).catch((e) => {
        throw errorHandler(e);
      });
    } catch (e) {
      return Promise.reject(errorHandler(e));
    }
  }
  dispatchError(e) {
    this.emit("error", e, (e.stack || e).toString());
  }
  dispatchUpdateDownloaded(event) {
    this.emit(main_1$2.UPDATE_DOWNLOADED, event);
  }
  async loadUpdateConfig() {
    if (this._appUpdateConfigPath == null) {
      this._appUpdateConfigPath = this.app.appUpdateConfigPath;
    }
    return js_yaml_1.load(await promises_1.readFile(this._appUpdateConfigPath, "utf-8"));
  }
  computeRequestHeaders(provider) {
    const fileExtraDownloadHeaders = provider.fileExtraDownloadHeaders;
    if (fileExtraDownloadHeaders != null) {
      const requestHeaders = this.requestHeaders;
      return requestHeaders == null ? fileExtraDownloadHeaders : __spreadValues(__spreadValues({}, fileExtraDownloadHeaders), requestHeaders);
    }
    return this.computeFinalHeaders({ accept: "*/*" });
  }
  async getOrCreateStagingUserId() {
    const file2 = path$9.join(this.app.userDataPath, ".updaterId");
    try {
      const id3 = await promises_1.readFile(file2, "utf-8");
      if (builder_util_runtime_1$7.UUID.check(id3)) {
        return id3;
      } else {
        this._logger.warn(`Staging user id file exists, but content was invalid: ${id3}`);
      }
    } catch (e) {
      if (e.code !== "ENOENT") {
        this._logger.warn(`Couldn't read staging user ID, creating a blank one: ${e}`);
      }
    }
    const id2 = builder_util_runtime_1$7.UUID.v5(crypto_1.randomBytes(4096), builder_util_runtime_1$7.UUID.OID);
    this._logger.info(`Generated new staging user ID: ${id2}`);
    try {
      await fs_extra_1$5.outputFile(file2, id2);
    } catch (e) {
      this._logger.warn(`Couldn't write out staging user ID: ${e}`);
    }
    return id2;
  }
  get isAddNoCacheQuery() {
    const headers = this.requestHeaders;
    if (headers == null) {
      return true;
    }
    for (const headerName of Object.keys(headers)) {
      const s2 = headerName.toLowerCase();
      if (s2 === "authorization" || s2 === "private-token") {
        return false;
      }
    }
    return true;
  }
  async getOrCreateDownloadHelper() {
    let result = this.downloadedUpdateHelper;
    if (result == null) {
      const dirName = (await this.configOnDisk.value).updaterCacheDirName;
      const logger = this._logger;
      if (dirName == null) {
        logger.error("updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?");
      }
      const cacheDir = path$9.join(this.app.baseCachePath, dirName || this.app.name);
      if (logger.debug != null) {
        logger.debug(`updater cache dir: ${cacheDir}`);
      }
      result = new DownloadedUpdateHelper_1.DownloadedUpdateHelper(cacheDir);
      this.downloadedUpdateHelper = result;
    }
    return result;
  }
  async executeDownload(taskOptions) {
    const fileInfo = taskOptions.fileInfo;
    const downloadOptions = {
      headers: taskOptions.downloadUpdateOptions.requestHeaders,
      cancellationToken: taskOptions.downloadUpdateOptions.cancellationToken,
      sha2: fileInfo.info.sha2,
      sha512: fileInfo.info.sha512
    };
    if (this.listenerCount(main_1$2.DOWNLOAD_PROGRESS) > 0) {
      downloadOptions.onProgress = (it) => this.emit(main_1$2.DOWNLOAD_PROGRESS, it);
    }
    const updateInfo = taskOptions.downloadUpdateOptions.updateInfoAndProvider.info;
    const version = updateInfo.version;
    const packageInfo = fileInfo.packageInfo;
    function getCacheUpdateFileName() {
      const urlPath = decodeURIComponent(taskOptions.fileInfo.url.pathname);
      if (urlPath.endsWith(`.${taskOptions.fileExtension}`)) {
        return path$9.posix.basename(urlPath);
      } else {
        return `update.${taskOptions.fileExtension}`;
      }
    }
    const downloadedUpdateHelper = await this.getOrCreateDownloadHelper();
    const cacheDir = downloadedUpdateHelper.cacheDirForPendingUpdate;
    await promises_1.mkdir(cacheDir, { recursive: true });
    const updateFileName = getCacheUpdateFileName();
    let updateFile = path$9.join(cacheDir, updateFileName);
    const packageFile = packageInfo == null ? null : path$9.join(cacheDir, `package-${version}${path$9.extname(packageInfo.path) || ".7z"}`);
    const done = async (isSaveCache) => {
      await downloadedUpdateHelper.setDownloadedFile(updateFile, packageFile, updateInfo, fileInfo, updateFileName, isSaveCache);
      await taskOptions.done(__spreadProps(__spreadValues({}, updateInfo), {
        downloadedFile: updateFile
      }));
      return packageFile == null ? [updateFile] : [updateFile, packageFile];
    };
    const log = this._logger;
    const cachedUpdateFile = await downloadedUpdateHelper.validateDownloadedPath(updateFile, updateInfo, fileInfo, log);
    if (cachedUpdateFile != null) {
      updateFile = cachedUpdateFile;
      return await done(false);
    }
    const removeFileIfAny = async () => {
      await downloadedUpdateHelper.clear().catch(() => {
      });
      return await promises_1.unlink(updateFile).catch(() => {
      });
    };
    const tempUpdateFile = await DownloadedUpdateHelper_1.createTempUpdateFile(`temp-${updateFileName}`, cacheDir, log);
    try {
      await taskOptions.task(tempUpdateFile, downloadOptions, packageFile, removeFileIfAny);
      await promises_1.rename(tempUpdateFile, updateFile);
    } catch (e) {
      await removeFileIfAny();
      if (e instanceof builder_util_runtime_1$7.CancellationError) {
        log.info("cancelled");
        this.emit("update-cancelled", updateInfo);
      }
      throw e;
    }
    log.info(`New version ${version} has been downloaded to ${updateFile}`);
    return await done(true);
  }
}
AppUpdater$1.AppUpdater = AppUpdater;
function hasPrereleaseComponents(version) {
  const versionPrereleaseComponent = semver_1.prerelease(version);
  return versionPrereleaseComponent != null && versionPrereleaseComponent.length > 0;
}
class NoOpLogger {
  info(message) {
  }
  warn(message) {
  }
  error(message) {
  }
}
AppUpdater$1.NoOpLogger = NoOpLogger;
var AppImageUpdater$1 = {};
var BaseUpdater$1 = {};
Object.defineProperty(BaseUpdater$1, "__esModule", { value: true });
BaseUpdater$1.BaseUpdater = void 0;
const fs$3 = require$$0__default$2["default"];
const path$8 = require$$1__default$1["default"];
const AppUpdater_1$1 = AppUpdater$1;
class BaseUpdater extends AppUpdater_1$1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.quitAndInstallCalled = false;
    this.quitHandlerAdded = false;
  }
  quitAndInstall(isSilent = false, isForceRunAfter = false) {
    this._logger.info(`Install on explicit quitAndInstall`);
    const isInstalled = this.install(isSilent, isSilent ? isForceRunAfter : true);
    if (isInstalled) {
      setImmediate(() => {
        this.app.quit();
      });
    } else {
      this.quitAndInstallCalled = false;
    }
  }
  executeDownload(taskOptions) {
    return super.executeDownload(__spreadProps(__spreadValues({}, taskOptions), {
      done: (event) => {
        this.dispatchUpdateDownloaded(event);
        this.addQuitHandler();
        return Promise.resolve();
      }
    }));
  }
  install(isSilent, isForceRunAfter) {
    if (this.quitAndInstallCalled) {
      this._logger.warn("install call ignored: quitAndInstallCalled is set to true");
      return false;
    }
    const downloadedUpdateHelper = this.downloadedUpdateHelper;
    const installerPath = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.file;
    const downloadedFileInfo = downloadedUpdateHelper == null ? null : downloadedUpdateHelper.downloadedFileInfo;
    if (installerPath == null || downloadedFileInfo == null) {
      this.dispatchError(new Error("No valid update available, can't quit and install"));
      return false;
    }
    this.quitAndInstallCalled = true;
    try {
      let installPathRequiresElevation = false;
      if (process.platform === "win32") {
        try {
          const accessTestPath = path$8.join(path$8.dirname(process.execPath), `access-${Math.floor(Math.random() * 100)}.tmp`);
          fs$3.writeFileSync(accessTestPath, " ");
          fs$3.rmSync(accessTestPath);
        } catch (err) {
          installPathRequiresElevation = true;
        }
      }
      this._logger.info(`Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}, installPathRequiresElevation: ${installPathRequiresElevation}`);
      return this.doInstall({
        installerPath,
        isSilent,
        isForceRunAfter,
        isAdminRightsRequired: installPathRequiresElevation || downloadedFileInfo.isAdminRightsRequired
      });
    } catch (e) {
      this.dispatchError(e);
      return false;
    }
  }
  addQuitHandler() {
    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {
      return;
    }
    this.quitHandlerAdded = true;
    this.app.onQuit((exitCode) => {
      if (this.quitAndInstallCalled) {
        this._logger.info("Update installer has already been triggered. Quitting application.");
        return;
      }
      if (!this.autoInstallOnAppQuit) {
        this._logger.info("Update will not be installed on quit because autoInstallOnAppQuit is set to false.");
        return;
      }
      if (exitCode !== 0) {
        this._logger.info(`Update will be not installed on quit because application is quitting with exit code ${exitCode}`);
        return;
      }
      this._logger.info("Auto install update on quit");
      this.install(true, false);
    });
  }
}
BaseUpdater$1.BaseUpdater = BaseUpdater;
var FileWithEmbeddedBlockMapDifferentialDownloader$1 = {};
var DifferentialDownloader$1 = {};
var DataSplitter$1 = {};
var downloadPlanBuilder = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeOperations = exports.OperationKind = void 0;
  var OperationKind2;
  (function(OperationKind3) {
    OperationKind3[OperationKind3["COPY"] = 0] = "COPY";
    OperationKind3[OperationKind3["DOWNLOAD"] = 1] = "DOWNLOAD";
  })(OperationKind2 = exports.OperationKind || (exports.OperationKind = {}));
  function computeOperations(oldBlockMap, newBlockMap, logger) {
    const nameToOldBlocks = buildBlockFileMap(oldBlockMap.files);
    const nameToNewBlocks = buildBlockFileMap(newBlockMap.files);
    let lastOperation = null;
    const blockMapFile = newBlockMap.files[0];
    const operations = [];
    const name = blockMapFile.name;
    const oldEntry = nameToOldBlocks.get(name);
    if (oldEntry == null) {
      throw new Error(`no file ${name} in old blockmap`);
    }
    const newFile = nameToNewBlocks.get(name);
    let changedBlockCount = 0;
    const { checksumToOffset: checksumToOldOffset, checksumToOldSize } = buildChecksumMap(nameToOldBlocks.get(name), oldEntry.offset, logger);
    let newOffset = blockMapFile.offset;
    for (let i2 = 0; i2 < newFile.checksums.length; newOffset += newFile.sizes[i2], i2++) {
      const blockSize = newFile.sizes[i2];
      const checksum = newFile.checksums[i2];
      let oldOffset = checksumToOldOffset.get(checksum);
      if (oldOffset != null && checksumToOldSize.get(checksum) !== blockSize) {
        logger.warn(`Checksum ("${checksum}") matches, but size differs (old: ${checksumToOldSize.get(checksum)}, new: ${blockSize})`);
        oldOffset = void 0;
      }
      if (oldOffset === void 0) {
        changedBlockCount++;
        if (lastOperation != null && lastOperation.kind === OperationKind2.DOWNLOAD && lastOperation.end === newOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.DOWNLOAD,
            start: newOffset,
            end: newOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      } else {
        if (lastOperation != null && lastOperation.kind === OperationKind2.COPY && lastOperation.end === oldOffset) {
          lastOperation.end += blockSize;
        } else {
          lastOperation = {
            kind: OperationKind2.COPY,
            start: oldOffset,
            end: oldOffset + blockSize
          };
          validateAndAdd(lastOperation, operations, checksum, i2);
        }
      }
    }
    if (changedBlockCount > 0) {
      logger.info(`File${blockMapFile.name === "file" ? "" : " " + blockMapFile.name} has ${changedBlockCount} changed blocks`);
    }
    return operations;
  }
  exports.computeOperations = computeOperations;
  const isValidateOperationRange = process.env["DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES"] === "true";
  function validateAndAdd(operation, operations, checksum, index) {
    if (isValidateOperationRange && operations.length !== 0) {
      const lastOperation = operations[operations.length - 1];
      if (lastOperation.kind === operation.kind && operation.start < lastOperation.end && operation.start > lastOperation.start) {
        const min = [lastOperation.start, lastOperation.end, operation.start, operation.end].reduce((p, v) => p < v ? p : v);
        throw new Error(`operation (block index: ${index}, checksum: ${checksum}, kind: ${OperationKind2[operation.kind]}) overlaps previous operation (checksum: ${checksum}):
abs: ${lastOperation.start} until ${lastOperation.end} and ${operation.start} until ${operation.end}
rel: ${lastOperation.start - min} until ${lastOperation.end - min} and ${operation.start - min} until ${operation.end - min}`);
      }
    }
    operations.push(operation);
  }
  function buildChecksumMap(file2, fileOffset, logger) {
    const checksumToOffset = new Map();
    const checksumToSize = new Map();
    let offset = fileOffset;
    for (let i2 = 0; i2 < file2.checksums.length; i2++) {
      const checksum = file2.checksums[i2];
      const size = file2.sizes[i2];
      const existing = checksumToSize.get(checksum);
      if (existing === void 0) {
        checksumToOffset.set(checksum, offset);
        checksumToSize.set(checksum, size);
      } else if (logger.debug != null) {
        const sizeExplanation = existing === size ? "(same size)" : `(size: ${existing}, this size: ${size})`;
        logger.debug(`${checksum} duplicated in blockmap ${sizeExplanation}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`);
      }
      offset += size;
    }
    return { checksumToOffset, checksumToOldSize: checksumToSize };
  }
  function buildBlockFileMap(list) {
    const result = new Map();
    for (const item of list) {
      result.set(item.name, item);
    }
    return result;
  }
})(downloadPlanBuilder);
Object.defineProperty(DataSplitter$1, "__esModule", { value: true });
DataSplitter$1.DataSplitter = DataSplitter$1.copyData = void 0;
const builder_util_runtime_1$6 = out;
const fs_1$5 = require$$0__default$2["default"];
const stream_1$1 = require$$0__default$1["default"];
const downloadPlanBuilder_1$2 = downloadPlanBuilder;
const DOUBLE_CRLF = Buffer.from("\r\n\r\n");
var ReadState;
(function(ReadState2) {
  ReadState2[ReadState2["INIT"] = 0] = "INIT";
  ReadState2[ReadState2["HEADER"] = 1] = "HEADER";
  ReadState2[ReadState2["BODY"] = 2] = "BODY";
})(ReadState || (ReadState = {}));
function copyData(task, out2, oldFileFd, reject, resolve2) {
  const readStream = fs_1$5.createReadStream("", {
    fd: oldFileFd,
    autoClose: false,
    start: task.start,
    end: task.end - 1
  });
  readStream.on("error", reject);
  readStream.once("end", resolve2);
  readStream.pipe(out2, {
    end: false
  });
}
DataSplitter$1.copyData = copyData;
class DataSplitter extends stream_1$1.Writable {
  constructor(out2, options, partIndexToTaskIndex, boundary, partIndexToLength, finishHandler) {
    super();
    this.out = out2;
    this.options = options;
    this.partIndexToTaskIndex = partIndexToTaskIndex;
    this.partIndexToLength = partIndexToLength;
    this.finishHandler = finishHandler;
    this.partIndex = -1;
    this.headerListBuffer = null;
    this.readState = ReadState.INIT;
    this.ignoreByteCount = 0;
    this.remainingPartDataCount = 0;
    this.actualPartLength = 0;
    this.boundaryLength = boundary.length + 4;
    this.ignoreByteCount = this.boundaryLength - 2;
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  _write(data, encoding, callback) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${data.length} bytes`);
      return;
    }
    this.handleData(data).then(callback).catch(callback);
  }
  async handleData(chunk) {
    let start = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0) {
      throw builder_util_runtime_1$6.newError("Internal error", "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH");
    }
    if (this.ignoreByteCount > 0) {
      const toIgnore = Math.min(this.ignoreByteCount, chunk.length);
      this.ignoreByteCount -= toIgnore;
      start = toIgnore;
    } else if (this.remainingPartDataCount > 0) {
      const toRead = Math.min(this.remainingPartDataCount, chunk.length);
      this.remainingPartDataCount -= toRead;
      await this.processPartData(chunk, 0, toRead);
      start = toRead;
    }
    if (start === chunk.length) {
      return;
    }
    if (this.readState === ReadState.HEADER) {
      const headerListEnd = this.searchHeaderListEnd(chunk, start);
      if (headerListEnd === -1) {
        return;
      }
      start = headerListEnd;
      this.readState = ReadState.BODY;
      this.headerListBuffer = null;
    }
    while (true) {
      if (this.readState === ReadState.BODY) {
        this.readState = ReadState.INIT;
      } else {
        this.partIndex++;
        let taskIndex = this.partIndexToTaskIndex.get(this.partIndex);
        if (taskIndex == null) {
          if (this.isFinished) {
            taskIndex = this.options.end;
          } else {
            throw builder_util_runtime_1$6.newError("taskIndex is null", "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL");
          }
        }
        const prevTaskIndex = this.partIndex === 0 ? this.options.start : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
        if (prevTaskIndex < taskIndex) {
          await this.copyExistingData(prevTaskIndex, taskIndex);
        } else if (prevTaskIndex > taskIndex) {
          throw builder_util_runtime_1$6.newError("prevTaskIndex must be < taskIndex", "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED");
        }
        if (this.isFinished) {
          this.onPartEnd();
          this.finishHandler();
          return;
        }
        start = this.searchHeaderListEnd(chunk, start);
        if (start === -1) {
          this.readState = ReadState.HEADER;
          return;
        }
      }
      const partLength = this.partIndexToLength[this.partIndex];
      const end = start + partLength;
      const effectiveEnd = Math.min(end, chunk.length);
      await this.processPartStarted(chunk, start, effectiveEnd);
      this.remainingPartDataCount = partLength - (effectiveEnd - start);
      if (this.remainingPartDataCount > 0) {
        return;
      }
      start = end + this.boundaryLength;
      if (start >= chunk.length) {
        this.ignoreByteCount = this.boundaryLength - (chunk.length - end);
        return;
      }
    }
  }
  copyExistingData(index, end) {
    return new Promise((resolve2, reject) => {
      const w2 = () => {
        if (index === end) {
          resolve2();
          return;
        }
        const task = this.options.tasks[index];
        if (task.kind !== downloadPlanBuilder_1$2.OperationKind.COPY) {
          reject(new Error("Task kind must be COPY"));
          return;
        }
        copyData(task, this.out, this.options.oldFileFd, reject, () => {
          index++;
          w2();
        });
      };
      w2();
    });
  }
  searchHeaderListEnd(chunk, readOffset) {
    const headerListEnd = chunk.indexOf(DOUBLE_CRLF, readOffset);
    if (headerListEnd !== -1) {
      return headerListEnd + DOUBLE_CRLF.length;
    }
    const partialChunk = readOffset === 0 ? chunk : chunk.slice(readOffset);
    if (this.headerListBuffer == null) {
      this.headerListBuffer = partialChunk;
    } else {
      this.headerListBuffer = Buffer.concat([this.headerListBuffer, partialChunk]);
    }
    return -1;
  }
  onPartEnd() {
    const expectedLength = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== expectedLength) {
      throw builder_util_runtime_1$6.newError(`Expected length: ${expectedLength} differs from actual: ${this.actualPartLength}`, "ERR_DATA_SPLITTER_LENGTH_MISMATCH");
    }
    this.actualPartLength = 0;
  }
  processPartStarted(data, start, end) {
    if (this.partIndex !== 0) {
      this.onPartEnd();
    }
    return this.processPartData(data, start, end);
  }
  processPartData(data, start, end) {
    this.actualPartLength += end - start;
    const out2 = this.out;
    if (out2.write(start === 0 && data.length === end ? data : data.slice(start, end))) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2, reject) => {
        out2.on("error", reject);
        out2.once("drain", () => {
          out2.removeListener("error", reject);
          resolve2();
        });
      });
    }
  }
}
DataSplitter$1.DataSplitter = DataSplitter;
var multipleRangeDownloader = {};
Object.defineProperty(multipleRangeDownloader, "__esModule", { value: true });
multipleRangeDownloader.checkIsRangesSupported = multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = void 0;
const builder_util_runtime_1$5 = out;
const DataSplitter_1$1 = DataSplitter$1;
const downloadPlanBuilder_1$1 = downloadPlanBuilder;
function executeTasksUsingMultipleRangeRequests(differentialDownloader, tasks, out2, oldFileFd, reject) {
  const w2 = (taskOffset) => {
    if (taskOffset >= tasks.length) {
      if (differentialDownloader.fileMetadataBuffer != null) {
        out2.write(differentialDownloader.fileMetadataBuffer);
      }
      out2.end();
      return;
    }
    const nextOffset = taskOffset + 1e3;
    doExecuteTasks(differentialDownloader, {
      tasks,
      start: taskOffset,
      end: Math.min(tasks.length, nextOffset),
      oldFileFd
    }, out2, () => w2(nextOffset), reject);
  };
  return w2;
}
multipleRangeDownloader.executeTasksUsingMultipleRangeRequests = executeTasksUsingMultipleRangeRequests;
function doExecuteTasks(differentialDownloader, options, out2, resolve2, reject) {
  let ranges = "bytes=";
  let partCount = 0;
  const partIndexToTaskIndex = new Map();
  const partIndexToLength = [];
  for (let i2 = options.start; i2 < options.end; i2++) {
    const task = options.tasks[i2];
    if (task.kind === downloadPlanBuilder_1$1.OperationKind.DOWNLOAD) {
      ranges += `${task.start}-${task.end - 1}, `;
      partIndexToTaskIndex.set(partCount, i2);
      partCount++;
      partIndexToLength.push(task.end - task.start);
    }
  }
  if (partCount <= 1) {
    const w2 = (index) => {
      if (index >= options.end) {
        resolve2();
        return;
      }
      const task = options.tasks[index++];
      if (task.kind === downloadPlanBuilder_1$1.OperationKind.COPY) {
        DataSplitter_1$1.copyData(task, out2, options.oldFileFd, reject, () => w2(index));
      } else {
        const requestOptions2 = differentialDownloader.createRequestOptions();
        requestOptions2.headers.Range = `bytes=${task.start}-${task.end - 1}`;
        const request2 = differentialDownloader.httpExecutor.createRequest(requestOptions2, (response) => {
          if (!checkIsRangesSupported(response, reject)) {
            return;
          }
          response.pipe(out2, {
            end: false
          });
          response.once("end", () => w2(index));
        });
        differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request2, reject);
        request2.end();
      }
    };
    w2(options.start);
    return;
  }
  const requestOptions = differentialDownloader.createRequestOptions();
  requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
  const request = differentialDownloader.httpExecutor.createRequest(requestOptions, (response) => {
    if (!checkIsRangesSupported(response, reject)) {
      return;
    }
    const contentType = builder_util_runtime_1$5.safeGetHeader(response, "content-type");
    const m2 = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
    if (m2 == null) {
      reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
      return;
    }
    const dicer = new DataSplitter_1$1.DataSplitter(out2, options, partIndexToTaskIndex, m2[1] || m2[2], partIndexToLength, resolve2);
    dicer.on("error", reject);
    response.pipe(dicer);
    response.on("end", () => {
      setTimeout(() => {
        request.abort();
        reject(new Error("Response ends without calling any handlers"));
      }, 1e4);
    });
  });
  differentialDownloader.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
  request.end();
}
function checkIsRangesSupported(response, reject) {
  if (response.statusCode >= 400) {
    reject(builder_util_runtime_1$5.createHttpError(response));
    return false;
  }
  if (response.statusCode !== 206) {
    const acceptRanges = builder_util_runtime_1$5.safeGetHeader(response, "accept-ranges");
    if (acceptRanges == null || acceptRanges === "none") {
      reject(new Error(`Server doesn't support Accept-Ranges (response code ${response.statusCode})`));
      return false;
    }
  }
  return true;
}
multipleRangeDownloader.checkIsRangesSupported = checkIsRangesSupported;
var ProgressDifferentialDownloadCallbackTransform$1 = {};
Object.defineProperty(ProgressDifferentialDownloadCallbackTransform$1, "__esModule", { value: true });
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = void 0;
const stream_1 = require$$0__default$1["default"];
var OperationKind;
(function(OperationKind2) {
  OperationKind2[OperationKind2["COPY"] = 0] = "COPY";
  OperationKind2[OperationKind2["DOWNLOAD"] = 1] = "DOWNLOAD";
})(OperationKind || (OperationKind = {}));
class ProgressDifferentialDownloadCallbackTransform extends stream_1.Transform {
  constructor(progressDifferentialDownloadInfo, cancellationToken, onProgress) {
    super();
    this.progressDifferentialDownloadInfo = progressDifferentialDownloadInfo;
    this.cancellationToken = cancellationToken;
    this.onProgress = onProgress;
    this.start = Date.now();
    this.transferred = 0;
    this.delta = 0;
    this.expectedBytes = 0;
    this.index = 0;
    this.operationType = OperationKind.COPY;
    this.nextUpdate = this.start + 1e3;
  }
  _transform(chunk, encoding, callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == OperationKind.COPY) {
      callback(null, chunk);
      return;
    }
    this.transferred += chunk.length;
    this.delta += chunk.length;
    const now = Date.now();
    if (now >= this.nextUpdate && this.transferred !== this.expectedBytes && this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.nextUpdate = now + 1e3;
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((now - this.start) / 1e3))
      });
      this.delta = 0;
    }
    callback(null, chunk);
  }
  beginFileCopy() {
    this.operationType = OperationKind.COPY;
  }
  beginRangeDownload() {
    this.operationType = OperationKind.DOWNLOAD;
    this.expectedBytes += this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++];
  }
  endRangeDownload() {
    if (this.transferred !== this.progressDifferentialDownloadInfo.grandTotal) {
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent: this.transferred / this.progressDifferentialDownloadInfo.grandTotal * 100,
        bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
      });
    }
  }
  _flush(callback) {
    if (this.cancellationToken.cancelled) {
      callback(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(this.transferred / ((Date.now() - this.start) / 1e3))
    });
    this.delta = 0;
    this.transferred = 0;
    callback(null);
  }
}
ProgressDifferentialDownloadCallbackTransform$1.ProgressDifferentialDownloadCallbackTransform = ProgressDifferentialDownloadCallbackTransform;
Object.defineProperty(DifferentialDownloader$1, "__esModule", { value: true });
DifferentialDownloader$1.DifferentialDownloader = void 0;
const builder_util_runtime_1$4 = out;
const fs_extra_1$4 = lib;
const fs_1$4 = require$$0__default$2["default"];
const DataSplitter_1 = DataSplitter$1;
const url_1$1 = require$$2__default["default"];
const downloadPlanBuilder_1 = downloadPlanBuilder;
const multipleRangeDownloader_1 = multipleRangeDownloader;
const ProgressDifferentialDownloadCallbackTransform_1 = ProgressDifferentialDownloadCallbackTransform$1;
class DifferentialDownloader {
  constructor(blockAwareFileInfo, httpExecutor2, options) {
    this.blockAwareFileInfo = blockAwareFileInfo;
    this.httpExecutor = httpExecutor2;
    this.options = options;
    this.fileMetadataBuffer = null;
    this.logger = options.logger;
  }
  createRequestOptions() {
    const result = {
      headers: __spreadProps(__spreadValues({}, this.options.requestHeaders), {
        accept: "*/*"
      })
    };
    builder_util_runtime_1$4.configureRequestUrl(this.options.newUrl, result);
    builder_util_runtime_1$4.configureRequestOptions(result);
    return result;
  }
  doDownload(oldBlockMap, newBlockMap) {
    if (oldBlockMap.version !== newBlockMap.version) {
      throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
    }
    const logger = this.logger;
    const operations = downloadPlanBuilder_1.computeOperations(oldBlockMap, newBlockMap, logger);
    if (logger.debug != null) {
      logger.debug(JSON.stringify(operations, null, 2));
    }
    let downloadSize = 0;
    let copySize = 0;
    for (const operation of operations) {
      const length = operation.end - operation.start;
      if (operation.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
        downloadSize += length;
      } else {
        copySize += length;
      }
    }
    const newSize = this.blockAwareFileInfo.size;
    if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) !== newSize) {
      throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newSize: ${newSize}`);
    }
    logger.info(`Full: ${formatBytes(newSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newSize / 100))}%)`);
    return this.downloadFile(operations);
  }
  downloadFile(tasks) {
    const fdList = [];
    const closeFiles = () => {
      return Promise.all(fdList.map((openedFile) => {
        return fs_extra_1$4.close(openedFile.descriptor).catch((e) => {
          this.logger.error(`cannot close file "${openedFile.path}": ${e}`);
        });
      }));
    };
    return this.doDownloadFile(tasks, fdList).then(closeFiles).catch((e) => {
      return closeFiles().catch((closeFilesError) => {
        try {
          this.logger.error(`cannot close files: ${closeFilesError}`);
        } catch (errorOnLog) {
          try {
            console.error(errorOnLog);
          } catch (ignored) {
          }
        }
        throw e;
      }).then(() => {
        throw e;
      });
    });
  }
  async doDownloadFile(tasks, fdList) {
    const oldFileFd = await fs_extra_1$4.open(this.options.oldFile, "r");
    fdList.push({ descriptor: oldFileFd, path: this.options.oldFile });
    const newFileFd = await fs_extra_1$4.open(this.options.newFile, "w");
    fdList.push({ descriptor: newFileFd, path: this.options.newFile });
    const fileOut = fs_1$4.createWriteStream(this.options.newFile, { fd: newFileFd });
    await new Promise((resolve2, reject) => {
      const streams = [];
      let downloadInfoTransform = void 0;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const expectedByteCounts = [];
        let grandTotalBytes = 0;
        for (const task of tasks) {
          if (task.kind === downloadPlanBuilder_1.OperationKind.DOWNLOAD) {
            expectedByteCounts.push(task.end - task.start);
            grandTotalBytes += task.end - task.start;
          }
        }
        const progressDifferentialDownloadInfo = {
          expectedByteCounts,
          grandTotal: grandTotalBytes
        };
        downloadInfoTransform = new ProgressDifferentialDownloadCallbackTransform_1.ProgressDifferentialDownloadCallbackTransform(progressDifferentialDownloadInfo, this.options.cancellationToken, this.options.onProgress);
        streams.push(downloadInfoTransform);
      }
      const digestTransform = new builder_util_runtime_1$4.DigestTransform(this.blockAwareFileInfo.sha512);
      digestTransform.isValidateOnEnd = false;
      streams.push(digestTransform);
      fileOut.on("finish", () => {
        fileOut.close(() => {
          fdList.splice(1, 1);
          try {
            digestTransform.validate();
          } catch (e) {
            reject(e);
            return;
          }
          resolve2(void 0);
        });
      });
      streams.push(fileOut);
      let lastStream = null;
      for (const stream of streams) {
        stream.on("error", reject);
        if (lastStream == null) {
          lastStream = stream;
        } else {
          lastStream = lastStream.pipe(stream);
        }
      }
      const firstStream = streams[0];
      let w2;
      if (this.options.isUseMultipleRangeRequest) {
        w2 = multipleRangeDownloader_1.executeTasksUsingMultipleRangeRequests(this, tasks, firstStream, oldFileFd, reject);
        w2(0);
        return;
      }
      let downloadOperationCount = 0;
      let actualUrl = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const requestOptions = this.createRequestOptions();
      requestOptions.redirect = "manual";
      w2 = (index) => {
        var _a, _b;
        if (index >= tasks.length) {
          if (this.fileMetadataBuffer != null) {
            firstStream.write(this.fileMetadataBuffer);
          }
          firstStream.end();
          return;
        }
        const operation = tasks[index++];
        if (operation.kind === downloadPlanBuilder_1.OperationKind.COPY) {
          if (downloadInfoTransform) {
            downloadInfoTransform.beginFileCopy();
          }
          DataSplitter_1.copyData(operation, firstStream, oldFileFd, reject, () => w2(index));
          return;
        }
        const range2 = `bytes=${operation.start}-${operation.end - 1}`;
        requestOptions.headers.range = range2;
        (_b = (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `download range: ${range2}`);
        if (downloadInfoTransform) {
          downloadInfoTransform.beginRangeDownload();
        }
        const request = this.httpExecutor.createRequest(requestOptions, (response) => {
          if (response.statusCode >= 400) {
            reject(builder_util_runtime_1$4.createHttpError(response));
          }
          response.pipe(firstStream, {
            end: false
          });
          response.once("end", () => {
            if (downloadInfoTransform) {
              downloadInfoTransform.endRangeDownload();
            }
            if (++downloadOperationCount === 100) {
              downloadOperationCount = 0;
              setTimeout(() => w2(index), 1e3);
            } else {
              w2(index);
            }
          });
        });
        request.on("redirect", (statusCode, method, redirectUrl) => {
          this.logger.info(`Redirect to ${removeQuery(redirectUrl)}`);
          actualUrl = redirectUrl;
          builder_util_runtime_1$4.configureRequestUrl(new url_1$1.URL(actualUrl), requestOptions);
          request.followRedirect();
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
      };
      w2(0);
    });
  }
  async readRemoteBytes(start, endInclusive) {
    const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
    const requestOptions = this.createRequestOptions();
    requestOptions.headers.range = `bytes=${start}-${endInclusive}`;
    let position = 0;
    await this.request(requestOptions, (chunk) => {
      chunk.copy(buffer, position);
      position += chunk.length;
    });
    if (position !== buffer.length) {
      throw new Error(`Received data length ${position} is not equal to expected ${buffer.length}`);
    }
    return buffer;
  }
  request(requestOptions, dataHandler) {
    return new Promise((resolve2, reject) => {
      const request = this.httpExecutor.createRequest(requestOptions, (response) => {
        if (!multipleRangeDownloader_1.checkIsRangesSupported(response, reject)) {
          return;
        }
        response.on("data", dataHandler);
        response.on("end", () => resolve2());
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
      request.end();
    });
  }
}
DifferentialDownloader$1.DifferentialDownloader = DifferentialDownloader;
function formatBytes(value, symbol = " KB") {
  return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function removeQuery(url) {
  const index = url.indexOf("?");
  return index < 0 ? url : url.substring(0, index);
}
Object.defineProperty(FileWithEmbeddedBlockMapDifferentialDownloader$1, "__esModule", { value: true });
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const fs_extra_1$3 = lib;
const DifferentialDownloader_1$1 = DifferentialDownloader$1;
const zlib_1$1 = require$$2__default$1["default"];
class FileWithEmbeddedBlockMapDifferentialDownloader extends DifferentialDownloader_1$1.DifferentialDownloader {
  async download() {
    const packageInfo = this.blockAwareFileInfo;
    const fileSize = packageInfo.size;
    const offset = fileSize - (packageInfo.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(offset, fileSize - 1);
    const newBlockMap = readBlockMap(this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4));
    await this.doDownload(await readEmbeddedBlockMapData(this.options.oldFile), newBlockMap);
  }
}
FileWithEmbeddedBlockMapDifferentialDownloader$1.FileWithEmbeddedBlockMapDifferentialDownloader = FileWithEmbeddedBlockMapDifferentialDownloader;
function readBlockMap(data) {
  return JSON.parse(zlib_1$1.inflateRawSync(data).toString());
}
async function readEmbeddedBlockMapData(file2) {
  const fd = await fs_extra_1$3.open(file2, "r");
  try {
    const fileSize = (await fs_extra_1$3.fstat(fd)).size;
    const sizeBuffer = Buffer.allocUnsafe(4);
    await fs_extra_1$3.read(fd, sizeBuffer, 0, sizeBuffer.length, fileSize - sizeBuffer.length);
    const dataBuffer = Buffer.allocUnsafe(sizeBuffer.readUInt32BE(0));
    await fs_extra_1$3.read(fd, dataBuffer, 0, dataBuffer.length, fileSize - sizeBuffer.length - dataBuffer.length);
    await fs_extra_1$3.close(fd);
    return readBlockMap(dataBuffer);
  } catch (e) {
    await fs_extra_1$3.close(fd);
    throw e;
  }
}
Object.defineProperty(AppImageUpdater$1, "__esModule", { value: true });
AppImageUpdater$1.AppImageUpdater = void 0;
const builder_util_runtime_1$3 = out;
const child_process_1$3 = require$$1__default$4["default"];
const fs_extra_1$2 = lib;
const fs_1$3 = require$$0__default$2["default"];
const path$7 = require$$1__default$1["default"];
const BaseUpdater_1$1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1$1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const main_1$1 = main$1;
const Provider_1$2 = Provider$1;
class AppImageUpdater extends BaseUpdater_1$1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  isUpdaterActive() {
    if (process.env["APPIMAGE"] == null) {
      if (process.env["SNAP"] == null) {
        this._logger.warn("APPIMAGE env is not defined, current application is not an AppImage");
      } else {
        this._logger.info("SNAP env is defined, updater is disabled");
      }
      return false;
    }
    return super.isUpdaterActive();
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = Provider_1$2.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "AppImage");
    return this.executeDownload({
      fileExtension: "AppImage",
      fileInfo,
      downloadUpdateOptions,
      task: async (updateFile, downloadOptions) => {
        const oldFile = process.env["APPIMAGE"];
        if (oldFile == null) {
          throw builder_util_runtime_1$3.newError("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
        }
        let isDownloadFull = false;
        try {
          const downloadOptions2 = {
            newUrl: fileInfo.url,
            oldFile,
            logger: this._logger,
            newFile: updateFile,
            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
            requestHeaders: downloadUpdateOptions.requestHeaders,
            cancellationToken: downloadUpdateOptions.cancellationToken
          };
          if (this.listenerCount(main_1$1.DOWNLOAD_PROGRESS) > 0) {
            downloadOptions2.onProgress = (it) => this.emit(main_1$1.DOWNLOAD_PROGRESS, it);
          }
          await new FileWithEmbeddedBlockMapDifferentialDownloader_1$1.FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions2).download();
        } catch (e) {
          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
          isDownloadFull = process.platform === "linux";
        }
        if (isDownloadFull) {
          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions);
        }
        await fs_extra_1$2.chmod(updateFile, 493);
      }
    });
  }
  doInstall(options) {
    const appImageFile = process.env["APPIMAGE"];
    if (appImageFile == null) {
      throw builder_util_runtime_1$3.newError("APPIMAGE env is not defined", "ERR_UPDATER_OLD_FILE_NOT_FOUND");
    }
    fs_1$3.unlinkSync(appImageFile);
    let destination;
    const existingBaseName = path$7.basename(appImageFile);
    if (path$7.basename(options.installerPath) === existingBaseName || !/\d+\.\d+\.\d+/.test(existingBaseName)) {
      destination = appImageFile;
    } else {
      destination = path$7.join(path$7.dirname(appImageFile), path$7.basename(options.installerPath));
    }
    child_process_1$3.execFileSync("mv", ["-f", options.installerPath, destination]);
    if (destination !== appImageFile) {
      this.emit("appimage-filename-updated", destination);
    }
    const env2 = __spreadProps(__spreadValues({}, process.env), {
      APPIMAGE_SILENT_INSTALL: "true"
    });
    if (options.isForceRunAfter) {
      child_process_1$3.spawn(destination, [], {
        detached: true,
        stdio: "ignore",
        env: env2
      }).unref();
    } else {
      env2.APPIMAGE_EXIT_AFTER_INSTALL = "true";
      child_process_1$3.execFileSync(destination, [], { env: env2 });
    }
    return true;
  }
}
AppImageUpdater$1.AppImageUpdater = AppImageUpdater;
var MacUpdater$1 = {};
Object.defineProperty(MacUpdater$1, "__esModule", { value: true });
MacUpdater$1.MacUpdater = void 0;
const builder_util_runtime_1$2 = out;
const fs_extra_1$1 = lib;
const fs_1$2 = require$$0__default$2["default"];
const http_1 = require$$3__default["default"];
const AppUpdater_1 = AppUpdater$1;
const Provider_1$1 = Provider$1;
const child_process_1$2 = require$$1__default$4["default"];
class MacUpdater extends AppUpdater_1.AppUpdater {
  constructor(options, app2) {
    super(options, app2);
    this.nativeUpdater = require$$1__default["default"].autoUpdater;
    this.squirrelDownloadedUpdate = false;
    this.nativeUpdater.on("error", (it) => {
      this._logger.warn(it);
      this.emit("error", it);
    });
    this.nativeUpdater.on("update-downloaded", () => {
      this.squirrelDownloadedUpdate = true;
    });
  }
  debug(message) {
    if (this._logger.debug != null) {
      this._logger.debug(message);
    }
  }
  async doDownloadUpdate(downloadUpdateOptions) {
    let files = downloadUpdateOptions.updateInfoAndProvider.provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info);
    const log = this._logger;
    const sysctlRosettaInfoKey = "sysctl.proc_translated";
    let isRosetta;
    try {
      this.debug("Checking for macOS Rosetta environment");
      const result = child_process_1$2.execFileSync("sysctl", [sysctlRosettaInfoKey], { encoding: "utf8" });
      isRosetta = result.includes(`${sysctlRosettaInfoKey}: 1`);
      log.info(`Checked for macOS Rosetta environment (isRosetta=${isRosetta})`);
    } catch (e) {
      log.warn(`sysctl shell command to check for macOS Rosetta environment failed: ${e}`);
    }
    const isArm64 = (file2) => {
      var _a;
      return file2.url.pathname.includes("arm64") || ((_a = file2.info.url) === null || _a === void 0 ? void 0 : _a.includes("arm64"));
    };
    if (files.some(isArm64)) {
      files = files.filter((file2) => (process.arch === "arm64" || isRosetta) === isArm64(file2));
    }
    const zipFileInfo = Provider_1$1.findFile(files, "zip", ["pkg", "dmg"]);
    if (zipFileInfo == null) {
      throw builder_util_runtime_1$2.newError(`ZIP file not provided: ${builder_util_runtime_1$2.safeStringifyJson(files)}`, "ERR_UPDATER_ZIP_FILE_NOT_FOUND");
    }
    return this.executeDownload({
      fileExtension: "zip",
      fileInfo: zipFileInfo,
      downloadUpdateOptions,
      task: (destinationFile, downloadOptions) => {
        return this.httpExecutor.download(zipFileInfo.url, destinationFile, downloadOptions);
      },
      done: (event) => this.updateDownloaded(zipFileInfo, event)
    });
  }
  async updateDownloaded(zipFileInfo, event) {
    var _a;
    const downloadedFile = event.downloadedFile;
    const updateFileSize = (_a = zipFileInfo.info.size) !== null && _a !== void 0 ? _a : (await fs_extra_1$1.stat(downloadedFile)).size;
    const log = this._logger;
    const logContext = `fileToProxy=${zipFileInfo.url.href}`;
    this.debug(`Creating proxy server for native Squirrel.Mac (${logContext})`);
    const server = http_1.createServer();
    this.debug(`Proxy server for native Squirrel.Mac is created (${logContext})`);
    server.on("close", () => {
      log.info(`Proxy server for native Squirrel.Mac is closed (${logContext})`);
    });
    function getServerUrl() {
      const address = server.address();
      return `http://127.0.0.1:${address.port}`;
    }
    return await new Promise((resolve2, reject) => {
      const fileUrl = `/${Date.now().toString(16)}-${Math.floor(Math.random() * 9999).toString(16)}.zip`;
      server.on("request", (request, response) => {
        const requestUrl = request.url;
        log.info(`${requestUrl} requested`);
        if (requestUrl === "/") {
          const data = Buffer.from(`{ "url": "${getServerUrl()}${fileUrl}" }`);
          response.writeHead(200, { "Content-Type": "application/json", "Content-Length": data.length });
          response.end(data);
          return;
        }
        if (!requestUrl.startsWith(fileUrl)) {
          log.warn(`${requestUrl} requested, but not supported`);
          response.writeHead(404);
          response.end();
          return;
        }
        log.info(`${fileUrl} requested by Squirrel.Mac, pipe ${downloadedFile}`);
        let errorOccurred = false;
        response.on("finish", () => {
          try {
            setImmediate(() => server.close());
          } finally {
            if (!errorOccurred) {
              this.nativeUpdater.removeListener("error", reject);
              resolve2([]);
            }
          }
        });
        const readStream = fs_1$2.createReadStream(downloadedFile);
        readStream.on("error", (error2) => {
          try {
            response.end();
          } catch (e) {
            log.warn(`cannot end response: ${e}`);
          }
          errorOccurred = true;
          this.nativeUpdater.removeListener("error", reject);
          reject(new Error(`Cannot pipe "${downloadedFile}": ${error2}`));
        });
        response.writeHead(200, {
          "Content-Type": "application/zip",
          "Content-Length": updateFileSize
        });
        readStream.pipe(response);
      });
      this.debug(`Proxy server for native Squirrel.Mac is starting to listen (${logContext})`);
      server.listen(0, "127.0.0.1", () => {
        this.debug(`Proxy server for native Squirrel.Mac is listening (address=${getServerUrl()}, ${logContext})`);
        this.nativeUpdater.setFeedURL({
          url: getServerUrl(),
          headers: { "Cache-Control": "no-cache" }
        });
        this.dispatchUpdateDownloaded(event);
        if (this.autoInstallOnAppQuit) {
          this.nativeUpdater.once("error", reject);
          this.nativeUpdater.checkForUpdates();
        } else {
          resolve2([]);
        }
      });
    });
  }
  quitAndInstall() {
    if (this.squirrelDownloadedUpdate) {
      this.nativeUpdater.quitAndInstall();
    } else {
      this.nativeUpdater.on("update-downloaded", () => {
        this.nativeUpdater.quitAndInstall();
      });
    }
  }
}
MacUpdater$1.MacUpdater = MacUpdater;
var NsisUpdater$1 = {};
var GenericDifferentialDownloader$1 = {};
Object.defineProperty(GenericDifferentialDownloader$1, "__esModule", { value: true });
GenericDifferentialDownloader$1.GenericDifferentialDownloader = void 0;
const DifferentialDownloader_1 = DifferentialDownloader$1;
class GenericDifferentialDownloader extends DifferentialDownloader_1.DifferentialDownloader {
  download(oldBlockMap, newBlockMap) {
    return this.doDownload(oldBlockMap, newBlockMap);
  }
}
GenericDifferentialDownloader$1.GenericDifferentialDownloader = GenericDifferentialDownloader;
var windowsExecutableCodeSignatureVerifier = {};
Object.defineProperty(windowsExecutableCodeSignatureVerifier, "__esModule", { value: true });
windowsExecutableCodeSignatureVerifier.verifySignature = void 0;
const builder_util_runtime_1$1 = out;
const child_process_1$1 = require$$1__default$4["default"];
const os$1 = require$$1__default$3["default"];
function verifySignature(publisherNames, unescapedTempUpdateFile, logger) {
  return new Promise((resolve2) => {
    const tempUpdateFile = unescapedTempUpdateFile.replace(/'/g, "''").replace(/`/g, "``");
    child_process_1$1.execFile("powershell.exe", [
      "-NoProfile",
      "-NonInteractive",
      "-InputFormat",
      "None",
      "-Command",
      `Get-AuthenticodeSignature '${tempUpdateFile}' | ConvertTo-Json -Compress | ForEach-Object { [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_)) }`
    ], {
      timeout: 20 * 1e3
    }, (error2, stdout, stderr) => {
      try {
        if (error2 != null || stderr) {
          handleError(logger, error2, stderr);
          resolve2(null);
          return;
        }
        const data = parseOut(Buffer.from(stdout, "base64").toString("utf-8"));
        if (data.Status === 0) {
          const name = builder_util_runtime_1$1.parseDn(data.SignerCertificate.Subject).get("CN");
          if (publisherNames.includes(name)) {
            resolve2(null);
            return;
          }
        }
        const result = `publisherNames: ${publisherNames.join(" | ")}, raw info: ` + JSON.stringify(data, (name, value) => name === "RawData" ? void 0 : value, 2);
        logger.warn(`Sign verification failed, installer signed with incorrect certificate: ${result}`);
        resolve2(result);
      } catch (e) {
        logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2}. Ignoring signature validation due to unknown error.`);
        resolve2(null);
        return;
      }
    });
  });
}
windowsExecutableCodeSignatureVerifier.verifySignature = verifySignature;
function parseOut(out2) {
  const data = JSON.parse(out2);
  delete data.PrivateKey;
  delete data.IsOSBinary;
  delete data.SignatureType;
  const signerCertificate = data.SignerCertificate;
  if (signerCertificate != null) {
    delete signerCertificate.Archived;
    delete signerCertificate.Extensions;
    delete signerCertificate.Handle;
    delete signerCertificate.HasPrivateKey;
    delete signerCertificate.SubjectName;
  }
  delete data.Path;
  return data;
}
function handleError(logger, error2, stderr) {
  if (isOldWin6()) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature: ${error2 || stderr}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  try {
    child_process_1$1.execFileSync("powershell.exe", ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"], { timeout: 10 * 1e3 });
  } catch (testError) {
    logger.warn(`Cannot execute ConvertTo-Json: ${testError.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`);
    return;
  }
  if (error2 != null) {
    throw error2;
  }
  if (stderr) {
    logger.warn(`Cannot execute Get-AuthenticodeSignature, stderr: ${stderr}. Ignoring signature validation due to unknown stderr.`);
    return;
  }
}
function isOldWin6() {
  const winVersion = os$1.release();
  return winVersion.startsWith("6.") && !winVersion.startsWith("6.3");
}
Object.defineProperty(NsisUpdater$1, "__esModule", { value: true });
NsisUpdater$1.NsisUpdater = void 0;
const builder_util_runtime_1 = out;
const child_process_1 = require$$1__default$4["default"];
const path$6 = require$$1__default$1["default"];
const BaseUpdater_1 = BaseUpdater$1;
const FileWithEmbeddedBlockMapDifferentialDownloader_1 = FileWithEmbeddedBlockMapDifferentialDownloader$1;
const GenericDifferentialDownloader_1 = GenericDifferentialDownloader$1;
const main_1 = main$1;
const util_1$q = util$1;
const Provider_1 = Provider$1;
const fs_extra_1 = lib;
const windowsExecutableCodeSignatureVerifier_1 = windowsExecutableCodeSignatureVerifier;
const url_1 = require$$2__default["default"];
const zlib_1 = require$$2__default$1["default"];
class NsisUpdater extends BaseUpdater_1.BaseUpdater {
  constructor(options, app2) {
    super(options, app2);
  }
  doDownloadUpdate(downloadUpdateOptions) {
    const provider = downloadUpdateOptions.updateInfoAndProvider.provider;
    const fileInfo = Provider_1.findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), "exe");
    return this.executeDownload({
      fileExtension: "exe",
      downloadUpdateOptions,
      fileInfo,
      task: async (destinationFile, downloadOptions, packageFile, removeTempDirIfAny) => {
        const packageInfo = fileInfo.packageInfo;
        const isWebInstaller = packageInfo != null && packageFile != null;
        if (isWebInstaller || await this.differentialDownloadInstaller(fileInfo, downloadUpdateOptions, destinationFile, provider)) {
          await this.httpExecutor.download(fileInfo.url, destinationFile, downloadOptions);
        }
        const signatureVerificationStatus = await this.verifySignature(destinationFile);
        if (signatureVerificationStatus != null) {
          await removeTempDirIfAny();
          throw builder_util_runtime_1.newError(`New version ${downloadUpdateOptions.updateInfoAndProvider.info.version} is not signed by the application owner: ${signatureVerificationStatus}`, "ERR_UPDATER_INVALID_SIGNATURE");
        }
        if (isWebInstaller) {
          if (await this.differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packageFile, provider)) {
            try {
              await this.httpExecutor.download(new url_1.URL(packageInfo.path), packageFile, {
                headers: downloadUpdateOptions.requestHeaders,
                cancellationToken: downloadUpdateOptions.cancellationToken,
                sha512: packageInfo.sha512
              });
            } catch (e) {
              try {
                await fs_extra_1.unlink(packageFile);
              } catch (ignored) {
              }
              throw e;
            }
          }
        }
      }
    });
  }
  async verifySignature(tempUpdateFile) {
    let publisherName;
    try {
      publisherName = (await this.configOnDisk.value).publisherName;
      if (publisherName == null) {
        return null;
      }
    } catch (e) {
      if (e.code === "ENOENT") {
        return null;
      }
      throw e;
    }
    return await windowsExecutableCodeSignatureVerifier_1.verifySignature(Array.isArray(publisherName) ? publisherName : [publisherName], tempUpdateFile, this._logger);
  }
  doInstall(options) {
    const args = ["--updated"];
    if (options.isSilent) {
      args.push("/S");
    }
    if (options.isForceRunAfter) {
      args.push("--force-run");
    }
    const packagePath = this.downloadedUpdateHelper == null ? null : this.downloadedUpdateHelper.packageFile;
    if (packagePath != null) {
      args.push(`--package-file=${packagePath}`);
    }
    const callUsingElevation = () => {
      _spawn(path$6.join(process.resourcesPath, "elevate.exe"), [options.installerPath].concat(args)).catch((e) => this.dispatchError(e));
    };
    if (options.isAdminRightsRequired) {
      this._logger.info("isAdminRightsRequired is set to true, run installer using elevate.exe");
      callUsingElevation();
      return true;
    }
    _spawn(options.installerPath, args).catch((e) => {
      const errorCode = e.code;
      this._logger.info(`Cannot run installer: error code: ${errorCode}, error message: "${e.message}", will be executed again using elevate if EACCES"`);
      if (errorCode === "UNKNOWN" || errorCode === "EACCES") {
        callUsingElevation();
      } else {
        this.dispatchError(e);
      }
    });
    return true;
  }
  async differentialDownloadInstaller(fileInfo, downloadUpdateOptions, installerPath, provider) {
    try {
      if (this._testOnlyOptions != null && !this._testOnlyOptions.isUseDifferentialDownload) {
        return true;
      }
      const blockmapFileUrls = util_1$q.blockmapFiles(fileInfo.url, this.app.version, downloadUpdateOptions.updateInfoAndProvider.info.version);
      this._logger.info(`Download block maps (old: "${blockmapFileUrls[0]}", new: ${blockmapFileUrls[1]})`);
      const downloadBlockMap = async (url) => {
        const data = await this.httpExecutor.downloadToBuffer(url, {
          headers: downloadUpdateOptions.requestHeaders,
          cancellationToken: downloadUpdateOptions.cancellationToken
        });
        if (data == null || data.length === 0) {
          throw new Error(`Blockmap "${url.href}" is empty`);
        }
        try {
          return JSON.parse(zlib_1.gunzipSync(data).toString());
        } catch (e) {
          throw new Error(`Cannot parse blockmap "${url.href}", error: ${e}`);
        }
      };
      const downloadOptions = {
        newUrl: fileInfo.url,
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_INSTALLER_FILE_NAME),
        logger: this._logger,
        newFile: installerPath,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        requestHeaders: downloadUpdateOptions.requestHeaders,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      const blockMapDataList = await Promise.all(blockmapFileUrls.map((u2) => downloadBlockMap(u2)));
      await new GenericDifferentialDownloader_1.GenericDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download(blockMapDataList[0], blockMapDataList[1]);
      return false;
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      if (this._testOnlyOptions != null) {
        throw e;
      }
      return true;
    }
  }
  async differentialDownloadWebPackage(downloadUpdateOptions, packageInfo, packagePath, provider) {
    if (packageInfo.blockMapSize == null) {
      return true;
    }
    try {
      const downloadOptions = {
        newUrl: new url_1.URL(packageInfo.path),
        oldFile: path$6.join(this.downloadedUpdateHelper.cacheDir, builder_util_runtime_1.CURRENT_APP_PACKAGE_FILE_NAME),
        logger: this._logger,
        newFile: packagePath,
        requestHeaders: this.requestHeaders,
        isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,
        cancellationToken: downloadUpdateOptions.cancellationToken
      };
      if (this.listenerCount(main_1.DOWNLOAD_PROGRESS) > 0) {
        downloadOptions.onProgress = (it) => this.emit(main_1.DOWNLOAD_PROGRESS, it);
      }
      await new FileWithEmbeddedBlockMapDifferentialDownloader_1.FileWithEmbeddedBlockMapDifferentialDownloader(packageInfo, this.httpExecutor, downloadOptions).download();
    } catch (e) {
      this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`);
      return process.platform === "win32";
    }
    return false;
  }
}
NsisUpdater$1.NsisUpdater = NsisUpdater;
async function _spawn(exe, args) {
  return new Promise((resolve2, reject) => {
    try {
      const process2 = child_process_1.spawn(exe, args, {
        detached: true,
        stdio: "ignore"
      });
      process2.on("error", (error2) => {
        reject(error2);
      });
      process2.unref();
      if (process2.pid !== void 0) {
        resolve2(true);
      }
    } catch (error2) {
      reject(error2);
    }
  });
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdaterSignal = exports.UPDATE_DOWNLOADED = exports.DOWNLOAD_PROGRESS = exports.NsisUpdater = exports.MacUpdater = exports.AppImageUpdater = exports.Provider = exports.CancellationToken = exports.NoOpLogger = exports.AppUpdater = void 0;
  const builder_util_runtime_12 = out;
  Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
    return builder_util_runtime_12.CancellationToken;
  } });
  var AppUpdater_12 = AppUpdater$1;
  Object.defineProperty(exports, "AppUpdater", { enumerable: true, get: function() {
    return AppUpdater_12.AppUpdater;
  } });
  Object.defineProperty(exports, "NoOpLogger", { enumerable: true, get: function() {
    return AppUpdater_12.NoOpLogger;
  } });
  var Provider_12 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return Provider_12.Provider;
  } });
  var AppImageUpdater_1 = AppImageUpdater$1;
  Object.defineProperty(exports, "AppImageUpdater", { enumerable: true, get: function() {
    return AppImageUpdater_1.AppImageUpdater;
  } });
  var MacUpdater_1 = MacUpdater$1;
  Object.defineProperty(exports, "MacUpdater", { enumerable: true, get: function() {
    return MacUpdater_1.MacUpdater;
  } });
  var NsisUpdater_1 = NsisUpdater$1;
  Object.defineProperty(exports, "NsisUpdater", { enumerable: true, get: function() {
    return NsisUpdater_1.NsisUpdater;
  } });
  let _autoUpdater;
  function doLoadAutoUpdater() {
    if (process.platform === "win32") {
      _autoUpdater = new NsisUpdater$1.NsisUpdater();
    } else if (process.platform === "darwin") {
      _autoUpdater = new MacUpdater$1.MacUpdater();
    } else {
      _autoUpdater = new AppImageUpdater$1.AppImageUpdater();
    }
    return _autoUpdater;
  }
  Object.defineProperty(exports, "autoUpdater", {
    enumerable: true,
    get: () => {
      return _autoUpdater || doLoadAutoUpdater();
    }
  });
  exports.DOWNLOAD_PROGRESS = "download-progress";
  exports.UPDATE_DOWNLOADED = "update-downloaded";
  class UpdaterSignal {
    constructor(emitter) {
      this.emitter = emitter;
    }
    login(handler) {
      addHandler(this.emitter, "login", handler);
    }
    progress(handler) {
      addHandler(this.emitter, exports.DOWNLOAD_PROGRESS, handler);
    }
    updateDownloaded(handler) {
      addHandler(this.emitter, exports.UPDATE_DOWNLOADED, handler);
    }
    updateCancelled(handler) {
      addHandler(this.emitter, "update-cancelled", handler);
    }
  }
  exports.UpdaterSignal = UpdaterSignal;
  function addHandler(emitter, event, handler) {
    {
      emitter.on(event, handler);
    }
  }
})(main$1);
var source = { exports: {} };
var isObj$1 = (value) => {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
const isObj = isObj$1;
const disallowedKeys = new Set([
  "__proto__",
  "prototype",
  "constructor"
]);
const isValidPath = (pathSegments) => !pathSegments.some((segment) => disallowedKeys.has(segment));
function getPathSegments(path2) {
  const pathArray = path2.split(".");
  const parts = [];
  for (let i2 = 0; i2 < pathArray.length; i2++) {
    let p = pathArray[i2];
    while (p[p.length - 1] === "\\" && pathArray[i2 + 1] !== void 0) {
      p = p.slice(0, -1) + ".";
      p += pathArray[++i2];
    }
    parts.push(p);
  }
  if (!isValidPath(parts)) {
    return [];
  }
  return parts;
}
var dotProp = {
  get(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return value === void 0 ? object : value;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      object = object[pathArray[i2]];
      if (object === void 0 || object === null) {
        if (i2 !== pathArray.length - 1) {
          return value;
        }
        break;
      }
    }
    return object === void 0 ? value : object;
  },
  set(object, path2, value) {
    if (!isObj(object) || typeof path2 !== "string") {
      return object;
    }
    const root2 = object;
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (!isObj(object[p])) {
        object[p] = {};
      }
      if (i2 === pathArray.length - 1) {
        object[p] = value;
      }
      object = object[p];
    }
    return root2;
  },
  delete(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      const p = pathArray[i2];
      if (i2 === pathArray.length - 1) {
        delete object[p];
        return true;
      }
      object = object[p];
      if (!isObj(object)) {
        return false;
      }
    }
  },
  has(object, path2) {
    if (!isObj(object) || typeof path2 !== "string") {
      return false;
    }
    const pathArray = getPathSegments(path2);
    if (pathArray.length === 0) {
      return false;
    }
    for (let i2 = 0; i2 < pathArray.length; i2++) {
      if (isObj(object)) {
        if (!(pathArray[i2] in object)) {
          return false;
        }
        object = object[pathArray[i2]];
      } else {
        return false;
      }
    }
    return true;
  }
};
var pkgUp = { exports: {} };
var findUp$1 = { exports: {} };
var locatePath$1 = { exports: {} };
var pathExists$1 = { exports: {} };
const fs$2 = require$$0__default$2["default"];
pathExists$1.exports = (fp) => new Promise((resolve2) => {
  fs$2.access(fp, (err) => {
    resolve2(!err);
  });
});
pathExists$1.exports.sync = (fp) => {
  try {
    fs$2.accessSync(fp);
    return true;
  } catch (err) {
    return false;
  }
};
var pLimit$2 = { exports: {} };
var pTry$2 = { exports: {} };
const pTry$1 = (fn, ...arguments_) => new Promise((resolve2) => {
  resolve2(fn(...arguments_));
});
pTry$2.exports = pTry$1;
pTry$2.exports.default = pTry$1;
const pTry = pTry$2.exports;
const pLimit$1 = (concurrency) => {
  if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
  }
  const queue2 = [];
  let activeCount = 0;
  const next = () => {
    activeCount--;
    if (queue2.length > 0) {
      queue2.shift()();
    }
  };
  const run = (fn, resolve2, ...args) => {
    activeCount++;
    const result = pTry(fn, ...args);
    resolve2(result);
    result.then(next, next);
  };
  const enqueue2 = (fn, resolve2, ...args) => {
    if (activeCount < concurrency) {
      run(fn, resolve2, ...args);
    } else {
      queue2.push(run.bind(null, fn, resolve2, ...args));
    }
  };
  const generator = (fn, ...args) => new Promise((resolve2) => enqueue2(fn, resolve2, ...args));
  Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue2.length
    },
    clearQueue: {
      value: () => {
        queue2.length = 0;
      }
    }
  });
  return generator;
};
pLimit$2.exports = pLimit$1;
pLimit$2.exports.default = pLimit$1;
const pLimit = pLimit$2.exports;
class EndError extends Error {
  constructor(value) {
    super();
    this.value = value;
  }
}
const testElement = (el, tester) => Promise.resolve(el).then(tester);
const finder = (el) => Promise.all(el).then((val) => val[1] === true && Promise.reject(new EndError(val[0])));
var pLocate$1 = (iterable, tester, opts2) => {
  opts2 = Object.assign({
    concurrency: Infinity,
    preserveOrder: true
  }, opts2);
  const limit2 = pLimit(opts2.concurrency);
  const items2 = [...iterable].map((el) => [el, limit2(testElement, el, tester)]);
  const checkLimit = pLimit(opts2.preserveOrder ? 1 : Infinity);
  return Promise.all(items2.map((el) => checkLimit(finder, el))).then(() => {
  }).catch((err) => err instanceof EndError ? err.value : Promise.reject(err));
};
const path$5 = require$$1__default$1["default"];
const pathExists = pathExists$1.exports;
const pLocate = pLocate$1;
locatePath$1.exports = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  return pLocate(iterable, (el) => pathExists(path$5.resolve(options.cwd, el)), options);
};
locatePath$1.exports.sync = (iterable, options) => {
  options = Object.assign({
    cwd: process.cwd()
  }, options);
  for (const el of iterable) {
    if (pathExists.sync(path$5.resolve(options.cwd, el))) {
      return el;
    }
  }
};
const path$4 = require$$1__default$1["default"];
const locatePath = locatePath$1.exports;
findUp$1.exports = (filename, opts2 = {}) => {
  const startDir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(startDir);
  const filenames = [].concat(filename);
  return new Promise((resolve2) => {
    (function find(dir) {
      locatePath(filenames, { cwd: dir }).then((file2) => {
        if (file2) {
          resolve2(path$4.join(dir, file2));
        } else if (dir === root2) {
          resolve2(null);
        } else {
          find(path$4.dirname(dir));
        }
      });
    })(startDir);
  });
};
findUp$1.exports.sync = (filename, opts2 = {}) => {
  let dir = path$4.resolve(opts2.cwd || "");
  const { root: root2 } = path$4.parse(dir);
  const filenames = [].concat(filename);
  while (true) {
    const file2 = locatePath.sync(filenames, { cwd: dir });
    if (file2) {
      return path$4.join(dir, file2);
    }
    if (dir === root2) {
      return null;
    }
    dir = path$4.dirname(dir);
  }
};
const findUp = findUp$1.exports;
pkgUp.exports = async ({ cwd: cwd2 } = {}) => findUp("package.json", { cwd: cwd2 });
pkgUp.exports.sync = ({ cwd: cwd2 } = {}) => findUp.sync("package.json", { cwd: cwd2 });
var envPaths$1 = { exports: {} };
const path$3 = require$$1__default$1["default"];
const os = require$$1__default$3["default"];
const homedir = os.homedir();
const tmpdir = os.tmpdir();
const { env: env$1 } = process;
const macos = (name) => {
  const library = path$3.join(homedir, "Library");
  return {
    data: path$3.join(library, "Application Support", name),
    config: path$3.join(library, "Preferences", name),
    cache: path$3.join(library, "Caches", name),
    log: path$3.join(library, "Logs", name),
    temp: path$3.join(tmpdir, name)
  };
};
const windows = (name) => {
  const appData = env$1.APPDATA || path$3.join(homedir, "AppData", "Roaming");
  const localAppData = env$1.LOCALAPPDATA || path$3.join(homedir, "AppData", "Local");
  return {
    data: path$3.join(localAppData, name, "Data"),
    config: path$3.join(appData, name, "Config"),
    cache: path$3.join(localAppData, name, "Cache"),
    log: path$3.join(localAppData, name, "Log"),
    temp: path$3.join(tmpdir, name)
  };
};
const linux = (name) => {
  const username = path$3.basename(homedir);
  return {
    data: path$3.join(env$1.XDG_DATA_HOME || path$3.join(homedir, ".local", "share"), name),
    config: path$3.join(env$1.XDG_CONFIG_HOME || path$3.join(homedir, ".config"), name),
    cache: path$3.join(env$1.XDG_CACHE_HOME || path$3.join(homedir, ".cache"), name),
    log: path$3.join(env$1.XDG_STATE_HOME || path$3.join(homedir, ".local", "state"), name),
    temp: path$3.join(tmpdir, username, name)
  };
};
const envPaths = (name, options) => {
  if (typeof name !== "string") {
    throw new TypeError(`Expected string, got ${typeof name}`);
  }
  options = Object.assign({ suffix: "nodejs" }, options);
  if (options.suffix) {
    name += `-${options.suffix}`;
  }
  if (process.platform === "darwin") {
    return macos(name);
  }
  if (process.platform === "win32") {
    return windows(name);
  }
  return linux(name);
};
envPaths$1.exports = envPaths;
envPaths$1.exports.default = envPaths;
var dist$1 = {};
var consts = {};
Object.defineProperty(consts, "__esModule", { value: true });
consts.NOOP = consts.LIMIT_FILES_DESCRIPTORS = consts.LIMIT_BASENAME_LENGTH = consts.IS_USER_ROOT = consts.IS_POSIX = consts.DEFAULT_TIMEOUT_SYNC = consts.DEFAULT_TIMEOUT_ASYNC = consts.DEFAULT_WRITE_OPTIONS = consts.DEFAULT_READ_OPTIONS = consts.DEFAULT_FOLDER_MODE = consts.DEFAULT_FILE_MODE = consts.DEFAULT_ENCODING = void 0;
const DEFAULT_ENCODING = "utf8";
consts.DEFAULT_ENCODING = DEFAULT_ENCODING;
const DEFAULT_FILE_MODE = 438;
consts.DEFAULT_FILE_MODE = DEFAULT_FILE_MODE;
const DEFAULT_FOLDER_MODE = 511;
consts.DEFAULT_FOLDER_MODE = DEFAULT_FOLDER_MODE;
const DEFAULT_READ_OPTIONS = {};
consts.DEFAULT_READ_OPTIONS = DEFAULT_READ_OPTIONS;
const DEFAULT_WRITE_OPTIONS = {};
consts.DEFAULT_WRITE_OPTIONS = DEFAULT_WRITE_OPTIONS;
const DEFAULT_TIMEOUT_ASYNC = 5e3;
consts.DEFAULT_TIMEOUT_ASYNC = DEFAULT_TIMEOUT_ASYNC;
const DEFAULT_TIMEOUT_SYNC = 100;
consts.DEFAULT_TIMEOUT_SYNC = DEFAULT_TIMEOUT_SYNC;
const IS_POSIX = !!process.getuid;
consts.IS_POSIX = IS_POSIX;
const IS_USER_ROOT = process.getuid ? !process.getuid() : false;
consts.IS_USER_ROOT = IS_USER_ROOT;
const LIMIT_BASENAME_LENGTH = 128;
consts.LIMIT_BASENAME_LENGTH = LIMIT_BASENAME_LENGTH;
const LIMIT_FILES_DESCRIPTORS = 1e4;
consts.LIMIT_FILES_DESCRIPTORS = LIMIT_FILES_DESCRIPTORS;
const NOOP = () => {
};
consts.NOOP = NOOP;
var fs$1 = {};
var attemptify = {};
Object.defineProperty(attemptify, "__esModule", { value: true });
attemptify.attemptifySync = attemptify.attemptifyAsync = void 0;
const consts_1$4 = consts;
const attemptifyAsync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    return fn.apply(void 0, arguments).catch(onError);
  };
};
attemptify.attemptifyAsync = attemptifyAsync;
const attemptifySync = (fn, onError = consts_1$4.NOOP) => {
  return function() {
    try {
      return fn.apply(void 0, arguments);
    } catch (error2) {
      return onError(error2);
    }
  };
};
attemptify.attemptifySync = attemptifySync;
var fs_handlers = {};
Object.defineProperty(fs_handlers, "__esModule", { value: true });
const consts_1$3 = consts;
const Handlers = {
  isChangeErrorOk: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "ENOSYS")
      return true;
    if (!consts_1$3.IS_USER_ROOT && (code2 === "EINVAL" || code2 === "EPERM"))
      return true;
    return false;
  },
  isRetriableError: (error2) => {
    const { code: code2 } = error2;
    if (code2 === "EMFILE" || code2 === "ENFILE" || code2 === "EAGAIN" || code2 === "EBUSY" || code2 === "EACCESS" || code2 === "EACCS" || code2 === "EPERM")
      return true;
    return false;
  },
  onChangeError: (error2) => {
    if (Handlers.isChangeErrorOk(error2))
      return;
    throw error2;
  }
};
fs_handlers.default = Handlers;
var retryify = {};
var retryify_queue = {};
Object.defineProperty(retryify_queue, "__esModule", { value: true });
const consts_1$2 = consts;
const RetryfyQueue = {
  interval: 25,
  intervalId: void 0,
  limit: consts_1$2.LIMIT_FILES_DESCRIPTORS,
  queueActive: new Set(),
  queueWaiting: new Set(),
  init: () => {
    if (RetryfyQueue.intervalId)
      return;
    RetryfyQueue.intervalId = setInterval(RetryfyQueue.tick, RetryfyQueue.interval);
  },
  reset: () => {
    if (!RetryfyQueue.intervalId)
      return;
    clearInterval(RetryfyQueue.intervalId);
    delete RetryfyQueue.intervalId;
  },
  add: (fn) => {
    RetryfyQueue.queueWaiting.add(fn);
    if (RetryfyQueue.queueActive.size < RetryfyQueue.limit / 2) {
      RetryfyQueue.tick();
    } else {
      RetryfyQueue.init();
    }
  },
  remove: (fn) => {
    RetryfyQueue.queueWaiting.delete(fn);
    RetryfyQueue.queueActive.delete(fn);
  },
  schedule: () => {
    return new Promise((resolve2) => {
      const cleanup = () => RetryfyQueue.remove(resolver);
      const resolver = () => resolve2(cleanup);
      RetryfyQueue.add(resolver);
    });
  },
  tick: () => {
    if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
      return;
    if (!RetryfyQueue.queueWaiting.size)
      return RetryfyQueue.reset();
    for (const fn of RetryfyQueue.queueWaiting) {
      if (RetryfyQueue.queueActive.size >= RetryfyQueue.limit)
        break;
      RetryfyQueue.queueWaiting.delete(fn);
      RetryfyQueue.queueActive.add(fn);
      fn();
    }
  }
};
retryify_queue.default = RetryfyQueue;
Object.defineProperty(retryify, "__esModule", { value: true });
retryify.retryifySync = retryify.retryifyAsync = void 0;
const retryify_queue_1 = retryify_queue;
const retryifyAsync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      return retryify_queue_1.default.schedule().then((cleanup) => {
        return fn.apply(void 0, arguments).then((result) => {
          cleanup();
          return result;
        }, (error2) => {
          cleanup();
          if (Date.now() >= timestamp2)
            throw error2;
          if (isRetriableError(error2)) {
            const delay = Math.round(100 + 400 * Math.random()), delayPromise = new Promise((resolve2) => setTimeout(resolve2, delay));
            return delayPromise.then(() => attempt.apply(void 0, arguments));
          }
          throw error2;
        });
      });
    };
  };
};
retryify.retryifyAsync = retryifyAsync;
const retryifySync = (fn, isRetriableError) => {
  return function(timestamp2) {
    return function attempt() {
      try {
        return fn.apply(void 0, arguments);
      } catch (error2) {
        if (Date.now() > timestamp2)
          throw error2;
        if (isRetriableError(error2))
          return attempt.apply(void 0, arguments);
        throw error2;
      }
    };
  };
};
retryify.retryifySync = retryifySync;
Object.defineProperty(fs$1, "__esModule", { value: true });
const fs = require$$0__default$2["default"];
const util_1$p = require$$4__default["default"];
const attemptify_1 = attemptify;
const fs_handlers_1 = fs_handlers;
const retryify_1 = retryify;
const FS = {
  chmodAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chmod), fs_handlers_1.default.onChangeError),
  chownAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.chown), fs_handlers_1.default.onChangeError),
  closeAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.close)),
  fsyncAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.fsync)),
  mkdirAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.mkdir)),
  realpathAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.realpath)),
  statAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.stat)),
  unlinkAttempt: attemptify_1.attemptifyAsync(util_1$p.promisify(fs.unlink)),
  closeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.close), fs_handlers_1.default.isRetriableError),
  fsyncRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.fsync), fs_handlers_1.default.isRetriableError),
  openRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.open), fs_handlers_1.default.isRetriableError),
  readFileRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.readFile), fs_handlers_1.default.isRetriableError),
  renameRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.rename), fs_handlers_1.default.isRetriableError),
  statRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.stat), fs_handlers_1.default.isRetriableError),
  writeRetry: retryify_1.retryifyAsync(util_1$p.promisify(fs.write), fs_handlers_1.default.isRetriableError),
  chmodSyncAttempt: attemptify_1.attemptifySync(fs.chmodSync, fs_handlers_1.default.onChangeError),
  chownSyncAttempt: attemptify_1.attemptifySync(fs.chownSync, fs_handlers_1.default.onChangeError),
  closeSyncAttempt: attemptify_1.attemptifySync(fs.closeSync),
  mkdirSyncAttempt: attemptify_1.attemptifySync(fs.mkdirSync),
  realpathSyncAttempt: attemptify_1.attemptifySync(fs.realpathSync),
  statSyncAttempt: attemptify_1.attemptifySync(fs.statSync),
  unlinkSyncAttempt: attemptify_1.attemptifySync(fs.unlinkSync),
  closeSyncRetry: retryify_1.retryifySync(fs.closeSync, fs_handlers_1.default.isRetriableError),
  fsyncSyncRetry: retryify_1.retryifySync(fs.fsyncSync, fs_handlers_1.default.isRetriableError),
  openSyncRetry: retryify_1.retryifySync(fs.openSync, fs_handlers_1.default.isRetriableError),
  readFileSyncRetry: retryify_1.retryifySync(fs.readFileSync, fs_handlers_1.default.isRetriableError),
  renameSyncRetry: retryify_1.retryifySync(fs.renameSync, fs_handlers_1.default.isRetriableError),
  statSyncRetry: retryify_1.retryifySync(fs.statSync, fs_handlers_1.default.isRetriableError),
  writeSyncRetry: retryify_1.retryifySync(fs.writeSync, fs_handlers_1.default.isRetriableError)
};
fs$1.default = FS;
var lang = {};
Object.defineProperty(lang, "__esModule", { value: true });
const Lang = {
  isFunction: (x) => {
    return typeof x === "function";
  },
  isString: (x) => {
    return typeof x === "string";
  },
  isUndefined: (x) => {
    return typeof x === "undefined";
  }
};
lang.default = Lang;
var scheduler = {};
Object.defineProperty(scheduler, "__esModule", { value: true });
const Queues = {};
const Scheduler = {
  next: (id2) => {
    const queue2 = Queues[id2];
    if (!queue2)
      return;
    queue2.shift();
    const job = queue2[0];
    if (job) {
      job(() => Scheduler.next(id2));
    } else {
      delete Queues[id2];
    }
  },
  schedule: (id2) => {
    return new Promise((resolve2) => {
      let queue2 = Queues[id2];
      if (!queue2)
        queue2 = Queues[id2] = [];
      queue2.push(resolve2);
      if (queue2.length > 1)
        return;
      resolve2(() => Scheduler.next(id2));
    });
  }
};
scheduler.default = Scheduler;
var temp = {};
Object.defineProperty(temp, "__esModule", { value: true });
const path$2 = require$$1__default$1["default"];
const consts_1$1 = consts;
const fs_1$1 = fs$1;
const Temp = {
  store: {},
  create: (filePath) => {
    const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), timestamp2 = Date.now().toString().slice(-10), prefix = "tmp-", suffix = `.${prefix}${timestamp2}${randomness}`, tempPath = `${filePath}${suffix}`;
    return tempPath;
  },
  get: (filePath, creator, purge = true) => {
    const tempPath = Temp.truncate(creator(filePath));
    if (tempPath in Temp.store)
      return Temp.get(filePath, creator, purge);
    Temp.store[tempPath] = purge;
    const disposer = () => delete Temp.store[tempPath];
    return [tempPath, disposer];
  },
  purge: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkAttempt(filePath);
  },
  purgeSync: (filePath) => {
    if (!Temp.store[filePath])
      return;
    delete Temp.store[filePath];
    fs_1$1.default.unlinkSyncAttempt(filePath);
  },
  purgeSyncAll: () => {
    for (const filePath in Temp.store) {
      Temp.purgeSync(filePath);
    }
  },
  truncate: (filePath) => {
    const basename = path$2.basename(filePath);
    if (basename.length <= consts_1$1.LIMIT_BASENAME_LENGTH)
      return filePath;
    const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    const truncationLength = basename.length - consts_1$1.LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
process.on("exit", Temp.purgeSyncAll);
temp.default = Temp;
Object.defineProperty(dist$1, "__esModule", { value: true });
dist$1.writeFileSync = dist$1.writeFile = dist$1.readFileSync = dist$1.readFile = void 0;
const path$1 = require$$1__default$1["default"];
const consts_1 = consts;
const fs_1 = fs$1;
const lang_1 = lang;
const scheduler_1 = scheduler;
const temp_1 = temp;
function readFile(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFile(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  return fs_1.default.readFileRetry(timeout)(filePath, options);
}
dist$1.readFile = readFile;
function readFileSync(filePath, options = consts_1.DEFAULT_READ_OPTIONS) {
  var _a;
  if (lang_1.default.isString(options))
    return readFileSync(filePath, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  return fs_1.default.readFileSyncRetry(timeout)(filePath, options);
}
dist$1.readFileSync = readFileSync;
const writeFile = (filePath, data, options, callback) => {
  if (lang_1.default.isFunction(options))
    return writeFile(filePath, data, consts_1.DEFAULT_WRITE_OPTIONS, options);
  const promise = writeFileAsync(filePath, data, options);
  if (callback)
    promise.then(callback, callback);
  return promise;
};
dist$1.writeFile = writeFile;
const writeFileAsync = async (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileAsync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_ASYNC);
  let schedulerCustomDisposer = null, schedulerDisposer = null, tempDisposer = null, tempPath = null, fd = null;
  try {
    if (options.schedule)
      schedulerCustomDisposer = await options.schedule(filePath);
    schedulerDisposer = await scheduler_1.default.schedule(filePath);
    filePath = await fs_1.default.realpathAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = await fs_1.default.statAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    await fs_1.default.mkdirAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = await fs_1.default.openRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      await fs_1.default.writeRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        await fs_1.default.fsyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    await fs_1.default.closeRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      await fs_1.default.chownAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      await fs_1.default.chmodAttempt(tempPath, options.mode);
    try {
      await fs_1.default.renameRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      await fs_1.default.renameRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      await fs_1.default.closeAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
    if (schedulerCustomDisposer)
      schedulerCustomDisposer();
    if (schedulerDisposer)
      schedulerDisposer();
  }
};
const writeFileSync = (filePath, data, options = consts_1.DEFAULT_WRITE_OPTIONS) => {
  var _a;
  if (lang_1.default.isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  const timeout = Date.now() + ((_a = options.timeout) !== null && _a !== void 0 ? _a : consts_1.DEFAULT_TIMEOUT_SYNC);
  let tempDisposer = null, tempPath = null, fd = null;
  try {
    filePath = fs_1.default.realpathSyncAttempt(filePath) || filePath;
    [tempPath, tempDisposer] = temp_1.default.get(filePath, options.tmpCreate || temp_1.default.create, !(options.tmpPurge === false));
    const useStatChown = consts_1.IS_POSIX && lang_1.default.isUndefined(options.chown), useStatMode = lang_1.default.isUndefined(options.mode);
    if (useStatChown || useStatMode) {
      const stat2 = fs_1.default.statSyncAttempt(filePath);
      if (stat2) {
        options = __spreadValues({}, options);
        if (useStatChown)
          options.chown = { uid: stat2.uid, gid: stat2.gid };
        if (useStatMode)
          options.mode = stat2.mode;
      }
    }
    const parentPath = path$1.dirname(filePath);
    fs_1.default.mkdirSyncAttempt(parentPath, {
      mode: consts_1.DEFAULT_FOLDER_MODE,
      recursive: true
    });
    fd = fs_1.default.openSyncRetry(timeout)(tempPath, "w", options.mode || consts_1.DEFAULT_FILE_MODE);
    if (options.tmpCreated)
      options.tmpCreated(tempPath);
    if (lang_1.default.isString(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, options.encoding || consts_1.DEFAULT_ENCODING);
    } else if (!lang_1.default.isUndefined(data)) {
      fs_1.default.writeSyncRetry(timeout)(fd, data, 0, data.length, 0);
    }
    if (options.fsync !== false) {
      if (options.fsyncWait !== false) {
        fs_1.default.fsyncSyncRetry(timeout)(fd);
      } else {
        fs_1.default.fsyncAttempt(fd);
      }
    }
    fs_1.default.closeSyncRetry(timeout)(fd);
    fd = null;
    if (options.chown)
      fs_1.default.chownSyncAttempt(tempPath, options.chown.uid, options.chown.gid);
    if (options.mode)
      fs_1.default.chmodSyncAttempt(tempPath, options.mode);
    try {
      fs_1.default.renameSyncRetry(timeout)(tempPath, filePath);
    } catch (error2) {
      if (error2.code !== "ENAMETOOLONG")
        throw error2;
      fs_1.default.renameSyncRetry(timeout)(tempPath, temp_1.default.truncate(filePath));
    }
    tempDisposer();
    tempPath = null;
  } finally {
    if (fd)
      fs_1.default.closeSyncAttempt(fd);
    if (tempPath)
      temp_1.default.purge(tempPath);
  }
};
dist$1.writeFileSync = writeFileSync;
var ajv = { exports: {} };
var core$2 = {};
var validate = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s2, c) => `${s2}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _(strs, ...args) {
    const code2 = [strs[0]];
    let i2 = 0;
    while (i2 < args.length) {
      addCodeArg(code2, args[i2]);
      code2.push(strs[++i2]);
    }
    return new _Code(code2);
  }
  exports._ = _;
  const plus = new _Code("+");
  function str2(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i2 = 0;
    while (i2 < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i2]);
      expr.push(plus, safeStringify(strs[++i2]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str2;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i2 = 1;
    while (i2 < expr.length - 1) {
      if (expr[i2] === plus) {
        const res = mergeExprItems(expr[i2 - 1], expr[i2 + 1]);
        if (res !== void 0) {
          expr.splice(i2 - 1, 3, res);
          continue;
        }
        expr[i2++] = "+";
      }
      i2++;
    }
  }
  function mergeExprItems(a, b) {
    if (b === '""')
      return a;
    if (a === '""')
      return b;
    if (typeof a == "string") {
      if (b instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b != "string")
        return `${a.slice(0, -1)}${b}"`;
      if (b[0] === '"')
        return a.slice(0, -1) + b.slice(1);
      return;
    }
    if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
      return `"${a}${b.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x) {
    return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
  }
  function stringify2(x) {
    return new _Code(safeStringify(x));
  }
  exports.stringify = stringify2;
  function safeStringify(x) {
    return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
  }
  exports.getProperty = getProperty;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_12.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = code_12._`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = code_12._`\n`;
  class ValueScope extends Scope {
    constructor(opts2) {
      super(opts2);
      this._values = {};
      this._scope = opts2.scope;
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? line : code_12.nil });
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map();
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return code_12._`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = code_12._`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = code_12._`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node2 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node2 {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node2 {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants2) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants2);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : __spreadValues({}, this.lhs.names);
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node2 {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node2 {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node2 {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      this.code = optimizeExpr(this.code, names2, constants2);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node2 {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts2) {
      return this.nodes.reduce((code2, n) => code2 + n.render(opts2), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i2, 1, ...n);
        else if (n)
          nodes[i2] = n;
        else
          nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants2) {
      const { nodes } = this;
      let i2 = nodes.length;
      while (i2--) {
        const n = nodes[i2];
        if (n.optimizeNames(names2, constants2))
          continue;
        subtractNames(names2, n.names);
        nodes.splice(i2, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n) => addNames(names2, n.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts2) {
      return "{" + opts2._n + super.render(opts2) + "}" + opts2._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts2) {
      let code2 = `if(${this.condition})` + super.render(opts2);
      if (this.else)
        code2 += "else " + this.else.render(opts2);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      if (!(super.optimizeNames(names2, constants2) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts2) {
      return `for(${this.iteration})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts2) {
      const varKind = opts2.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts2);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts2) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts2);
    }
    optimizeNames(names2, constants2) {
      if (!super.optimizeNames(names2, constants2))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants2);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts2) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts2);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts2) {
      return "return " + super.render(opts2);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts2) {
      let code2 = "try" + super.render(opts2);
      if (this.catch)
        code2 += this.catch.render(opts2);
      if (this.finally)
        code2 += this.finally.render(opts2);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants2) {
      var _a, _b;
      super.optimizeNames(names2, constants2);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants2);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants2);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts2) {
      return `catch(${this.error})` + super.render(opts2);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts2) {
      return "finally" + super.render(opts2);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts2 = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = __spreadProps(__spreadValues({}, opts2), { _n: opts2.lines ? "\n" : "" });
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          code_12.addCodeArg(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else());
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, code_12._`${arr}.length`, (i2) => {
          this.var(name, code_12._`${arr}[${i2}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, code_12._`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n = this._currNode;
      if (n instanceof N1 || N2 && n instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) + (from[n] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants2) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n) {
      const c = constants2[n.str];
      if (c === void 0 || names2[n.str] !== 1)
        return n;
      delete names2[n.str];
      return c;
    }
    function canOptimize(e) {
      return e instanceof code_12._Code && e._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants2[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n in from)
      names2[n] = (names2[n] || 0) - (from[n] || 0);
  }
  function not2(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : code_12._`!${par(x)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x, y2) => x === code_12.nil ? y2 : y2 === code_12.nil ? x : code_12._`${par(x)} ${op} ${par(y2)}`;
  }
  function par(x) {
    return x instanceof code_12.Name ? x : code_12._`(${x})`;
  }
})(codegen);
var util = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
  const codegen_12 = codegen;
  const code_12 = code$1;
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it, schema2) {
    if (typeof schema2 == "boolean")
      return schema2;
    if (Object.keys(schema2).length === 0)
      return true;
    checkUnknownRules(it, schema2);
    return !schemaHasRules(schema2, it.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it, schema2 = it.schema) {
    const { opts: opts2, self: self2 } = it;
    if (!opts2.strictSchema)
      return;
    if (typeof schema2 === "boolean")
      return;
    const rules2 = self2.RULES.keywords;
    for (const key in schema2) {
      if (!rules2[key])
        checkStrictMode(it, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema2, rules2) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (rules2[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema2, RULES) {
    if (typeof schema2 == "boolean")
      return !schema2;
    for (const key in schema2)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
    if (!$data) {
      if (typeof schema2 == "number" || typeof schema2 == "boolean")
        return schema2;
      if (typeof schema2 == "string")
        return codegen_12._`${schema2}`;
    }
    return codegen_12._`${topSchemaRef}${schemaPath}${codegen_12.getProperty(keyword2)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str2) {
    return unescapeJsonPointer(decodeURIComponent(str2));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str2) {
    return encodeURIComponent(escapeJsonPointer(str2));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str2) {
    if (typeof str2 == "number")
      return `${str2}`;
    return str2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str2) {
    return str2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f) {
    if (Array.isArray(xs)) {
      for (const x of xs)
        f(x);
    } else {
      f(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to, toName) => {
      const res = to === void 0 ? from : to instanceof codegen_12.Name ? (from instanceof codegen_12.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_12.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
      return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => {
        gen.if(codegen_12._`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, codegen_12._`${to} || {}`).code(codegen_12._`Object.assign(${to}, ${from})`));
      }),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => {
        if (from === true) {
          gen.assign(to, true);
        } else {
          gen.assign(to, codegen_12._`${to} || {}`);
          setEvaluated(gen, to, from);
        }
      }),
      mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to) => gen.if(codegen_12._`${to} !== true && ${from} !== undefined`, () => gen.assign(to, codegen_12._`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
      mergeToName: (gen, from, to) => gen.if(codegen_12._`${to} !== true`, () => gen.assign(to, from === true ? true : codegen_12._`${to} > ${from} ? ${to} : ${from}`)),
      mergeValues: (from, to) => from === true ? true : Math.max(from, to),
      resultToName: (gen, items2) => gen.var("items", items2)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", codegen_12._`{}`);
    if (ps !== void 0)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign(codegen_12._`${props}${codegen_12.getProperty(p)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  const snippets = {};
  function useFunc(gen, f) {
    return gen.scopeValue("func", {
      ref: f,
      code: snippets[f.code] || (snippets[f.code] = new code_12._Code(f.code))
    });
  }
  exports.useFunc = useFunc;
  var Type2;
  (function(Type3) {
    Type3[Type3["Num"] = 0] = "Num";
    Type3[Type3["Str"] = 1] = "Str";
  })(Type2 = exports.Type || (exports.Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_12.Name) {
      const isNumber = dataPropType === Type2.Num;
      return jsPropertySyntax ? isNumber ? codegen_12._`"[" + ${dataProp} + "]"` : codegen_12._`"['" + ${dataProp} + "']"` : isNumber ? codegen_12._`"/" + ${dataProp}` : codegen_12._`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? codegen_12.getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
})(util);
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$t = codegen;
const names = {
  data: new codegen_1$t.Name("data"),
  valCxt: new codegen_1$t.Name("valCxt"),
  instancePath: new codegen_1$t.Name("instancePath"),
  parentData: new codegen_1$t.Name("parentData"),
  parentDataProperty: new codegen_1$t.Name("parentDataProperty"),
  rootData: new codegen_1$t.Name("rootData"),
  dynamicAnchors: new codegen_1$t.Name("dynamicAnchors"),
  vErrors: new codegen_1$t.Name("vErrors"),
  errors: new codegen_1$t.Name("errors"),
  this: new codegen_1$t.Name("this"),
  self: new codegen_1$t.Name("self"),
  scope: new codegen_1$t.Name("scope"),
  json: new codegen_1$t.Name("json"),
  jsonPos: new codegen_1$t.Name("jsonPos"),
  jsonLen: new codegen_1$t.Name("jsonLen"),
  jsonPart: new codegen_1$t.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => codegen_12.str`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? codegen_12.str`"${keyword2}" keyword must be ${schemaType} ($data)` : codegen_12.str`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it, codegen_12._`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it } = cxt;
    const { gen, compositeRule, allErrors } = it;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if(codegen_12._`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_12._`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i2) => {
      gen.const(err, codegen_12._`${names_12.default.vErrors}[${i2}]`);
      gen.if(codegen_12._`${err}.instancePath === undefined`, () => gen.assign(codegen_12._`${err}.instancePath`, codegen_12.strConcat(names_12.default.instancePath, it.errorPath)));
      gen.assign(codegen_12._`${err}.schemaPath`, codegen_12.str`${it.errSchemaPath}/${keyword2}`);
      if (it.opts.verbose) {
        gen.assign(codegen_12._`${err}.schema`, schemaValue);
        gen.assign(codegen_12._`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if(codegen_12._`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, codegen_12._`[${err}]`), codegen_12._`${names_12.default.vErrors}.push(${err})`);
    gen.code(codegen_12._`${names_12.default.errors}++`);
  }
  function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv } = it;
    if (schemaEnv.$async) {
      gen.throw(codegen_12._`new ${it.ValidationError}(${errs})`);
    } else {
      gen.assign(codegen_12._`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return codegen_12._`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it } = cxt;
    const keyValues = [
      errorInstancePath(it, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? codegen_12.str`${errorPath}${util_12.getErrorPath(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, codegen_12.strConcat(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : codegen_12.str`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = codegen_12.str`${schPath}${util_12.getErrorPath(schemaPath, util_12.Type.Str)}`;
    }
    return [E.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it } = cxt;
    const { opts: opts2, propertyName, topSchemaRef, schemaPath } = it;
    keyValues.push([E.keyword, keyword2], [E.params, typeof params == "function" ? params(cxt) : params || codegen_12._`{}`]);
    if (opts2.messages) {
      keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts2.verbose) {
      keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_12._`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$2 = errors;
const codegen_1$s = codegen;
const names_1$6 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it) {
  const { gen, schema: schema2, validateName } = it;
  if (schema2 === false) {
    falseSchemaError(it, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$6.default.data);
  } else {
    gen.assign(codegen_1$s._`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it, valid2) {
  const { gen, schema: schema2 } = it;
  if (schema2 === false) {
    gen.var(valid2, false);
    falseSchemaError(it);
  } else {
    gen.var(valid2, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it, overrideAllErrors) {
  const { gen, data } = it;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it
  };
  errors_1$2.reportError(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x) {
  return typeof x == "string" && jsonTypes.has(x);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
  const rules_1 = rules;
  const applicability_12 = applicability;
  const errors_12 = errors;
  const codegen_12 = codegen;
  const util_12 = util;
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType = exports.DataType || (exports.DataType = {}));
  function getSchemaTypes(schema2) {
    const types2 = getJSONTypes(schema2.type);
    const hasNull = types2.includes("null");
    if (hasNull) {
      if (schema2.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types2.length && schema2.nullable !== void 0) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema2.nullable === true)
        types2.push("null");
    }
    return types2;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types2.every(rules_1.isJSONType))
      return types2;
    throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it, types2) {
    const { gen, data, opts: opts2 } = it;
    const coerceTo = coerceToTypes(types2, opts2.coerceTypes);
    const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && applicability_12.schemaHasRulesForType(it, types2[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types2, data, opts2.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it, types2, coerceTo);
        else
          reportTypeError(it);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types2, coerceTypes) {
    return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
  }
  function coerceData(it, types2, coerceTo) {
    const { gen, data, opts: opts2 } = it;
    const dataType2 = gen.let("dataType", codegen_12._`typeof ${data}`);
    const coerced = gen.let("coerced", codegen_12._`undefined`);
    if (opts2.coerceTypes === "array") {
      gen.if(codegen_12._`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, codegen_12._`${data}[0]`).assign(dataType2, codegen_12._`typeof ${data}`).if(checkDataTypes(types2, data, opts2.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if(codegen_12._`${coerced} !== undefined`);
    for (const t2 of coerceTo) {
      if (COERCIBLE.has(t2) || t2 === "array" && opts2.coerceTypes === "array") {
        coerceSpecificType(t2);
      }
    }
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if(codegen_12._`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it, coerced);
    });
    function coerceSpecificType(t2) {
      switch (t2) {
        case "string":
          gen.elseIf(codegen_12._`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, codegen_12._`"" + ${data}`).elseIf(codegen_12._`${data} === null`).assign(coerced, codegen_12._`""`);
          return;
        case "number":
          gen.elseIf(codegen_12._`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "integer":
          gen.elseIf(codegen_12._`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, codegen_12._`+${data}`);
          return;
        case "boolean":
          gen.elseIf(codegen_12._`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf(codegen_12._`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf(codegen_12._`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf(codegen_12._`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, codegen_12._`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if(codegen_12._`${parentData} !== undefined`, () => gen.assign(codegen_12._`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
    let cond;
    switch (dataType2) {
      case "null":
        return codegen_12._`${data} ${EQ} null`;
      case "array":
        cond = codegen_12._`Array.isArray(${data})`;
        break;
      case "object":
        cond = codegen_12._`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond(codegen_12._`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return codegen_12._`typeof ${data} ${EQ} ${dataType2}`;
    }
    return correct === DataType.Correct ? cond : codegen_12.not(cond);
    function numCond(_cond = codegen_12.nil) {
      return codegen_12.and(codegen_12._`typeof ${data} == "number"`, _cond, strictNums ? codegen_12._`isFinite(${data})` : codegen_12.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types2 = util_12.toHash(dataTypes);
    if (types2.array && types2.object) {
      const notObj = codegen_12._`typeof ${data} != "object"`;
      cond = types2.null ? notObj : codegen_12._`!${data} || ${notObj}`;
      delete types2.null;
      delete types2.array;
      delete types2.object;
    } else {
      cond = codegen_12.nil;
    }
    if (types2.number)
      delete types2.integer;
    for (const t2 in types2)
      cond = codegen_12.and(cond, checkDataType(t2, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  const typeError = {
    message: ({ schema: schema2 }) => `must be ${schema2}`,
    params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? codegen_12._`{type: ${schema2}}` : codegen_12._`{type: ${schemaValue}}`
  };
  function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    errors_12.reportError(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it) {
    const { gen, data, schema: schema2 } = it;
    const schemaCode = util_12.schemaRefOrVal(it, schema2, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema2.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema2,
      params: {},
      it
    };
  }
})(dataType);
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$r = codegen;
const util_1$o = util;
function assignDefaults(it, ty) {
  const { properties: properties2, items: items2 } = it.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i2) => assignDefault(it, i2, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it, prop, defaultValue) {
  const { gen, compositeRule, data, opts: opts2 } = it;
  if (defaultValue === void 0)
    return;
  const childData = codegen_1$r._`${data}${codegen_1$r.getProperty(prop)}`;
  if (compositeRule) {
    util_1$o.checkStrictMode(it, `default is ignored for: ${childData}`);
    return;
  }
  let condition = codegen_1$r._`${childData} === undefined`;
  if (opts2.useDefaults === "empty") {
    condition = codegen_1$r._`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, codegen_1$r._`${childData} = ${codegen_1$r.stringify(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$q = codegen;
const util_1$n = util;
const names_1$5 = names$1;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: codegen_1$q._`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts: opts2 } }, properties2, missing) {
  return codegen_1$q.or(...properties2.map((prop) => codegen_1$q.and(noPropertyInData(gen, data, prop, opts2.ownProperties), codegen_1$q._`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: codegen_1$q._`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return codegen_1$q._`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} !== undefined`;
  return ownProperties ? codegen_1$q._`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = codegen_1$q._`${data}${codegen_1$q.getProperty(property)} === undefined`;
  return ownProperties ? codegen_1$q.or(cond, codegen_1$q.not(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p) => !util_1$n.alwaysValidSchema(it, schemaMap[p]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
  const dataAndSchema = passSchema ? codegen_1$q._`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$5.default.instancePath, codegen_1$q.strConcat(names_1$5.default.instancePath, errorPath)],
    [names_1$5.default.parentData, it.parentData],
    [names_1$5.default.parentDataProperty, it.parentDataProperty],
    [names_1$5.default.rootData, names_1$5.default.rootData]
  ];
  if (it.opts.dynamicRef)
    valCxt.push([names_1$5.default.dynamicAnchors, names_1$5.default.dynamicAnchors]);
  const args = codegen_1$q._`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$q.nil ? codegen_1$q._`${func}.call(${context}, ${args})` : codegen_1$q._`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
function usePattern({ gen, it: { opts: opts2 } }, pattern2) {
  const u2 = opts2.unicodeRegExp ? "u" : "";
  return gen.scopeValue("pattern", {
    key: pattern2,
    ref: new RegExp(pattern2, u2),
    code: codegen_1$q._`new RegExp(${pattern2}, ${u2})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it } = cxt;
  const valid2 = gen.name("valid");
  if (it.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid2, true);
  validateItems(() => gen.break());
  return valid2;
  function validateItems(notValid) {
    const len = gen.const("len", codegen_1$q._`${data}.length`);
    gen.forRange("i", 0, len, (i2) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i2,
        dataPropType: util_1$n.Type.Num
      }, valid2);
      gen.if(codegen_1$q.not(valid2), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => util_1$n.alwaysValidSchema(it, sch));
  if (alwaysValid && !it.opts.unevaluated)
    return;
  const valid2 = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i2) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      compositeRule: true
    }, schValid);
    gen.assign(valid2, codegen_1$q._`${valid2} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if(codegen_1$q.not(valid2));
  }));
  cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it } = cxt;
  const macroSchema = def2.macro.call(it.self, schema2, parentSchema, it);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it.opts.validateSchema !== false)
    it.self.validateSchema(macroSchema, true);
  const valid2 = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$p.nil,
    errSchemaPath: `${it.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid2);
  cxt.pass(valid2, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it } = cxt;
  checkAsyncKeyword(it, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it.self, schema2, parentSchema, it) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid2 = gen.let("valid");
  cxt.block$data(valid2, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid2);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid(codegen_1$p._`await `), (e) => gen.assign(valid2, false).if(codegen_1$p._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1$p._`${e}.errors`), () => gen.throw(e)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = codegen_1$p._`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$p.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? codegen_1$p._`await ` : codegen_1$p.nil) {
    const passCxt = it.opts.passContext ? names_1$4.default.this : names_1$4.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid2, codegen_1$p._`${_await}${code_1$9.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if(codegen_1$p.not((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid2), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it } = cxt;
  gen.if(it.parentData, () => gen.assign(data, codegen_1$p._`${it.parentData}[${it.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if(codegen_1$p._`Array.isArray(${errs})`, () => {
    gen.assign(names_1$4.default.vErrors, codegen_1$p._`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`).assign(names_1$4.default.errors, codegen_1$p._`${names_1$4.default.vErrors}.length`);
    errors_1$1.extendErrors(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: codegen_1$p.stringify(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema2) : st === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts: opts2, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid2 = def2.validateSchema(schema2[keyword2]);
    if (!valid2) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts2.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$o = codegen;
const util_1$m = util;
function getSubschema(it, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: codegen_1$o._`${it.schemaPath}${codegen_1$o.getProperty(keyword2)}${codegen_1$o.getProperty(schemaProp)}`,
      errSchemaPath: `${it.errSchemaPath}/${keyword2}/${util_1$m.escapeFragment(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts: opts2 } = it;
    const nextData = gen.let("data", codegen_1$o._`${it.data}${codegen_1$o.getProperty(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = codegen_1$o.str`${errorPath}${util_1$m.getErrorPath(dataProp, dpType, opts2.jsPropertySyntax)}`;
    subschema2.parentDataProperty = codegen_1$o._`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$o.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it.dataLevel + 1;
    subschema2.dataTypes = [];
    it.definedProperties = new Set();
    subschema2.parentData = it.data;
    subschema2.dataNames = [...it.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$1 = {};
var fastDeepEqual = function equal2(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length, i2, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal2(a[i2], b[i2]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal2(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts2, cb) {
  if (typeof opts2 == "function") {
    cb = opts2;
    opts2 = {};
  }
  cb = opts2.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts2, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts2, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i2 = 0; i2 < sch.length; i2++)
            _traverse(opts2, pre, post, sch[i2], jsonPtr + "/" + key + "/" + i2, rootSchema, jsonPtr, key, schema2, i2);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts2, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts2.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts2, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str2) {
  return str2.replace(/~/g, "~0").replace(/\//g, "~1");
}
var uri_all = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function merge2() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str2) {
      return "(?:" + str2 + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str2) {
      return str2.toUpperCase();
    }
    function toArray2(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source2) {
      var obj = target;
      if (source2) {
        for (var key in source2) {
          obj[key] = source2[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI) {
      var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge2(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge2(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge2(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
      subexp(ALPHA$$ + merge2(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
      var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
      subexp("[vV]" + HEXDIG$$2 + "+\\." + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
      var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
      subexp(subexp(PCT_ENCODED$2 + "|" + merge2(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
      subexp(subexp(PCHAR$ + "|" + merge2("[\\/\\?]", IPRIVATE$$)) + "*");
      return {
        NOT_SCHEME: new RegExp(merge2("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge2("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge2("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge2("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge2("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge2("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge2("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge2("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i2) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i2) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i2);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = Array(arr.length); i2 < arr.length; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$12(type2) {
      throw new RangeError(errors2[type2]);
    }
    function map2(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output2 = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output2.push(value);
            counter--;
          }
        } else {
          output2.push(value);
        }
      }
      return output2;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output2 = [];
      var inputLength = input.length;
      var i2 = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$12("not-basic");
        }
        output2.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i2;
        for (var w2 = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$12("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error$12("overflow");
          }
          i2 += digit * w2;
          var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          var baseMinusT = base - t2;
          if (w2 > floor(maxInt / baseMinusT)) {
            error$12("overflow");
          }
          w2 *= baseMinusT;
        }
        var out2 = output2.length + 1;
        bias = adapt(i2 - oldi, out2, oldi == 0);
        if (floor(i2 / out2) > maxInt - n) {
          error$12("overflow");
        }
        n += floor(i2 / out2);
        i2 %= out2;
        output2.splice(i2++, 0, n);
      }
      return String.fromCodePoint.apply(String, output2);
    };
    var encode = function encode2(input) {
      var output2 = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output2.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output2.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output2.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m2 = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m2) {
              m2 = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$12("overflow");
        }
        delta += (m2 - n) * handledCPCountPlusOne;
        n = m2;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$12("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t2) {
                  break;
                }
                var qMinusT = q - t2;
                var baseMinusT = base - t2;
                output2.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output2.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output2.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str2) {
      var newStr = "";
      var i2 = 0;
      var il = str2.length;
      while (i2 < il) {
        var c = parseInt(str2.substr(i2 + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i2 += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i2 >= 6) {
            var c2 = parseInt(str2.substr(i2 + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str2.substr(i2, 6);
          }
          i2 += 6;
        } else if (c >= 224) {
          if (il - i2 >= 9) {
            var _c = parseInt(str2.substr(i2 + 4, 2), 16);
            var c3 = parseInt(str2.substr(i2 + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str2.substr(i2, 9);
          }
          i2 += 9;
        } else {
          newStr += str2.substr(i2, 3);
          i2 += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str2) {
        var decStr = pctDecChars(str2);
        return !decStr.match(protocol.UNRESERVED) ? str2 : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str2) {
      return str2.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse2(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output2 = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output2.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s2 = im[0];
            input = input.slice(s2.length);
            output2.push(s2);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output2.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host))
          ;
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s2 = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s2 = removeDotSegments(s2);
        }
        if (authority === void 0) {
          s2 = s2.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s2);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse2(serialize(base2, options), options);
        relative = parse2(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve2(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: "null" }, options);
      return serialize(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse2(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse2(serialize(uri, options), options);
      }
      return uri;
    }
    function equal3(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse2(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse2(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str2, options) {
      return str2 && str2.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse3(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        if (components.port === (secure ? 443 : 80) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    var handler$2 = {
      scheme: "ws",
      domainHost: true,
      parse: function parse3(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === "boolean") {
          wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
          wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      }
    };
    var handler$3 = {
      scheme: "wss",
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize
    };
    var O = {};
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge2(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge2("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge2("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str2) {
      var decStr = pctDecChars(str2);
      return !decStr.match(UNRESERVED) ? str2 : decStr;
    }
    var handler$4 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray2(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID2 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: "urn:uuid",
      parse: function parse3(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID2))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports2.SCHEMES = SCHEMES;
    exports2.pctEncChar = pctEncChar;
    exports2.pctDecChars = pctDecChars;
    exports2.parse = parse2;
    exports2.removeDotSegments = removeDotSegments;
    exports2.serialize = serialize;
    exports2.resolveComponents = resolveComponents;
    exports2.resolve = resolve2;
    exports2.normalize = normalize;
    exports2.equal = equal3;
    exports2.escapeComponent = escapeComponent;
    exports2.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(uri_all, uri_all.exports);
Object.defineProperty(resolve$1, "__esModule", { value: true });
resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
const util_1$l = util;
const equal$2 = fastDeepEqual;
const traverse = jsonSchemaTraverse.exports;
const URI$1 = uri_all.exports;
const SIMPLE_INLINED = new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit2 = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit2 === true)
    return !hasRef(schema2);
  if (!limit2)
    return false;
  return countKeys(schema2) <= limit2;
}
resolve$1.inlineRef = inlineRef;
const REF_KEYWORDS = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      util_1$l.eachItem(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(id2 = "", normalize) {
  if (normalize !== false)
    id2 = normalizeId(id2);
  const p = URI$1.parse(id2);
  return _getFullPath(p);
}
resolve$1.getFullPath = getFullPath;
function _getFullPath(p) {
  return URI$1.serialize(p).split("#")[0] + "#";
}
resolve$1._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$1.normalizeId = normalizeId;
function resolveUrl(baseId, id2) {
  id2 = normalizeId(id2);
  return URI$1.resolve(baseId, id2);
}
resolve$1.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId } = this.opts;
  const schId = normalizeId(schema2[schemaId]);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(schId, false);
  const localRefs = {};
  const schemaRefs = new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let baseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      baseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = baseId;
    function addRef(ref2) {
      ref2 = normalizeId(baseId ? URI$1.resolve(baseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$2(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$1.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate, "__esModule", { value: true });
validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$n = codegen;
const names_1$3 = names$1;
const resolve_1$2 = resolve$1;
const util_1$k = util;
const errors_1 = errors;
function validateFunctionCode(it) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it);
      return;
    }
  }
  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));
}
validate.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts: opts2 }, body) {
  if (opts2.code.es5) {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${names_1$3.default.valCxt}`, schemaEnv.$async, () => {
      gen.code(codegen_1$n._`"use strict"; ${funcSourceUrl(schema2, opts2)}`);
      destructureValCxtES5(gen, opts2);
      gen.code(body);
    });
  } else {
    gen.func(validateName, codegen_1$n._`${names_1$3.default.data}, ${destructureValCxt(opts2)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts2)).code(body));
  }
}
function destructureValCxt(opts2) {
  return codegen_1$n._`{${names_1$3.default.instancePath}="", ${names_1$3.default.parentData}, ${names_1$3.default.parentDataProperty}, ${names_1$3.default.rootData}=${names_1$3.default.data}${opts2.dynamicRef ? codegen_1$n._`, ${names_1$3.default.dynamicAnchors}={}` : codegen_1$n.nil}}={}`;
}
function destructureValCxtES5(gen, opts2) {
  gen.if(names_1$3.default.valCxt, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.instancePath}`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentData}`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.parentDataProperty}`);
    gen.var(names_1$3.default.rootData, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.rootData}`);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`${names_1$3.default.valCxt}.${names_1$3.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$3.default.instancePath, codegen_1$n._`""`);
    gen.var(names_1$3.default.parentData, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.parentDataProperty, codegen_1$n._`undefined`);
    gen.var(names_1$3.default.rootData, names_1$3.default.data);
    if (opts2.dynamicRef)
      gen.var(names_1$3.default.dynamicAnchors, codegen_1$n._`{}`);
  });
}
function topSchemaObjCode(it) {
  const { schema: schema2, opts: opts2, gen } = it;
  validateFunction(it, () => {
    if (opts2.$comment && schema2.$comment)
      commentKeyword(it);
    checkNoDefault(it);
    gen.let(names_1$3.default.vErrors, null);
    gen.let(names_1$3.default.errors, 0);
    if (opts2.unevaluated)
      resetEvaluated(it);
    typeAndKeywords(it);
    returnResults(it);
  });
  return;
}
function resetEvaluated(it) {
  const { gen, validateName } = it;
  it.evaluated = gen.const("evaluated", codegen_1$n._`${validateName}.evaluated`);
  gen.if(codegen_1$n._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1$n._`${it.evaluated}.props`, codegen_1$n._`undefined`));
  gen.if(codegen_1$n._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1$n._`${it.evaluated}.items`, codegen_1$n._`undefined`));
}
function funcSourceUrl(schema2, opts2) {
  const schId = typeof schema2 == "object" && schema2[opts2.schemaId];
  return schId && (opts2.code.source || opts2.code.process) ? codegen_1$n._`/*# sourceURL=${schId} */` : codegen_1$n.nil;
}
function subschemaCode(it, valid2) {
  if (isSchemaObj(it)) {
    checkKeywords(it);
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid2);
      return;
    }
  }
  boolSchema_1.boolOrEmptySchema(it, valid2);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it) {
  return typeof it.schema != "boolean";
}
function subSchemaObjCode(it, valid2) {
  const { schema: schema2, gen, opts: opts2 } = it;
  if (opts2.$comment && schema2.$comment)
    commentKeyword(it);
  updateContext(it);
  checkAsyncSchema(it);
  const errsCount = gen.const("_errs", names_1$3.default.errors);
  typeAndKeywords(it, errsCount);
  gen.var(valid2, codegen_1$n._`${errsCount} === ${names_1$3.default.errors}`);
}
function checkKeywords(it) {
  util_1$k.checkUnknownRules(it);
  checkRefsAndKeywords(it);
}
function typeAndKeywords(it, errsCount) {
  if (it.opts.jtd)
    return schemaKeywords(it, [], false, errsCount);
  const types2 = dataType_1$1.getSchemaTypes(it.schema);
  const checkedTypes = dataType_1$1.coerceAndCheckDataType(it, types2);
  schemaKeywords(it, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it) {
  const { schema: schema2, errSchemaPath, opts: opts2, self: self2 } = it;
  if (schema2.$ref && opts2.ignoreKeywordsWithRef && util_1$k.schemaHasRulesButRef(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it) {
  const { schema: schema2, opts: opts2 } = it;
  if (schema2.default !== void 0 && opts2.useDefaults && opts2.strictSchema) {
    util_1$k.checkStrictMode(it, "default is ignored in the schema root");
  }
}
function updateContext(it) {
  const schId = it.schema[it.opts.schemaId];
  if (schId)
    it.baseId = resolve_1$2.resolveUrl(it.baseId, schId);
}
function checkAsyncSchema(it) {
  if (it.schema.$async && !it.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts: opts2 }) {
  const msg = schema2.$comment;
  if (opts2.$comment === true) {
    gen.code(codegen_1$n._`${names_1$3.default.self}.logger.log(${msg})`);
  } else if (typeof opts2.$comment == "function") {
    const schemaPath = codegen_1$n.str`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code(codegen_1$n._`${names_1$3.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts: opts2 } = it;
  if (schemaEnv.$async) {
    gen.if(codegen_1$n._`${names_1$3.default.errors} === 0`, () => gen.return(names_1$3.default.data), () => gen.throw(codegen_1$n._`new ${ValidationError2}(${names_1$3.default.vErrors})`));
  } else {
    gen.assign(codegen_1$n._`${validateName}.errors`, names_1$3.default.vErrors);
    if (opts2.unevaluated)
      assignEvaluated(it);
    gen.return(codegen_1$n._`${names_1$3.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$n.Name)
    gen.assign(codegen_1$n._`${evaluated}.items`, items2);
}
function schemaKeywords(it, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts: opts2, self: self2 } = it;
  const { RULES } = self2;
  if (schema2.$ref && (opts2.ignoreKeywordsWithRef || !util_1$k.schemaHasRulesButRef(schema2, RULES))) {
    gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts2.jtd)
    checkStrictTypes(it, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!applicability_1.shouldUseGroup(schema2, group))
      return;
    if (group.type) {
      gen.if(dataType_2.checkDataType(group.type, data, opts2.strictNumbers));
      iterateKeywords(it, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        dataType_2.reportTypeError(it);
      }
      gen.endIf();
    } else {
      iterateKeywords(it, group);
    }
    if (!allErrors)
      gen.if(codegen_1$n._`${names_1$3.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it;
  if (useDefaults)
    defaults_1.assignDefaults(it, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if (applicability_1.shouldUseRule(schema2, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it, types2) {
  if (it.schemaEnv.meta || !it.opts.strictTypes)
    return;
  checkContextTypes(it, types2);
  if (!it.opts.allowUnionTypes)
    checkMultipleTypes(it, types2);
  checkKeywordTypes(it, it.dataTypes);
}
function checkContextTypes(it, types2) {
  if (!types2.length)
    return;
  if (!it.dataTypes.length) {
    it.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it.dataTypes, t2)) {
      strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
    }
  });
  it.dataTypes = it.dataTypes.filter((t2) => includesType(types2, t2));
}
function checkMultipleTypes(it, ts) {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it, ts) {
  const rules2 = it.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && applicability_1.shouldUseRule(it.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts, t2))) {
        strictTypesError(it, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts, t2) {
  return ts.includes(t2) || t2 === "integer" && ts.includes("number");
}
function strictTypesError(it, msg) {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  util_1$k.checkStrictMode(it, msg, it.opts.strictTypes);
}
class KeywordCxt {
  constructor(it, def2, keyword2) {
    keyword_1.validateKeywordUsage(it, def2, keyword2);
    this.gen = it.gen;
    this.allErrors = it.allErrors;
    this.keyword = keyword2;
    this.data = it.data;
    this.schema = it.schema[keyword2];
    this.$data = def2.$data && it.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = util_1$k.schemaRefOrVal(it, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it.schema;
    this.params = {};
    this.it = it;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
    } else {
      this.schemaCode = this.schemaValue;
      if (!keyword_1.validSchemaType(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it.gen.const("_errs", names_1$3.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult(codegen_1$n.not(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult(codegen_1$n.not(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail(codegen_1$n._`${schemaCode} !== undefined && (${codegen_1$n.or(this.invalid$data(), condition)})`);
  }
  error(append, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append, errorPaths);
  }
  _error(append, errorPaths) {
    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    errors_1.resetErrorsCount(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid2, codeBlock, $dataValid = codegen_1$n.nil) {
    this.gen.block(() => {
      this.check$data(valid2, $dataValid);
      codeBlock();
    });
  }
  check$data(valid2 = codegen_1$n.nil, $dataValid = codegen_1$n.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if(codegen_1$n.or(codegen_1$n._`${schemaCode} === undefined`, $dataValid));
    if (valid2 !== codegen_1$n.nil)
      gen.assign(valid2, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid2 !== codegen_1$n.nil)
        gen.assign(valid2, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it } = this;
    return codegen_1$n.or(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$n.Name))
          throw new Error("ajv implementation error");
        const st = Array.isArray(schemaType) ? schemaType : [schemaType];
        return codegen_1$n._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$n.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return codegen_1$n._`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$n.nil;
    }
  }
  subschema(appl, valid2) {
    const subschema2 = subschema_1.getSubschema(this.it, appl);
    subschema_1.extendSubschemaData(subschema2, this.it, appl);
    subschema_1.extendSubschemaMode(subschema2, appl);
    const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema2), { items: void 0, props: void 0 });
    subschemaCode(nextContext, valid2);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it, gen } = this;
    if (!it.opts.unevaluated)
      return;
    if (it.props !== true && schemaCxt.props !== void 0) {
      it.props = util_1$k.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
    }
    if (it.items !== true && schemaCxt.items !== void 0) {
      it.items = util_1$k.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid2) {
    const { it, gen } = this;
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid2, () => this.mergeEvaluated(schemaCxt, codegen_1$n.Name));
      return true;
    }
  }
}
validate.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  } else if ("macro" in def2) {
    keyword_1.macroKeywordCode(cxt, def2);
  } else if (def2.compile || def2.validate) {
    keyword_1.funcKeywordCode(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$3.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$3.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = codegen_1$n._`${data}${codegen_1$n.getProperty(util_1$k.unescapeJsonPointer(segment))}`;
      expr = codegen_1$n._`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$1;
class MissingRefError extends Error {
  constructor(baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = resolve_1$1.resolveUrl(baseId, ref2);
    this.missingSchema = resolve_1$1.normalizeId(resolve_1$1.getFullPath(this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$m = codegen;
const validation_error_1 = validation_error;
const names_1$2 = names$1;
const resolve_1 = resolve$1;
const util_1$j = util;
const validate_1$1 = validate;
const URI = uri_all.exports;
class SchemaEnv {
  constructor(env2) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env2.schema == "object")
      schema2 = env2.schema;
    this.schema = env2.schema;
    this.schemaId = env2.schemaId;
    this.root = env2.root || this;
    this.baseId = (_a = env2.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema2 === null || schema2 === void 0 ? void 0 : schema2[env2.schemaId || "$id"]);
    this.schemaPath = env2.schemaPath;
    this.localRefs = env2.localRefs;
    this.meta = env2.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = resolve_1.getFullPath(sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$m.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: codegen_1$m._`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$2.default.data,
    parentData: names_1$2.default.parentData,
    parentDataProperty: names_1$2.default.parentDataProperty,
    dataNames: [names_1$2.default.data],
    dataPathArr: [codegen_1$m.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: codegen_1$m.stringify(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$m.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: codegen_1$m._`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    validate_1$1.validateFunctionCode(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$2.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$2.default.self}`, `${names_1$2.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$m.Name ? void 0 : props,
        items: items2 instanceof codegen_1$m.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$m.Name,
        dynamicItems: items2 instanceof codegen_1$m.Name
      };
      if (validate2.source)
        validate2.source.evaluated = codegen_1$m.stringify(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root2, baseId, ref2) {
  var _a;
  ref2 = resolve_1.resolveUrl(baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p = URI.parse(ref2);
  const refPath = resolve_1._getFullPath(p);
  let baseId = resolve_1.getFullPath(root2.baseId);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p, root2);
  }
  const id2 = resolve_1.normalizeId(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === resolve_1.normalizeId(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = resolve_1.resolveUrl(baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root: root2 }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 == "boolean")
      return;
    schema2 = schema2[util_1$j.unescapeFragment(part)];
    if (schema2 === void 0)
      return;
    const schId = typeof schema2 == "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = resolve_1.resolveUrl(baseId, schId);
    }
  }
  let env2;
  if (typeof schema2 != "boolean" && schema2.$ref && !util_1$j.schemaHasRulesButRef(schema2, this.RULES)) {
    const $ref = resolve_1.resolveUrl(baseId, schema2.$ref);
    env2 = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env2 = env2 || new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  if (env2.schema !== env2.root.schema)
    return env2;
  return void 0;
}
const $id$1 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$1 = "object";
const required$1 = [
  "$data"
];
const properties$2 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
var require$$9 = {
  $id: $id$1,
  description,
  type: type$1,
  required: required$1,
  properties: properties$2,
  additionalProperties: additionalProperties$1
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_1 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$1;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const s2 = o.strict;
    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    return {
      strictSchema: (_c = (_b = o.strictSchema) !== null && _b !== void 0 ? _b : s2) !== null && _c !== void 0 ? _c : true,
      strictNumbers: (_e = (_d = o.strictNumbers) !== null && _d !== void 0 ? _d : s2) !== null && _e !== void 0 ? _e : true,
      strictTypes: (_g = (_f = o.strictTypes) !== null && _f !== void 0 ? _f : s2) !== null && _g !== void 0 ? _g : "log",
      strictTuples: (_j = (_h = o.strictTuples) !== null && _h !== void 0 ? _h : s2) !== null && _j !== void 0 ? _j : "log",
      strictRequired: (_l = (_k = o.strictRequired) !== null && _k !== void 0 ? _k : s2) !== null && _l !== void 0 ? _l : false,
      code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize }) : { optimize },
      loopRequired: (_m = o.loopRequired) !== null && _m !== void 0 ? _m : MAX_EXPRESSION,
      loopEnum: (_o = o.loopEnum) !== null && _o !== void 0 ? _o : MAX_EXPRESSION,
      meta: (_p = o.meta) !== null && _p !== void 0 ? _p : true,
      messages: (_q = o.messages) !== null && _q !== void 0 ? _q : true,
      inlineRefs: (_r = o.inlineRefs) !== null && _r !== void 0 ? _r : true,
      schemaId: (_s = o.schemaId) !== null && _s !== void 0 ? _s : "$id",
      addUsedSchema: (_t = o.addUsedSchema) !== null && _t !== void 0 ? _t : true,
      validateSchema: (_u = o.validateSchema) !== null && _u !== void 0 ? _u : true,
      validateFormats: (_v = o.validateFormats) !== null && _v !== void 0 ? _v : true,
      unicodeRegExp: (_w = o.unicodeRegExp) !== null && _w !== void 0 ? _w : true,
      int32range: (_x = o.int32range) !== null && _x !== void 0 ? _x : true
    };
  }
  class Ajv {
    constructor(opts2 = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set();
      this._loading = {};
      this._cache = new Map();
      opts2 = this.opts = __spreadValues(__spreadValues({}, opts2), requiredOptions(opts2));
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts2.logger);
      const formatOpt = opts2.validateFormats;
      opts2.validateFormats = false;
      this.RULES = rules_1.getRules();
      checkOptions.call(this, removedOptions, opts2, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts2, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts2.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts2.keywords)
        addInitialKeywords.call(this, opts2.keywords);
      if (typeof opts2.meta == "object")
        this.addMetaSchema(opts2.meta);
      addInitialSchemas.call(this);
      opts2.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = __spreadValues({}, $dataRefSchema);
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v = this.compile(schemaKeyRef);
      }
      const valid2 = v(data);
      if (!("$async" in v))
        this.errors = v.errors;
      return valid2;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_12.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p = this._loading[ref2];
        if (p)
          return p;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = resolve_12.normalizeId(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid2 = this.validate($schema2, schema2);
      if (!valid2 && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid2;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = resolve_12.normalizeId(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions2) {
      for (const def2 of definitions2)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        util_12.eachItem(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = __spreadProps(__spreadValues({}, def2), {
        type: dataType_12.getJSONTypes(def2.type),
        schemaType: dataType_12.getJSONTypes(def2.schemaType)
      });
      util_12.eachItem(keyword2, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i2 = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i2 >= 0)
          group.rules.splice(i2, 1);
      }
      return this;
    }
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2);
      baseId = resolve_12.normalizeId(id2 || baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  exports.default = Ajv;
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = resolve_12.normalizeId(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = __spreadValues({}, this.opts);
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    util_12.eachItem(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: __spreadProps(__spreadValues({}, definition), {
        type: dataType_12.getJSONTypes(definition.type),
        schemaType: dataType_12.getJSONTypes(definition.schemaType)
      })
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i2 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i2 >= 0) {
      ruleGroup.rules.splice(i2, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema } = def2;
    if (metaSchema === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def2.validateSchema = this.compile(metaSchema, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$2);
var draft7 = {};
var core$1 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$s = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$s;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1 = ref_error;
const code_1$8 = code;
const codegen_1$l = codegen;
const names_1$1 = names$1;
const compile_1 = compile;
const util_1$i = util;
const def$r = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it } = cxt;
    const { baseId, schemaEnv: env2, validateName, opts: opts2, self: self2 } = it;
    const { root: root2 } = env2;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1.default(baseId, $ref);
    if (schOrEnv instanceof compile_1.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env2 === root2)
        return callRef(cxt, validateName, env2, env2.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, codegen_1$l._`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v = getValidate(cxt, sch);
      callRef(cxt, v, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts2.code.source === true ? { ref: sch, code: codegen_1$l.stringify(sch) } : { ref: sch });
      const valid2 = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$l.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid2);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid2);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : codegen_1$l._`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v, sch, $async) {
  const { gen, it } = cxt;
  const { allErrors, schemaEnv: env2, opts: opts2 } = it;
  const passCxt = opts2.passContext ? names_1$1.default.this : codegen_1$l.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env2.$async)
      throw new Error("async schema referenced by sync schema");
    const valid2 = gen.let("valid");
    gen.try(() => {
      gen.code(codegen_1$l._`await ${code_1$8.callValidateCode(cxt, v, passCxt)}`);
      addEvaluatedFrom(v);
      if (!allErrors)
        gen.assign(valid2, true);
    }, (e) => {
      gen.if(codegen_1$l._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
      addErrorsFrom(e);
      if (!allErrors)
        gen.assign(valid2, false);
    });
    cxt.ok(valid2);
  }
  function callSyncRef() {
    cxt.result(code_1$8.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
  }
  function addErrorsFrom(source2) {
    const errs = codegen_1$l._`${source2}.errors`;
    gen.assign(names_1$1.default.vErrors, codegen_1$l._`${names_1$1.default.vErrors} === null ? ${errs} : ${names_1$1.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$1.default.errors, codegen_1$l._`${names_1$1.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source2) {
    var _a;
    if (!it.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it.props = util_1$i.mergeEvaluated.props(gen, schEvaluated.props, it.props);
        }
      } else {
        const props = gen.var("props", codegen_1$l._`${source2}.evaluated.props`);
        it.props = util_1$i.mergeEvaluated.props(gen, props, it.props, codegen_1$l.Name);
      }
    }
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it.items = util_1$i.mergeEvaluated.items(gen, schEvaluated.items, it.items);
        }
      } else {
        const items2 = gen.var("items", codegen_1$l._`${source2}.evaluated.items`);
        it.items = util_1$i.mergeEvaluated.items(gen, items2, it.items, codegen_1$l.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$r;
Object.defineProperty(core$1, "__esModule", { value: true });
const id_1 = id;
const ref_1 = ref;
const core = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1.default
];
core$1.default = core;
var validation$1 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$k = codegen;
const ops = codegen_1$k.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$i = {
  message: ({ keyword: keyword2, schemaCode }) => codegen_1$k.str`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => codegen_1$k._`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$q = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data(codegen_1$k._`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$q;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$j = codegen;
const error$h = {
  message: ({ schemaCode }) => codegen_1$j.str`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => codegen_1$j._`{multipleOf: ${schemaCode}}`
};
const def$p = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$h,
  code(cxt) {
    const { gen, data, schemaCode, it } = cxt;
    const prec = it.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? codegen_1$j._`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : codegen_1$j._`${res} !== parseInt(${res})`;
    cxt.fail$data(codegen_1$j._`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$p;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str2) {
  const len = str2.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str2.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str2.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$i = codegen;
const util_1$h = util;
const ucs2length_1 = ucs2length$1;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return codegen_1$i.str`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => codegen_1$i._`{limit: ${schemaCode}}`
};
const def$o = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    const len = it.opts.unicode === false ? codegen_1$i._`${data}.length` : codegen_1$i._`${util_1$h.useFunc(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data(codegen_1$i._`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$o;
var pattern = {};
Object.defineProperty(pattern, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$h = codegen;
const error$f = {
  message: ({ schemaCode }) => codegen_1$h.str`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$h._`{pattern: ${schemaCode}}`
};
const def$n = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$f,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it } = cxt;
    const u2 = it.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? codegen_1$h._`(new RegExp(${schemaCode}, ${u2}))` : code_1$7.usePattern(cxt, schema2);
    cxt.fail$data(codegen_1$h._`!${regExp}.test(${data})`);
  }
};
pattern.default = def$n;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$g = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return codegen_1$g.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$g._`{limit: ${schemaCode}}`
};
const def$m = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$g.operators.GT : codegen_1$g.operators.LT;
    cxt.fail$data(codegen_1$g._`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$m;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$f = codegen;
const util_1$g = util;
const error$d = {
  message: ({ params: { missingProperty } }) => codegen_1$f.str`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => codegen_1$f._`{missingProperty: ${missingProperty}}`
};
const def$l = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it } = cxt;
    const { opts: opts2 } = it;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts2.loopRequired;
    if (it.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts2.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          util_1$g.checkStrictMode(it, msg, it.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$f.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          code_1$6.checkReportMissingProp(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid2 = gen.let("valid", true);
        cxt.block$data(valid2, () => loopUntilMissing(missing, valid2));
        cxt.ok(valid2);
      } else {
        gen.if(code_1$6.checkMissingProp(cxt, schema2, missing));
        code_1$6.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if(code_1$6.noPropertyInData(gen, data, prop, opts2.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid2) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid2, code_1$6.propertyInData(gen, data, missing, opts2.ownProperties));
        gen.if(codegen_1$f.not(valid2), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$f.nil);
    }
  }
};
required.default = def$l;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$e = codegen;
const error$c = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return codegen_1$e.str`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => codegen_1$e._`{limit: ${schemaCode}}`
};
const def$k = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$c,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$e.operators.GT : codegen_1$e.operators.LT;
    cxt.fail$data(codegen_1$e._`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$k;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal = fastDeepEqual;
equal.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$d = codegen;
const util_1$f = util;
const equal_1$2 = equal$1;
const error$b = {
  message: ({ params: { i: i2, j } }) => codegen_1$d.str`must NOT have duplicate items (items ## ${j} and ${i2} are identical)`,
  params: ({ params: { i: i2, j } }) => codegen_1$d._`{i: ${i2}, j: ${j}}`
};
const def$j = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it } = cxt;
    if (!$data && !schema2)
      return;
    const valid2 = gen.let("valid");
    const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];
    cxt.block$data(valid2, validateUniqueItems, codegen_1$d._`${schemaCode} === false`);
    cxt.ok(valid2);
    function validateUniqueItems() {
      const i2 = gen.let("i", codegen_1$d._`${data}.length`);
      const j = gen.let("j");
      cxt.setParams({ i: i2, j });
      gen.assign(valid2, true);
      gen.if(codegen_1$d._`${i2} > 1`, () => (canOptimize() ? loopN : loopN2)(i2, j));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i2, j) {
      const item = gen.name("item");
      const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", codegen_1$d._`{}`);
      gen.for(codegen_1$d._`;${i2}--;`, () => {
        gen.let(item, codegen_1$d._`${data}[${i2}]`);
        gen.if(wrongType, codegen_1$d._`continue`);
        if (itemTypes.length > 1)
          gen.if(codegen_1$d._`typeof ${item} == "string"`, codegen_1$d._`${item} += "_"`);
        gen.if(codegen_1$d._`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j, codegen_1$d._`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid2, false).break();
        }).code(codegen_1$d._`${indices}[${item}] = ${i2}`);
      });
    }
    function loopN2(i2, j) {
      const eql = util_1$f.useFunc(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for(codegen_1$d._`;${i2}--;`, () => gen.for(codegen_1$d._`${j} = ${i2}; ${j}--;`, () => gen.if(codegen_1$d._`${eql}(${data}[${i2}], ${data}[${j}])`, () => {
        cxt.error();
        gen.assign(valid2, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$j;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$e = util;
const equal_1$1 = equal$1;
const error$a = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => codegen_1$c._`{allowedValue: ${schemaCode}}`
};
const def$i = {
  keyword: "const",
  $data: true,
  error: error$a,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data(codegen_1$c._`!${util_1$e.useFunc(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail(codegen_1$c._`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$i;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$d = util;
const equal_1 = equal$1;
const error$9 = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => codegen_1$b._`{allowedValues: ${schemaCode}}`
};
const def$h = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$9,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it.opts.loopEnum;
    const eql = util_1$d.useFunc(gen, equal_1.default);
    let valid2;
    if (useLoop || $data) {
      valid2 = gen.let("valid");
      cxt.block$data(valid2, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid2 = codegen_1$b.or(...schema2.map((_x, i2) => equalCode(vSchema, i2)));
    }
    cxt.pass(valid2);
    function loopEnum() {
      gen.assign(valid2, false);
      gen.forOf("v", schemaCode, (v) => gen.if(codegen_1$b._`${eql}(${data}, ${v})`, () => gen.assign(valid2, true).break()));
    }
    function equalCode(vSchema, i2) {
      const sch = schema2[i2];
      return typeof sch === "object" && sch !== null ? codegen_1$b._`${eql}(${data}, ${vSchema}[${i2}])` : codegen_1$b._`${data} === ${sch}`;
    }
  }
};
_enum.default = def$h;
Object.defineProperty(validation$1, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation = [
  limitNumber_1.default,
  multipleOf_1.default,
  limitLength_1.default,
  pattern_1.default,
  limitProperties_1.default,
  required_1.default,
  limitItems_1.default,
  uniqueItems_1.default,
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$1.default = validation;
var applicator = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$a = codegen;
const util_1$c = util;
const error$8 = {
  message: ({ params: { len } }) => codegen_1$a.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$a._`{limit: ${len}}`
};
const def$g = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$8,
  code(cxt) {
    const { parentSchema, it } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      util_1$c.checkStrictMode(it, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it } = cxt;
  it.items = true;
  const len = gen.const("len", codegen_1$a._`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass(codegen_1$a._`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !util_1$c.alwaysValidSchema(it, schema2)) {
    const valid2 = gen.var("valid", codegen_1$a._`${len} <= ${items2.length}`);
    gen.if(codegen_1$a.not(valid2), () => validateItems(valid2));
    cxt.ok(valid2);
  }
  function validateItems(valid2) {
    gen.forRange("i", items2.length, len, (i2) => {
      cxt.subschema({ keyword: keyword2, dataProp: i2, dataPropType: util_1$c.Type.Num }, valid2);
      if (!it.allErrors)
        gen.if(codegen_1$a.not(valid2), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$g;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$9 = codegen;
const util_1$b = util;
const code_1$5 = code;
const def$f = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it.items = true;
    if (util_1$b.alwaysValidSchema(it, schema2))
      return;
    cxt.ok(code_1$5.validateArray(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it } = cxt;
  checkStrictTuple(parentSchema);
  if (it.opts.unevaluated && schArr.length && it.items !== true) {
    it.items = util_1$b.mergeEvaluated.items(gen, schArr.length, it.items);
  }
  const valid2 = gen.name("valid");
  const len = gen.const("len", codegen_1$9._`${data}.length`);
  schArr.forEach((sch, i2) => {
    if (util_1$b.alwaysValidSchema(it, sch))
      return;
    gen.if(codegen_1$9._`${len} > ${i2}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i2,
      dataProp: i2
    }, valid2));
    cxt.ok(valid2);
  });
  function checkStrictTuple(sch) {
    const { opts: opts2, errSchemaPath } = it;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts2.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      util_1$b.checkStrictMode(it, msg, opts2.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$f;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$e = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => items_1$1.validateTuple(cxt, "items")
};
prefixItems.default = def$e;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$8 = codegen;
const util_1$a = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$7 = {
  message: ({ params: { len } }) => codegen_1$8.str`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => codegen_1$8._`{limit: ${len}}`
};
const def$d = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$7,
  code(cxt) {
    const { schema: schema2, parentSchema, it } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it.items = true;
    if (util_1$a.alwaysValidSchema(it, schema2))
      return;
    if (prefixItems2)
      additionalItems_1$1.validateAdditionalItems(cxt, prefixItems2);
    else
      cxt.ok(code_1$4.validateArray(cxt));
  }
};
items2020.default = def$d;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$9 = util;
const error$6 = {
  message: ({ params: { min, max } }) => max === void 0 ? codegen_1$7.str`must contain at least ${min} valid item(s)` : codegen_1$7.str`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? codegen_1$7._`{minContains: ${min}}` : codegen_1$7._`{minContains: ${min}, maxContains: ${max}}`
};
const def$c = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", codegen_1$7._`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      util_1$9.checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      util_1$9.checkStrictMode(it, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if (util_1$9.alwaysValidSchema(it, schema2)) {
      let cond = codegen_1$7._`${len} >= ${min}`;
      if (max !== void 0)
        cond = codegen_1$7._`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it.items = true;
    const valid2 = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid2, () => gen.if(valid2, () => gen.break()));
    } else {
      gen.let(valid2, false);
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    cxt.result(valid2, () => cxt.reset());
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i2) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i2,
          dataPropType: util_1$9.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code(codegen_1$7._`${count}++`);
      if (max === void 0) {
        gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true).break());
      } else {
        gen.if(codegen_1$7._`${count} > ${max}`, () => gen.assign(valid2, false).break());
        if (min === 1)
          gen.assign(valid2, true);
        else
          gen.if(codegen_1$7._`${count} >= ${min}`, () => gen.assign(valid2, true));
      }
    }
  }
};
contains.default = def$c;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return codegen_12.str`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => codegen_12._`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = code_12.propertyInData(gen, data, prop, it.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            code_12.checkReportMissingProp(cxt, depProp);
          }
        });
      } else {
        gen.if(codegen_12._`${hasProperty} && (${code_12.checkMissingProp(cxt, deps, missing)})`);
        code_12.reportMissingProp(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it } = cxt;
    const valid2 = gen.name("valid");
    for (const prop in schemaDeps) {
      if (util_12.alwaysValidSchema(it, schemaDeps[prop]))
        continue;
      gen.if(code_12.propertyInData(gen, data, prop, it.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid2);
        cxt.mergeValidEvaluated(schCxt, valid2);
      }, () => gen.var(valid2, true));
      cxt.ok(valid2);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "property name must be valid",
  params: ({ params }) => codegen_1$6._`{propertyName: ${params.propertyName}}`
};
const def$b = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, data, it } = cxt;
    if (util_1$8.alwaysValidSchema(it, schema2))
      return;
    const valid2 = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid2);
      gen.if(codegen_1$6.not(valid2), () => {
        cxt.error(true);
        if (!it.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid2);
  }
};
propertyNames.default = def$b;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$5 = codegen;
const names_1 = names$1;
const util_1$7 = util;
const error$4 = {
  message: "must NOT have additional properties",
  params: ({ params }) => codegen_1$5._`{additionalProperty: ${params.additionalProperty}}`
};
const def$a = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts: opts2 } = it;
    it.props = true;
    if (opts2.removeAdditional !== "all" && util_1$7.alwaysValidSchema(it, schema2))
      return;
    const props = code_1$3.allSchemaProperties(parentSchema.properties);
    const patProps = code_1$3.allSchemaProperties(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok(codegen_1$5._`${errsCount} === ${names_1.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = util_1$7.schemaRefOrVal(it, parentSchema.properties, "properties");
        definedProp = code_1$3.isOwnProperty(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = codegen_1$5.or(...props.map((p) => codegen_1$5._`${key} === ${p}`));
      } else {
        definedProp = codegen_1$5.nil;
      }
      if (patProps.length) {
        definedProp = codegen_1$5.or(definedProp, ...patProps.map((p) => codegen_1$5._`${code_1$3.usePattern(cxt, p)}.test(${key})`));
      }
      return codegen_1$5.not(definedProp);
    }
    function deleteAdditional(key) {
      gen.code(codegen_1$5._`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts2.removeAdditional === "all" || opts2.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !util_1$7.alwaysValidSchema(it, schema2)) {
        const valid2 = gen.name("valid");
        if (opts2.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid2, false);
          gen.if(codegen_1$5.not(valid2), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid2);
          if (!allErrors)
            gen.if(codegen_1$5.not(valid2), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid2, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$7.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid2);
    }
  }
};
additionalProperties.default = def$a;
var properties$1 = {};
Object.defineProperty(properties$1, "__esModule", { value: true });
const validate_1 = validate;
const code_1$2 = code;
const util_1$6 = util;
const additionalProperties_1$1 = additionalProperties;
const def$9 = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it } = cxt;
    if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = code_1$2.allSchemaProperties(schema2);
    for (const prop of allProps) {
      it.definedProperties.add(prop);
    }
    if (it.opts.unevaluated && allProps.length && it.props !== true) {
      it.props = util_1$6.mergeEvaluated.props(gen, util_1$6.toHash(allProps), it.props);
    }
    const properties2 = allProps.filter((p) => !util_1$6.alwaysValidSchema(it, schema2[p]));
    if (properties2.length === 0)
      return;
    const valid2 = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if(code_1$2.propertyInData(gen, data, prop, it.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it.allErrors)
          gen.else().var(valid2, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid2);
    }
    function hasDefault(prop) {
      return it.opts.useDefaults && !it.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid2);
    }
  }
};
properties$1.default = def$9;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$4 = codegen;
const util_1$5 = util;
const util_2 = util;
const def$8 = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it } = cxt;
    const { opts: opts2 } = it;
    const patterns = code_1$1.allSchemaProperties(schema2);
    const alwaysValidPatterns = patterns.filter((p) => util_1$5.alwaysValidSchema(it, schema2[p]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
      return;
    }
    const checkProperties = opts2.strictSchema && !opts2.allowMatchingProperties && parentSchema.properties;
    const valid2 = gen.name("valid");
    if (it.props !== true && !(it.props instanceof codegen_1$4.Name)) {
      it.props = util_2.evaluatedPropsToName(gen, it.props);
    }
    const { props } = it;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid2, true);
          validateProperties(pat);
          gen.if(valid2);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          util_1$5.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if(codegen_1$4._`${code_1$1.usePattern(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid2);
          }
          if (it.opts.unevaluated && props !== true) {
            gen.assign(codegen_1$4._`${props}[${key}]`, true);
          } else if (!alwaysValid && !it.allErrors) {
            gen.if(codegen_1$4.not(valid2), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$8;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$4 = util;
const def$7 = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (util_1$4.alwaysValidSchema(it, schema2)) {
      cxt.fail();
      return;
    }
    const valid2 = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid2);
    cxt.failResult(valid2, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$7;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$6 = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$6;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$3 = codegen;
const util_1$3 = util;
const error$3 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => codegen_1$3._`{passingSchemas: ${params.passing}}`
};
const def$5 = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$3,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid2 = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid2, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i2) => {
        let schCxt;
        if (util_1$3.alwaysValidSchema(it, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i2,
            compositeRule: true
          }, schValid);
        }
        if (i2 > 0) {
          gen.if(codegen_1$3._`${schValid} && ${valid2}`).assign(valid2, false).assign(passing, codegen_1$3._`[${passing}, ${i2}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid2, true);
          gen.assign(passing, i2);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$3.Name);
        });
      });
    }
  }
};
oneOf.default = def$5;
var allOf = {};
Object.defineProperty(allOf, "__esModule", { value: true });
const util_1$2 = util;
const def$4 = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid2 = gen.name("valid");
    schema2.forEach((sch, i2) => {
      if (util_1$2.alwaysValidSchema(it, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i2 }, valid2);
      cxt.ok(valid2);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf.default = def$4;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$1 = util;
const error$2 = {
  message: ({ params }) => codegen_1$2.str`must match "${params.ifClause}" schema`,
  params: ({ params }) => codegen_1$2._`{failingKeyword: ${params.ifClause}}`
};
const def$3 = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, parentSchema, it } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      util_1$1.checkStrictMode(it, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it, "then");
    const hasElse = hasSchema(it, "else");
    if (!hasThen && !hasElse)
      return;
    const valid2 = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if(codegen_1$2.not(schValid), validateClause("else"));
    }
    cxt.pass(valid2, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid2, schValid);
        cxt.mergeValidEvaluated(schCxt, valid2);
        if (ifClause)
          gen.assign(ifClause, codegen_1$2._`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it, keyword2) {
  const schema2 = it.schema[keyword2];
  return schema2 !== void 0 && !util_1$1.alwaysValidSchema(it, schema2);
}
_if.default = def$3;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1 = util;
const def$2 = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it }) {
    if (parentSchema.if === void 0)
      util_1.checkStrictMode(it, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$2;
Object.defineProperty(applicator, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$1;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator.default = getApplicator;
var format$2 = {};
var format$1 = {};
Object.defineProperty(format$1, "__esModule", { value: true });
const codegen_1$1 = codegen;
const error$1 = {
  message: ({ schemaCode }) => codegen_1$1.str`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => codegen_1$1._`{format: ${schemaCode}}`
};
const def$1 = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$1,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it } = cxt;
    const { opts: opts2, errSchemaPath, schemaEnv, self: self2 } = it;
    if (!opts2.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts2.code.formats
      });
      const fDef = gen.const("fDef", codegen_1$1._`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if(codegen_1$1._`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1$1._`${fDef}.type || "string"`).assign(format2, codegen_1$1._`${fDef}.validate`), () => gen.assign(fType, codegen_1$1._`"string"`).assign(format2, fDef));
      cxt.fail$data(codegen_1$1.or(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts2.strictSchema === false)
          return codegen_1$1.nil;
        return codegen_1$1._`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? codegen_1$1._`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : codegen_1$1._`${format2}(${data})`;
        const validData = codegen_1$1._`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return codegen_1$1._`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts2.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? codegen_1$1.regexpCode(fmtDef) : opts2.code.formats ? codegen_1$1._`${opts2.code.formats}${codegen_1$1.getProperty(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, codegen_1$1._`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return codegen_1$1._`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? codegen_1$1._`${fmtRef}(${data})` : codegen_1$1._`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$1.default = def$1;
Object.defineProperty(format$2, "__esModule", { value: true });
const format_1$1 = format$1;
const format = [format_1$1.default];
format$2.default = format;
var metadata = {};
Object.defineProperty(metadata, "__esModule", { value: true });
metadata.contentVocabulary = metadata.metadataVocabulary = void 0;
metadata.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$1;
const validation_1 = validation$1;
const applicator_1 = applicator;
const format_1 = format$2;
const metadata_1 = metadata;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  applicator_1.default(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var discriminator = {};
var types = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = void 0;
  (function(DiscrError) {
    DiscrError["Tag"] = "tag";
    DiscrError["Mapping"] = "mapping";
  })(exports.DiscrError || (exports.DiscrError = {}));
})(types);
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => codegen_1._`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid2 = gen.let("valid", false);
    const tag = gen.const("tag", codegen_1._`${data}${codegen_1.getProperty(tagName)}`);
    gen.if(codegen_1._`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid2);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf(codegen_1._`${tag} === ${tagValue}`);
        gen.assign(valid2, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i2 = 0; i2 < oneOf2.length; i2++) {
        const sch = oneOf2[i2];
        const propSch = (_a = sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf schemas must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i2);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i2) {
        if (sch.const) {
          addMapping(sch.const, i2);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i2);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i2) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i2;
      }
    }
  }
};
discriminator.default = def;
const $schema = "http://json-schema.org/draft-07/schema#";
const $id = "http://json-schema.org/draft-07/schema#";
const title = "Core schema meta-schema";
const definitions = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        "default": 0
      }
    ]
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const type = [
  "object",
  "boolean"
];
const properties = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  readOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    "default": true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  "const": true,
  "enum": {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  "if": {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  "else": {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var require$$3 = {
  $schema,
  $id,
  title,
  definitions,
  type,
  properties,
  "default": true
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  const core_12 = core$2;
  const draft7_1 = draft7;
  const discriminator_1 = discriminator;
  const draft7MetaSchema = require$$3;
  const META_SUPPORT_DATA = ["/properties"];
  const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  class Ajv extends core_12.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v) => this.addVocabulary(v));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  module.exports = exports = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_12 = validate;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
})(ajv, ajv.exports);
var dist = { exports: {} };
var formats = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
  function fmtDef(validate2, compare2) {
    return { validate: validate2, compare: compare2 };
  }
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  });
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str2) {
    const matches = DATE.exec(str2);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d2) {
    if (!(d1 && d2))
      return void 0;
    if (d1 > d2)
      return 1;
    if (d1 < d2)
      return -1;
    return 0;
  }
  const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function time(str2, withTimeZone) {
    const matches = TIME.exec(str2);
    if (!matches)
      return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
  }
  function compareTime(t1, t2) {
    if (!(t1 && t2))
      return void 0;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
      return void 0;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  const DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str2) {
    const dateTime = str2.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
      return void 0;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === void 0)
      return void 0;
    return res || compareTime(t1, t2);
  }
  const NOT_URI_FRAGMENT = /\/|:/;
  const URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str2) {
    return NOT_URI_FRAGMENT.test(str2) && URI2.test(str2);
  }
  const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str2) {
    BYTE.lastIndex = 0;
    return BYTE.test(str2);
  }
  const MIN_INT32 = -(2 ** 31);
  const MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  const Z_ANCHOR = /[^\\]\\Z/;
  function regex(str2) {
    if (Z_ANCHOR.test(str2))
      return false;
    try {
      new RegExp(str2);
      return true;
    } catch (e) {
      return false;
    }
  }
})(formats);
var limit = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = void 0;
  const ajv_1 = ajv.exports;
  const codegen_12 = codegen;
  const ops2 = codegen_12.operators;
  const KWDs2 = {
    formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
    formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
  };
  const error2 = {
    message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs2),
    type: "string",
    schemaType: "string",
    $data: true,
    error: error2,
    code(cxt) {
      const { gen, data, schemaCode, keyword: keyword2, it } = cxt;
      const { opts: opts2, self: self2 } = it;
      if (!opts2.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts2.code.formats
        });
        const fmt = gen.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format2 = fCxt.schema;
        const fmtDef = self2.formats[format2];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format2,
          ref: fmtDef,
          code: opts2.code.formats ? codegen_12._`${opts2.code.formats}${codegen_12.getProperty(format2)}` : void 0
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const formatLimitPlugin = (ajv2) => {
    ajv2.addKeyword(exports.formatLimitDefinition);
    return ajv2;
  };
  exports.default = formatLimitPlugin;
})(limit);
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const formats_1 = formats;
  const limit_1 = limit;
  const codegen_12 = codegen;
  const fullName = new codegen_12.Name("fullFormats");
  const fastName = new codegen_12.Name("fastFormats");
  const formatsPlugin = (ajv2, opts2 = { keywords: true }) => {
    if (Array.isArray(opts2)) {
      addFormats(ajv2, opts2, formats_1.fullFormats, fullName);
      return ajv2;
    }
    const [formats2, exportName] = opts2.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts2.formats || formats_1.formatNames;
    addFormats(ajv2, list, formats2, exportName);
    if (opts2.keywords)
      limit_1.default(ajv2);
    return ajv2;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats2[name];
    if (!f)
      throw new Error(`Unknown format "${name}"`);
    return f;
  };
  function addFormats(ajv2, list, fs2, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv2.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)
      ajv2.addFormat(f, fs2[f]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
})(dist, dist.exports);
const copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
const canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
const changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  Object.defineProperty(to, "toString", __spreadProps(__spreadValues({}, toStringDescriptor), { value: newToString }));
};
const mimicFn$4 = (to, from, { ignoreNonConfigurable = false } = {}) => {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
};
var mimicFn_1 = mimicFn$4;
const mimicFn$3 = mimicFn_1;
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction !== "function") {
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  }
  const {
    wait = 0,
    before = false,
    after = true
  } = options;
  if (!before && !after) {
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  }
  let timeout;
  let result;
  const debouncedFunction = function(...arguments_) {
    const context = this;
    const later = () => {
      timeout = void 0;
      if (after) {
        result = inputFunction.apply(context, arguments_);
      }
    };
    const shouldCallNow = before && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (shouldCallNow) {
      result = inputFunction.apply(context, arguments_);
    }
    return result;
  };
  mimicFn$3(debouncedFunction, inputFunction);
  debouncedFunction.cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = void 0;
    }
  };
  return debouncedFunction;
};
var re$5 = { exports: {} };
const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH$2 = 256;
const MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
const MAX_SAFE_COMPONENT_LENGTH = 16;
var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH: MAX_LENGTH$2,
  MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
  MAX_SAFE_COMPONENT_LENGTH
};
const debug$3 = typeof process === "object" && process.env && {}.NODE_DEBUG && /\bsemver\b/i.test({}.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
};
var debug_1 = debug$3;
(function(module, exports) {
  const { MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH2 } = constants;
  const debug2 = debug_1;
  exports = module.exports = {};
  const re2 = exports.re = [];
  const src = exports.src = [];
  const t2 = exports.t = {};
  let R = 0;
  const createToken = (name, value, isGlobal) => {
    const index = R++;
    debug2(index, value);
    t2[name] = index;
    src[index] = value;
    re2[index] = new RegExp(value, isGlobal ? "g" : void 0);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
  createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
  createToken("MAINVERSION", `(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})\\.(${src[t2.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.(${src[t2.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t2.NUMERICIDENTIFIER]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t2.NUMERICIDENTIFIERLOOSE]}|${src[t2.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
  createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
  createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`);
  createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:\\.(${src[t2.XRANGEIDENTIFIER]})(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?)?)?`);
  createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH2}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH2}}))?(?:$|[^\\d])`);
  createToken("COERCERTL", src[t2.COERCE], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t2.XRANGEPLAIN]})\\s+-\\s+(${src[t2.XRANGEPLAIN]})\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t2.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t2.XRANGEPLAINLOOSE]})\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
})(re$5, re$5.exports);
const opts = ["includePrerelease", "loose", "rtl"];
const parseOptions$4 = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((options2, k) => {
  options2[k] = true;
  return options2;
}, {});
var parseOptions_1 = parseOptions$4;
const numeric = /^[0-9]+$/;
const compareIdentifiers$1 = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);
  if (anum && bnum) {
    a = +a;
    b = +b;
  }
  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b) => compareIdentifiers$1(b, a);
var identifiers = {
  compareIdentifiers: compareIdentifiers$1,
  rcompareIdentifiers
};
const debug$2 = debug_1;
const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER } = constants;
const { re: re$4, t: t$4 } = re$5.exports;
const parseOptions$3 = parseOptions_1;
const { compareIdentifiers } = identifiers;
class SemVer$e {
  constructor(version, options) {
    options = parseOptions$3(options);
    if (version instanceof SemVer$e) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(`version is longer than ${MAX_LENGTH$1} characters`);
    }
    debug$2("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    const m2 = version.trim().match(options.loose ? re$4[t$4.LOOSE] : re$4[t$4.FULL]);
    if (!m2) {
      throw new TypeError(`Invalid Version: ${version}`);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map((id2) => {
        if (/^[0-9]+$/.test(id2)) {
          const num = +id2;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id2;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join(".")}`;
    }
    return this.version;
  }
  toString() {
    return this.version;
  }
  compare(other) {
    debug$2("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer$e)) {
      if (typeof other === "string" && other === this.version) {
        return 0;
      }
      other = new SemVer$e(other, this.options);
    }
    if (other.version === this.version) {
      return 0;
    }
    return this.compareMain(other) || this.comparePre(other);
  }
  compareMain(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }
  comparePre(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    let i2 = 0;
    do {
      const a = this.prerelease[i2];
      const b = other.prerelease[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  compareBuild(other) {
    if (!(other instanceof SemVer$e)) {
      other = new SemVer$e(other, this.options);
    }
    let i2 = 0;
    do {
      const a = this.build[i2];
      const b = other.build[i2];
      debug$2("prerelease compare", i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  }
  inc(release, identifier) {
    switch (release) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === "number") {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error(`invalid increment argument: ${release}`);
    }
    this.format();
    this.raw = this.version;
    return this;
  }
}
var semver$1 = SemVer$e;
const { MAX_LENGTH } = constants;
const { re: re$3, t: t$3 } = re$5.exports;
const SemVer$d = semver$1;
const parseOptions$2 = parseOptions_1;
const parse$5 = (version, options) => {
  options = parseOptions$2(options);
  if (version instanceof SemVer$d) {
    return version;
  }
  if (typeof version !== "string") {
    return null;
  }
  if (version.length > MAX_LENGTH) {
    return null;
  }
  const r = options.loose ? re$3[t$3.LOOSE] : re$3[t$3.FULL];
  if (!r.test(version)) {
    return null;
  }
  try {
    return new SemVer$d(version, options);
  } catch (er) {
    return null;
  }
};
var parse_1 = parse$5;
const parse$4 = parse_1;
const valid$1 = (version, options) => {
  const v = parse$4(version, options);
  return v ? v.version : null;
};
var valid_1 = valid$1;
const parse$3 = parse_1;
const clean = (version, options) => {
  const s2 = parse$3(version.trim().replace(/^[=v]+/, ""), options);
  return s2 ? s2.version : null;
};
var clean_1 = clean;
const SemVer$c = semver$1;
const inc = (version, release, options, identifier) => {
  if (typeof options === "string") {
    identifier = options;
    options = void 0;
  }
  try {
    return new SemVer$c(version, options).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
};
var inc_1 = inc;
const SemVer$b = semver$1;
const compare$a = (a, b, loose) => new SemVer$b(a, loose).compare(new SemVer$b(b, loose));
var compare_1 = compare$a;
const compare$9 = compare_1;
const eq$2 = (a, b, loose) => compare$9(a, b, loose) === 0;
var eq_1 = eq$2;
const parse$2 = parse_1;
const eq$1 = eq_1;
const diff = (version1, version2) => {
  if (eq$1(version1, version2)) {
    return null;
  } else {
    const v1 = parse$2(version1);
    const v2 = parse$2(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? "pre" : "";
    const defaultResult = hasPre ? "prerelease" : "";
    for (const key in v1) {
      if (key === "major" || key === "minor" || key === "patch") {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }
    return defaultResult;
  }
};
var diff_1 = diff;
const SemVer$a = semver$1;
const major = (a, loose) => new SemVer$a(a, loose).major;
var major_1 = major;
const SemVer$9 = semver$1;
const minor = (a, loose) => new SemVer$9(a, loose).minor;
var minor_1 = minor;
const SemVer$8 = semver$1;
const patch = (a, loose) => new SemVer$8(a, loose).patch;
var patch_1 = patch;
const parse$1 = parse_1;
const prerelease = (version, options) => {
  const parsed = parse$1(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
var prerelease_1 = prerelease;
const compare$8 = compare_1;
const rcompare = (a, b, loose) => compare$8(b, a, loose);
var rcompare_1 = rcompare;
const compare$7 = compare_1;
const compareLoose = (a, b) => compare$7(a, b, true);
var compareLoose_1 = compareLoose;
const SemVer$7 = semver$1;
const compareBuild$2 = (a, b, loose) => {
  const versionA = new SemVer$7(a, loose);
  const versionB = new SemVer$7(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
var compareBuild_1 = compareBuild$2;
const compareBuild$1 = compareBuild_1;
const sort = (list, loose) => list.sort((a, b) => compareBuild$1(a, b, loose));
var sort_1 = sort;
const compareBuild = compareBuild_1;
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
var rsort_1 = rsort;
const compare$6 = compare_1;
const gt$3 = (a, b, loose) => compare$6(a, b, loose) > 0;
var gt_1 = gt$3;
const compare$5 = compare_1;
const lt$2 = (a, b, loose) => compare$5(a, b, loose) < 0;
var lt_1 = lt$2;
const compare$4 = compare_1;
const neq$1 = (a, b, loose) => compare$4(a, b, loose) !== 0;
var neq_1 = neq$1;
const compare$3 = compare_1;
const gte$2 = (a, b, loose) => compare$3(a, b, loose) >= 0;
var gte_1 = gte$2;
const compare$2 = compare_1;
const lte$2 = (a, b, loose) => compare$2(a, b, loose) <= 0;
var lte_1 = lte$2;
const eq = eq_1;
const neq = neq_1;
const gt$2 = gt_1;
const gte$1 = gte_1;
const lt$1 = lt_1;
const lte$1 = lte_1;
const cmp$1 = (a, op, b, loose) => {
  switch (op) {
    case "===":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a === b;
    case "!==":
      if (typeof a === "object")
        a = a.version;
      if (typeof b === "object")
        b = b.version;
      return a !== b;
    case "":
    case "=":
    case "==":
      return eq(a, b, loose);
    case "!=":
      return neq(a, b, loose);
    case ">":
      return gt$2(a, b, loose);
    case ">=":
      return gte$1(a, b, loose);
    case "<":
      return lt$1(a, b, loose);
    case "<=":
      return lte$1(a, b, loose);
    default:
      throw new TypeError(`Invalid operator: ${op}`);
  }
};
var cmp_1 = cmp$1;
const SemVer$6 = semver$1;
const parse = parse_1;
const { re: re$2, t: t$2 } = re$5.exports;
const coerce = (version, options) => {
  if (version instanceof SemVer$6) {
    return version;
  }
  if (typeof version === "number") {
    version = String(version);
  }
  if (typeof version !== "string") {
    return null;
  }
  options = options || {};
  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    re$2[t$2.COERCERTL].lastIndex = -1;
  }
  if (match === null)
    return null;
  return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
var coerce_1 = coerce;
class Range$a {
  constructor(range2, options) {
    options = parseOptions$1(options);
    if (range2 instanceof Range$a) {
      if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
        return range2;
      } else {
        return new Range$a(range2.raw, options);
      }
    }
    if (range2 instanceof Comparator$3) {
      this.raw = range2.value;
      this.set = [[range2]];
      this.format();
      return this;
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range2;
    this.set = range2.split(/\s*\|\|\s*/).map((range3) => this.parseRange(range3.trim())).filter((c) => c.length);
    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range2}`);
    }
    if (this.set.length > 1) {
      const first = this.set[0];
      this.set = this.set.filter((c) => !isNullSet(c[0]));
      if (this.set.length === 0)
        this.set = [first];
      else if (this.set.length > 1) {
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c];
            break;
          }
        }
      }
    }
    this.format();
  }
  format() {
    this.range = this.set.map((comps) => {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  }
  toString() {
    return this.range;
  }
  parseRange(range2) {
    range2 = range2.trim();
    const memoOpts = Object.keys(this.options).join(",");
    const memoKey = `parseRange:${memoOpts}:${range2}`;
    const cached = cache.get(memoKey);
    if (cached)
      return cached;
    const loose = this.options.loose;
    const hr = loose ? re$1[t$1.HYPHENRANGELOOSE] : re$1[t$1.HYPHENRANGE];
    range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
    debug$1("hyphen replace", range2);
    range2 = range2.replace(re$1[t$1.COMPARATORTRIM], comparatorTrimReplace);
    debug$1("comparator trim", range2, re$1[t$1.COMPARATORTRIM]);
    range2 = range2.replace(re$1[t$1.TILDETRIM], tildeTrimReplace);
    range2 = range2.replace(re$1[t$1.CARETTRIM], caretTrimReplace);
    range2 = range2.split(/\s+/).join(" ");
    const compRe = loose ? re$1[t$1.COMPARATORLOOSE] : re$1[t$1.COMPARATOR];
    const rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator$3(comp, this.options));
    rangeList.length;
    const rangeMap = new Map();
    for (const comp of rangeList) {
      if (isNullSet(comp))
        return [comp];
      rangeMap.set(comp.value, comp);
    }
    if (rangeMap.size > 1 && rangeMap.has(""))
      rangeMap.delete("");
    const result = [...rangeMap.values()];
    cache.set(memoKey, result);
    return result;
  }
  intersects(range2, options) {
    if (!(range2 instanceof Range$a)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some((thisComparators) => {
      return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
        return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
          return rangeComparators.every((rangeComparator) => {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  }
  test(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$5(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (let i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  }
}
var range = Range$a;
const LRU = lruCache;
const cache = new LRU({ max: 1e3 });
const parseOptions$1 = parseOptions_1;
const Comparator$3 = comparator;
const debug$1 = debug_1;
const SemVer$5 = semver$1;
const {
  re: re$1,
  t: t$1,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re$5.exports;
const isNullSet = (c) => c.value === "<0.0.0-0";
const isAny = (c) => c.value === "";
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();
  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }
  return result;
};
const parseComparator = (comp, options) => {
  debug$1("comp", comp, options);
  comp = replaceCarets(comp, options);
  debug$1("caret", comp);
  comp = replaceTildes(comp, options);
  debug$1("tildes", comp);
  comp = replaceXRanges(comp, options);
  debug$1("xrange", comp);
  comp = replaceStars(comp, options);
  debug$1("stars", comp);
  return comp;
};
const isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
const replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceTilde(comp2, options);
}).join(" ");
const replaceTilde = (comp, options) => {
  const r = options.loose ? re$1[t$1.TILDELOOSE] : re$1[t$1.TILDE];
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("tilde", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
    } else if (pr) {
      debug$1("replaceTilde pr", pr);
      ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
    } else {
      ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("tilde return", ret);
    return ret;
  });
};
const replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((comp2) => {
  return replaceCaret(comp2, options);
}).join(" ");
const replaceCaret = (comp, options) => {
  debug$1("caret", comp, options);
  const r = options.loose ? re$1[t$1.CARETLOOSE] : re$1[t$1.CARET];
  const z = options.includePrerelease ? "-0" : "";
  return comp.replace(r, (_, M, m2, p, pr) => {
    debug$1("caret", comp, _, M, m2, p, pr);
    let ret;
    if (isX(M)) {
      ret = "";
    } else if (isX(m2)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
    } else if (isX(p)) {
      if (M === "0") {
        ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
      }
    } else if (pr) {
      debug$1("replaceCaret pr", pr);
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
      }
    } else {
      debug$1("no pr");
      if (M === "0") {
        if (m2 === "0") {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
        } else {
          ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
        }
      } else {
        ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
      }
    }
    debug$1("caret return", ret);
    return ret;
  });
};
const replaceXRanges = (comp, options) => {
  debug$1("replaceXRanges", comp, options);
  return comp.split(/\s+/).map((comp2) => {
    return replaceXRange(comp2, options);
  }).join(" ");
};
const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$1[t$1.XRANGELOOSE] : re$1[t$1.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m2, p, pr) => {
    debug$1("xRange", comp, ret, gtlt, M, m2, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m2);
    const xp = xm || isX(p);
    const anyX = xp;
    if (gtlt === "=" && anyX) {
      gtlt = "";
    }
    pr = options.includePrerelease ? "-0" : "";
    if (xM) {
      if (gtlt === ">" || gtlt === "<") {
        ret = "<0.0.0-0";
      } else {
        ret = "*";
      }
    } else if (gtlt && anyX) {
      if (xm) {
        m2 = 0;
      }
      p = 0;
      if (gtlt === ">") {
        gtlt = ">=";
        if (xm) {
          M = +M + 1;
          m2 = 0;
          p = 0;
        } else {
          m2 = +m2 + 1;
          p = 0;
        }
      } else if (gtlt === "<=") {
        gtlt = "<";
        if (xm) {
          M = +M + 1;
        } else {
          m2 = +m2 + 1;
        }
      }
      if (gtlt === "<")
        pr = "-0";
      ret = `${gtlt + M}.${m2}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
    } else if (xp) {
      ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
    }
    debug$1("xRange return", ret);
    return ret;
  });
};
const replaceStars = (comp, options) => {
  debug$1("replaceStars", comp, options);
  return comp.trim().replace(re$1[t$1.STAR], "");
};
const replaceGTE0 = (comp, options) => {
  debug$1("replaceGTE0", comp, options);
  return comp.trim().replace(re$1[options.includePrerelease ? t$1.GTE0PRE : t$1.GTE0], "");
};
const hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = "";
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
  } else if (fpr) {
    from = `>=${from}`;
  } else {
    from = `>=${from}${incPr ? "-0" : ""}`;
  }
  if (isX(tM)) {
    to = "";
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`;
  } else {
    to = `<=${to}`;
  }
  return `${from} ${to}`.trim();
};
const testSet = (set2, version, options) => {
  for (let i2 = 0; i2 < set2.length; i2++) {
    if (!set2[i2].test(version)) {
      return false;
    }
  }
  if (version.prerelease.length && !options.includePrerelease) {
    for (let i2 = 0; i2 < set2.length; i2++) {
      debug$1(set2[i2].semver);
      if (set2[i2].semver === Comparator$3.ANY) {
        continue;
      }
      if (set2[i2].semver.prerelease.length > 0) {
        const allowed = set2[i2].semver;
        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    }
    return false;
  }
  return true;
};
const ANY$2 = Symbol("SemVer ANY");
class Comparator$2 {
  static get ANY() {
    return ANY$2;
  }
  constructor(comp, options) {
    options = parseOptions(options);
    if (comp instanceof Comparator$2) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY$2) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  parse(comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
    const m2 = comp.match(r);
    if (!m2) {
      throw new TypeError(`Invalid comparator: ${comp}`);
    }
    this.operator = m2[1] !== void 0 ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY$2;
    } else {
      this.semver = new SemVer$4(m2[2], this.options.loose);
    }
  }
  toString() {
    return this.value;
  }
  test(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY$2 || version === ANY$2) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer$4(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  }
  intersects(comp, options) {
    if (!(comp instanceof Comparator$2)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      return new Range$9(comp.value, options).test(this.value);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      return new Range$9(this.value, options).test(comp.semver);
    }
    const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
    const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  }
}
var comparator = Comparator$2;
const parseOptions = parseOptions_1;
const { re, t } = re$5.exports;
const cmp = cmp_1;
const debug = debug_1;
const SemVer$4 = semver$1;
const Range$9 = range;
const Range$8 = range;
const satisfies$3 = (version, range2, options) => {
  try {
    range2 = new Range$8(range2, options);
  } catch (er) {
    return false;
  }
  return range2.test(version);
};
var satisfies_1 = satisfies$3;
const Range$7 = range;
const toComparators = (range2, options) => new Range$7(range2, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
var toComparators_1 = toComparators;
const SemVer$3 = semver$1;
const Range$6 = range;
const maxSatisfying = (versions, range2, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$6(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!max || maxSV.compare(v) === -1) {
        max = v;
        maxSV = new SemVer$3(max, options);
      }
    }
  });
  return max;
};
var maxSatisfying_1 = maxSatisfying;
const SemVer$2 = semver$1;
const Range$5 = range;
const minSatisfying = (versions, range2, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new Range$5(range2, options);
  } catch (er) {
    return null;
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      if (!min || minSV.compare(v) === 1) {
        min = v;
        minSV = new SemVer$2(min, options);
      }
    }
  });
  return min;
};
var minSatisfying_1 = minSatisfying;
const SemVer$1 = semver$1;
const Range$4 = range;
const gt$1 = gt_1;
const minVersion = (range2, loose) => {
  range2 = new Range$4(range2, loose);
  let minver = new SemVer$1("0.0.0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = new SemVer$1("0.0.0-0");
  if (range2.test(minver)) {
    return minver;
  }
  minver = null;
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let setMin = null;
    comparators.forEach((comparator2) => {
      const compver = new SemVer$1(comparator2.semver.version);
      switch (comparator2.operator) {
        case ">":
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
        case "":
        case ">=":
          if (!setMin || gt$1(compver, setMin)) {
            setMin = compver;
          }
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${comparator2.operator}`);
      }
    });
    if (setMin && (!minver || gt$1(minver, setMin)))
      minver = setMin;
  }
  if (minver && range2.test(minver)) {
    return minver;
  }
  return null;
};
var minVersion_1 = minVersion;
const Range$3 = range;
const validRange = (range2, options) => {
  try {
    return new Range$3(range2, options).range || "*";
  } catch (er) {
    return null;
  }
};
var valid = validRange;
const SemVer = semver$1;
const Comparator$1 = comparator;
const { ANY: ANY$1 } = Comparator$1;
const Range$2 = range;
const satisfies$2 = satisfies_1;
const gt = gt_1;
const lt = lt_1;
const lte = lte_1;
const gte = gte_1;
const outside$2 = (version, range2, hilo, options) => {
  version = new SemVer(version, options);
  range2 = new Range$2(range2, options);
  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case ">":
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = ">";
      ecomp = ">=";
      break;
    case "<":
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = "<";
      ecomp = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (satisfies$2(version, range2, options)) {
    return false;
  }
  for (let i2 = 0; i2 < range2.set.length; ++i2) {
    const comparators = range2.set[i2];
    let high = null;
    let low = null;
    comparators.forEach((comparator2) => {
      if (comparator2.semver === ANY$1) {
        comparator2 = new Comparator$1(">=0.0.0");
      }
      high = high || comparator2;
      low = low || comparator2;
      if (gtfn(comparator2.semver, high.semver, options)) {
        high = comparator2;
      } else if (ltfn(comparator2.semver, low.semver, options)) {
        low = comparator2;
      }
    });
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }
    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
};
var outside_1 = outside$2;
const outside$1 = outside_1;
const gtr = (version, range2, options) => outside$1(version, range2, ">", options);
var gtr_1 = gtr;
const outside = outside_1;
const ltr = (version, range2, options) => outside(version, range2, "<", options);
var ltr_1 = ltr;
const Range$1 = range;
const intersects = (r1, r2, options) => {
  r1 = new Range$1(r1, options);
  r2 = new Range$1(r2, options);
  return r1.intersects(r2);
};
var intersects_1 = intersects;
const satisfies$1 = satisfies_1;
const compare$1 = compare_1;
var simplify = (versions, range2, options) => {
  const set2 = [];
  let min = null;
  let prev = null;
  const v = versions.sort((a, b) => compare$1(a, b, options));
  for (const version of v) {
    const included = satisfies$1(version, range2, options);
    if (included) {
      prev = version;
      if (!min)
        min = version;
    } else {
      if (prev) {
        set2.push([min, prev]);
      }
      prev = null;
      min = null;
    }
  }
  if (min)
    set2.push([min, null]);
  const ranges = [];
  for (const [min2, max] of set2) {
    if (min2 === max)
      ranges.push(min2);
    else if (!max && min2 === v[0])
      ranges.push("*");
    else if (!max)
      ranges.push(`>=${min2}`);
    else if (min2 === v[0])
      ranges.push(`<=${max}`);
    else
      ranges.push(`${min2} - ${max}`);
  }
  const simplified = ranges.join(" || ");
  const original = typeof range2.raw === "string" ? range2.raw : String(range2);
  return simplified.length < original.length ? simplified : range2;
};
const Range = range;
const Comparator = comparator;
const { ANY } = Comparator;
const satisfies = satisfies_1;
const compare = compare_1;
const subset = (sub, dom, options = {}) => {
  if (sub === dom)
    return true;
  sub = new Range(sub, options);
  dom = new Range(dom, options);
  let sawNonNull = false;
  OUTER:
    for (const simpleSub of sub.set) {
      for (const simpleDom of dom.set) {
        const isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub)
          continue OUTER;
      }
      if (sawNonNull)
        return false;
    }
  return true;
};
const simpleSubset = (sub, dom, options) => {
  if (sub === dom)
    return true;
  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY)
      return true;
    else if (options.includePrerelease)
      sub = [new Comparator(">=0.0.0-0")];
    else
      sub = [new Comparator(">=0.0.0")];
  }
  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease)
      return true;
    else
      dom = [new Comparator(">=0.0.0")];
  }
  const eqSet = new Set();
  let gt2, lt2;
  for (const c of sub) {
    if (c.operator === ">" || c.operator === ">=")
      gt2 = higherGT(gt2, c, options);
    else if (c.operator === "<" || c.operator === "<=")
      lt2 = lowerLT(lt2, c, options);
    else
      eqSet.add(c.semver);
  }
  if (eqSet.size > 1)
    return null;
  let gtltComp;
  if (gt2 && lt2) {
    gtltComp = compare(gt2.semver, lt2.semver, options);
    if (gtltComp > 0)
      return null;
    else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<="))
      return null;
  }
  for (const eq2 of eqSet) {
    if (gt2 && !satisfies(eq2, String(gt2), options))
      return null;
    if (lt2 && !satisfies(eq2, String(lt2), options))
      return null;
    for (const c of dom) {
      if (!satisfies(eq2, String(c), options))
        return false;
    }
    return true;
  }
  let higher, lower;
  let hasDomLT, hasDomGT;
  let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
  let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false;
  }
  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
    hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
    if (gt2) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false;
        }
      }
      if (c.operator === ">" || c.operator === ">=") {
        higher = higherGT(gt2, c, options);
        if (higher === c && higher !== gt2)
          return false;
      } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c), options))
        return false;
    }
    if (lt2) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false;
        }
      }
      if (c.operator === "<" || c.operator === "<=") {
        lower = lowerLT(lt2, c, options);
        if (lower === c && lower !== lt2)
          return false;
      } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c), options))
        return false;
    }
    if (!c.operator && (lt2 || gt2) && gtltComp !== 0)
      return false;
  }
  if (gt2 && hasDomLT && !lt2 && gtltComp !== 0)
    return false;
  if (lt2 && hasDomGT && !gt2 && gtltComp !== 0)
    return false;
  if (needDomGTPre || needDomLTPre)
    return false;
  return true;
};
const higherGT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
const lowerLT = (a, b, options) => {
  if (!a)
    return b;
  const comp = compare(a.semver, b.semver, options);
  return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
var subset_1 = subset;
const internalRe = re$5.exports;
var semver = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver$1,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
  simplifyRange: simplify,
  subset: subset_1
};
var onetime$1 = { exports: {} };
var mimicFn$2 = { exports: {} };
const mimicFn$1 = (to, from) => {
  for (const prop of Reflect.ownKeys(from)) {
    Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
  }
  return to;
};
mimicFn$2.exports = mimicFn$1;
mimicFn$2.exports.default = mimicFn$1;
const mimicFn = mimicFn$2.exports;
const calledFunctions = new WeakMap();
const onetime = (function_, options = {}) => {
  if (typeof function_ !== "function") {
    throw new TypeError("Expected a function");
  }
  let returnValue;
  let callCount = 0;
  const functionName = function_.displayName || function_.name || "<anonymous>";
  const onetime2 = function(...arguments_) {
    calledFunctions.set(onetime2, ++callCount);
    if (callCount === 1) {
      returnValue = function_.apply(this, arguments_);
      function_ = null;
    } else if (options.throw === true) {
      throw new Error(`Function \`${functionName}\` can only be called once`);
    }
    return returnValue;
  };
  mimicFn(onetime2, function_);
  calledFunctions.set(onetime2, callCount);
  return onetime2;
};
onetime$1.exports = onetime;
onetime$1.exports.default = onetime;
onetime$1.exports.callCount = (function_) => {
  if (!calledFunctions.has(function_)) {
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  }
  return calledFunctions.get(function_);
};
(function(module, exports) {
  var __classPrivateFieldSet = commonjsGlobal && commonjsGlobal.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = commonjsGlobal && commonjsGlobal.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _a, _b;
  var _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues;
  Object.defineProperty(exports, "__esModule", { value: true });
  const util_12 = require$$4__default["default"];
  const fs2 = require$$0__default$2["default"];
  const path2 = require$$1__default$1["default"];
  const crypto = require$$0__default$4["default"];
  const assert2 = require$$5__default["default"];
  const events_12 = require$$0__default$3["default"];
  const dotProp$1 = dotProp;
  const pkgUp$1 = pkgUp.exports;
  const envPaths2 = envPaths$1.exports;
  const atomically = dist$1;
  const ajv_1 = ajv.exports;
  const ajv_formats_1 = dist.exports;
  const debounceFn$1 = debounceFn;
  const semver$12 = semver;
  const onetime2 = onetime$1.exports;
  const encryptionAlgorithm = "aes-256-cbc";
  const createPlainObject = () => {
    return Object.create(null);
  };
  const isExist = (data) => {
    return data !== void 0 && data !== null;
  };
  let parentDir = "";
  try {
    delete require.cache[__filename];
    parentDir = path2.dirname((_b = (_a = module.parent) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : ".");
  } catch (_c) {
  }
  const checkValueType = (key, value) => {
    const nonJsonTypes = new Set([
      "undefined",
      "symbol",
      "function"
    ]);
    const type2 = typeof value;
    if (nonJsonTypes.has(type2)) {
      throw new TypeError(`Setting a value of type \`${type2}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
    }
  };
  const INTERNAL_KEY = "__internal__";
  const MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`;
  class Conf2 {
    constructor(partialOptions = {}) {
      var _a2;
      _Conf_validator.set(this, void 0);
      _Conf_encryptionKey.set(this, void 0);
      _Conf_options.set(this, void 0);
      _Conf_defaultValues.set(this, {});
      this._deserialize = (value) => JSON.parse(value);
      this._serialize = (value) => JSON.stringify(value, void 0, "	");
      const options = __spreadValues({
        configName: "config",
        fileExtension: "json",
        projectSuffix: "nodejs",
        clearInvalidConfig: false,
        accessPropertiesByDotNotation: true
      }, partialOptions);
      const getPackageData = onetime2(() => {
        const packagePath = pkgUp$1.sync({ cwd: parentDir });
        const packageData = packagePath && JSON.parse(fs2.readFileSync(packagePath, "utf8"));
        return packageData !== null && packageData !== void 0 ? packageData : {};
      });
      if (!options.cwd) {
        if (!options.projectName) {
          options.projectName = getPackageData().name;
        }
        if (!options.projectName) {
          throw new Error("Project name could not be inferred. Please specify the `projectName` option.");
        }
        options.cwd = envPaths2(options.projectName, { suffix: options.projectSuffix }).config;
      }
      __classPrivateFieldSet(this, _Conf_options, options, "f");
      if (options.schema) {
        if (typeof options.schema !== "object") {
          throw new TypeError("The `schema` option must be an object.");
        }
        const ajv2 = new ajv_1.default({
          allErrors: true,
          useDefaults: true
        });
        ajv_formats_1.default(ajv2);
        const schema2 = {
          type: "object",
          properties: options.schema
        };
        __classPrivateFieldSet(this, _Conf_validator, ajv2.compile(schema2), "f");
        for (const [key, value] of Object.entries(options.schema)) {
          if (value === null || value === void 0 ? void 0 : value.default) {
            __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default;
          }
        }
      }
      if (options.defaults) {
        __classPrivateFieldSet(this, _Conf_defaultValues, __spreadValues(__spreadValues({}, __classPrivateFieldGet(this, _Conf_defaultValues, "f")), options.defaults), "f");
      }
      if (options.serialize) {
        this._serialize = options.serialize;
      }
      if (options.deserialize) {
        this._deserialize = options.deserialize;
      }
      this.events = new events_12.EventEmitter();
      __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
      const fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
      this.path = path2.resolve(options.cwd, `${(_a2 = options.configName) !== null && _a2 !== void 0 ? _a2 : "config"}${fileExtension}`);
      const fileStore = this.store;
      const store2 = Object.assign(createPlainObject(), options.defaults, fileStore);
      this._validate(store2);
      try {
        assert2.deepEqual(fileStore, store2);
      } catch (_b2) {
        this.store = store2;
      }
      if (options.watch) {
        this._watch();
      }
      if (options.migrations) {
        if (!options.projectVersion) {
          options.projectVersion = getPackageData().version;
        }
        if (!options.projectVersion) {
          throw new Error("Project version could not be inferred. Please specify the `projectVersion` option.");
        }
        this._migrate(options.migrations, options.projectVersion);
      }
    }
    get(key, defaultValue) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return this._get(key, defaultValue);
      }
      const { store: store2 } = this;
      return key in store2 ? store2[key] : defaultValue;
    }
    set(key, value) {
      if (typeof key !== "string" && typeof key !== "object") {
        throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
      }
      if (typeof key !== "object" && value === void 0) {
        throw new TypeError("Use `delete()` to clear values");
      }
      if (this._containsReservedKey(key)) {
        throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
      }
      const { store: store2 } = this;
      const set2 = (key2, value2) => {
        checkValueType(key2, value2);
        if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
          dotProp$1.set(store2, key2, value2);
        } else {
          store2[key2] = value2;
        }
      };
      if (typeof key === "object") {
        const object = key;
        for (const [key2, value2] of Object.entries(object)) {
          set2(key2, value2);
        }
      } else {
        set2(key, value);
      }
      this.store = store2;
    }
    has(key) {
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        return dotProp$1.has(this.store, key);
      }
      return key in this.store;
    }
    reset(...keys) {
      for (const key of keys) {
        if (isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key])) {
          this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
        }
      }
    }
    delete(key) {
      const { store: store2 } = this;
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        dotProp$1.delete(store2, key);
      } else {
        delete store2[key];
      }
      this.store = store2;
    }
    clear() {
      this.store = createPlainObject();
      for (const key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f"))) {
        this.reset(key);
      }
    }
    onDidChange(key, callback) {
      if (typeof key !== "string") {
        throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
      }
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.get(key), callback);
    }
    onDidAnyChange(callback) {
      if (typeof callback !== "function") {
        throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
      }
      return this._handleChange(() => this.store, callback);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8");
        const dataString = this._encryptData(data);
        const deserializedData = this._deserialize(dataString);
        this._validate(deserializedData);
        return Object.assign(createPlainObject(), deserializedData);
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this._ensureDirectory();
          return createPlainObject();
        }
        if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error2.name === "SyntaxError") {
          return createPlainObject();
        }
        throw error2;
      }
    }
    set store(value) {
      this._ensureDirectory();
      this._validate(value);
      this._write(value);
      this.events.emit("change");
    }
    *[(_Conf_validator = new WeakMap(), _Conf_encryptionKey = new WeakMap(), _Conf_options = new WeakMap(), _Conf_defaultValues = new WeakMap(), Symbol.iterator)]() {
      for (const [key, value] of Object.entries(this.store)) {
        yield [key, value];
      }
    }
    _encryptData(data) {
      if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        return data.toString();
      }
      try {
        if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
          try {
            if (data.slice(16, 17).toString() === ":") {
              const initializationVector = data.slice(0, 16);
              const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
              const decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
              data = Buffer.concat([decipher.update(Buffer.from(data.slice(17))), decipher.final()]).toString("utf8");
            } else {
              const decipher = crypto.createDecipher(encryptionAlgorithm, __classPrivateFieldGet(this, _Conf_encryptionKey, "f"));
              data = Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]).toString("utf8");
            }
          } catch (_a2) {
          }
        }
      } catch (_b2) {
      }
      return data.toString();
    }
    _handleChange(getter, callback) {
      let currentValue = getter();
      const onChange = () => {
        const oldValue = currentValue;
        const newValue = getter();
        if (util_12.isDeepStrictEqual(newValue, oldValue)) {
          return;
        }
        currentValue = newValue;
        callback.call(this, newValue, oldValue);
      };
      this.events.on("change", onChange);
      return () => this.events.removeListener("change", onChange);
    }
    _validate(data) {
      if (!__classPrivateFieldGet(this, _Conf_validator, "f")) {
        return;
      }
      const valid2 = __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data);
      if (valid2 || !__classPrivateFieldGet(this, _Conf_validator, "f").errors) {
        return;
      }
      const errors2 = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
      throw new Error("Config schema violation: " + errors2.join("; "));
    }
    _ensureDirectory() {
      fs2.mkdirSync(path2.dirname(this.path), { recursive: true });
    }
    _write(value) {
      let data = this._serialize(value);
      if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
        const initializationVector = crypto.randomBytes(16);
        const password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512");
        const cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
        data = Buffer.concat([initializationVector, Buffer.from(":"), cipher.update(Buffer.from(data)), cipher.final()]);
      }
      {
        try {
          atomically.writeFileSync(this.path, data);
        } catch (error2) {
          if (error2.code === "EXDEV") {
            fs2.writeFileSync(this.path, data);
            return;
          }
          throw error2;
        }
      }
    }
    _watch() {
      this._ensureDirectory();
      if (!fs2.existsSync(this.path)) {
        this._write(createPlainObject());
      }
      if (process.platform === "win32") {
        fs2.watch(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 100 }));
      } else {
        fs2.watchFile(this.path, { persistent: false }, debounceFn$1(() => {
          this.events.emit("change");
        }, { wait: 5e3 }));
      }
    }
    _migrate(migrations, versionToMigrate) {
      let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0");
      const newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate));
      let storeBackup = __spreadValues({}, this.store);
      for (const version of newerVersions) {
        try {
          const migration = migrations[version];
          migration(this);
          this._set(MIGRATION_KEY, version);
          previousMigratedVersion = version;
          storeBackup = __spreadValues({}, this.store);
        } catch (error2) {
          this.store = storeBackup;
          throw new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error2}`);
        }
      }
      if (this._isVersionInRangeFormat(previousMigratedVersion) || !semver$12.eq(previousMigratedVersion, versionToMigrate)) {
        this._set(MIGRATION_KEY, versionToMigrate);
      }
    }
    _containsReservedKey(key) {
      if (typeof key === "object") {
        const firsKey = Object.keys(key)[0];
        if (firsKey === INTERNAL_KEY) {
          return true;
        }
      }
      if (typeof key !== "string") {
        return false;
      }
      if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation) {
        if (key.startsWith(`${INTERNAL_KEY}.`)) {
          return true;
        }
        return false;
      }
      return false;
    }
    _isVersionInRangeFormat(version) {
      return semver$12.clean(version) === null;
    }
    _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
      if (this._isVersionInRangeFormat(candidateVersion)) {
        if (previousMigratedVersion !== "0.0.0" && semver$12.satisfies(previousMigratedVersion, candidateVersion)) {
          return false;
        }
        return semver$12.satisfies(versionToMigrate, candidateVersion);
      }
      if (semver$12.lte(candidateVersion, previousMigratedVersion)) {
        return false;
      }
      if (semver$12.gt(candidateVersion, versionToMigrate)) {
        return false;
      }
      return true;
    }
    _get(key, defaultValue) {
      return dotProp$1.get(this.store, key, defaultValue);
    }
    _set(key, value) {
      const { store: store2 } = this;
      dotProp$1.set(store2, key, value);
      this.store = store2;
    }
  }
  exports.default = Conf2;
  module.exports = Conf2;
  module.exports.default = Conf2;
})(source, source.exports);
const path = require$$1__default$1["default"];
const { app, ipcMain, ipcRenderer, shell } = require$$1__default["default"];
const Conf = source.exports;
let isInitialized = false;
const initDataListener = () => {
  if (!ipcMain || !app) {
    throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
  }
  const appData = {
    defaultCwd: app.getPath("userData"),
    appVersion: app.getVersion()
  };
  if (isInitialized) {
    return appData;
  }
  ipcMain.on("electron-store-get-data", (event) => {
    event.returnValue = appData;
  });
  isInitialized = true;
  return appData;
};
class ElectronStore extends Conf {
  constructor(options) {
    let defaultCwd;
    let appVersion;
    if (ipcRenderer) {
      const appData = ipcRenderer.sendSync("electron-store-get-data");
      if (!appData) {
        throw new Error("Electron Store: You need to call `.initRenderer()` from the main process.");
      }
      ({ defaultCwd, appVersion } = appData);
    } else if (ipcMain && app) {
      ({ defaultCwd, appVersion } = initDataListener());
    }
    options = __spreadValues({
      name: "config"
    }, options);
    if (!options.projectVersion) {
      options.projectVersion = appVersion;
    }
    if (options.cwd) {
      options.cwd = path.isAbsolute(options.cwd) ? options.cwd : path.join(defaultCwd, options.cwd);
    } else {
      options.cwd = defaultCwd;
    }
    options.configName = options.name;
    delete options.name;
    super(options);
  }
  static initRenderer() {
    initDataListener();
  }
  openInEditor() {
    shell.openPath(this.path);
  }
}
var electronStore = ElectronStore;
const schema$1 = {
  notes: {
    type: "object",
    patternProperties: {
      "[A-Za-z0-9_-]": {
        type: "object",
        properties: {
          id: { type: "string", default: "" },
          title: { type: "string", default: "" },
          content: { type: "object", default: { type: "doc", content: [] } },
          labels: { type: "array", default: [] },
          createdAt: { type: "number", default: Date.now() },
          updatedAt: { type: "number", default: Date.now() },
          isBookmarked: { type: "boolean", default: false },
          isArchived: { type: "boolean", default: false },
          lastCursorPosition: { type: "number", default: 0 }
        }
      }
    }
  },
  labels: {
    type: "array"
  }
};
const store$1 = new electronStore({
  schema: schema$1,
  encryptionKey: {}.VITE_ENCRYPT_KEY
});
const schema = {
  dataDir: {
    type: "string",
    default: require$$1.app.getPath("userData")
  }
};
var settings = new electronStore({ name: "settings", schema, encryptionKey: {}.VITE_ENCRYPT_KEY });
var store = {
  data: store$1,
  settings
};
const isSingleInstance = require$$1.app.requestSingleInstanceLock();
if (!isSingleInstance) {
  require$$1.app.quit();
  process.exit(0);
}
require$$1.app.disableHardwareAcceleration();
const env = { "VITE_DEV_SERVER_URL": "http://localhost:3000/", "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false };
{
  require$$1.app.whenReady().then(() => Promise.resolve().then(function() {
    return /* @__PURE__ */ _interopNamespace(require("electron-devtools-installer"));
  })).then(({ default: installExtension, VUEJS3_DEVTOOLS }) => installExtension(VUEJS3_DEVTOOLS, {
    loadExtensionOptions: {
      allowFileAccess: true
    }
  })).catch((e) => console.error("Failed install extension:", e));
}
let mainWindow = null;
const createWindow = async () => {
  mainWindow = new require$$1.BrowserWindow({
    show: false,
    width: 950,
    height: 600,
    webPreferences: {
      preload: require$$1$1.join(__dirname, "../../preload/dist/index.cjs"),
      contextIsolation: env.MODE !== "test",
      enableRemoteModule: env.MODE === "test"
    }
  });
  mainWindow.setMenuBarVisibility(false);
  mainWindow.on("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    {
      mainWindow == null ? void 0 : mainWindow.webContents.openDevTools();
    }
  });
  mainWindow == null ? void 0 : mainWindow.webContents.on("new-window", function(event, url) {
    event.preventDefault();
    if (url.startsWith("note://"))
      return;
    require$$1.shell.openExternal(url);
  });
  const pageUrl = env.VITE_DEV_SERVER_URL;
  await mainWindow.loadURL(pageUrl);
};
require$$1.app.on("second-instance", () => {
  if (mainWindow) {
    if (mainWindow.isMinimized())
      mainWindow.restore();
    mainWindow.focus();
  }
});
require$$1.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    require$$1.app.quit();
  }
});
require$$1.app.whenReady().then(async () => {
  require$$1.protocol.registerFileProtocol("assets", (request, callback) => {
    const url = request.url.substr(9);
    const dir = store.settings.get("dataDir");
    const imgPath = `${dir}/notes-assets/${url}`;
    callback({ path: require$$1$1.normalize(imgPath) });
  });
  await lib.ensureDir(require$$1$1.join(require$$1.app.getPath("userData"), "notes-assets"));
  await createWindow();
}).catch((e) => console.error("Failed create window:", e));
ipcMain$1.answerRenderer("app:info", () => ({
  name: require$$1.app.getName(),
  version: require$$1.app.getVersion()
}));
ipcMain$1.answerRenderer("dialog:open", (props) => require$$1.dialog.showOpenDialog(props));
ipcMain$1.answerRenderer("dialog:message", (props) => require$$1.dialog.showMessageBox(props));
ipcMain$1.answerRenderer("dialog:save", (props) => require$$1.dialog.showSaveDialog(props));
ipcMain$1.answerRenderer("fs:copy", ({ path: path2, dest }) => lib.copy(path2, dest));
ipcMain$1.answerRenderer("fs:output-json", ({ path: path2, data }) => lib.outputJson(path2, data));
ipcMain$1.answerRenderer("fs:read-json", (path2) => lib.readJson(path2));
ipcMain$1.answerRenderer("fs:ensureDir", (path2) => lib.ensureDir(path2));
ipcMain$1.answerRenderer("fs:pathExists", (path2) => lib.pathExistsSync(path2));
ipcMain$1.answerRenderer("fs:remove", (path2) => lib.remove(path2));
ipcMain$1.answerRenderer("helper:relaunch", (options = {}) => {
  require$$1.app.relaunch(__spreadValues({ args: process.argv.slice(1).concat(["--relaunch"]) }, options));
  require$$1.app.exit(0);
});
ipcMain$1.answerRenderer("helper:get-path", (name) => require$$1.app.getPath(name));
ipcMain$1.answerRenderer("helper:is-dark-theme", () => require$$1.nativeTheme.shouldUseDarkColors);
ipcMain$1.answerRenderer("storage:store", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.store;
});
ipcMain$1.answerRenderer("storage:replace", ({ name, data }) => store[name].store = data);
ipcMain$1.answerRenderer("storage:get", ({ name, key, def: def2 }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.get(key, def2);
});
ipcMain$1.answerRenderer("storage:set", ({ name, key, value }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.set(key, value);
});
ipcMain$1.answerRenderer("storage:delete", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.delete(key);
});
ipcMain$1.answerRenderer("storage:has", ({ name, key }) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.has(key);
});
ipcMain$1.answerRenderer("storage:clear", (name) => {
  var _a;
  return (_a = store[name]) == null ? void 0 : _a.clear();
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2VyaWFsaXplLWVycm9yL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLWJldHRlci1pcGMvc291cmNlL3V0aWwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvcmVuZGVyZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tYmV0dGVyLWlwYy9zb3VyY2UvbWFpbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi1iZXR0ZXItaXBjL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VuaXZlcnNhbGlmeS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9ncmFjZWZ1bC1mcy9wb2x5ZmlsbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvbGVnYWN5LXN0cmVhbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvY2xvbmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2ZzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9ta2RpcnMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21rZGlycy9tYWtlLWRpci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbWtkaXJzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi91dGlsL3V0aW1lcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvdXRpbC9zdGF0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvY29weS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5LXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9jb3B5L2NvcHkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2NvcHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9yaW1yYWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL3JlbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW1wdHkvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9maWxlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvbGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvZW5zdXJlL3N5bWxpbmstcGF0aHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLXR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2Vuc3VyZS9zeW1saW5rLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9lbnN1cmUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanNvbmZpbGUvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL2pzb24vanNvbmZpbGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL291dHB1dC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvanNvbi9vdXRwdXQtanNvbi1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9qc29uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvbW92ZS1zeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZzLWV4dHJhL2xpYi9tb3ZlLXN5bmMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnMtZXh0cmEvbGliL21vdmUvbW92ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvbW92ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mcy1leHRyYS9saWIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L0NhbmNlbGxhdGlvblRva2VuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L2h0dHBFeGVjdXRvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvcHVibGlzaE9wdGlvbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3JmYzIyNTNQYXJzZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3V1aWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc2F4L2xpYi9zYXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvYnVpbGRlci11dGlsLXJ1bnRpbWUvb3V0L3htbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9idWlsZGVyLXV0aWwtcnVudGltZS9vdXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvY29tbW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL2V4Y2VwdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zbmlwcGV0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc3RyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvc2VxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvbWFwLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3NjaGVtYS9mYWlsc2FmZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL251bGwuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9ib29sLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvaW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvbGliL3R5cGUvZmxvYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2pzb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvc2NoZW1hL2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS90aW1lc3RhbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9tZXJnZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL2JpbmFyeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL29tYXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvdHlwZS9wYWlycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi90eXBlL3NldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9zY2hlbWEvZGVmYXVsdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy15YW1sL2xpYi9sb2FkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvanMteWFtbC9saWIvZHVtcGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXlhbWwvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGF6eS12YWwvb3V0L21haW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3lhbGxpc3QvaXRlcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9yYW5nZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9jb21wYXJhdG9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvdG8tY29tcGFyYXRvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9tYXgtc2F0aXNmeWluZy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21pbi1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXZlcnNpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy92YWxpZC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL291dHNpZGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9ndHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9sdHIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9pbnRlcnNlY3RzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvc2ltcGxpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zdWJzZXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9ub2RlX21vZHVsZXMvc2VtdmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Rvd25sb2FkZWRVcGRhdGVIZWxwZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwQWRhcHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9FbGVjdHJvbkFwcEFkYXB0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZWxlY3Ryb25IdHRwRXhlY3V0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLmVzY2FwZXJlZ2V4cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9Qcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlcnMvR2VuZXJpY1Byb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvbm9kZV9tb2R1bGVzL2J1aWxkZXItdXRpbC1ydW50aW1lL291dC9iaW50cmF5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9CaW50cmF5UHJvdmlkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvcHJvdmlkZXJzL0dpdEh1YlByb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVycy9LZXlnZW5Qcm92aWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9wcm92aWRlcnMvUHJpdmF0ZUdpdEh1YlByb3ZpZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L3Byb3ZpZGVyRmFjdG9yeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9BcHBVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L0Jhc2VVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvZG93bmxvYWRQbGFuQnVpbGRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0RhdGFTcGxpdHRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL211bHRpcGxlUmFuZ2VEb3dubG9hZGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L2RpZmZlcmVudGlhbERvd25sb2FkZXIvRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvQXBwSW1hZ2VVcGRhdGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXVwZGF0ZXIvb3V0L01hY1VwZGF0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZWxlY3Ryb24tdXBkYXRlci9vdXQvZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC93aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9Oc2lzVXBkYXRlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9lbGVjdHJvbi11cGRhdGVyL291dC9tYWluLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2lzLW9iai9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kb3QtcHJvcC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtdHJ5L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtbGltaXQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcGtnLXVwL25vZGVfbW9kdWxlcy9wLWxvY2F0ZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvbm9kZV9tb2R1bGVzL2xvY2F0ZS1wYXRoL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3BrZy11cC9ub2RlX21vZHVsZXMvZmluZC11cC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wa2ctdXAvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZW52LXBhdGhzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC9jb25zdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2F0dGVtcHRpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzX2hhbmRsZXJzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9yZXRyeWlmeV9xdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hdG9taWNhbGx5L2Rpc3QvdXRpbHMvcmV0cnlpZnkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL2ZzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9sYW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2F0b21pY2FsbHkvZGlzdC91dGlscy9zY2hlZHVsZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L3V0aWxzL3RlbXAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXRvbWljYWxseS9kaXN0L2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9jb2RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvY29kZWdlbi9zY29wZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2NvZGVnZW4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS91dGlsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvbmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS9lcnJvcnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcnVsZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9hcHBsaWNhYmlsaXR5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9kZWZhdWx0cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvY29kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2pzb24tc2NoZW1hLXRyYXZlcnNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3VyaS1qcy9kaXN0L2VzNS91cmkuYWxsLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvbXBpbGUvcmVzb2x2ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3ZhbGlkYXRlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL3JlZl9lcnJvci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9jb21waWxlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L2NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2NvcmUvcmVmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TnVtYmVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL211bHRpcGxlT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0TGVuZ3RoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3BhdHRlcm4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL3JlcXVpcmVkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2xpbWl0SXRlbXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3QvcnVudGltZS9lcXVhbC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi91bmlxdWVJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9jb25zdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FkZGl0aW9uYWxJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wcmVmaXhJdGVtcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtczIwMjAuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvZGVwZW5kZW5jaWVzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnR5TmFtZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9wYXR0ZXJuUHJvcGVydGllcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYW55T2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3Ivb25lT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaWYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvdGhlbkVsc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9mb3JtYXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2Zvcm1hdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvbWV0YWRhdGEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2L2Rpc3Qvdm9jYWJ1bGFyaWVzL2RyYWZ0Ny5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci90eXBlcy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9hanYvZGlzdC9hanYuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kZWJvdW5jZS1mbi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZGVib3VuY2UtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvZGVidWcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9pZGVudGlmaWVycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvY2xhc3Nlcy9zZW12ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9wYXJzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY2xlYW4uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9pbmMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9jb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZXEuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9kaWZmLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbWFqb3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9taW5vci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3BhdGNoLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcHJlcmVsZWFzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL3Jjb21wYXJlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS1sb29zZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zb3J0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvcnNvcnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9ndC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbmVxLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvZ3RlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvbHRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY21wLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29lcmNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3JhbmdlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL2NvbXBhcmF0b3IuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy90by1jb21wYXJhdG9ycy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL21heC1zYXRpc2Z5aW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvbWluLXNhdGlzZnlpbmcuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9taW4tdmVyc2lvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3ZhbGlkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NvbmYvbm9kZV9tb2R1bGVzL3NlbXZlci9yYW5nZXMvb3V0c2lkZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2d0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2x0ci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL2ludGVyc2VjdHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY29uZi9ub2RlX21vZHVsZXMvc2VtdmVyL3Jhbmdlcy9zaW1wbGlmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvcmFuZ2VzL3N1YnNldC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL25vZGVfbW9kdWxlcy9zZW12ZXIvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvb25ldGltZS9pbmRleC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jb25mL2Rpc3Qvc291cmNlL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2VsZWN0cm9uLXN0b3JlL2luZGV4LmpzIiwiLi4vc3JjL3N0b3JlL21vZHVsZXMvZGF0YS5zdG9yZS5qcyIsIi4uL3NyYy9zdG9yZS9tb2R1bGVzL3NldHRpbmdzLnN0b3JlLmpzIiwiLi4vc3JjL3N0b3JlL2luZGV4LmpzIiwiLi4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgTm9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcihOb25FcnJvci5fcHJlcGFyZVN1cGVyTWVzc2FnZShtZXNzYWdlKSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICdOb25FcnJvcicsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdH0pO1xuXG5cdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb25FcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0c3RhdGljIF9wcmVwYXJlU3VwZXJNZXNzYWdlKG1lc3NhZ2UpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpO1xuXHRcdH0gY2F0Y2gge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhtZXNzYWdlKTtcblx0XHR9XG5cdH1cbn1cblxuY29uc3QgY29tbW9uUHJvcGVydGllcyA9IFtcblx0e3Byb3BlcnR5OiAnbmFtZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnbWVzc2FnZScsIGVudW1lcmFibGU6IGZhbHNlfSxcblx0e3Byb3BlcnR5OiAnc3RhY2snLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG5cdHtwcm9wZXJ0eTogJ2NvZGUnLCBlbnVtZXJhYmxlOiB0cnVlfVxuXTtcblxuY29uc3QgaXNDYWxsZWQgPSBTeW1ib2woJy50b0pTT04gY2FsbGVkJyk7XG5cbmNvbnN0IHRvSlNPTiA9IGZyb20gPT4ge1xuXHRmcm9tW2lzQ2FsbGVkXSA9IHRydWU7XG5cdGNvbnN0IGpzb24gPSBmcm9tLnRvSlNPTigpO1xuXHRkZWxldGUgZnJvbVtpc0NhbGxlZF07XG5cdHJldHVybiBqc29uO1xufTtcblxuY29uc3QgZGVzdHJveUNpcmN1bGFyID0gKHtcblx0ZnJvbSxcblx0c2Vlbixcblx0dG9fLFxuXHRmb3JjZUVudW1lcmFibGUsXG5cdG1heERlcHRoLFxuXHRkZXB0aFxufSkgPT4ge1xuXHRjb25zdCB0byA9IHRvXyB8fCAoQXJyYXkuaXNBcnJheShmcm9tKSA/IFtdIDoge30pO1xuXG5cdHNlZW4ucHVzaChmcm9tKTtcblxuXHRpZiAoZGVwdGggPj0gbWF4RGVwdGgpIHtcblx0XHRyZXR1cm4gdG87XG5cdH1cblxuXHRpZiAodHlwZW9mIGZyb20udG9KU09OID09PSAnZnVuY3Rpb24nICYmIGZyb21baXNDYWxsZWRdICE9PSB0cnVlKSB7XG5cdFx0cmV0dXJuIHRvSlNPTihmcm9tKTtcblx0fVxuXG5cdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZyb20pKSB7XG5cdFx0aWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuXHRcdFx0dG9ba2V5XSA9ICdbb2JqZWN0IEJ1ZmZlcl0nO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0b1trZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXNlZW4uaW5jbHVkZXMoZnJvbVtrZXldKSkge1xuXHRcdFx0ZGVwdGgrKztcblxuXHRcdFx0dG9ba2V5XSA9IGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRcdGZyb206IGZyb21ba2V5XSxcblx0XHRcdFx0c2Vlbjogc2Vlbi5zbGljZSgpLFxuXHRcdFx0XHRmb3JjZUVudW1lcmFibGUsXG5cdFx0XHRcdG1heERlcHRoLFxuXHRcdFx0XHRkZXB0aFxuXHRcdFx0fSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHR0b1trZXldID0gJ1tDaXJjdWxhcl0nO1xuXHR9XG5cblx0Zm9yIChjb25zdCB7cHJvcGVydHksIGVudW1lcmFibGV9IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcblx0XHRpZiAodHlwZW9mIGZyb21bcHJvcGVydHldID09PSAnc3RyaW5nJykge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwge1xuXHRcdFx0XHR2YWx1ZTogZnJvbVtwcm9wZXJ0eV0sXG5cdFx0XHRcdGVudW1lcmFibGU6IGZvcmNlRW51bWVyYWJsZSA/IHRydWUgOiBlbnVtZXJhYmxlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5jb25zdCBzZXJpYWxpemVFcnJvciA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGNvbnN0IHttYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWX0gPSBvcHRpb25zO1xuXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0cmV0dXJuIGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0Zm9yY2VFbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0bWF4RGVwdGgsXG5cdFx0XHRkZXB0aDogMFxuXHRcdH0pO1xuXHR9XG5cblx0Ly8gUGVvcGxlIHNvbWV0aW1lcyB0aHJvdyB0aGluZ3MgYmVzaWRlcyBFcnJvciBvYmplY3Rz4oCmXG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBgSlNPTi5zdHJpbmdpZnkoKWAgZGlzY2FyZHMgZnVuY3Rpb25zLiBXZSBkbyB0b28sIHVubGVzcyBhIGZ1bmN0aW9uIGlzIHRocm93biBkaXJlY3RseS5cblx0XHRyZXR1cm4gYFtGdW5jdGlvbjogJHsodmFsdWUubmFtZSB8fCAnYW5vbnltb3VzJyl9XWA7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkZXNlcmlhbGl6ZUVycm9yID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcblx0Y29uc3Qge21heERlcHRoID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSA9IG9wdGlvbnM7XG5cblx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRjb25zdCBuZXdFcnJvciA9IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHVuaWNvcm4vZXJyb3ItbWVzc2FnZVxuXHRcdGRlc3Ryb3lDaXJjdWxhcih7XG5cdFx0XHRmcm9tOiB2YWx1ZSxcblx0XHRcdHNlZW46IFtdLFxuXHRcdFx0dG9fOiBuZXdFcnJvcixcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0ZGVwdGg6IDBcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3RXJyb3I7XG5cdH1cblxuXHRyZXR1cm4gbmV3IE5vbkVycm9yKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzZXJpYWxpemVFcnJvcixcblx0ZGVzZXJpYWxpemVFcnJvclxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0VW5pcXVlSWQgPSAoKSA9PiBgJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YDtcblxuY29uc3QgZ2V0U2VuZENoYW5uZWwgPSBjaGFubmVsID0+IGAlYmV0dGVyLWlwYy1zZW5kLWNoYW5uZWwtJHtjaGFubmVsfWA7XG5jb25zdCBnZXRSZW5kZXJlclNlbmRDaGFubmVsID0gY2hhbm5lbCA9PiBgJWJldHRlci1pcGMtc2VuZC1jaGFubmVsLSR7Y2hhbm5lbH1gO1xuXG5tb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93Q2hhbm5lbCA9ICclYmV0dGVyLWlwYy1jdXJyZW50LXdpbmRvdyc7XG5cbm1vZHVsZS5leHBvcnRzLmdldFNlbmRDaGFubmVsID0gZ2V0U2VuZENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5nZXRSZW5kZXJlclNlbmRDaGFubmVsID0gZ2V0UmVuZGVyZXJTZW5kQ2hhbm5lbDtcblxubW9kdWxlLmV4cG9ydHMuZ2V0UmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFNlbmRDaGFubmVsKGNoYW5uZWwpLFxuXHRcdGRhdGFDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZGF0YS1jaGFubmVsLSR7Y2hhbm5lbH0tJHtpZH1gLFxuXHRcdGVycm9yQ2hhbm5lbDogYCViZXR0ZXItaXBjLXJlc3BvbnNlLWVycm9yLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWBcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmdldFJlbmRlcmVyUmVzcG9uc2VDaGFubmVscyA9IGNoYW5uZWwgPT4ge1xuXHRjb25zdCBpZCA9IGdldFVuaXF1ZUlkKCk7XG5cdHJldHVybiB7XG5cdFx0c2VuZENoYW5uZWw6IGdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCksXG5cdFx0ZGF0YUNoYW5uZWw6IGAlYmV0dGVyLWlwYy1yZXNwb25zZS1kYXRhLWNoYW5uZWwtJHtjaGFubmVsfS0ke2lkfWAsXG5cdFx0ZXJyb3JDaGFubmVsOiBgJWJldHRlci1pcGMtcmVzcG9uc2UtZXJyb3ItY2hhbm5lbC0ke2NoYW5uZWx9LSR7aWR9YFxuXHR9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGVsZWN0cm9uID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IHtzZXJpYWxpemVFcnJvciwgZGVzZXJpYWxpemVFcnJvcn0gPSByZXF1aXJlKCdzZXJpYWxpemUtZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwuanMnKTtcblxuY29uc3Qge2lwY1JlbmRlcmVyfSA9IGVsZWN0cm9uO1xuY29uc3QgaXBjID0gT2JqZWN0LmNyZWF0ZShpcGNSZW5kZXJlciB8fCB7fSk7XG5cbmlwYy5jYWxsTWFpbiA9IChjaGFubmVsLCBkYXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdGNvbnN0IHtzZW5kQ2hhbm5lbCwgZGF0YUNoYW5uZWwsIGVycm9yQ2hhbm5lbH0gPSB1dGlsLmdldFJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoZGF0YUNoYW5uZWwsIG9uRGF0YSk7XG5cdFx0aXBjUmVuZGVyZXIub2ZmKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cdH07XG5cblx0Y29uc3Qgb25EYXRhID0gKF9ldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y2xlYW51cCgpO1xuXHRcdHJlc29sdmUocmVzdWx0KTtcblx0fTtcblxuXHRjb25zdCBvbkVycm9yID0gKF9ldmVudCwgZXJyb3IpID0+IHtcblx0XHRjbGVhbnVwKCk7XG5cdFx0cmVqZWN0KGRlc2VyaWFsaXplRXJyb3IoZXJyb3IpKTtcblx0fTtcblxuXHRpcGNSZW5kZXJlci5vbmNlKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNSZW5kZXJlci5vbmNlKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLnNlbmQoc2VuZENoYW5uZWwsIGNvbXBsZXRlRGF0YSk7XG59KTtcblxuaXBjLmFuc3dlck1haW4gPSAoY2hhbm5lbCwgY2FsbGJhY2spID0+IHtcblx0Y29uc3Qgc2VuZENoYW5uZWwgPSB1dGlsLmdldFJlbmRlcmVyU2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoX2V2ZW50LCBkYXRhKSA9PiB7XG5cdFx0Y29uc3Qge2RhdGFDaGFubmVsLCBlcnJvckNoYW5uZWwsIHVzZXJEYXRhfSA9IGRhdGE7XG5cblx0XHR0cnkge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChkYXRhQ2hhbm5lbCwgYXdhaXQgY2FsbGJhY2sodXNlckRhdGEpKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aXBjUmVuZGVyZXIuc2VuZChlcnJvckNoYW5uZWwsIHNlcmlhbGl6ZUVycm9yKGVycm9yKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGlwY1JlbmRlcmVyLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNSZW5kZXJlci5vZmYoc2VuZENoYW5uZWwsIGxpc3RlbmVyKTtcblx0fTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXBjO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZWxlY3Ryb24gPSByZXF1aXJlKCdlbGVjdHJvbicpO1xuY29uc3Qge3NlcmlhbGl6ZUVycm9yLCBkZXNlcmlhbGl6ZUVycm9yfSA9IHJlcXVpcmUoJ3NlcmlhbGl6ZS1lcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG5jb25zdCB7aXBjTWFpbiwgQnJvd3NlcldpbmRvd30gPSBlbGVjdHJvbjtcbmNvbnN0IGlwYyA9IE9iamVjdC5jcmVhdGUoaXBjTWFpbiB8fCB7fSk7XG5cbmlwYy5jYWxsUmVuZGVyZXIgPSAoYnJvd3NlcldpbmRvdywgY2hhbm5lbCwgZGF0YSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAoIWJyb3dzZXJXaW5kb3cpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgd2luZG93IHJlcXVpcmVkJyk7XG5cdH1cblxuXHRjb25zdCB7c2VuZENoYW5uZWwsIGRhdGFDaGFubmVsLCBlcnJvckNoYW5uZWx9ID0gdXRpbC5nZXRSZW5kZXJlclJlc3BvbnNlQ2hhbm5lbHMoY2hhbm5lbCk7XG5cblx0Y29uc3QgY2xlYW51cCA9ICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihkYXRhQ2hhbm5lbCwgb25EYXRhKTtcblx0XHRpcGNNYWluLm9mZihlcnJvckNoYW5uZWwsIG9uRXJyb3IpO1xuXHR9O1xuXG5cdGNvbnN0IG9uRGF0YSA9IChldmVudCwgcmVzdWx0KSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IG9uRXJyb3IgPSAoZXZlbnQsIGVycm9yKSA9PiB7XG5cdFx0Y29uc3Qgd2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblx0XHRpZiAod2luZG93LmlkID09PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRyZWplY3QoZGVzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKGRhdGFDaGFubmVsLCBvbkRhdGEpO1xuXHRpcGNNYWluLm9uKGVycm9yQ2hhbm5lbCwgb25FcnJvcik7XG5cblx0Y29uc3QgY29tcGxldGVEYXRhID0ge1xuXHRcdGRhdGFDaGFubmVsLFxuXHRcdGVycm9yQ2hhbm5lbCxcblx0XHR1c2VyRGF0YTogZGF0YVxuXHR9O1xuXG5cdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0YnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKHNlbmRDaGFubmVsLCBjb21wbGV0ZURhdGEpO1xuXHR9XG59KTtcblxuaXBjLmNhbGxGb2N1c2VkUmVuZGVyZXIgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRjb25zdCBmb2N1c2VkV2luZG93ID0gQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCk7XG5cdGlmICghZm9jdXNlZFdpbmRvdykge1xuXHRcdHRocm93IG5ldyBFcnJvcignTm8gYnJvd3NlciB3aW5kb3cgaW4gZm9jdXMnKTtcblx0fVxuXG5cdHJldHVybiBpcGMuY2FsbFJlbmRlcmVyKGZvY3VzZWRXaW5kb3csIC4uLmFyZ3MpO1xufTtcblxuaXBjLmFuc3dlclJlbmRlcmVyID0gKGJyb3dzZXJXaW5kb3dPckNoYW5uZWwsIGNoYW5uZWxPckNhbGxiYWNrLCBjYWxsYmFja09yTm90aGluZykgPT4ge1xuXHRsZXQgd2luZG93O1xuXHRsZXQgY2hhbm5lbDtcblx0bGV0IGNhbGxiYWNrO1xuXG5cdGlmIChjYWxsYmFja09yTm90aGluZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y2hhbm5lbCA9IGJyb3dzZXJXaW5kb3dPckNoYW5uZWw7XG5cdFx0Y2FsbGJhY2sgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cgPSBicm93c2VyV2luZG93T3JDaGFubmVsO1xuXHRcdGNoYW5uZWwgPSBjaGFubmVsT3JDYWxsYmFjaztcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrT3JOb3RoaW5nO1xuXG5cdFx0aWYgKCF3aW5kb3cpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQnJvd3NlciB3aW5kb3cgcmVxdWlyZWQnKTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBzZW5kQ2hhbm5lbCA9IHV0aWwuZ2V0U2VuZENoYW5uZWwoY2hhbm5lbCk7XG5cblx0Y29uc3QgbGlzdGVuZXIgPSBhc3luYyAoZXZlbnQsIGRhdGEpID0+IHtcblx0XHRjb25zdCBicm93c2VyV2luZG93ID0gQnJvd3NlcldpbmRvdy5mcm9tV2ViQ29udGVudHMoZXZlbnQuc2VuZGVyKTtcblxuXHRcdGlmICh3aW5kb3cgJiYgd2luZG93LmlkICE9PSBicm93c2VyV2luZG93LmlkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2VuZCA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdFx0XHRpZiAoIShicm93c2VyV2luZG93ICYmIGJyb3dzZXJXaW5kb3cuaXNEZXN0cm95ZWQoKSkpIHtcblx0XHRcdFx0ZXZlbnQuc2VuZGVyLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGNvbnN0IHtkYXRhQ2hhbm5lbCwgZXJyb3JDaGFubmVsLCB1c2VyRGF0YX0gPSBkYXRhO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHNlbmQoZGF0YUNoYW5uZWwsIGF3YWl0IGNhbGxiYWNrKHVzZXJEYXRhLCBicm93c2VyV2luZG93KSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHNlbmQoZXJyb3JDaGFubmVsLCBzZXJpYWxpemVFcnJvcihlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRpcGNNYWluLm9uKHNlbmRDaGFubmVsLCBsaXN0ZW5lcik7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpcGNNYWluLm9mZihzZW5kQ2hhbm5lbCwgbGlzdGVuZXIpO1xuXHR9O1xufTtcblxuaXBjLnNlbmRUb1JlbmRlcmVycyA9IChjaGFubmVsLCBkYXRhKSA9PiB7XG5cdGZvciAoY29uc3QgYnJvd3NlcldpbmRvdyBvZiBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKSkge1xuXHRcdGlmIChicm93c2VyV2luZG93LndlYkNvbnRlbnRzKSB7XG5cdFx0XHRicm93c2VyV2luZG93LndlYkNvbnRlbnRzLnNlbmQoY2hhbm5lbCwgZGF0YSk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlwYztcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNSZW5kZXJlciA9IHJlcXVpcmUoJy4vc291cmNlL3JlbmRlcmVyLmpzJyk7XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cy5pcGNNYWluID0gcmVxdWlyZSgnLi9zb3VyY2UvbWFpbi5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuZnJvbUNhbGxiYWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykgZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZuLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgIChlcnIsIHJlcykgPT4gKGVyciAhPSBudWxsKSA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXMpXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cblxuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgY29uc3QgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV1cbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICBlbHNlIGZuLmFwcGx5KHRoaXMsIGFyZ3Muc2xpY2UoMCwgLTEpKS50aGVuKHIgPT4gY2IobnVsbCwgciksIGNiKVxuICB9LCAnbmFtZScsIHsgdmFsdWU6IGZuLm5hbWUgfSlcbn1cbiIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxuLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdW50aWwgbm9kZS5qcyAxMiBpcyByZXF1aXJlZFxuaWYgKHR5cGVvZiBwcm9jZXNzLmNoZGlyID09PSAnZnVuY3Rpb24nKSB7XG4gIHZhciBjaGRpciA9IHByb2Nlc3MuY2hkaXJcbiAgcHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgY3dkID0gbnVsbFxuICAgIGNoZGlyLmNhbGwocHJvY2VzcywgZClcbiAgfVxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvY2Vzcy5jaGRpciwgY2hkaXIpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7XG4gICAgZnVuY3Rpb24gcmVhZCAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICAgIHZhciBjYWxsYmFja1xuICAgICAgaWYgKGNhbGxiYWNrXyAmJiB0eXBlb2YgY2FsbGJhY2tfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlciwgXywgX18pIHtcbiAgICAgICAgICBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VBR0FJTicgJiYgZWFnQ291bnRlciA8IDEwKSB7XG4gICAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICAgIH1cblxuICAgIC8vIFRoaXMgZW5zdXJlcyBgdXRpbC5wcm9taXNpZnlgIHdvcmtzIGFzIGl0IGRvZXMgZm9yIG5hdGl2ZSBgZnMucmVhZGAuXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikgT2JqZWN0LnNldFByb3RvdHlwZU9mKHJlYWQsIGZzJHJlYWQpXG4gICAgcmV0dXJuIHJlYWRcbiAgfSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxuXG4gIGZ1bmN0aW9uIHBhdGNoTGNobW9kIChmcykge1xuICAgIGZzLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAgICwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOS1xuICAgICAgICAgICAgICwgbW9kZVxuICAgICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICAgIGZzLmZjaG1vZChmZCwgbW9kZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbihlcnIyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZzLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoTHV0aW1lcyAoZnMpIHtcbiAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgICBmcy5sdXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0LCBtdCwgY2IpIHtcbiAgICAgICAgZnMub3BlbihwYXRoLCBjb25zdGFudHMuT19TWU1MSU5LLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLmZ1dGltZXMoZmQsIGF0LCBtdCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgICAgICBmcy5jbG9zZShmZCwgZnVuY3Rpb24gKGVyMikge1xuICAgICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgYXQsIG10KSB7XG4gICAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICAgIHZhciByZXRcbiAgICAgICAgdmFyIHRocmV3ID0gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldCA9IGZzLmZ1dGltZXNTeW5jKGZkLCBhdCwgbXQpXG4gICAgICAgICAgdGhyZXcgPSBmYWxzZVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0aHJldykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2htb2RGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIG1vZGUsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG1vZEZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgbW9kZSlcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmICghY2hvd25Fck9rKGVyKSkgdGhyb3cgZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNob3duRml4IChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCwgY2IpIHtcbiAgICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgdWlkLCBnaWQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaG93bkZpeFN5bmMgKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHVpZCwgZ2lkKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgaWYgKCFjaG93bkVyT2soZXIpKSB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXggKG9yaWcpIHtcbiAgICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgTm9kZSBlcnJvbmVvdXNseSByZXR1cm5lZCBzaWduZWQgaW50ZWdlcnMgZm9yXG4gICAgLy8gdWlkICsgZ2lkLlxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zLCBjYikge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNiID0gb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0gbnVsbFxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2sgKGVyLCBzdGF0cykge1xuICAgICAgICBpZiAoc3RhdHMpIHtcbiAgICAgICAgICBpZiAoc3RhdHMudWlkIDwgMCkgc3RhdHMudWlkICs9IDB4MTAwMDAwMDAwXG4gICAgICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMgPyBvcmlnLmNhbGwoZnMsIHRhcmdldCwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIDogb3JpZy5jYWxsKGZzLCB0YXJnZXQsIGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXRGaXhTeW5jIChvcmlnKSB7XG4gICAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAgIC8vIHVpZCArIGdpZC5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdmFyIHN0YXRzID0gb3B0aW9ucyA/IG9yaWcuY2FsbChmcywgdGFyZ2V0LCBvcHRpb25zKVxuICAgICAgICA6IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgICAgaWYgKHN0YXRzLnVpZCA8IDApIHN0YXRzLnVpZCArPSAweDEwMDAwMDAwMFxuICAgICAgaWYgKHN0YXRzLmdpZCA8IDApIHN0YXRzLmdpZCArPSAweDEwMDAwMDAwMFxuICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuICAvLyB0aGF0LCBiZWNhdXNlIGl0IGRvZXNuJ3QgbWF0dGVyLlxuICAvL1xuICAvLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4gIC8vIHRoYW4gMCwgYW5kIHRoZSBlcnJvciBpcyBFSU5WQUwgb3IgRVBFUk0sIHRoZW4ganVzdCBpZ25vcmVcbiAgLy8gaXQuXG4gIC8vXG4gIC8vIFRoaXMgc3BlY2lmaWMgY2FzZSBpcyBhIHNpbGVudCBmYWlsdXJlIGluIGNwLCBpbnN0YWxsLCB0YXIsXG4gIC8vIGFuZCBtb3N0IG90aGVyIHVuaXggdG9vbHMgdGhhdCBtYW5hZ2UgcGVybWlzc2lvbnMuXG4gIC8vXG4gIC8vIFdoZW4gcnVubmluZyBhcyByb290LCBvciBpZiBvdGhlciB0eXBlcyBvZiBlcnJvcnMgYXJlXG4gIC8vIGVuY291bnRlcmVkLCB0aGVuIGl0J3Mgc3RyaWN0LlxuICBmdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gICAgaWYgKCFlcilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICAgIHJldHVybiB0cnVlXG5cbiAgICB2YXIgbm9ucm9vdCA9ICFwcm9jZXNzLmdldHVpZCB8fCBwcm9jZXNzLmdldHVpZCgpICE9PSAwXG4gICAgaWYgKG5vbnJvb3QpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSBcIkVJTlZBTFwiIHx8IGVyLmNvZGUgPT09IFwiRVBFUk1cIilcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlZ2FjeVxuXG5mdW5jdGlvbiBsZWdhY3kgKGZzKSB7XG4gIHJldHVybiB7XG4gICAgUmVhZFN0cmVhbTogUmVhZFN0cmVhbSxcbiAgICBXcml0ZVN0cmVhbTogV3JpdGVTdHJlYW1cbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSkpIHJldHVybiBuZXcgUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5mbGFncyA9ICdyJztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDY0ICogMTAyNDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5jb2RpbmcpIHRoaXMuc2V0RW5jb2RpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuZCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIDw9IGVuZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmQgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZzLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgc2VsZi5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgc2VsZi5fcmVhZCgpO1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSkpIHJldHVybiBuZXcgV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3cnO1xuICAgIHRoaXMuZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPj0gemVybycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAgIGlmICh0aGlzLmZkID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZnMub3BlbjtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goW3RoaXMuX29wZW4sIHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCB1bmRlZmluZWRdKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lXG5cbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmouX19wcm90b19fXG59XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JylcbiAgICByZXR1cm4gb2JqXG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE9iamVjdClcbiAgICB2YXIgY29weSA9IHsgX19wcm90b19fOiBnZXRQcm90b3R5cGVPZihvYmopIH1cbiAgZWxzZVxuICAgIHZhciBjb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvcHksIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkpXG4gIH0pXG5cbiAgcmV0dXJuIGNvcHlcbn1cbiIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgY2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lLmpzJylcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBub2RlIDAueCBwb2x5ZmlsbCAqL1xudmFyIGdyYWNlZnVsUXVldWVcbnZhciBwcmV2aW91c1N5bWJvbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vZGUgMC54IHBvbHlmaWxsICovXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBncmFjZWZ1bFF1ZXVlID0gU3ltYm9sLmZvcignZ3JhY2VmdWwtZnMucXVldWUnKVxuICAvLyBUaGlzIGlzIHVzZWQgaW4gdGVzdGluZyBieSBmdXR1cmUgdmVyc2lvbnNcbiAgcHJldmlvdXNTeW1ib2wgPSBTeW1ib2wuZm9yKCdncmFjZWZ1bC1mcy5wcmV2aW91cycpXG59IGVsc2Uge1xuICBncmFjZWZ1bFF1ZXVlID0gJ19fX2dyYWNlZnVsLWZzLnF1ZXVlJ1xuICBwcmV2aW91c1N5bWJvbCA9ICdfX19ncmFjZWZ1bC1mcy5wcmV2aW91cydcbn1cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBwdWJsaXNoUXVldWUoY29udGV4dCwgcXVldWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnRleHQsIGdyYWNlZnVsUXVldWUsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHF1ZXVlXG4gICAgfVxuICB9KVxufVxuXG52YXIgZGVidWcgPSBub29wXG5pZiAodXRpbC5kZWJ1Z2xvZylcbiAgZGVidWcgPSB1dGlsLmRlYnVnbG9nKCdnZnM0JylcbmVsc2UgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSlcbiAgZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbSA9IHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIGFyZ3VtZW50cylcbiAgICBtID0gJ0dGUzQ6ICcgKyBtLnNwbGl0KC9cXG4vKS5qb2luKCdcXG5HRlM0OiAnKVxuICAgIGNvbnNvbGUuZXJyb3IobSlcbiAgfVxuXG4vLyBPbmNlIHRpbWUgaW5pdGlhbGl6YXRpb25cbmlmICghZnNbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgLy8gVGhpcyBxdWV1ZSBjYW4gYmUgc2hhcmVkIGJ5IG11bHRpcGxlIGxvYWRlZCBpbnN0YW5jZXNcbiAgdmFyIHF1ZXVlID0gZ2xvYmFsW2dyYWNlZnVsUXVldWVdIHx8IFtdXG4gIHB1Ymxpc2hRdWV1ZShmcywgcXVldWUpXG5cbiAgLy8gUGF0Y2ggZnMuY2xvc2UvY2xvc2VTeW5jIHRvIHNoYXJlZCBxdWV1ZSB2ZXJzaW9uLCBiZWNhdXNlIHdlIG5lZWRcbiAgLy8gdG8gcmV0cnkoKSB3aGVuZXZlciBhIGNsb3NlIGhhcHBlbnMgKmFueXdoZXJlKiBpbiB0aGUgcHJvZ3JhbS5cbiAgLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4gIC8vIGluIHBsYXkgYXQgdGhlIHNhbWUgdGltZS5cbiAgZnMuY2xvc2UgPSAoZnVuY3Rpb24gKGZzJGNsb3NlKSB7XG4gICAgZnVuY3Rpb24gY2xvc2UgKGZkLCBjYikge1xuICAgICAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gdXNlcyB0aGUgZ3JhY2VmdWwtZnMgc2hhcmVkIHF1ZXVlXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgcmVzZXRRdWV1ZSgpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlXG4gICAgfSlcbiAgICByZXR1cm4gY2xvc2VcbiAgfSkoZnMuY2xvc2UpXG5cbiAgZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHtcbiAgICBmdW5jdGlvbiBjbG9zZVN5bmMgKGZkKSB7XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHVzZXMgdGhlIGdyYWNlZnVsLWZzIHNoYXJlZCBxdWV1ZVxuICAgICAgZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gICAgICByZXNldFF1ZXVlKClcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VTeW5jLCBwcmV2aW91c1N5bWJvbCwge1xuICAgICAgdmFsdWU6IGZzJGNsb3NlU3luY1xuICAgIH0pXG4gICAgcmV0dXJuIGNsb3NlU3luY1xuICB9KShmcy5jbG9zZVN5bmMpXG5cbiAgaWYgKC9cXGJnZnM0XFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnKSkge1xuICAgIHByb2Nlc3Mub24oJ2V4aXQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKGZzW2dyYWNlZnVsUXVldWVdKVxuICAgICAgcmVxdWlyZSgnYXNzZXJ0JykuZXF1YWwoZnNbZ3JhY2VmdWxRdWV1ZV0ubGVuZ3RoLCAwKVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKCFnbG9iYWxbZ3JhY2VmdWxRdWV1ZV0pIHtcbiAgcHVibGlzaFF1ZXVlKGdsb2JhbCwgZnNbZ3JhY2VmdWxRdWV1ZV0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoKGNsb25lKGZzKSlcbmlmIChwcm9jZXNzLmVudi5URVNUX0dSQUNFRlVMX0ZTX0dMT0JBTF9QQVRDSCAmJiAhZnMuX19wYXRjaGVkKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbiAgICBmcy5fX3BhdGNoZWQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBwYXRjaCAoZnMpIHtcbiAgLy8gRXZlcnl0aGluZyB0aGF0IHJlZmVyZW5jZXMgdGhlIG9wZW4oKSBmdW5jdGlvbiBuZWVkcyB0byBiZSBpbiBoZXJlXG4gIHBvbHlmaWxscyhmcylcbiAgZnMuZ3JhY2VmdWxpZnkgPSBwYXRjaFxuXG4gIGZzLmNyZWF0ZVJlYWRTdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtXG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gY3JlYXRlV3JpdGVTdHJlYW1cbiAgdmFyIGZzJHJlYWRGaWxlID0gZnMucmVhZEZpbGVcbiAgZnMucmVhZEZpbGUgPSByZWFkRmlsZVxuICBmdW5jdGlvbiByZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkRmlsZSAocGF0aCwgb3B0aW9ucywgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kcmVhZEZpbGUsIFtwYXRoLCBvcHRpb25zLCBjYl0sIGVyciwgc3RhcnRUaW1lIHx8IERhdGUubm93KCksIERhdGUubm93KCldKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kd3JpdGVGaWxlLCBbcGF0aCwgZGF0YSwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB2YXIgZnMkYXBwZW5kRmlsZSA9IGZzLmFwcGVuZEZpbGVcbiAgaWYgKGZzJGFwcGVuZEZpbGUpXG4gICAgZnMuYXBwZW5kRmlsZSA9IGFwcGVuZEZpbGVcbiAgZnVuY3Rpb24gYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kYXBwZW5kRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGFwcGVuZEZpbGUgKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiLCBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJGNvcHlGaWxlID0gZnMuY29weUZpbGVcbiAgaWYgKGZzJGNvcHlGaWxlKVxuICAgIGZzLmNvcHlGaWxlID0gY29weUZpbGVcbiAgZnVuY3Rpb24gY29weUZpbGUgKHNyYywgZGVzdCwgZmxhZ3MsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBmbGFnc1xuICAgICAgZmxhZ3MgPSAwXG4gICAgfVxuICAgIHJldHVybiBnbyRjb3B5RmlsZShzcmMsIGRlc3QsIGZsYWdzLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJGNvcHlGaWxlIChzcmMsIGRlc3QsIGZsYWdzLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkY29weUZpbGUoc3JjLCBkZXN0LCBmbGFncywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRjb3B5RmlsZSwgW3NyYywgZGVzdCwgZmxhZ3MsIGNiXSwgZXJyLCBzdGFydFRpbWUgfHwgRGF0ZS5ub3coKSwgRGF0ZS5ub3coKV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIGZzJHJlYWRkaXIgPSBmcy5yZWFkZGlyXG4gIGZzLnJlYWRkaXIgPSByZWFkZGlyXG4gIGZ1bmN0aW9uIHJlYWRkaXIgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIocGF0aCwgb3B0aW9ucywgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRyZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYiwgc3RhcnRUaW1lKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZGRpcihwYXRoLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBmaWxlcykge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkZGlyLCBbcGF0aCwgb3B0aW9ucywgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGZpbGVzICYmIGZpbGVzLnNvcnQpXG4gICAgICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5jYWxsKHRoaXMsIGVyciwgZmlsZXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MudmVyc2lvbi5zdWJzdHIoMCwgNCkgPT09ICd2MC44Jykge1xuICAgIHZhciBsZWdTdHJlYW1zID0gbGVnYWN5KGZzKVxuICAgIFJlYWRTdHJlYW0gPSBsZWdTdHJlYW1zLlJlYWRTdHJlYW1cbiAgICBXcml0ZVN0cmVhbSA9IGxlZ1N0cmVhbXMuV3JpdGVTdHJlYW1cbiAgfVxuXG4gIHZhciBmcyRSZWFkU3RyZWFtID0gZnMuUmVhZFN0cmVhbVxuICBpZiAoZnMkUmVhZFN0cmVhbSkge1xuICAgIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgICBSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gUmVhZFN0cmVhbSRvcGVuXG4gIH1cblxuICB2YXIgZnMkV3JpdGVTdHJlYW0gPSBmcy5Xcml0ZVN0cmVhbVxuICBpZiAoZnMkV3JpdGVTdHJlYW0pIHtcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGZzJFdyaXRlU3RyZWFtLnByb3RvdHlwZSlcbiAgICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ1JlYWRTdHJlYW0nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBSZWFkU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBXcml0ZVN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICAvLyBsZWdhY3kgbmFtZXNcbiAgdmFyIEZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnMsICdGaWxlUmVhZFN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlUmVhZFN0cmVhbVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBGaWxlUmVhZFN0cmVhbSA9IHZhbFxuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbiAgdmFyIEZpbGVXcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmcywgJ0ZpbGVXcml0ZVN0cmVhbScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGaWxlV3JpdGVTdHJlYW1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgRmlsZVdyaXRlU3RyZWFtID0gdmFsXG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJlYWRTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkUmVhZFN0cmVhbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIFJlYWRTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShSZWFkU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0kb3BlbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgb3Blbih0aGF0LnBhdGgsIHRoYXQuZmxhZ3MsIHRoYXQubW9kZSwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHRoYXQuYXV0b0Nsb3NlKVxuICAgICAgICAgIHRoYXQuZGVzdHJveSgpXG5cbiAgICAgICAgdGhhdC5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoYXQuZmQgPSBmZFxuICAgICAgICB0aGF0LmVtaXQoJ29wZW4nLCBmZClcbiAgICAgICAgdGhhdC5yZWFkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gV3JpdGVTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyaXRlU3RyZWFtKVxuICAgICAgcmV0dXJuIGZzJFdyaXRlU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gV3JpdGVTdHJlYW0uYXBwbHkoT2JqZWN0LmNyZWF0ZShXcml0ZVN0cmVhbS5wcm90b3R5cGUpLCBhcmd1bWVudHMpXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGF0LmRlc3Ryb3koKVxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSZWFkU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBmcy5SZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgZnMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciBmcyRvcGVuID0gZnMub3BlblxuICBmcy5vcGVuID0gb3BlblxuICBmdW5jdGlvbiBvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG1vZGUsIG1vZGUgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kb3BlbihwYXRoLCBmbGFncywgbW9kZSwgY2IpXG5cbiAgICBmdW5jdGlvbiBnbyRvcGVuIChwYXRoLCBmbGFncywgbW9kZSwgY2IsIHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdLCBlcnIsIHN0YXJ0VGltZSB8fCBEYXRlLm5vdygpLCBEYXRlLm5vdygpXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnNcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZSAoZWxlbSkge1xuICBkZWJ1ZygnRU5RVUVVRScsIGVsZW1bMF0ubmFtZSwgZWxlbVsxXSlcbiAgZnNbZ3JhY2VmdWxRdWV1ZV0ucHVzaChlbGVtKVxuICByZXRyeSgpXG59XG5cbi8vIGtlZXAgdHJhY2sgb2YgdGhlIHRpbWVvdXQgYmV0d2VlbiByZXRyeSgpIGNhbGxzXG52YXIgcmV0cnlUaW1lclxuXG4vLyByZXNldCB0aGUgc3RhcnRUaW1lIGFuZCBsYXN0VGltZSB0byBub3dcbi8vIHRoaXMgcmVzZXRzIHRoZSBzdGFydCBvZiB0aGUgNjAgc2Vjb25kIG92ZXJhbGwgdGltZW91dCBhcyB3ZWxsIGFzIHRoZVxuLy8gZGVsYXkgYmV0d2VlbiBhdHRlbXB0cyBzbyB0aGF0IHdlJ2xsIHJldHJ5IHRoZXNlIGpvYnMgc29vbmVyXG5mdW5jdGlvbiByZXNldFF1ZXVlICgpIHtcbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGg7ICsraSkge1xuICAgIC8vIGVudHJpZXMgdGhhdCBhcmUgb25seSBhIGxlbmd0aCBvZiAyIGFyZSBmcm9tIGFuIG9sZGVyIHZlcnNpb24sIGRvbid0XG4gICAgLy8gYm90aGVyIG1vZGlmeWluZyB0aG9zZSBzaW5jZSB0aGV5J2xsIGJlIHJldHJpZWQgYW55d2F5LlxuICAgIGlmIChmc1tncmFjZWZ1bFF1ZXVlXVtpXS5sZW5ndGggPiAyKSB7XG4gICAgICBmc1tncmFjZWZ1bFF1ZXVlXVtpXVszXSA9IG5vdyAvLyBzdGFydFRpbWVcbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdW2ldWzRdID0gbm93IC8vIGxhc3RUaW1lXG4gICAgfVxuICB9XG4gIC8vIGNhbGwgcmV0cnkgdG8gbWFrZSBzdXJlIHdlJ3JlIGFjdGl2ZWx5IHByb2Nlc3NpbmcgdGhlIHF1ZXVlXG4gIHJldHJ5KClcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICAvLyBjbGVhciB0aGUgdGltZXIgYW5kIHJlbW92ZSBpdCB0byBoZWxwIHByZXZlbnQgdW5pbnRlbmRlZCBjb25jdXJyZW5jeVxuICBjbGVhclRpbWVvdXQocmV0cnlUaW1lcilcbiAgcmV0cnlUaW1lciA9IHVuZGVmaW5lZFxuXG4gIGlmIChmc1tncmFjZWZ1bFF1ZXVlXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuXG5cbiAgdmFyIGVsZW0gPSBmc1tncmFjZWZ1bFF1ZXVlXS5zaGlmdCgpXG4gIHZhciBmbiA9IGVsZW1bMF1cbiAgdmFyIGFyZ3MgPSBlbGVtWzFdXG4gIC8vIHRoZXNlIGl0ZW1zIG1heSBiZSB1bnNldCBpZiB0aGV5IHdlcmUgYWRkZWQgYnkgYW4gb2xkZXIgZ3JhY2VmdWwtZnNcbiAgdmFyIGVyciA9IGVsZW1bMl1cbiAgdmFyIHN0YXJ0VGltZSA9IGVsZW1bM11cbiAgdmFyIGxhc3RUaW1lID0gZWxlbVs0XVxuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBzdGFydFRpbWUgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZiB3ZSd2ZSB3YWl0ZWRcbiAgLy8gbG9uZyBlbm91Z2gsIHNvIGdvIGFoZWFkIGFuZCByZXRyeSB0aGlzIGl0ZW0gbm93XG4gIGlmIChzdGFydFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgZm4uYXBwbHkobnVsbCwgYXJncylcbiAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lID49IDYwMDAwKSB7XG4gICAgLy8gaXQncyBiZWVuIG1vcmUgdGhhbiA2MCBzZWNvbmRzIHRvdGFsLCBiYWlsIG5vd1xuICAgIGRlYnVnKCdUSU1FT1VUJywgZm4ubmFtZSwgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzLnBvcCgpXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiLmNhbGwobnVsbCwgZXJyKVxuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSBiZXR3ZWVuIHRoZSBsYXN0IGF0dGVtcHQgYW5kIHJpZ2h0IG5vd1xuICAgIHZhciBzaW5jZUF0dGVtcHQgPSBEYXRlLm5vdygpIC0gbGFzdFRpbWVcbiAgICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgYmV0d2VlbiB3aGVuIHdlIGZpcnN0IHRyaWVkLCBhbmQgd2hlbiB3ZSBsYXN0IHRyaWVkXG4gICAgLy8gcm91bmRlZCB1cCB0byBhdCBsZWFzdCAxXG4gICAgdmFyIHNpbmNlU3RhcnQgPSBNYXRoLm1heChsYXN0VGltZSAtIHN0YXJ0VGltZSwgMSlcbiAgICAvLyBiYWNrb2ZmLiB3YWl0IGxvbmdlciB0aGFuIHRoZSB0b3RhbCB0aW1lIHdlJ3ZlIGJlZW4gcmV0cnlpbmcsIGJ1dCBvbmx5XG4gICAgLy8gdXAgdG8gYSBtYXhpbXVtIG9mIDEwMG1zXG4gICAgdmFyIGRlc2lyZWREZWxheSA9IE1hdGgubWluKHNpbmNlU3RhcnQgKiAxLjIsIDEwMClcbiAgICAvLyBpdCdzIGJlZW4gbG9uZyBlbm91Z2ggc2luY2UgdGhlIGxhc3QgcmV0cnksIGRvIGl0IGFnYWluXG4gICAgaWYgKHNpbmNlQXR0ZW1wdCA+PSBkZXNpcmVkRGVsYXkpIHtcbiAgICAgIGRlYnVnKCdSRVRSWScsIGZuLm5hbWUsIGFyZ3MpXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbc3RhcnRUaW1lXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIGNhbid0IGRvIHRoaXMgam9iIHlldCwgcHVzaCBpdCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgICAgLy8gYW5kIGxldCB0aGUgbmV4dCBpdGVyYXRpb24gY2hlY2sgYWdhaW5cbiAgICAgIGZzW2dyYWNlZnVsUXVldWVdLnB1c2goZWxlbSlcbiAgICB9XG4gIH1cblxuICAvLyBzY2hlZHVsZSBvdXIgbmV4dCBydW4gaWYgb25lIGlzbid0IGFscmVhZHkgc2NoZWR1bGVkXG4gIGlmIChyZXRyeVRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXRyeVRpbWVyID0gc2V0VGltZW91dChyZXRyeSwgMClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG4vLyBUaGlzIGlzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9ybWFsaXplL216XG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiBKb25hdGhhbiBPbmcgbWVAam9uZ2xlYmVycnkuY29tIGFuZCBDb250cmlidXRvcnNcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5jb25zdCBhcGkgPSBbXG4gICdhY2Nlc3MnLFxuICAnYXBwZW5kRmlsZScsXG4gICdjaG1vZCcsXG4gICdjaG93bicsXG4gICdjbG9zZScsXG4gICdjb3B5RmlsZScsXG4gICdmY2htb2QnLFxuICAnZmNob3duJyxcbiAgJ2ZkYXRhc3luYycsXG4gICdmc3RhdCcsXG4gICdmc3luYycsXG4gICdmdHJ1bmNhdGUnLFxuICAnZnV0aW1lcycsXG4gICdsY2htb2QnLFxuICAnbGNob3duJyxcbiAgJ2xpbmsnLFxuICAnbHN0YXQnLFxuICAnbWtkaXInLFxuICAnbWtkdGVtcCcsXG4gICdvcGVuJyxcbiAgJ29wZW5kaXInLFxuICAncmVhZGRpcicsXG4gICdyZWFkRmlsZScsXG4gICdyZWFkbGluaycsXG4gICdyZWFscGF0aCcsXG4gICdyZW5hbWUnLFxuICAncm0nLFxuICAncm1kaXInLFxuICAnc3RhdCcsXG4gICdzeW1saW5rJyxcbiAgJ3RydW5jYXRlJyxcbiAgJ3VubGluaycsXG4gICd1dGltZXMnLFxuICAnd3JpdGVGaWxlJ1xuXS5maWx0ZXIoa2V5ID0+IHtcbiAgLy8gU29tZSBjb21tYW5kcyBhcmUgbm90IGF2YWlsYWJsZSBvbiBzb21lIHN5c3RlbXMuIEV4OlxuICAvLyBmcy5vcGVuZGlyIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHYxMi4xMi4wXG4gIC8vIGZzLnJtIHdhcyBhZGRlZCBpbiBOb2RlLmpzIHYxNC4xNC4wXG4gIC8vIGZzLmxjaG93biBpcyBub3QgYXZhaWxhYmxlIG9uIGF0IGxlYXN0IHNvbWUgTGludXhcbiAgcmV0dXJuIHR5cGVvZiBmc1trZXldID09PSAnZnVuY3Rpb24nXG59KVxuXG4vLyBFeHBvcnQgY2xvbmVkIGZzOlxuT2JqZWN0LmFzc2lnbihleHBvcnRzLCBmcylcblxuLy8gVW5pdmVyc2FsaWZ5IGFzeW5jIG1ldGhvZHM6XG5hcGkuZm9yRWFjaChtZXRob2QgPT4ge1xuICBleHBvcnRzW21ldGhvZF0gPSB1KGZzW21ldGhvZF0pXG59KVxuZXhwb3J0cy5yZWFscGF0aC5uYXRpdmUgPSB1KGZzLnJlYWxwYXRoLm5hdGl2ZSlcblxuLy8gV2UgZGlmZmVyIGZyb20gbXovZnMgaW4gdGhhdCB3ZSBzdGlsbCBzaGlwIHRoZSBvbGQsIGJyb2tlbiwgZnMuZXhpc3RzKClcbi8vIHNpbmNlIHdlIGFyZSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBuYXRpdmUgbW9kdWxlXG5leHBvcnRzLmV4aXN0cyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy5leGlzdHMoZmlsZW5hbWUsIGNhbGxiYWNrKVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICByZXR1cm4gZnMuZXhpc3RzKGZpbGVuYW1lLCByZXNvbHZlKVxuICB9KVxufVxuXG4vLyBmcy5yZWFkKCksIGZzLndyaXRlKCksICYgZnMud3JpdGV2KCkgbmVlZCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gbXVsdGlwbGUgY2FsbGJhY2sgYXJnc1xuXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWQoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCAoZXJyLCBieXRlc1JlYWQsIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNSZWFkLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBGdW5jdGlvbiBzaWduYXR1cmUgY2FuIGJlXG4vLyBmcy53cml0ZShmZCwgYnVmZmVyWywgb2Zmc2V0WywgbGVuZ3RoWywgcG9zaXRpb25dXV0sIGNhbGxiYWNrKVxuLy8gT1Jcbi8vIGZzLndyaXRlKGZkLCBzdHJpbmdbLCBwb3NpdGlvblssIGVuY29kaW5nXV0sIGNhbGxiYWNrKVxuLy8gV2UgbmVlZCB0byBoYW5kbGUgYm90aCBjYXNlcywgc28gd2UgdXNlIC4uLmFyZ3NcbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgLi4uYXJncykge1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy53cml0ZShmZCwgYnVmZmVyLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICByZXNvbHZlKHsgYnl0ZXNXcml0dGVuLCBidWZmZXIgfSlcbiAgICB9KVxuICB9KVxufVxuXG4vLyBmcy53cml0ZXYgb25seSBhdmFpbGFibGUgaW4gTm9kZSB2MTIuOS4wK1xuaWYgKHR5cGVvZiBmcy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gRnVuY3Rpb24gc2lnbmF0dXJlIGlzXG4gIC8vIHMud3JpdGV2KGZkLCBidWZmZXJzWywgcG9zaXRpb25dLCBjYWxsYmFjaylcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgdGhlIG9wdGlvbmFsIGFyZywgc28gd2UgdXNlIC4uLmFyZ3NcbiAgZXhwb3J0cy53cml0ZXYgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlcnMsIC4uLmFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZzLndyaXRldihmZCwgYnVmZmVycywgLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnMud3JpdGV2KGZkLCBidWZmZXJzLCAuLi5hcmdzLCAoZXJyLCBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIHJlc29sdmUoeyBieXRlc1dyaXR0ZW4sIGJ1ZmZlcnMgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuIiwiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbWFrZS1kaXJcbi8vIENvcHlyaWdodCAoYykgU2luZHJlIFNvcmh1cyA8c2luZHJlc29yaHVzQGdtYWlsLmNvbT4gKHNpbmRyZXNvcmh1cy5jb20pXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0J1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg5ODdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWJ1di9saWJ1di9wdWxsLzEwODhcbm1vZHVsZS5leHBvcnRzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uIGNoZWNrUGF0aCAocHRoKSB7XG4gIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgY29uc3QgcGF0aEhhc0ludmFsaWRXaW5DaGFyYWN0ZXJzID0gL1s8PjpcInw/Kl0vLnRlc3QocHRoLnJlcGxhY2UocGF0aC5wYXJzZShwdGgpLnJvb3QsICcnKSlcblxuICAgIGlmIChwYXRoSGFzSW52YWxpZFdpbkNoYXJhY3RlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyczogJHtwdGh9YClcbiAgICAgIGVycm9yLmNvZGUgPSAnRUlOVkFMJ1xuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0J1xuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCB7IGNoZWNrUGF0aCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5cbmNvbnN0IGdldE1vZGUgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7IG1vZGU6IDBvNzc3IH1cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgcmV0dXJuIG9wdGlvbnNcbiAgcmV0dXJuICh7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zIH0pLm1vZGVcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpciA9IGFzeW5jIChkaXIsIG9wdGlvbnMpID0+IHtcbiAgY2hlY2tQYXRoKGRpcilcblxuICByZXR1cm4gZnMubWtkaXIoZGlyLCB7XG4gICAgbW9kZTogZ2V0TW9kZShvcHRpb25zKSxcbiAgICByZWN1cnNpdmU6IHRydWVcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMubWFrZURpclN5bmMgPSAoZGlyLCBvcHRpb25zKSA9PiB7XG4gIGNoZWNrUGF0aChkaXIpXG5cbiAgcmV0dXJuIGZzLm1rZGlyU3luYyhkaXIsIHtcbiAgICBtb2RlOiBnZXRNb2RlKG9wdGlvbnMpLFxuICAgIHJlY3Vyc2l2ZTogdHJ1ZVxuICB9KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IHsgbWFrZURpcjogX21ha2VEaXIsIG1ha2VEaXJTeW5jIH0gPSByZXF1aXJlKCcuL21ha2UtZGlyJylcbmNvbnN0IG1ha2VEaXIgPSB1KF9tYWtlRGlyKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWtkaXJzOiBtYWtlRGlyLFxuICBta2RpcnNTeW5jOiBtYWtlRGlyU3luYyxcbiAgLy8gYWxpYXNcbiAgbWtkaXJwOiBtYWtlRGlyLFxuICBta2RpcnBTeW5jOiBtYWtlRGlyU3luYyxcbiAgZW5zdXJlRGlyOiBtYWtlRGlyLFxuICBlbnN1cmVEaXJTeW5jOiBtYWtlRGlyU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiB1dGltZXNNaWxsaXMgKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spIHtcbiAgLy8gaWYgKCFIQVNfTUlMTElTX1JFUykgcmV0dXJuIGZzLnV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKVxuICBmcy5vcGVuKHBhdGgsICdyKycsIChlcnIsIGZkKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGZ1dGltZXNFcnIgPT4ge1xuICAgICAgZnMuY2xvc2UoZmQsIGNsb3NlRXJyID0+IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhmdXRpbWVzRXJyIHx8IGNsb3NlRXJyKVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiB1dGltZXNNaWxsaXNTeW5jIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhwYXRoLCAncisnKVxuICBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuICByZXR1cm4gZnMuY2xvc2VTeW5jKGZkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXRpbWVzTWlsbGlzLFxuICB1dGltZXNNaWxsaXNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIGdldFN0YXRzIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdEZ1bmMgPSBvcHRzLmRlcmVmZXJlbmNlXG4gICAgPyAoZmlsZSkgPT4gZnMuc3RhdChmaWxlLCB7IGJpZ2ludDogdHJ1ZSB9KVxuICAgIDogKGZpbGUpID0+IGZzLmxzdGF0KGZpbGUsIHsgYmlnaW50OiB0cnVlIH0pXG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgc3RhdEZ1bmMoc3JjKSxcbiAgICBzdGF0RnVuYyhkZXN0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIG51bGxcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIF0pLnRoZW4oKFtzcmNTdGF0LCBkZXN0U3RhdF0pID0+ICh7IHNyY1N0YXQsIGRlc3RTdGF0IH0pKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0c1N5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgZGVzdFN0YXRcbiAgY29uc3Qgc3RhdEZ1bmMgPSBvcHRzLmRlcmVmZXJlbmNlXG4gICAgPyAoZmlsZSkgPT4gZnMuc3RhdFN5bmMoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgICA6IChmaWxlKSA9PiBmcy5sc3RhdFN5bmMoZmlsZSwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRGdW5jKHNyYylcbiAgdHJ5IHtcbiAgICBkZXN0U3RhdCA9IHN0YXRGdW5jKGRlc3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0OiBudWxsIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUGF0aHMgKHNyYywgZGVzdCwgZnVuY05hbWUsIG9wdHMsIGNiKSB7XG4gIHV0aWwuY2FsbGJhY2tpZnkoZ2V0U3RhdHMpKHNyYywgZGVzdCwgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXRzXG5cbiAgICBpZiAoZGVzdFN0YXQpIHtcbiAgICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICAgIGNvbnN0IHNyY0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpXG4gICAgICAgIGNvbnN0IGRlc3RCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZGVzdClcbiAgICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgICBzcmNCYXNlTmFtZSAhPT0gZGVzdEJhc2VOYW1lICYmXG4gICAgICAgICAgc3JjQmFzZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZGVzdEJhc2VOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpKVxuICAgICAgfVxuICAgICAgaWYgKHNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiAhZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIG5vbi1kaXJlY3RvcnkgJyR7ZGVzdH0nIHdpdGggZGlyZWN0b3J5ICcke3NyY30nLmApKVxuICAgICAgfVxuICAgICAgaWYgKCFzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgZGVzdFN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3Qgb3ZlcndyaXRlIGRpcmVjdG9yeSAnJHtkZXN0fScgd2l0aCBub24tZGlyZWN0b3J5ICcke3NyY30nLmApKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNTcmNTdWJkaXIoc3JjLCBkZXN0KSkge1xuICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcihlcnJNc2coc3JjLCBkZXN0LCBmdW5jTmFtZSkpKVxuICAgIH1cbiAgICByZXR1cm4gY2IobnVsbCwgeyBzcmNTdGF0LCBkZXN0U3RhdCB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhdGhzU3luYyAoc3JjLCBkZXN0LCBmdW5jTmFtZSwgb3B0cykge1xuICBjb25zdCB7IHNyY1N0YXQsIGRlc3RTdGF0IH0gPSBnZXRTdGF0c1N5bmMoc3JjLCBkZXN0LCBvcHRzKVxuXG4gIGlmIChkZXN0U3RhdCkge1xuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICBjb25zdCBzcmNCYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoc3JjKVxuICAgICAgY29uc3QgZGVzdEJhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShkZXN0KVxuICAgICAgaWYgKGZ1bmNOYW1lID09PSAnbW92ZScgJiZcbiAgICAgICAgc3JjQmFzZU5hbWUgIT09IGRlc3RCYXNlTmFtZSAmJlxuICAgICAgICBzcmNCYXNlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBkZXN0QmFzZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4geyBzcmNTdGF0LCBkZXN0U3RhdCwgaXNDaGFuZ2luZ0Nhc2U6IHRydWUgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3Qgbm90IGJlIHRoZSBzYW1lLicpXG4gICAgfVxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkgJiYgIWRlc3RTdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSBub24tZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIGRpcmVjdG9yeSAnJHtzcmN9Jy5gKVxuICAgIH1cbiAgICBpZiAoIXNyY1N0YXQuaXNEaXJlY3RvcnkoKSAmJiBkZXN0U3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgZGlyZWN0b3J5ICcke2Rlc3R9JyB3aXRoIG5vbi1kaXJlY3RvcnkgJyR7c3JjfScuYClcbiAgICB9XG4gIH1cblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpICYmIGlzU3JjU3ViZGlyKHNyYywgZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiB7IHNyY1N0YXQsIGRlc3RTdGF0IH1cbn1cblxuLy8gcmVjdXJzaXZlbHkgY2hlY2sgaWYgZGVzdCBwYXJlbnQgaXMgYSBzdWJkaXJlY3Rvcnkgb2Ygc3JjLlxuLy8gSXQgd29ya3MgZm9yIGFsbCBmaWxlIHR5cGVzIGluY2x1ZGluZyBzeW1saW5rcyBzaW5jZSBpdFxuLy8gY2hlY2tzIHRoZSBzcmMgYW5kIGRlc3QgaW5vZGVzLiBJdCBzdGFydHMgZnJvbSB0aGUgZGVlcGVzdFxuLy8gcGFyZW50IGFuZCBzdG9wcyBvbmNlIGl0IHJlYWNoZXMgdGhlIHNyYyBwYXJlbnQgb3IgdGhlIHJvb3QgcGF0aC5cbmZ1bmN0aW9uIGNoZWNrUGFyZW50UGF0aHMgKHNyYywgc3JjU3RhdCwgZGVzdCwgZnVuY05hbWUsIGNiKSB7XG4gIGNvbnN0IHNyY1BhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoc3JjKSlcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZGVzdCkpXG4gIGlmIChkZXN0UGFyZW50ID09PSBzcmNQYXJlbnQgfHwgZGVzdFBhcmVudCA9PT0gcGF0aC5wYXJzZShkZXN0UGFyZW50KS5yb290KSByZXR1cm4gY2IoKVxuICBmcy5zdGF0KGRlc3RQYXJlbnQsIHsgYmlnaW50OiB0cnVlIH0sIChlcnIsIGRlc3RTdGF0KSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuIGNiKClcbiAgICAgIHJldHVybiBjYihlcnIpXG4gICAgfVxuICAgIGlmIChhcmVJZGVudGljYWwoc3JjU3RhdCwgZGVzdFN0YXQpKSB7XG4gICAgICByZXR1cm4gY2IobmV3IEVycm9yKGVyck1zZyhzcmMsIGRlc3QsIGZ1bmNOYW1lKSkpXG4gICAgfVxuICAgIHJldHVybiBjaGVja1BhcmVudFBhdGhzKHNyYywgc3JjU3RhdCwgZGVzdFBhcmVudCwgZnVuY05hbWUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudFBhdGhzU3luYyAoc3JjLCBzcmNTdGF0LCBkZXN0LCBmdW5jTmFtZSkge1xuICBjb25zdCBzcmNQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKHNyYykpXG4gIGNvbnN0IGRlc3RQYXJlbnQgPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGRlc3QpKVxuICBpZiAoZGVzdFBhcmVudCA9PT0gc3JjUGFyZW50IHx8IGRlc3RQYXJlbnQgPT09IHBhdGgucGFyc2UoZGVzdFBhcmVudCkucm9vdCkgcmV0dXJuXG4gIGxldCBkZXN0U3RhdFxuICB0cnkge1xuICAgIGRlc3RTdGF0ID0gZnMuc3RhdFN5bmMoZGVzdFBhcmVudCwgeyBiaWdpbnQ6IHRydWUgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykgcmV0dXJuXG4gICAgdGhyb3cgZXJyXG4gIH1cbiAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkZXN0U3RhdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKHNyYywgZGVzdCwgZnVuY05hbWUpKVxuICB9XG4gIHJldHVybiBjaGVja1BhcmVudFBhdGhzU3luYyhzcmMsIHNyY1N0YXQsIGRlc3RQYXJlbnQsIGZ1bmNOYW1lKVxufVxuXG5mdW5jdGlvbiBhcmVJZGVudGljYWwgKHNyY1N0YXQsIGRlc3RTdGF0KSB7XG4gIHJldHVybiBkZXN0U3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ICYmIGRlc3RTdGF0LmlubyA9PT0gc3JjU3RhdC5pbm8gJiYgZGVzdFN0YXQuZGV2ID09PSBzcmNTdGF0LmRldlxufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBkZXN0IGlzIGEgc3ViZGlyIG9mIHNyYywgb3RoZXJ3aXNlIGZhbHNlLlxuLy8gSXQgb25seSBjaGVja3MgdGhlIHBhdGggc3RyaW5ncy5cbmZ1bmN0aW9uIGlzU3JjU3ViZGlyIChzcmMsIGRlc3QpIHtcbiAgY29uc3Qgc3JjQXJyID0gcGF0aC5yZXNvbHZlKHNyYykuc3BsaXQocGF0aC5zZXApLmZpbHRlcihpID0+IGkpXG4gIGNvbnN0IGRlc3RBcnIgPSBwYXRoLnJlc29sdmUoZGVzdCkuc3BsaXQocGF0aC5zZXApLmZpbHRlcihpID0+IGkpXG4gIHJldHVybiBzcmNBcnIucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4gYWNjICYmIGRlc3RBcnJbaV0gPT09IGN1ciwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXJyTXNnIChzcmMsIGRlc3QsIGZ1bmNOYW1lKSB7XG4gIHJldHVybiBgQ2Fubm90ICR7ZnVuY05hbWV9ICcke3NyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7ZGVzdH0nLmBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNoZWNrUGF0aHMsXG4gIGNoZWNrUGF0aHNTeW5jLFxuICBjaGVja1BhcmVudFBhdGhzLFxuICBjaGVja1BhcmVudFBhdGhzU3luYyxcbiAgaXNTcmNTdWJkaXIsXG4gIGFyZUlkZW50aWNhbFxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXJzU3luYyA9IHJlcXVpcmUoJy4uL21rZGlycycpLm1rZGlyc1N5bmNcbmNvbnN0IHV0aW1lc01pbGxpc1N5bmMgPSByZXF1aXJlKCcuLi91dGlsL3V0aW1lcycpLnV0aW1lc01pbGxpc1N5bmNcbmNvbnN0IHN0YXQgPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjb3B5U3luYyAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdHMgPSB7IGZpbHRlcjogb3B0cyB9XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuICBvcHRzLmNsb2JiZXIgPSAnY2xvYmJlcicgaW4gb3B0cyA/ICEhb3B0cy5jbG9iYmVyIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWUgZm9yIG5vd1xuICBvcHRzLm92ZXJ3cml0ZSA9ICdvdmVyd3JpdGUnIGluIG9wdHMgPyAhIW9wdHMub3ZlcndyaXRlIDogb3B0cy5jbG9iYmVyIC8vIG92ZXJ3cml0ZSBmYWxscyBiYWNrIHRvIGNsb2JiZXJcblxuICAvLyBXYXJuIGFib3V0IHVzaW5nIHByZXNlcnZlVGltZXN0YW1wcyBvbiAzMi1iaXQgbm9kZVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMgJiYgcHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICBjb25zb2xlLndhcm4oYGZzLWV4dHJhOiBVc2luZyB0aGUgcHJlc2VydmVUaW1lc3RhbXBzIG9wdGlvbiBpbiAzMi1iaXQgbm9kZSBpcyBub3QgcmVjb21tZW5kZWQ7XFxuXG4gICAgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcHJpY2hhcmRzb24vbm9kZS1mcy1leHRyYS9pc3N1ZXMvMjY5YClcbiAgfVxuXG4gIGNvbnN0IHsgc3JjU3RhdCwgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnY29weScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScpXG4gIHJldHVybiBoYW5kbGVGaWx0ZXJBbmRDb3B5KGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZpbHRlckFuZENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMuZmlsdGVyICYmICFvcHRzLmZpbHRlcihzcmMsIGRlc3QpKSByZXR1cm5cbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBpZiAoIWZzLmV4aXN0c1N5bmMoZGVzdFBhcmVudCkpIG1rZGlyc1N5bmMoZGVzdFBhcmVudClcbiAgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29weSAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBpZiAob3B0cy5maWx0ZXIgJiYgIW9wdHMuZmlsdGVyKHNyYywgZGVzdCkpIHJldHVyblxuICByZXR1cm4gZ2V0U3RhdHMoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3RhdFN5bmMgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmNcbiAgY29uc3Qgc3JjU3RhdCA9IHN0YXRTeW5jKHNyYylcblxuICBpZiAoc3JjU3RhdC5pc0RpcmVjdG9yeSgpKSByZXR1cm4gb25EaXIoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZpbGUoKSB8fFxuICAgICAgICAgICBzcmNTdGF0LmlzQ2hhcmFjdGVyRGV2aWNlKCkgfHxcbiAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cylcbiAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSBhIHNvY2tldCBmaWxlOiAke3NyY31gKVxuICBlbHNlIGlmIChzcmNTdGF0LmlzRklGTygpKSB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjb3B5IGEgRklGTyBwaXBlOiAke3NyY31gKVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YClcbn1cblxuZnVuY3Rpb24gb25GaWxlIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG1heUNvcHlGaWxlIChzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgaWYgKG9wdHMub3ZlcndyaXRlKSB7XG4gICAgZnMudW5saW5rU3luYyhkZXN0KVxuICAgIHJldHVybiBjb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMpXG4gIH0gZWxzZSBpZiAob3B0cy5lcnJvck9uRXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke2Rlc3R9JyBhbHJlYWR5IGV4aXN0c2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUZpbGUgKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBmcy5jb3B5RmlsZVN5bmMoc3JjLCBkZXN0KVxuICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIGhhbmRsZVRpbWVzdGFtcHMoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QpXG4gIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNTdGF0Lm1vZGUpXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHMgKHNyY01vZGUsIHNyYywgZGVzdCkge1xuICAvLyBNYWtlIHN1cmUgdGhlIGZpbGUgaXMgd3JpdGFibGUgYmVmb3JlIHNldHRpbmcgdGhlIHRpbWVzdGFtcFxuICAvLyBvdGhlcndpc2Ugb3BlbiBmYWlscyB3aXRoIEVQRVJNIHdoZW4gaW52b2tlZCB3aXRoICdyKydcbiAgLy8gKHRocm91Z2ggdXRpbWVzIGNhbGwpXG4gIGlmIChmaWxlSXNOb3RXcml0YWJsZShzcmNNb2RlKSkgbWFrZUZpbGVXcml0YWJsZShkZXN0LCBzcmNNb2RlKVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHMoc3JjLCBkZXN0KVxufVxuXG5mdW5jdGlvbiBmaWxlSXNOb3RXcml0YWJsZSAoc3JjTW9kZSkge1xuICByZXR1cm4gKHNyY01vZGUgJiAwbzIwMCkgPT09IDBcbn1cblxuZnVuY3Rpb24gbWFrZUZpbGVXcml0YWJsZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwKVxufVxuXG5mdW5jdGlvbiBzZXREZXN0TW9kZSAoZGVzdCwgc3JjTW9kZSkge1xuICByZXR1cm4gZnMuY2htb2RTeW5jKGRlc3QsIHNyY01vZGUpXG59XG5cbmZ1bmN0aW9uIHNldERlc3RUaW1lc3RhbXBzIChzcmMsIGRlc3QpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGNvbnN0IHVwZGF0ZWRTcmNTdGF0ID0gZnMuc3RhdFN5bmMoc3JjKVxuICByZXR1cm4gdXRpbWVzTWlsbGlzU3luYyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUpXG59XG5cbmZ1bmN0aW9uIG9uRGlyIChzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGlmICghZGVzdFN0YXQpIHJldHVybiBta0RpckFuZENvcHkoc3JjU3RhdC5tb2RlLCBzcmMsIGRlc3QsIG9wdHMpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cylcbn1cblxuZnVuY3Rpb24gbWtEaXJBbmRDb3B5IChzcmNNb2RlLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgZnMubWtkaXJTeW5jKGRlc3QpXG4gIGNvcHlEaXIoc3JjLCBkZXN0LCBvcHRzKVxuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSlcbn1cblxuZnVuY3Rpb24gY29weURpciAoc3JjLCBkZXN0LCBvcHRzKSB7XG4gIGZzLnJlYWRkaXJTeW5jKHNyYykuZm9yRWFjaChpdGVtID0+IGNvcHlEaXJJdGVtKGl0ZW0sIHNyYywgZGVzdCwgb3B0cykpXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXJJdGVtIChpdGVtLCBzcmMsIGRlc3QsIG9wdHMpIHtcbiAgY29uc3Qgc3JjSXRlbSA9IHBhdGguam9pbihzcmMsIGl0ZW0pXG4gIGNvbnN0IGRlc3RJdGVtID0gcGF0aC5qb2luKGRlc3QsIGl0ZW0pXG4gIGNvbnN0IHsgZGVzdFN0YXQgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjSXRlbSwgZGVzdEl0ZW0sICdjb3B5Jywgb3B0cylcbiAgcmV0dXJuIHN0YXJ0Q29weShkZXN0U3RhdCwgc3JjSXRlbSwgZGVzdEl0ZW0sIG9wdHMpXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cykge1xuICBsZXQgcmVzb2x2ZWRTcmMgPSBmcy5yZWFkbGlua1N5bmMoc3JjKVxuICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICB9XG5cbiAgaWYgKCFkZXN0U3RhdCkge1xuICAgIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzb2x2ZWREZXN0XG4gICAgdHJ5IHtcbiAgICAgIHJlc29sdmVkRGVzdCA9IGZzLnJlYWRsaW5rU3luYyhkZXN0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZGVzdCBleGlzdHMgYW5kIGlzIGEgcmVndWxhciBmaWxlIG9yIGRpcmVjdG9yeSxcbiAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAvLyBmcyB0aHJvd3MgZXJyb3IgYW55d2F5LCBzbyBubyBuZWVkIHRvIGd1YXJkIGFnYWluc3QgaXQgaGVyZS5cbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VJTlZBTCcgfHwgZXJyLmNvZGUgPT09ICdVTktOT1dOJykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHJlc29sdmVkU3JjLCBkZXN0KVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGlmIChvcHRzLmRlcmVmZXJlbmNlKSB7XG4gICAgICByZXNvbHZlZERlc3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVzb2x2ZWREZXN0KVxuICAgIH1cbiAgICBpZiAoc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZFNyYywgcmVzb2x2ZWREZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYClcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGNvcHkgaWYgc3JjIGlzIGEgc3ViZGlyIG9mIGRlc3Qgc2luY2UgdW5saW5raW5nXG4gICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgIC8vIGFuZCB0aGVyZWZvcmUgYSBicm9rZW4gc3ltbGluayB3b3VsZCBiZSBjcmVhdGVkLlxuICAgIGlmIChmcy5zdGF0U3luYyhkZXN0KS5pc0RpcmVjdG9yeSgpICYmIHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWREZXN0LCByZXNvbHZlZFNyYykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG92ZXJ3cml0ZSAnJHtyZXNvbHZlZERlc3R9JyB3aXRoICcke3Jlc29sdmVkU3JjfScuYClcbiAgICB9XG4gICAgcmV0dXJuIGNvcHlMaW5rKHJlc29sdmVkU3JjLCBkZXN0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHlMaW5rIChyZXNvbHZlZFNyYywgZGVzdCkge1xuICBmcy51bmxpbmtTeW5jKGRlc3QpXG4gIHJldHVybiBmcy5zeW1saW5rU3luYyhyZXNvbHZlZFNyYywgZGVzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3luY1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3B5U3luYzogcmVxdWlyZSgnLi9jb3B5LXN5bmMnKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGZzID0gcmVxdWlyZSgnLi4vZnMnKVxuXG5mdW5jdGlvbiBwYXRoRXhpc3RzIChwYXRoKSB7XG4gIHJldHVybiBmcy5hY2Nlc3MocGF0aCkudGhlbigoKSA9PiB0cnVlKS5jYXRjaCgoKSA9PiBmYWxzZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhdGhFeGlzdHM6IHUocGF0aEV4aXN0cyksXG4gIHBhdGhFeGlzdHNTeW5jOiBmcy5leGlzdHNTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBta2RpcnMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnNcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHV0aW1lc01pbGxpcyA9IHJlcXVpcmUoJy4uL3V0aWwvdXRpbWVzJykudXRpbWVzTWlsbGlzXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY29weSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicgJiYgIWNiKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzID0geyBmaWx0ZXI6IG9wdHMgfVxuICB9XG5cbiAgY2IgPSBjYiB8fCBmdW5jdGlvbiAoKSB7fVxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIG9wdHMuY2xvYmJlciA9ICdjbG9iYmVyJyBpbiBvcHRzID8gISFvcHRzLmNsb2JiZXIgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZSBmb3Igbm93XG4gIG9wdHMub3ZlcndyaXRlID0gJ292ZXJ3cml0ZScgaW4gb3B0cyA/ICEhb3B0cy5vdmVyd3JpdGUgOiBvcHRzLmNsb2JiZXIgLy8gb3ZlcndyaXRlIGZhbGxzIGJhY2sgdG8gY2xvYmJlclxuXG4gIC8vIFdhcm4gYWJvdXQgdXNpbmcgcHJlc2VydmVUaW1lc3RhbXBzIG9uIDMyLWJpdCBub2RlXG4gIGlmIChvcHRzLnByZXNlcnZlVGltZXN0YW1wcyAmJiBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJykge1xuICAgIGNvbnNvbGUud2FybihgZnMtZXh0cmE6IFVzaW5nIHRoZSBwcmVzZXJ2ZVRpbWVzdGFtcHMgb3B0aW9uIGluIDMyLWJpdCBub2RlIGlzIG5vdCByZWNvbW1lbmRlZDtcXG5cbiAgICBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2pwcmljaGFyZHNvbi9ub2RlLWZzLWV4dHJhL2lzc3Vlcy8yNjlgKVxuICB9XG5cbiAgc3RhdC5jaGVja1BhdGhzKHNyYywgZGVzdCwgJ2NvcHknLCBvcHRzLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29uc3QgeyBzcmNTdGF0LCBkZXN0U3RhdCB9ID0gc3RhdHNcbiAgICBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnY29weScsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKG9wdHMuZmlsdGVyKSByZXR1cm4gaGFuZGxlRmlsdGVyKGNoZWNrUGFyZW50RGlyLCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICAgIHJldHVybiBjaGVja1BhcmVudERpcihkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudERpciAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgY29uc3QgZGVzdFBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBwYXRoRXhpc3RzKGRlc3RQYXJlbnQsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGdldFN0YXRzKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIG1rZGlycyhkZXN0UGFyZW50LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGaWx0ZXIgKG9uSW5jbHVkZSwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgUHJvbWlzZS5yZXNvbHZlKG9wdHMuZmlsdGVyKHNyYywgZGVzdCkpLnRoZW4oaW5jbHVkZSA9PiB7XG4gICAgaWYgKGluY2x1ZGUpIHJldHVybiBvbkluY2x1ZGUoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgcmV0dXJuIGNiKClcbiAgfSwgZXJyb3IgPT4gY2IoZXJyb3IpKVxufVxuXG5mdW5jdGlvbiBzdGFydENvcHkgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGlmIChvcHRzLmZpbHRlcikgcmV0dXJuIGhhbmRsZUZpbHRlcihnZXRTdGF0cywgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBnZXRTdGF0cyhkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdHMgKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHN0YXQgPSBvcHRzLmRlcmVmZXJlbmNlID8gZnMuc3RhdCA6IGZzLmxzdGF0XG4gIHN0YXQoc3JjLCAoZXJyLCBzcmNTdGF0KSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcblxuICAgIGlmIChzcmNTdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBvbkRpcihzcmNTdGF0LCBkZXN0U3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICBlbHNlIGlmIChzcmNTdGF0LmlzRmlsZSgpIHx8XG4gICAgICAgICAgICAgc3JjU3RhdC5pc0NoYXJhY3RlckRldmljZSgpIHx8XG4gICAgICAgICAgICAgc3JjU3RhdC5pc0Jsb2NrRGV2aWNlKCkpIHJldHVybiBvbkZpbGUoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc1N5bWJvbGljTGluaygpKSByZXR1cm4gb25MaW5rKGRlc3RTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIGVsc2UgaWYgKHNyY1N0YXQuaXNTb2NrZXQoKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBzb2NrZXQgZmlsZTogJHtzcmN9YCkpXG4gICAgZWxzZSBpZiAoc3JjU3RhdC5pc0ZJRk8oKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgQ2Fubm90IGNvcHkgYSBGSUZPIHBpcGU6ICR7c3JjfWApKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gZmlsZTogJHtzcmN9YCkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uRmlsZSAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIGNvcHlGaWxlKHNyY1N0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBtYXlDb3B5RmlsZShzcmNTdGF0LCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxufVxuXG5mdW5jdGlvbiBtYXlDb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAob3B0cy5vdmVyd3JpdGUpIHtcbiAgICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gY29weUZpbGUoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbiAgICB9KVxuICB9IGVsc2UgaWYgKG9wdHMuZXJyb3JPbkV4aXN0KSB7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihgJyR7ZGVzdH0nIGFscmVhZHkgZXhpc3RzYCkpXG4gIH0gZWxzZSByZXR1cm4gY2IoKVxufVxuXG5mdW5jdGlvbiBjb3B5RmlsZSAoc3JjU3RhdCwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5jb3B5RmlsZShzcmMsIGRlc3QsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAob3B0cy5wcmVzZXJ2ZVRpbWVzdGFtcHMpIHJldHVybiBoYW5kbGVUaW1lc3RhbXBzQW5kTW9kZShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgY2IpXG4gICAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY1N0YXQubW9kZSwgY2IpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcHNBbmRNb2RlIChzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGUgZmlsZSBpcyB3cml0YWJsZSBiZWZvcmUgc2V0dGluZyB0aGUgdGltZXN0YW1wXG4gIC8vIG90aGVyd2lzZSBvcGVuIGZhaWxzIHdpdGggRVBFUk0gd2hlbiBpbnZva2VkIHdpdGggJ3IrJ1xuICAvLyAodGhyb3VnaCB1dGltZXMgY2FsbClcbiAgaWYgKGZpbGVJc05vdFdyaXRhYmxlKHNyY01vZGUpKSB7XG4gICAgcmV0dXJuIG1ha2VGaWxlV3JpdGFibGUoZGVzdCwgc3JjTW9kZSwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlKHNyY01vZGUsIHNyYywgZGVzdCwgY2IpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlKHNyY01vZGUsIHNyYywgZGVzdCwgY2IpXG59XG5cbmZ1bmN0aW9uIGZpbGVJc05vdFdyaXRhYmxlIChzcmNNb2RlKSB7XG4gIHJldHVybiAoc3JjTW9kZSAmIDBvMjAwKSA9PT0gMFxufVxuXG5mdW5jdGlvbiBtYWtlRmlsZVdyaXRhYmxlIChkZXN0LCBzcmNNb2RlLCBjYikge1xuICByZXR1cm4gc2V0RGVzdE1vZGUoZGVzdCwgc3JjTW9kZSB8IDBvMjAwLCBjYilcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHNBbmRNb2RlIChzcmNNb2RlLCBzcmMsIGRlc3QsIGNiKSB7XG4gIHNldERlc3RUaW1lc3RhbXBzKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBzZXREZXN0TW9kZShkZXN0LCBzcmNNb2RlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gc2V0RGVzdE1vZGUgKGRlc3QsIHNyY01vZGUsIGNiKSB7XG4gIHJldHVybiBmcy5jaG1vZChkZXN0LCBzcmNNb2RlLCBjYilcbn1cblxuZnVuY3Rpb24gc2V0RGVzdFRpbWVzdGFtcHMgKHNyYywgZGVzdCwgY2IpIHtcbiAgLy8gVGhlIGluaXRpYWwgc3JjU3RhdC5hdGltZSBjYW5ub3QgYmUgdHJ1c3RlZFxuICAvLyBiZWNhdXNlIGl0IGlzIG1vZGlmaWVkIGJ5IHRoZSByZWFkKDIpIHN5c3RlbSBjYWxsXG4gIC8vIChTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX3N0YXRfdGltZV92YWx1ZXMpXG4gIGZzLnN0YXQoc3JjLCAoZXJyLCB1cGRhdGVkU3JjU3RhdCkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIHV0aW1lc01pbGxpcyhkZXN0LCB1cGRhdGVkU3JjU3RhdC5hdGltZSwgdXBkYXRlZFNyY1N0YXQubXRpbWUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBvbkRpciAoc3JjU3RhdCwgZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgaWYgKCFkZXN0U3RhdCkgcmV0dXJuIG1rRGlyQW5kQ29weShzcmNTdGF0Lm1vZGUsIHNyYywgZGVzdCwgb3B0cywgY2IpXG4gIHJldHVybiBjb3B5RGlyKHNyYywgZGVzdCwgb3B0cywgY2IpXG59XG5cbmZ1bmN0aW9uIG1rRGlyQW5kQ29weSAoc3JjTW9kZSwgc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBmcy5ta2RpcihkZXN0LCBlcnIgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY29weURpcihzcmMsIGRlc3QsIG9wdHMsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgcmV0dXJuIHNldERlc3RNb2RlKGRlc3QsIHNyY01vZGUsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNvcHlEaXIgKHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMucmVhZGRpcihzcmMsIChlcnIsIGl0ZW1zKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gY29weURpckl0ZW1zKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb3B5RGlySXRlbXMgKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IGl0ZW0gPSBpdGVtcy5wb3AoKVxuICBpZiAoIWl0ZW0pIHJldHVybiBjYigpXG4gIHJldHVybiBjb3B5RGlySXRlbShpdGVtcywgaXRlbSwgc3JjLCBkZXN0LCBvcHRzLCBjYilcbn1cblxuZnVuY3Rpb24gY29weURpckl0ZW0gKGl0ZW1zLCBpdGVtLCBzcmMsIGRlc3QsIG9wdHMsIGNiKSB7XG4gIGNvbnN0IHNyY0l0ZW0gPSBwYXRoLmpvaW4oc3JjLCBpdGVtKVxuICBjb25zdCBkZXN0SXRlbSA9IHBhdGguam9pbihkZXN0LCBpdGVtKVxuICBzdGF0LmNoZWNrUGF0aHMoc3JjSXRlbSwgZGVzdEl0ZW0sICdjb3B5Jywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgZGVzdFN0YXQgfSA9IHN0YXRzXG4gICAgc3RhcnRDb3B5KGRlc3RTdGF0LCBzcmNJdGVtLCBkZXN0SXRlbSwgb3B0cywgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICByZXR1cm4gY29weURpckl0ZW1zKGl0ZW1zLCBzcmMsIGRlc3QsIG9wdHMsIGNiKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG9uTGluayAoZGVzdFN0YXQsIHNyYywgZGVzdCwgb3B0cywgY2IpIHtcbiAgZnMucmVhZGxpbmsoc3JjLCAoZXJyLCByZXNvbHZlZFNyYykgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKG9wdHMuZGVyZWZlcmVuY2UpIHtcbiAgICAgIHJlc29sdmVkU3JjID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIHJlc29sdmVkU3JjKVxuICAgIH1cblxuICAgIGlmICghZGVzdFN0YXQpIHtcbiAgICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0LCBjYilcbiAgICB9IGVsc2Uge1xuICAgICAgZnMucmVhZGxpbmsoZGVzdCwgKGVyciwgcmVzb2x2ZWREZXN0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBkZXN0IGV4aXN0cyBhbmQgaXMgYSByZWd1bGFyIGZpbGUgb3IgZGlyZWN0b3J5LFxuICAgICAgICAgIC8vIFdpbmRvd3MgbWF5IHRocm93IFVOS05PV04gZXJyb3IuIElmIGRlc3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAgICAgLy8gZnMgdGhyb3dzIGVycm9yIGFueXdheSwgc28gbm8gbmVlZCB0byBndWFyZCBhZ2FpbnN0IGl0IGhlcmUuXG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUlOVkFMJyB8fCBlcnIuY29kZSA9PT0gJ1VOS05PV04nKSByZXR1cm4gZnMuc3ltbGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5kZXJlZmVyZW5jZSkge1xuICAgICAgICAgIHJlc29sdmVkRGVzdCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXNvbHZlZERlc3QpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQuaXNTcmNTdWJkaXIocmVzb2x2ZWRTcmMsIHJlc29sdmVkRGVzdCkpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKGBDYW5ub3QgY29weSAnJHtyZXNvbHZlZFNyY30nIHRvIGEgc3ViZGlyZWN0b3J5IG9mIGl0c2VsZiwgJyR7cmVzb2x2ZWREZXN0fScuYCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBub3QgY29weSBpZiBzcmMgaXMgYSBzdWJkaXIgb2YgZGVzdCBzaW5jZSB1bmxpbmtpbmdcbiAgICAgICAgLy8gZGVzdCBpbiB0aGlzIGNhc2Ugd291bGQgcmVzdWx0IGluIHJlbW92aW5nIHNyYyBjb250ZW50c1xuICAgICAgICAvLyBhbmQgdGhlcmVmb3JlIGEgYnJva2VuIHN5bWxpbmsgd291bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgaWYgKGRlc3RTdGF0LmlzRGlyZWN0b3J5KCkgJiYgc3RhdC5pc1NyY1N1YmRpcihyZXNvbHZlZERlc3QsIHJlc29sdmVkU3JjKSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoYENhbm5vdCBvdmVyd3JpdGUgJyR7cmVzb2x2ZWREZXN0fScgd2l0aCAnJHtyZXNvbHZlZFNyY30nLmApKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3B5TGluayhyZXNvbHZlZFNyYywgZGVzdCwgY2IpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY29weUxpbmsgKHJlc29sdmVkU3JjLCBkZXN0LCBjYikge1xuICBmcy51bmxpbmsoZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBmcy5zeW1saW5rKHJlc29sdmVkU3JjLCBkZXN0LCBjYilcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcHk6IHUocmVxdWlyZSgnLi9jb3B5JykpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5jb25zdCBpc1dpbmRvd3MgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJylcblxuZnVuY3Rpb24gZGVmYXVsdHMgKG9wdGlvbnMpIHtcbiAgY29uc3QgbWV0aG9kcyA9IFtcbiAgICAndW5saW5rJyxcbiAgICAnY2htb2QnLFxuICAgICdzdGF0JyxcbiAgICAnbHN0YXQnLFxuICAgICdybWRpcicsXG4gICAgJ3JlYWRkaXInXG4gIF1cbiAgbWV0aG9kcy5mb3JFYWNoKG0gPT4ge1xuICAgIG9wdGlvbnNbbV0gPSBvcHRpb25zW21dIHx8IGZzW21dXG4gICAgbSA9IG0gKyAnU3luYydcbiAgICBvcHRpb25zW21dID0gb3B0aW9uc1ttXSB8fCBmc1ttXVxuICB9KVxuXG4gIG9wdGlvbnMubWF4QnVzeVRyaWVzID0gb3B0aW9ucy5tYXhCdXN5VHJpZXMgfHwgM1xufVxuXG5mdW5jdGlvbiByaW1yYWYgKHAsIG9wdGlvbnMsIGNiKSB7XG4gIGxldCBidXN5VHJpZXMgPSAwXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAncmltcmFmOiBjYWxsYmFjayBmdW5jdGlvbiByZXF1aXJlZCcpXG4gIGFzc2VydChvcHRpb25zLCAncmltcmFmOiBpbnZhbGlkIG9wdGlvbnMgYXJndW1lbnQgcHJvdmlkZWQnKVxuICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIG9wdGlvbnMsICdvYmplY3QnLCAncmltcmFmOiBvcHRpb25zIHNob3VsZCBiZSBvYmplY3QnKVxuXG4gIGRlZmF1bHRzKG9wdGlvbnMpXG5cbiAgcmltcmFmXyhwLCBvcHRpb25zLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmICgoZXIuY29kZSA9PT0gJ0VCVVNZJyB8fCBlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSAmJlxuICAgICAgICAgIGJ1c3lUcmllcyA8IG9wdGlvbnMubWF4QnVzeVRyaWVzKSB7XG4gICAgICAgIGJ1c3lUcmllcysrXG4gICAgICAgIGNvbnN0IHRpbWUgPSBidXN5VHJpZXMgKiAxMDBcbiAgICAgICAgLy8gdHJ5IGFnYWluLCB3aXRoIHRoZSBzYW1lIGV4YWN0IGNhbGxiYWNrIGFzIHRoaXMgb25lLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiByaW1yYWZfKHAsIG9wdGlvbnMsIENCKSwgdGltZSlcbiAgICAgIH1cblxuICAgICAgLy8gYWxyZWFkeSBnb25lXG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIGVyID0gbnVsbFxuICAgIH1cblxuICAgIGNiKGVyKVxuICB9KVxufVxuXG4vLyBUd28gcG9zc2libGUgc3RyYXRlZ2llcy5cbi8vIDEuIEFzc3VtZSBpdCdzIGEgZmlsZS4gIHVubGluayBpdCwgdGhlbiBkbyB0aGUgZGlyIHN0dWZmIG9uIEVQRVJNIG9yIEVJU0RJUlxuLy8gMi4gQXNzdW1lIGl0J3MgYSBkaXJlY3RvcnkuICByZWFkZGlyLCB0aGVuIGRvIHRoZSBmaWxlIHN0dWZmIG9uIEVOT1RESVJcbi8vXG4vLyBCb3RoIHJlc3VsdCBpbiBhbiBleHRyYSBzeXNjYWxsIHdoZW4geW91IGd1ZXNzIHdyb25nLiAgSG93ZXZlciwgdGhlcmVcbi8vIGFyZSBsaWtlbHkgZmFyIG1vcmUgbm9ybWFsIGZpbGVzIGluIHRoZSB3b3JsZCB0aGFuIGRpcmVjdG9yaWVzLiAgVGhpc1xuLy8gaXMgYmFzZWQgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBhIHRoZSBhdmVyYWdlIG51bWJlciBvZiBmaWxlcyBwZXJcbi8vIGRpcmVjdG9yeSBpcyA+PSAxLlxuLy9cbi8vIElmIGFueW9uZSBldmVyIGNvbXBsYWlucyBhYm91dCB0aGlzLCB0aGVuIEkgZ3Vlc3MgdGhlIHN0cmF0ZWd5IGNvdWxkXG4vLyBiZSBtYWRlIGNvbmZpZ3VyYWJsZSBzb21laG93LiAgQnV0IHVudGlsIHRoZW4sIFlBR05JLlxuZnVuY3Rpb24gcmltcmFmXyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAvLyBzbyB3ZSBoYXZlIHRvIGxzdGF0IGhlcmUgYW5kIG1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpci5cbiAgb3B0aW9ucy5sc3RhdChwLCAoZXIsIHN0KSA9PiB7XG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm4gY2IobnVsbClcbiAgICB9XG5cbiAgICAvLyBXaW5kb3dzIGNhbiBFUEVSTSBvbiBzdGF0LiAgTGlmZSBpcyBzdWZmZXJpbmcuXG4gICAgaWYgKGVyICYmIGVyLmNvZGUgPT09ICdFUEVSTScgJiYgaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gZml4V2luRVBFUk0ocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgIH1cblxuICAgIG9wdGlvbnMudW5saW5rKHAsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgIHJldHVybiAoaXNXaW5kb3dzKVxuICAgICAgICAgICAgPyBmaXhXaW5FUEVSTShwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgICAgICA6IHJtZGlyKHAsIG9wdGlvbnMsIGVyLCBjYilcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VJU0RJUicpIHtcbiAgICAgICAgICByZXR1cm4gcm1kaXIocCwgb3B0aW9ucywgZXIsIGNiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZml4V2luRVBFUk0gKHAsIG9wdGlvbnMsIGVyLCBjYikge1xuICBhc3NlcnQocClcbiAgYXNzZXJ0KG9wdGlvbnMpXG4gIGFzc2VydCh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG5cbiAgb3B0aW9ucy5jaG1vZChwLCAwbzY2NiwgZXIyID0+IHtcbiAgICBpZiAoZXIyKSB7XG4gICAgICBjYihlcjIuY29kZSA9PT0gJ0VOT0VOVCcgPyBudWxsIDogZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RhdChwLCAoZXIzLCBzdGF0cykgPT4ge1xuICAgICAgICBpZiAoZXIzKSB7XG4gICAgICAgICAgY2IoZXIzLmNvZGUgPT09ICdFTk9FTlQnID8gbnVsbCA6IGVyKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBybWRpcihwLCBvcHRpb25zLCBlciwgY2IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy51bmxpbmsocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBmaXhXaW5FUEVSTVN5bmMgKHAsIG9wdGlvbnMsIGVyKSB7XG4gIGxldCBzdGF0c1xuXG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMuY2htb2RTeW5jKHAsIDBvNjY2KVxuICB9IGNhdGNoIChlcjIpIHtcbiAgICBpZiAoZXIyLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHN0YXRzID0gb3B0aW9ucy5zdGF0U3luYyhwKVxuICB9IGNhdGNoIChlcjMpIHtcbiAgICBpZiAoZXIzLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVubGlua1N5bmMocClcbiAgfVxufVxuXG5mdW5jdGlvbiBybWRpciAocCwgb3B0aW9ucywgb3JpZ2luYWxFciwgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIC8vIHRyeSB0byBybWRpciBmaXJzdCwgYW5kIG9ubHkgcmVhZGRpciBvbiBFTk9URU1QVFkgb3IgRUVYSVNUIChTdW5PUylcbiAgLy8gaWYgd2UgZ3Vlc3NlZCB3cm9uZywgYW5kIGl0J3Mgbm90IGEgZGlyZWN0b3J5LCB0aGVuXG4gIC8vIHJhaXNlIHRoZSBvcmlnaW5hbCBlcnJvci5cbiAgb3B0aW9ucy5ybWRpcihwLCBlciA9PiB7XG4gICAgaWYgKGVyICYmIChlci5jb2RlID09PSAnRU5PVEVNUFRZJyB8fCBlci5jb2RlID09PSAnRUVYSVNUJyB8fCBlci5jb2RlID09PSAnRVBFUk0nKSkge1xuICAgICAgcm1raWRzKHAsIG9wdGlvbnMsIGNiKVxuICAgIH0gZWxzZSBpZiAoZXIgJiYgZXIuY29kZSA9PT0gJ0VOT1RESVInKSB7XG4gICAgICBjYihvcmlnaW5hbEVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBjYihlcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJta2lkcyAocCwgb3B0aW9ucywgY2IpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBhc3NlcnQodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuXG4gIG9wdGlvbnMucmVhZGRpcihwLCAoZXIsIGZpbGVzKSA9PiB7XG4gICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpXG5cbiAgICBsZXQgbiA9IGZpbGVzLmxlbmd0aFxuICAgIGxldCBlcnJTdGF0ZVxuXG4gICAgaWYgKG4gPT09IDApIHJldHVybiBvcHRpb25zLnJtZGlyKHAsIGNiKVxuXG4gICAgZmlsZXMuZm9yRWFjaChmID0+IHtcbiAgICAgIHJpbXJhZihwYXRoLmpvaW4ocCwgZiksIG9wdGlvbnMsIGVyID0+IHtcbiAgICAgICAgaWYgKGVyclN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXJyU3RhdGUgPSBlcilcbiAgICAgICAgaWYgKC0tbiA9PT0gMCkge1xuICAgICAgICAgIG9wdGlvbnMucm1kaXIocCwgY2IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuLy8gdGhpcyBsb29rcyBzaW1wbGVyLCBhbmQgaXMgc3RyaWN0bHkgKmZhc3RlciosIGJ1dCB3aWxsXG4vLyB0aWUgdXAgdGhlIEphdmFTY3JpcHQgdGhyZWFkIGFuZCBmYWlsIG9uIGV4Y2Vzc2l2ZWx5XG4vLyBkZWVwIGRpcmVjdG9yeSB0cmVlcy5cbmZ1bmN0aW9uIHJpbXJhZlN5bmMgKHAsIG9wdGlvbnMpIHtcbiAgbGV0IHN0XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgZGVmYXVsdHMob3B0aW9ucylcblxuICBhc3NlcnQocCwgJ3JpbXJhZjogbWlzc2luZyBwYXRoJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBwLCAnc3RyaW5nJywgJ3JpbXJhZjogcGF0aCBzaG91bGQgYmUgYSBzdHJpbmcnKVxuICBhc3NlcnQob3B0aW9ucywgJ3JpbXJhZjogbWlzc2luZyBvcHRpb25zJylcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBvcHRpb25zLCAnb2JqZWN0JywgJ3JpbXJhZjogb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0JylcblxuICB0cnkge1xuICAgIHN0ID0gb3B0aW9ucy5sc3RhdFN5bmMocClcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFdpbmRvd3MgY2FuIEVQRVJNIG9uIHN0YXQuICBMaWZlIGlzIHN1ZmZlcmluZy5cbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VQRVJNJyAmJiBpc1dpbmRvd3MpIHtcbiAgICAgIGZpeFdpbkVQRVJNU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIC8vIHN1bm9zIGxldHMgdGhlIHJvb3QgdXNlciB1bmxpbmsgZGlyZWN0b3JpZXMsIHdoaWNoIGlzLi4uIHdlaXJkLlxuICAgIGlmIChzdCAmJiBzdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICBybWRpclN5bmMocCwgb3B0aW9ucywgbnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy51bmxpbmtTeW5jKHApXG4gICAgfVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIGlmIChlci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICByZXR1cm4gaXNXaW5kb3dzID8gZml4V2luRVBFUk1TeW5jKHAsIG9wdGlvbnMsIGVyKSA6IHJtZGlyU3luYyhwLCBvcHRpb25zLCBlcilcbiAgICB9IGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFSVNESVInKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgICBybWRpclN5bmMocCwgb3B0aW9ucywgZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcm1kaXJTeW5jIChwLCBvcHRpb25zLCBvcmlnaW5hbEVyKSB7XG4gIGFzc2VydChwKVxuICBhc3NlcnQob3B0aW9ucylcblxuICB0cnkge1xuICAgIG9wdGlvbnMucm1kaXJTeW5jKHApXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgdGhyb3cgb3JpZ2luYWxFclxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VOT1RFTVBUWScgfHwgZXIuY29kZSA9PT0gJ0VFWElTVCcgfHwgZXIuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgcm1raWRzU3luYyhwLCBvcHRpb25zKVxuICAgIH0gZWxzZSBpZiAoZXIuY29kZSAhPT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJta2lkc1N5bmMgKHAsIG9wdGlvbnMpIHtcbiAgYXNzZXJ0KHApXG4gIGFzc2VydChvcHRpb25zKVxuICBvcHRpb25zLnJlYWRkaXJTeW5jKHApLmZvckVhY2goZiA9PiByaW1yYWZTeW5jKHBhdGguam9pbihwLCBmKSwgb3B0aW9ucykpXG5cbiAgaWYgKGlzV2luZG93cykge1xuICAgIC8vIFdlIG9ubHkgZW5kIHVwIGhlcmUgb25jZSB3ZSBnb3QgRU5PVEVNUFRZIGF0IGxlYXN0IG9uY2UsIGFuZFxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIHdlIGFyZSBndWFyYW50ZWVkIHRvIGhhdmUgcmVtb3ZlZCBhbGwgdGhlIGtpZHMuXG4gICAgLy8gU28sIHdlIGtub3cgdGhhdCBpdCB3b24ndCBiZSBFTk9FTlQgb3IgRU5PVERJUiBvciBhbnl0aGluZyBlbHNlLlxuICAgIC8vIHRyeSByZWFsbHkgaGFyZCB0byBkZWxldGUgc3R1ZmYgb24gd2luZG93cywgYmVjYXVzZSBpdCBoYXMgYVxuICAgIC8vIFBST0ZPVU5ETFkgYW5ub3lpbmcgaGFiaXQgb2Ygbm90IGNsb3NpbmcgaGFuZGxlcyBwcm9tcHRseSB3aGVuXG4gICAgLy8gZmlsZXMgYXJlIGRlbGV0ZWQsIHJlc3VsdGluZyBpbiBzcHVyaW91cyBFTk9URU1QVFkgZXJyb3JzLlxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBkbyB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXQgPSBvcHRpb25zLnJtZGlyU3luYyhwLCBvcHRpb25zKVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfSB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IDUwMCkgLy8gZ2l2ZSB1cCBhZnRlciA1MDBtc1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJldCA9IG9wdGlvbnMucm1kaXJTeW5jKHAsIG9wdGlvbnMpXG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmltcmFmXG5yaW1yYWYuc3luYyA9IHJpbXJhZlN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbmNvbnN0IHJpbXJhZiA9IHJlcXVpcmUoJy4vcmltcmFmJylcblxuZnVuY3Rpb24gcmVtb3ZlIChwYXRoLCBjYWxsYmFjaykge1xuICAvLyBOb2RlIDE0LjE0LjArXG4gIGlmIChmcy5ybSkgcmV0dXJuIGZzLnJtKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9LCBjYWxsYmFjaylcbiAgcmltcmFmKHBhdGgsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiByZW1vdmVTeW5jIChwYXRoKSB7XG4gIC8vIE5vZGUgMTQuMTQuMCtcbiAgaWYgKGZzLnJtU3luYykgcmV0dXJuIGZzLnJtU3luYyhwYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSlcbiAgcmltcmFmLnN5bmMocGF0aClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbW92ZTogdShyZW1vdmUpLFxuICByZW1vdmVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21Qcm9taXNlXG5jb25zdCBmcyA9IHJlcXVpcmUoJy4uL2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpXG5cbmNvbnN0IGVtcHR5RGlyID0gdShhc3luYyBmdW5jdGlvbiBlbXB0eURpciAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gYXdhaXQgZnMucmVhZGRpcihkaXIpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyKVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHJlbW92ZS5yZW1vdmUocGF0aC5qb2luKGRpciwgaXRlbSkpKSlcbn0pXG5cbmZ1bmN0aW9uIGVtcHR5RGlyU3luYyAoZGlyKSB7XG4gIGxldCBpdGVtc1xuICB0cnkge1xuICAgIGl0ZW1zID0gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbWtkaXIubWtkaXJzU3luYyhkaXIpXG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGl0ZW0gPSBwYXRoLmpvaW4oZGlyLCBpdGVtKVxuICAgIHJlbW92ZS5yZW1vdmVTeW5jKGl0ZW0pXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbXB0eURpclN5bmMsXG4gIGVtcHR5ZGlyU3luYzogZW1wdHlEaXJTeW5jLFxuICBlbXB0eURpcixcbiAgZW1wdHlkaXI6IGVtcHR5RGlyXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBta2RpciA9IHJlcXVpcmUoJy4uL21rZGlycycpXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGUgKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIG1ha2VGaWxlICgpIHtcbiAgICBmcy53cml0ZUZpbGUoZmlsZSwgJycsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgY2FsbGJhY2soKVxuICAgIH0pXG4gIH1cblxuICBmcy5zdGF0KGZpbGUsIChlcnIsIHN0YXRzKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaGFuZGxlLWNhbGxiYWNrLWVyclxuICAgIGlmICghZXJyICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm4gY2FsbGJhY2soKVxuICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICAgIGZzLnN0YXQoZGlyLCAoZXJyLCBzdGF0cykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBpZiB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3QsIG1ha2UgaXRcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgIHJldHVybiBta2Rpci5ta2RpcnMoZGlyLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIG1ha2VGaWxlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0cy5pc0RpcmVjdG9yeSgpKSBtYWtlRmlsZSgpXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIG5vdCBhIGRpcmVjdG9yeVxuICAgICAgICAvLyBUaGlzIGlzIGp1c3QgdG8gY2F1c2UgYW4gaW50ZXJuYWwgRU5PVERJUiBlcnJvciB0byBiZSB0aHJvd25cbiAgICAgICAgZnMucmVhZGRpcihkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWxlU3luYyAoZmlsZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIH0gY2F0Y2gge31cbiAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRmlsZSgpKSByZXR1cm5cblxuICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSlcbiAgdHJ5IHtcbiAgICBpZiAoIWZzLnN0YXRTeW5jKGRpcikuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBhIGRpcmVjdG9yeVxuICAgICAgLy8gVGhpcyBpcyBqdXN0IHRvIGNhdXNlIGFuIGludGVybmFsIEVOT1RESVIgZXJyb3IgdG8gYmUgdGhyb3duXG4gICAgICBmcy5yZWFkZGlyU3luYyhkaXIpXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJZiB0aGUgc3RhdCBjYWxsIGFib3ZlIGZhaWxlZCBiZWNhdXNlIHRoZSBkaXJlY3RvcnkgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuICAgIGVsc2UgdGhyb3cgZXJyXG4gIH1cblxuICBmcy53cml0ZUZpbGVTeW5jKGZpbGUsICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlRmlsZTogdShjcmVhdGVGaWxlKSxcbiAgY3JlYXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcbmNvbnN0IHsgYXJlSWRlbnRpY2FsIH0gPSByZXF1aXJlKCcuLi91dGlsL3N0YXQnKVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBtYWtlTGluayAoc3JjcGF0aCwgZHN0cGF0aCkge1xuICAgIGZzLmxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgZXJyID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjYWxsYmFjayhudWxsKVxuICAgIH0pXG4gIH1cblxuICBmcy5sc3RhdChkc3RwYXRoLCAoXywgZHN0U3RhdCkgPT4ge1xuICAgIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIsIHNyY1N0YXQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIGlmIChkc3RTdGF0ICYmIGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpXG5cbiAgICAgIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgICAgcGF0aEV4aXN0cyhkaXIsIChlcnIsIGRpckV4aXN0cykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICBpZiAoZGlyRXhpc3RzKSByZXR1cm4gbWFrZUxpbmsoc3JjcGF0aCwgZHN0cGF0aClcbiAgICAgICAgbWtkaXIubWtkaXJzKGRpciwgZXJyID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuICAgICAgICAgIG1ha2VMaW5rKHNyY3BhdGgsIGRzdHBhdGgpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBkc3RTdGF0XG4gIHRyeSB7XG4gICAgZHN0U3RhdCA9IGZzLmxzdGF0U3luYyhkc3RwYXRoKVxuICB9IGNhdGNoIHt9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzcmNTdGF0ID0gZnMubHN0YXRTeW5jKHNyY3BhdGgpXG4gICAgaWYgKGRzdFN0YXQgJiYgYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm5cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVMaW5rJylcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBkaXJFeGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLmxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgpXG4gIG1rZGlyLm1rZGlyc1N5bmMoZGlyKVxuXG4gIHJldHVybiBmcy5saW5rU3luYyhzcmNwYXRoLCBkc3RwYXRoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlTGluazogdShjcmVhdGVMaW5rKSxcbiAgY3JlYXRlTGlua1N5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdHdvIHR5cGVzIG9mIHBhdGhzLCBvbmUgcmVsYXRpdmUgdG8gc3ltbGluaywgYW5kIG9uZVxuICogcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIENoZWNrcyBpZiBwYXRoIGlzIGFic29sdXRlIG9yXG4gKiByZWxhdGl2ZS4gSWYgdGhlIHBhdGggaXMgcmVsYXRpdmUsIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBwYXRoIGlzXG4gKiByZWxhdGl2ZSB0byBzeW1saW5rIG9yIHJlbGF0aXZlIHRvIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIFRoaXMgaXMgYW5cbiAqIGluaXRpYXRpdmUgdG8gZmluZCBhIHNtYXJ0ZXIgYHNyY3BhdGhgIHRvIHN1cHBseSB3aGVuIGJ1aWxkaW5nIHN5bWxpbmtzLlxuICogVGhpcyBhbGxvd3MgeW91IHRvIGRldGVybWluZSB3aGljaCBwYXRoIHRvIHVzZSBvdXQgb2Ygb25lIG9mIHRocmVlIHBvc3NpYmxlXG4gKiB0eXBlcyBvZiBzb3VyY2UgcGF0aHMuIFRoZSBmaXJzdCBpcyBhbiBhYnNvbHV0ZSBwYXRoLiBUaGlzIGlzIGRldGVjdGVkIGJ5XG4gKiBgcGF0aC5pc0Fic29sdXRlKClgLiBXaGVuIGFuIGFic29sdXRlIHBhdGggaXMgcHJvdmlkZWQsIGl0IGlzIGNoZWNrZWQgdG9cbiAqIHNlZSBpZiBpdCBleGlzdHMuIElmIGl0IGRvZXMgaXQncyB1c2VkLCBpZiBub3QgYW4gZXJyb3IgaXMgcmV0dXJuZWRcbiAqIChjYWxsYmFjaykvIHRocm93biAoc3luYykuIFRoZSBvdGhlciB0d28gb3B0aW9ucyBmb3IgYHNyY3BhdGhgIGFyZSBhXG4gKiByZWxhdGl2ZSB1cmwuIEJ5IGRlZmF1bHQgTm9kZSdzIGBmcy5zeW1saW5rYCB3b3JrcyBieSBjcmVhdGluZyBhIHN5bWxpbmtcbiAqIHVzaW5nIGBkc3RwYXRoYCBhbmQgZXhwZWN0cyB0aGUgYHNyY3BhdGhgIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBuZXdseVxuICogY3JlYXRlZCBzeW1saW5rLiBJZiB5b3UgcHJvdmlkZSBhIGBzcmNwYXRoYCB0aGF0IGRvZXMgbm90IGV4aXN0IG9uIHRoZSBmaWxlXG4gKiBzeXN0ZW0gaXQgcmVzdWx0cyBpbiBhIGJyb2tlbiBzeW1saW5rLiBUbyBtaW5pbWl6ZSB0aGlzLCB0aGUgZnVuY3Rpb25cbiAqIGNoZWNrcyB0byBzZWUgaWYgdGhlICdyZWxhdGl2ZSB0byBzeW1saW5rJyBzb3VyY2UgZmlsZSBleGlzdHMsIGFuZCBpZiBpdFxuICogZG9lcyBpdCB3aWxsIHVzZSBpdC4gSWYgaXQgZG9lcyBub3QsIGl0IGNoZWNrcyBpZiB0aGVyZSdzIGEgZmlsZSB0aGF0XG4gKiBleGlzdHMgdGhhdCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSwgaWYgZG9lcyBpdHMgdXNlZC5cbiAqIFRoaXMgcHJlc2VydmVzIHRoZSBleHBlY3RhdGlvbnMgb2YgdGhlIG9yaWdpbmFsIGZzLnN5bWxpbmsgc3BlYyBhbmQgYWRkc1xuICogdGhlIGFiaWxpdHkgdG8gcGFzcyBpbiBgcmVsYXRpdmUgdG8gY3VycmVudCB3b3JraW5nIGRpcmVjb3RyeWAgcGF0aHMuXG4gKi9cblxuZnVuY3Rpb24gc3ltbGlua1BhdGhzIChzcmNwYXRoLCBkc3RwYXRoLCBjYWxsYmFjaykge1xuICBpZiAocGF0aC5pc0Fic29sdXRlKHNyY3BhdGgpKSB7XG4gICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKCdsc3RhdCcsICdlbnN1cmVTeW1saW5rJylcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRzdGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICAgIGNvbnN0IHJlbGF0aXZlVG9Ec3QgPSBwYXRoLmpvaW4oZHN0ZGlyLCBzcmNwYXRoKVxuICAgIHJldHVybiBwYXRoRXhpc3RzKHJlbGF0aXZlVG9Ec3QsIChlcnIsIGV4aXN0cykgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgIGlmIChleGlzdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICB0b0N3ZDogcmVsYXRpdmVUb0RzdCxcbiAgICAgICAgICB0b0RzdDogc3JjcGF0aFxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZzLmxzdGF0KHNyY3BhdGgsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlLnJlcGxhY2UoJ2xzdGF0JywgJ2Vuc3VyZVN5bWxpbmsnKVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgICAgIHRvQ3dkOiBzcmNwYXRoLFxuICAgICAgICAgICAgdG9Ec3Q6IHBhdGgucmVsYXRpdmUoZHN0ZGlyLCBzcmNwYXRoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW1saW5rUGF0aHNTeW5jIChzcmNwYXRoLCBkc3RwYXRoKSB7XG4gIGxldCBleGlzdHNcbiAgaWYgKHBhdGguaXNBYnNvbHV0ZShzcmNwYXRoKSkge1xuICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICBpZiAoIWV4aXN0cykgdGhyb3cgbmV3IEVycm9yKCdhYnNvbHV0ZSBzcmNwYXRoIGRvZXMgbm90IGV4aXN0JylcbiAgICByZXR1cm4ge1xuICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICB0b0RzdDogc3JjcGF0aFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkc3RkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICBjb25zdCByZWxhdGl2ZVRvRHN0ID0gcGF0aC5qb2luKGRzdGRpciwgc3JjcGF0aClcbiAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHJlbGF0aXZlVG9Ec3QpXG4gICAgaWYgKGV4aXN0cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9Dd2Q6IHJlbGF0aXZlVG9Ec3QsXG4gICAgICAgIHRvRHN0OiBzcmNwYXRoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmMoc3JjcGF0aClcbiAgICAgIGlmICghZXhpc3RzKSB0aHJvdyBuZXcgRXJyb3IoJ3JlbGF0aXZlIHNyY3BhdGggZG9lcyBub3QgZXhpc3QnKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9Dd2Q6IHNyY3BhdGgsXG4gICAgICAgIHRvRHN0OiBwYXRoLnJlbGF0aXZlKGRzdGRpciwgc3JjcGF0aClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN5bWxpbmtQYXRocyxcbiAgc3ltbGlua1BhdGhzU3luY1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuXG5mdW5jdGlvbiBzeW1saW5rVHlwZSAoc3JjcGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG4gIGlmICh0eXBlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHlwZSlcbiAgZnMubHN0YXQoc3JjcGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ2ZpbGUnKVxuICAgIHR5cGUgPSAoc3RhdHMgJiYgc3RhdHMuaXNEaXJlY3RvcnkoKSkgPyAnZGlyJyA6ICdmaWxlJ1xuICAgIGNhbGxiYWNrKG51bGwsIHR5cGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHN5bWxpbmtUeXBlU3luYyAoc3JjcGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcblxuICBpZiAodHlwZSkgcmV0dXJuIHR5cGVcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhzcmNwYXRoKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gJ2ZpbGUnXG4gIH1cbiAgcmV0dXJuIChzdGF0cyAmJiBzdGF0cy5pc0RpcmVjdG9yeSgpKSA/ICdkaXInIDogJ2ZpbGUnXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzeW1saW5rVHlwZSxcbiAgc3ltbGlua1R5cGVTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpLmZyb21DYWxsYmFja1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgZnMgPSByZXF1aXJlKCcuLi9mcycpXG5jb25zdCBfbWtkaXJzID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IG1rZGlycyA9IF9ta2RpcnMubWtkaXJzXG5jb25zdCBta2RpcnNTeW5jID0gX21rZGlycy5ta2RpcnNTeW5jXG5cbmNvbnN0IF9zeW1saW5rUGF0aHMgPSByZXF1aXJlKCcuL3N5bWxpbmstcGF0aHMnKVxuY29uc3Qgc3ltbGlua1BhdGhzID0gX3N5bWxpbmtQYXRocy5zeW1saW5rUGF0aHNcbmNvbnN0IHN5bWxpbmtQYXRoc1N5bmMgPSBfc3ltbGlua1BhdGhzLnN5bWxpbmtQYXRoc1N5bmNcblxuY29uc3QgX3N5bWxpbmtUeXBlID0gcmVxdWlyZSgnLi9zeW1saW5rLXR5cGUnKVxuY29uc3Qgc3ltbGlua1R5cGUgPSBfc3ltbGlua1R5cGUuc3ltbGlua1R5cGVcbmNvbnN0IHN5bWxpbmtUeXBlU3luYyA9IF9zeW1saW5rVHlwZS5zeW1saW5rVHlwZVN5bmNcblxuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJy4uL3BhdGgtZXhpc3RzJykucGF0aEV4aXN0c1xuXG5jb25zdCB7IGFyZUlkZW50aWNhbCB9ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gY3JlYXRlU3ltbGluayAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gdHlwZSA6IGNhbGxiYWNrXG4gIHR5cGUgPSAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpID8gZmFsc2UgOiB0eXBlXG5cbiAgZnMubHN0YXQoZHN0cGF0aCwgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoIWVyciAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGZzLnN0YXQoc3JjcGF0aCksXG4gICAgICAgIGZzLnN0YXQoZHN0cGF0aClcbiAgICAgIF0pLnRoZW4oKFtzcmNTdGF0LCBkc3RTdGF0XSkgPT4ge1xuICAgICAgICBpZiAoYXJlSWRlbnRpY2FsKHNyY1N0YXQsIGRzdFN0YXQpKSByZXR1cm4gY2FsbGJhY2sobnVsbClcbiAgICAgICAgX2NyZWF0ZVN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgIH0gZWxzZSBfY3JlYXRlU3ltbGluayhzcmNwYXRoLCBkc3RwYXRoLCB0eXBlLCBjYWxsYmFjaylcbiAgfSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN5bWxpbmsgKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIHN5bWxpbmtQYXRocyhzcmNwYXRoLCBkc3RwYXRoLCAoZXJyLCByZWxhdGl2ZSkgPT4ge1xuICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gICAgc3ltbGlua1R5cGUocmVsYXRpdmUudG9Dd2QsIHR5cGUsIChlcnIsIHR5cGUpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpXG4gICAgICBjb25zdCBkaXIgPSBwYXRoLmRpcm5hbWUoZHN0cGF0aClcbiAgICAgIHBhdGhFeGlzdHMoZGlyLCAoZXJyLCBkaXJFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgaWYgKGRpckV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmsoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSwgY2FsbGJhY2spXG4gICAgICAgIG1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICAgICAgICBmcy5zeW1saW5rKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTeW1saW5rU3luYyAoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSkge1xuICBsZXQgc3RhdHNcbiAgdHJ5IHtcbiAgICBzdGF0cyA9IGZzLmxzdGF0U3luYyhkc3RwYXRoKVxuICB9IGNhdGNoIHt9XG4gIGlmIChzdGF0cyAmJiBzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgY29uc3Qgc3JjU3RhdCA9IGZzLnN0YXRTeW5jKHNyY3BhdGgpXG4gICAgY29uc3QgZHN0U3RhdCA9IGZzLnN0YXRTeW5jKGRzdHBhdGgpXG4gICAgaWYgKGFyZUlkZW50aWNhbChzcmNTdGF0LCBkc3RTdGF0KSkgcmV0dXJuXG4gIH1cblxuICBjb25zdCByZWxhdGl2ZSA9IHN5bWxpbmtQYXRoc1N5bmMoc3JjcGF0aCwgZHN0cGF0aClcbiAgc3JjcGF0aCA9IHJlbGF0aXZlLnRvRHN0XG4gIHR5cGUgPSBzeW1saW5rVHlwZVN5bmMocmVsYXRpdmUudG9Dd2QsIHR5cGUpXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShkc3RwYXRoKVxuICBjb25zdCBleGlzdHMgPSBmcy5leGlzdHNTeW5jKGRpcilcbiAgaWYgKGV4aXN0cykgcmV0dXJuIGZzLnN5bWxpbmtTeW5jKHNyY3BhdGgsIGRzdHBhdGgsIHR5cGUpXG4gIG1rZGlyc1N5bmMoZGlyKVxuICByZXR1cm4gZnMuc3ltbGlua1N5bmMoc3JjcGF0aCwgZHN0cGF0aCwgdHlwZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZVN5bWxpbms6IHUoY3JlYXRlU3ltbGluayksXG4gIGNyZWF0ZVN5bWxpbmtTeW5jXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpXG5jb25zdCBsaW5rID0gcmVxdWlyZSgnLi9saW5rJylcbmNvbnN0IHN5bWxpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZmlsZVxuICBjcmVhdGVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGNyZWF0ZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICBlbnN1cmVGaWxlOiBmaWxlLmNyZWF0ZUZpbGUsXG4gIGVuc3VyZUZpbGVTeW5jOiBmaWxlLmNyZWF0ZUZpbGVTeW5jLFxuICAvLyBsaW5rXG4gIGNyZWF0ZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgY3JlYXRlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIGVuc3VyZUxpbms6IGxpbmsuY3JlYXRlTGluayxcbiAgZW5zdXJlTGlua1N5bmM6IGxpbmsuY3JlYXRlTGlua1N5bmMsXG4gIC8vIHN5bWxpbmtcbiAgY3JlYXRlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBjcmVhdGVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luYyxcbiAgZW5zdXJlU3ltbGluazogc3ltbGluay5jcmVhdGVTeW1saW5rLFxuICBlbnN1cmVTeW1saW5rU3luYzogc3ltbGluay5jcmVhdGVTeW1saW5rU3luY1xufVxuIiwiZnVuY3Rpb24gc3RyaW5naWZ5IChvYmosIHsgRU9MID0gJ1xcbicsIGZpbmFsRU9MID0gdHJ1ZSwgcmVwbGFjZXIgPSBudWxsLCBzcGFjZXMgfSA9IHt9KSB7XG4gIGNvbnN0IEVPRiA9IGZpbmFsRU9MID8gRU9MIDogJydcbiAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VzKVxuXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxuL2csIEVPTCkgKyBFT0Zcbn1cblxuZnVuY3Rpb24gc3RyaXBCb20gKGNvbnRlbnQpIHtcbiAgLy8gd2UgZG8gdGhpcyBiZWNhdXNlIEpTT04ucGFyc2Ugd291bGQgY29udmVydCBpdCB0byBhIHV0Zjggc3RyaW5nIGlmIGVuY29kaW5nIHdhc24ndCBzcGVjaWZpZWRcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSkgY29udGVudCA9IGNvbnRlbnQudG9TdHJpbmcoJ3V0ZjgnKVxuICByZXR1cm4gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3RyaW5naWZ5LCBzdHJpcEJvbSB9XG4iLCJsZXQgX2ZzXG50cnkge1xuICBfZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG59IGNhdGNoIChfKSB7XG4gIF9mcyA9IHJlcXVpcmUoJ2ZzJylcbn1cbmNvbnN0IHVuaXZlcnNhbGlmeSA9IHJlcXVpcmUoJ3VuaXZlcnNhbGlmeScpXG5jb25zdCB7IHN0cmluZ2lmeSwgc3RyaXBCb20gfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuXG5hc3luYyBmdW5jdGlvbiBfcmVhZEZpbGUgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIGxldCBkYXRhID0gYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy5yZWFkRmlsZSkoZmlsZSwgb3B0aW9ucylcblxuICBkYXRhID0gc3RyaXBCb20oZGF0YSlcblxuICBsZXQgb2JqXG4gIHRyeSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShkYXRhLCBvcHRpb25zID8gb3B0aW9ucy5yZXZpdmVyIDogbnVsbClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICBlcnIubWVzc2FnZSA9IGAke2ZpbGV9OiAke2Vyci5tZXNzYWdlfWBcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuY29uc3QgcmVhZEZpbGUgPSB1bml2ZXJzYWxpZnkuZnJvbVByb21pc2UoX3JlYWRGaWxlKVxuXG5mdW5jdGlvbiByZWFkRmlsZVN5bmMgKGZpbGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucyA9IHsgZW5jb2Rpbmc6IG9wdGlvbnMgfVxuICB9XG5cbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHNob3VsZFRocm93ID0gJ3Rocm93cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGhyb3dzIDogdHJ1ZVxuXG4gIHRyeSB7XG4gICAgbGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgb3B0aW9ucylcbiAgICBjb250ZW50ID0gc3RyaXBCb20oY29udGVudClcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50LCBvcHRpb25zLnJldml2ZXIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlfTogJHtlcnIubWVzc2FnZX1gXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3dyaXRlRmlsZSAoZmlsZSwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZnMgPSBvcHRpb25zLmZzIHx8IF9mc1xuXG4gIGNvbnN0IHN0ciA9IHN0cmluZ2lmeShvYmosIG9wdGlvbnMpXG5cbiAgYXdhaXQgdW5pdmVyc2FsaWZ5LmZyb21DYWxsYmFjayhmcy53cml0ZUZpbGUpKGZpbGUsIHN0ciwgb3B0aW9ucylcbn1cblxuY29uc3Qgd3JpdGVGaWxlID0gdW5pdmVyc2FsaWZ5LmZyb21Qcm9taXNlKF93cml0ZUZpbGUpXG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVN5bmMgKGZpbGUsIG9iaiwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGZzID0gb3B0aW9ucy5mcyB8fCBfZnNcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkob2JqLCBvcHRpb25zKVxuICAvLyBub3Qgc3VyZSBpZiBmcy53cml0ZUZpbGVTeW5jIHJldHVybnMgYW55dGhpbmcsIGJ1dCBqdXN0IGluIGNhc2VcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgc3RyLCBvcHRpb25zKVxufVxuXG5jb25zdCBqc29uZmlsZSA9IHtcbiAgcmVhZEZpbGUsXG4gIHJlYWRGaWxlU3luYyxcbiAgd3JpdGVGaWxlLFxuICB3cml0ZUZpbGVTeW5jXG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbmZpbGVcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBqc29uRmlsZSA9IHJlcXVpcmUoJ2pzb25maWxlJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGpzb25maWxlIGV4cG9ydHNcbiAgcmVhZEpzb246IGpzb25GaWxlLnJlYWRGaWxlLFxuICByZWFkSnNvblN5bmM6IGpzb25GaWxlLnJlYWRGaWxlU3luYyxcbiAgd3JpdGVKc29uOiBqc29uRmlsZS53cml0ZUZpbGUsXG4gIHdyaXRlSnNvblN5bmM6IGpzb25GaWxlLndyaXRlRmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbUNhbGxiYWNrXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2dyYWNlZnVsLWZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG1rZGlyID0gcmVxdWlyZSgnLi4vbWtkaXJzJylcbmNvbnN0IHBhdGhFeGlzdHMgPSByZXF1aXJlKCcuLi9wYXRoLWV4aXN0cycpLnBhdGhFeGlzdHNcblxuZnVuY3Rpb24gb3V0cHV0RmlsZSAoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBwYXRoRXhpc3RzKGRpciwgKGVyciwgaXREb2VzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycilcbiAgICBpZiAoaXREb2VzKSByZXR1cm4gZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaylcblxuICAgIG1rZGlyLm1rZGlycyhkaXIsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKVxuXG4gICAgICBmcy53cml0ZUZpbGUoZmlsZSwgZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKVxuICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG91dHB1dEZpbGVTeW5jIChmaWxlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGRpciA9IHBhdGguZGlybmFtZShmaWxlKVxuICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgLi4uYXJncylcbiAgfVxuICBta2Rpci5ta2RpcnNTeW5jKGRpcilcbiAgZnMud3JpdGVGaWxlU3luYyhmaWxlLCAuLi5hcmdzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3V0cHV0RmlsZTogdShvdXRwdXRGaWxlKSxcbiAgb3V0cHV0RmlsZVN5bmNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHN0cmluZ2lmeSB9ID0gcmVxdWlyZSgnanNvbmZpbGUvdXRpbHMnKVxuY29uc3QgeyBvdXRwdXRGaWxlIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQnKVxuXG5hc3luYyBmdW5jdGlvbiBvdXRwdXRKc29uIChmaWxlLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RyID0gc3RyaW5naWZ5KGRhdGEsIG9wdGlvbnMpXG5cbiAgYXdhaXQgb3V0cHV0RmlsZShmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdqc29uZmlsZS91dGlscycpXG5jb25zdCB7IG91dHB1dEZpbGVTeW5jIH0gPSByZXF1aXJlKCcuLi9vdXRwdXQnKVxuXG5mdW5jdGlvbiBvdXRwdXRKc29uU3luYyAoZmlsZSwgZGF0YSwgb3B0aW9ucykge1xuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoZGF0YSwgb3B0aW9ucylcblxuICBvdXRwdXRGaWxlU3luYyhmaWxlLCBzdHIsIG9wdGlvbnMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0cHV0SnNvblN5bmNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1ID0gcmVxdWlyZSgndW5pdmVyc2FsaWZ5JykuZnJvbVByb21pc2VcbmNvbnN0IGpzb25GaWxlID0gcmVxdWlyZSgnLi9qc29uZmlsZScpXG5cbmpzb25GaWxlLm91dHB1dEpzb24gPSB1KHJlcXVpcmUoJy4vb3V0cHV0LWpzb24nKSlcbmpzb25GaWxlLm91dHB1dEpzb25TeW5jID0gcmVxdWlyZSgnLi9vdXRwdXQtanNvbi1zeW5jJylcbi8vIGFsaWFzZXNcbmpzb25GaWxlLm91dHB1dEpTT04gPSBqc29uRmlsZS5vdXRwdXRKc29uXG5qc29uRmlsZS5vdXRwdXRKU09OU3luYyA9IGpzb25GaWxlLm91dHB1dEpzb25TeW5jXG5qc29uRmlsZS53cml0ZUpTT04gPSBqc29uRmlsZS53cml0ZUpzb25cbmpzb25GaWxlLndyaXRlSlNPTlN5bmMgPSBqc29uRmlsZS53cml0ZUpzb25TeW5jXG5qc29uRmlsZS5yZWFkSlNPTiA9IGpzb25GaWxlLnJlYWRKc29uXG5qc29uRmlsZS5yZWFkSlNPTlN5bmMgPSBqc29uRmlsZS5yZWFkSnNvblN5bmNcblxubW9kdWxlLmV4cG9ydHMgPSBqc29uRmlsZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZ3JhY2VmdWwtZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY29weVN5bmMgPSByZXF1aXJlKCcuLi9jb3B5LXN5bmMnKS5jb3B5U3luY1xuY29uc3QgcmVtb3ZlU3luYyA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVN5bmNcbmNvbnN0IG1rZGlycFN5bmMgPSByZXF1aXJlKCcuLi9ta2RpcnMnKS5ta2RpcnBTeW5jXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gbW92ZVN5bmMgKHNyYywgZGVzdCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBjb25zdCBvdmVyd3JpdGUgPSBvcHRzLm92ZXJ3cml0ZSB8fCBvcHRzLmNsb2JiZXIgfHwgZmFsc2VcblxuICBjb25zdCB7IHNyY1N0YXQsIGlzQ2hhbmdpbmdDYXNlID0gZmFsc2UgfSA9IHN0YXQuY2hlY2tQYXRoc1N5bmMoc3JjLCBkZXN0LCAnbW92ZScsIG9wdHMpXG4gIHN0YXQuY2hlY2tQYXJlbnRQYXRoc1N5bmMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnbW92ZScpXG4gIGlmICghaXNQYXJlbnRSb290KGRlc3QpKSBta2RpcnBTeW5jKHBhdGguZGlybmFtZShkZXN0KSlcbiAgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSlcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRSb290IChkZXN0KSB7XG4gIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aC5wYXJzZShwYXJlbnQpXG4gIHJldHVybiBwYXJzZWRQYXRoLnJvb3QgPT09IHBhcmVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlKSB7XG4gIGlmIChpc0NoYW5naW5nQ2FzZSkgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIHJlbW92ZVN5bmMoZGVzdClcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG4gIGlmIChmcy5leGlzdHNTeW5jKGRlc3QpKSB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3QgYWxyZWFkeSBleGlzdHMuJylcbiAgcmV0dXJuIHJlbmFtZShzcmMsIGRlc3QsIG92ZXJ3cml0ZSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSkge1xuICB0cnkge1xuICAgIGZzLnJlbmFtZVN5bmMoc3JjLCBkZXN0KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHRocm93IGVyclxuICAgIHJldHVybiBtb3ZlQWNyb3NzRGV2aWNlKHNyYywgZGVzdCwgb3ZlcndyaXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVBY3Jvc3NEZXZpY2UgKHNyYywgZGVzdCwgb3ZlcndyaXRlKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgb3ZlcndyaXRlLFxuICAgIGVycm9yT25FeGlzdDogdHJ1ZVxuICB9XG4gIGNvcHlTeW5jKHNyYywgZGVzdCwgb3B0cylcbiAgcmV0dXJuIHJlbW92ZVN5bmMoc3JjKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vdmVTeW5jXG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1vdmVTeW5jOiByZXF1aXJlKCcuL21vdmUtc3luYycpXG59XG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgZnMgPSByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjb3B5ID0gcmVxdWlyZSgnLi4vY29weScpLmNvcHlcbmNvbnN0IHJlbW92ZSA9IHJlcXVpcmUoJy4uL3JlbW92ZScpLnJlbW92ZVxuY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnLi4vbWtkaXJzJykubWtkaXJwXG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgnLi4vcGF0aC1leGlzdHMnKS5wYXRoRXhpc3RzXG5jb25zdCBzdGF0ID0gcmVxdWlyZSgnLi4vdXRpbC9zdGF0JylcblxuZnVuY3Rpb24gbW92ZSAoc3JjLCBkZXN0LCBvcHRzLCBjYikge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuXG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IG9wdHMuY2xvYmJlciB8fCBmYWxzZVxuXG4gIHN0YXQuY2hlY2tQYXRocyhzcmMsIGRlc3QsICdtb3ZlJywgb3B0cywgKGVyciwgc3RhdHMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGNvbnN0IHsgc3JjU3RhdCwgaXNDaGFuZ2luZ0Nhc2UgPSBmYWxzZSB9ID0gc3RhdHNcbiAgICBzdGF0LmNoZWNrUGFyZW50UGF0aHMoc3JjLCBzcmNTdGF0LCBkZXN0LCAnbW92ZScsIGVyciA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKGlzUGFyZW50Um9vdChkZXN0KSkgcmV0dXJuIGRvUmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBpc0NoYW5naW5nQ2FzZSwgY2IpXG4gICAgICBta2RpcnAocGF0aC5kaXJuYW1lKGRlc3QpLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgICByZXR1cm4gZG9SZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlLCBjYilcbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNQYXJlbnRSb290IChkZXN0KSB7XG4gIGNvbnN0IHBhcmVudCA9IHBhdGguZGlybmFtZShkZXN0KVxuICBjb25zdCBwYXJzZWRQYXRoID0gcGF0aC5wYXJzZShwYXJlbnQpXG4gIHJldHVybiBwYXJzZWRQYXRoLnJvb3QgPT09IHBhcmVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmFtZSAoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGlzQ2hhbmdpbmdDYXNlLCBjYikge1xuICBpZiAoaXNDaGFuZ2luZ0Nhc2UpIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICBpZiAob3ZlcndyaXRlKSB7XG4gICAgcmV0dXJuIHJlbW92ZShkZXN0LCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAgIHJldHVybiByZW5hbWUoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICAgIH0pXG4gIH1cbiAgcGF0aEV4aXN0cyhkZXN0LCAoZXJyLCBkZXN0RXhpc3RzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoZGVzdEV4aXN0cykgcmV0dXJuIGNiKG5ldyBFcnJvcignZGVzdCBhbHJlYWR5IGV4aXN0cy4nKSlcbiAgICByZXR1cm4gcmVuYW1lKHNyYywgZGVzdCwgb3ZlcndyaXRlLCBjYilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVuYW1lIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpIHtcbiAgZnMucmVuYW1lKHNyYywgZGVzdCwgZXJyID0+IHtcbiAgICBpZiAoIWVycikgcmV0dXJuIGNiKClcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFWERFVicpIHJldHVybiBjYihlcnIpXG4gICAgcmV0dXJuIG1vdmVBY3Jvc3NEZXZpY2Uoc3JjLCBkZXN0LCBvdmVyd3JpdGUsIGNiKVxuICB9KVxufVxuXG5mdW5jdGlvbiBtb3ZlQWNyb3NzRGV2aWNlIChzcmMsIGRlc3QsIG92ZXJ3cml0ZSwgY2IpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBvdmVyd3JpdGUsXG4gICAgZXJyb3JPbkV4aXN0OiB0cnVlXG4gIH1cbiAgY29weShzcmMsIGRlc3QsIG9wdHMsIGVyciA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICByZXR1cm4gcmVtb3ZlKHNyYywgY2IpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW92ZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHUgPSByZXF1aXJlKCd1bml2ZXJzYWxpZnknKS5mcm9tQ2FsbGJhY2tcbm1vZHVsZS5leHBvcnRzID0ge1xuICBtb3ZlOiB1KHJlcXVpcmUoJy4vbW92ZScpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBFeHBvcnQgcHJvbWlzZWlmaWVkIGdyYWNlZnVsLWZzOlxuICAuLi5yZXF1aXJlKCcuL2ZzJyksXG4gIC8vIEV4cG9ydCBleHRyYSBtZXRob2RzOlxuICAuLi5yZXF1aXJlKCcuL2NvcHktc3luYycpLFxuICAuLi5yZXF1aXJlKCcuL2NvcHknKSxcbiAgLi4ucmVxdWlyZSgnLi9lbXB0eScpLFxuICAuLi5yZXF1aXJlKCcuL2Vuc3VyZScpLFxuICAuLi5yZXF1aXJlKCcuL2pzb24nKSxcbiAgLi4ucmVxdWlyZSgnLi9ta2RpcnMnKSxcbiAgLi4ucmVxdWlyZSgnLi9tb3ZlLXN5bmMnKSxcbiAgLi4ucmVxdWlyZSgnLi9tb3ZlJyksXG4gIC4uLnJlcXVpcmUoJy4vb3V0cHV0JyksXG4gIC4uLnJlcXVpcmUoJy4vcGF0aC1leGlzdHMnKSxcbiAgLi4ucmVxdWlyZSgnLi9yZW1vdmUnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNsYXNzIENhbmNlbGxhdGlvblRva2VuIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvLyBiYWJlbCBjYW5ub3QgY29tcGlsZSAuLi4gY29ycmVjdGx5IGZvciBzdXBlciBjYWxsc1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FuY2VsbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsbGVkIHx8ICh0aGlzLl9wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLl9wYXJlbnQuY2FuY2VsbGVkKTtcbiAgICB9XG4gICAgc2V0IHBhcmVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlciA9ICgpID0+IHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX3BhcmVudC5vbkNhbmNlbCh0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImNhbmNlbFwiKTtcbiAgICB9XG4gICAgb25DYW5jZWwoaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZShcImNhbmNlbFwiLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVQcm9taXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbGx5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIGNhbmNlbEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRlZENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICAgICAgY2FuY2VsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRDYW5jZWxIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRDYW5jZWxIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDYW5jZWxsYXRpb25FcnJvcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25DYW5jZWwoY2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNvbHZlLCByZWplY3QsIChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZGVkQ2FuY2VsSGFuZGxlciA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihpdCA9PiB7XG4gICAgICAgICAgICBmaW5hbGx5SGFuZGxlcigpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgZmluYWxseUhhbmRsZXIoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVQYXJlbnRDYW5jZWxIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gbnVsbCAmJiB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUxpc3RlbmVyKFwiY2FuY2VsXCIsIHRoaXMucGFyZW50Q2FuY2VsSGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnBhcmVudENhbmNlbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhcmVudENhbmNlbEhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IENhbmNlbGxhdGlvblRva2VuO1xuY2xhc3MgQ2FuY2VsbGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiY2FuY2VsbGVkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FuY2VsbGF0aW9uRXJyb3IgPSBDYW5jZWxsYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbmNlbGxhdGlvblRva2VuLmpzLm1hcCIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKHRvdGFsLCBjYW5jZWxsYXRpb25Ub2tlbiwgb25Qcm9ncmVzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbjtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgPSAwO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gdGhpcy5zdGFydCArIDEwMDA7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMuZGVsdGEgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93ID49IHRoaXMubmV4dFVwZGF0ZSAmJiB0aGlzLnRyYW5zZmVycmVkICE9PSB0aGlzLnRvdGFsIC8qIHdpbGwgYmUgZW1pdHRlZCBvbiBfZmx1c2ggKi8pIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFVwZGF0ZSA9IG5vdyArIDEwMDA7XG4gICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgIHRvdGFsOiB0aGlzLnRvdGFsLFxuICAgICAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRyYW5zZmVycmVkLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6ICh0aGlzLnRyYW5zZmVycmVkIC8gdGhpcy50b3RhbCkgKiAxMDAsXG4gICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgobm93IC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGxhdGlvblRva2VuLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiY2FuY2VsbGVkXCIpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgdG90YWw6IHRoaXMudG90YWwsXG4gICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRvdGFsLFxuICAgICAgICAgICAgcGVyY2VudDogMTAwLFxuICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgoRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQpIC8gMTAwMCkpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWx0YSA9IDA7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybSA9IFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zYWZlU3RyaW5naWZ5SnNvbiA9IGV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMgPSBleHBvcnRzLnNhZmVHZXRIZWFkZXIgPSBleHBvcnRzLkRpZ2VzdFRyYW5zZm9ybSA9IGV4cG9ydHMuY29uZmlndXJlUmVxdWVzdFVybCA9IGV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBleHBvcnRzLnBhcnNlSnNvbiA9IGV4cG9ydHMuSHR0cEVycm9yID0gZXhwb3J0cy5jcmVhdGVIdHRwRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IENhbmNlbGxhdGlvblRva2VuXzEgPSByZXF1aXJlKFwiLi9DYW5jZWxsYXRpb25Ub2tlblwiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbmNvbnN0IFByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm1cIik7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdChcImVsZWN0cm9uLWJ1aWxkZXJcIik7XG5mdW5jdGlvbiBjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGRlc2NyaXB0aW9uID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgSHR0cEVycm9yKHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgLTEsIGAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9ICR7cmVzcG9uc2Uuc3RhdHVzTWVzc2FnZX1gICtcbiAgICAgICAgKGRlc2NyaXB0aW9uID09IG51bGwgPyBcIlwiIDogXCJcXG5cIiArIEpTT04uc3RyaW5naWZ5KGRlc2NyaXB0aW9uLCBudWxsLCBcIiAgXCIpKSArXG4gICAgICAgIFwiXFxuSGVhZGVyczogXCIgK1xuICAgICAgICBzYWZlU3RyaW5naWZ5SnNvbihyZXNwb25zZS5oZWFkZXJzKSwgZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5jcmVhdGVIdHRwRXJyb3IgPSBjcmVhdGVIdHRwRXJyb3I7XG5jb25zdCBIVFRQX1NUQVRVU19DT0RFUyA9IG5ldyBNYXAoW1xuICAgIFs0MjksIFwiVG9vIG1hbnkgcmVxdWVzdHNcIl0sXG4gICAgWzQwMCwgXCJCYWQgcmVxdWVzdFwiXSxcbiAgICBbNDAzLCBcIkZvcmJpZGRlblwiXSxcbiAgICBbNDA0LCBcIk5vdCBmb3VuZFwiXSxcbiAgICBbNDA1LCBcIk1ldGhvZCBub3QgYWxsb3dlZFwiXSxcbiAgICBbNDA2LCBcIk5vdCBhY2NlcHRhYmxlXCJdLFxuICAgIFs0MDgsIFwiUmVxdWVzdCB0aW1lb3V0XCJdLFxuICAgIFs0MTMsIFwiUmVxdWVzdCBlbnRpdHkgdG9vIGxhcmdlXCJdLFxuICAgIFs1MDAsIFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCJdLFxuICAgIFs1MDIsIFwiQmFkIGdhdGV3YXlcIl0sXG4gICAgWzUwMywgXCJTZXJ2aWNlIHVuYXZhaWxhYmxlXCJdLFxuICAgIFs1MDQsIFwiR2F0ZXdheSB0aW1lb3V0XCJdLFxuICAgIFs1MDUsIFwiSFRUUCB2ZXJzaW9uIG5vdCBzdXBwb3J0ZWRcIl0sXG5dKTtcbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBtZXNzYWdlID0gYEhUVFAgZXJyb3I6ICR7SFRUUF9TVEFUVVNfQ09ERVMuZ2V0KHN0YXR1c0NvZGUpIHx8IHN0YXR1c0NvZGV9YCwgZGVzY3JpcHRpb24gPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSHR0cEVycm9yXCI7XG4gICAgICAgIHRoaXMuY29kZSA9IGBIVFRQX0VSUk9SXyR7c3RhdHVzQ29kZX1gO1xuICAgIH1cbiAgICBpc1NlcnZlckVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXNDb2RlID49IDUwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPD0gNTk5O1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cEVycm9yID0gSHR0cEVycm9yO1xuZnVuY3Rpb24gcGFyc2VKc29uKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQudGhlbihpdCA9PiAoaXQgPT0gbnVsbCB8fCBpdC5sZW5ndGggPT09IDAgPyBudWxsIDogSlNPTi5wYXJzZShpdCkpKTtcbn1cbmV4cG9ydHMucGFyc2VKc29uID0gcGFyc2VKc29uO1xuY2xhc3MgSHR0cEV4ZWN1dG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXhSZWRpcmVjdHMgPSAxMDtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlbl8xLkNhbmNlbGxhdGlvblRva2VuKCksIGRhdGEpIHtcbiAgICAgICAgY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGpzb24gPSBkYXRhID09IG51bGwgPyB1bmRlZmluZWQgOiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgZW5jb2RlZERhdGEgPSBqc29uID8gQnVmZmVyLmZyb20oanNvbikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChlbmNvZGVkRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWJ1Zyhqc29uKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVycywgLi4ub3B0cyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInBvc3RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IGVuY29kZWREYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgaXQgPT4ge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaXQuZW5kKGVuY29kZWREYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCA9IDApIHtcbiAgICAgICAgaWYgKGRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKGBSZXF1ZXN0OiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxsYXRpb25Ub2tlbi5jcmVhdGVQcm9taXNlKChyZXNvbHZlLCByZWplY3QsIG9uQ2FuY2VsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KG9wdGlvbnMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMsIGNhbmNlbGxhdGlvblRva2VuLCByZXNvbHZlLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIHJlcXVlc3RQcm9jZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yQW5kVGltZW91dEhhbmRsZXJzKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICB0aGlzLmFkZFJlZGlyZWN0SGFuZGxlcnMocmVxdWVzdCwgb3B0aW9ucywgcmVqZWN0LCByZWRpcmVjdENvdW50LCBvcHRpb25zID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQXBpUmVxdWVzdChvcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXF1ZXN0UHJvY2Vzc29yKHJlcXVlc3QsIHJlamVjdCk7XG4gICAgICAgICAgICBvbkNhbmNlbCgoKSA9PiByZXF1ZXN0LmFib3J0KCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgYWRkUmVkaXJlY3RIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLCByZWplY3QsIHJlZGlyZWN0Q291bnQsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gbm90IHJlcXVpcmVkIGZvciBOb2RlSlNcbiAgICB9XG4gICAgYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KSB7XG4gICAgICAgIHRoaXMuYWRkVGltZU91dEhhbmRsZXIocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgcmVxdWVzdC5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJhYm9ydGVkXCIsICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJSZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQgYnkgdGhlIHNlcnZlclwiKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgb3B0aW9ucywgY2FuY2VsbGF0aW9uVG9rZW4sIHJlc29sdmUsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgcmVxdWVzdFByb2Nlc3Nvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhgUmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX0gJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfSwgcmVxdWVzdCBvcHRpb25zOiAke3NhZmVTdHJpbmdpZnlKc29uKG9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhbmRsZSBhbnkgb3RoZXIgPj0gNDAwIGVycm9yIG9uIHJlcXVlc3QgZW5kIChyZWFkIGRldGFpbGVkIG1lc3NhZ2UgaW4gdGhlIHJlc3BvbnNlIGJvZHkpXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgIC8vIGVycm9yIGlzIGNsZWFyLCB3ZSBkb24ndCBuZWVkIHRvIHJlYWQgZGV0YWlsZWQgZXJyb3IgZGVzY3JpcHRpb25cbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UsIGBtZXRob2Q6ICR7b3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIn0gdXJsOiAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7b3B0aW9ucy5ob3N0bmFtZX0ke29wdGlvbnMucG9ydCA/IGA6JHtvcHRpb25zLnBvcnR9YCA6IFwiXCJ9JHtvcHRpb25zLnBhdGh9XG5cblBsZWFzZSBkb3VibGUgY2hlY2sgdGhhdCB5b3VyIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlzIGNvcnJlY3QuIER1ZSB0byBzZWN1cml0eSByZWFzb25zLCBhY3R1YWwgc3RhdHVzIG1heWJlIG5vdCByZXBvcnRlZCwgYnV0IDQwNC5cbmApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDQpIHtcbiAgICAgICAgICAgIC8vIG9uIERFTEVURSByZXF1ZXN0XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IChfYSA9IHJlc3BvbnNlLnN0YXR1c0NvZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZGlyZWN0ID0gY29kZSA+PSAzMDAgJiYgY29kZSA8IDQwMDtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVkaXJlY3QgJiYgcmVkaXJlY3RVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0Q291bnQgPiB0aGlzLm1heFJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb0FwaVJlcXVlc3QoSHR0cEV4ZWN1dG9yLnByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpLCBjYW5jZWxsYXRpb25Ub2tlbiwgcmVxdWVzdFByb2Nlc3NvciwgcmVkaXJlY3RDb3VudCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbnNlLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICByZXNwb25zZS5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IChkYXRhICs9IGNodW5rKSk7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT0gbnVsbCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZSAhPSBudWxsICYmIChBcnJheS5pc0FycmF5KGNvbnRlbnRUeXBlKSA/IGNvbnRlbnRUeXBlLmZpbmQoaXQgPT4gaXQuaW5jbHVkZXMoXCJqc29uXCIpKSAhPSBudWxsIDogY29udGVudFR5cGUuaW5jbHVkZXMoXCJqc29uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGNyZWF0ZUh0dHBFcnJvcihyZXNwb25zZSwgYG1ldGhvZDogJHtvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwifSB1cmw6ICR7b3B0aW9ucy5wcm90b2NvbCB8fCBcImh0dHBzOlwifS8vJHtvcHRpb25zLmhvc3RuYW1lfSR7b3B0aW9ucy5wb3J0ID8gYDoke29wdGlvbnMucG9ydH1gIDogXCJcIn0ke29wdGlvbnMucGF0aH1cblxuICAgICAgICAgIERhdGE6XG4gICAgICAgICAgJHtpc0pzb24gPyBKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKGRhdGEpKSA6IGRhdGF9XG4gICAgICAgICAgYCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvd25sb2FkVG9CdWZmZXIodXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBvcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLmNyZWF0ZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIFByaXZhdGVHaXRIdWJQcm92aWRlciByZXF1aXJlcyBIdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyBsb2dpYywgc28sIHdlIG5lZWQgdG8gcmVkaXJlY3QgbWFudWFsbHlcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJtYW51YWxcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25maWd1cmVSZXF1ZXN0VXJsKHVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgY29uZmlndXJlUmVxdWVzdE9wdGlvbnMocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvbkNhbmNlbCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyOiAocmVzcG9uc2UsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtbGVuZ3RoXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gNTI0Mjg4MDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIk1heGltdW0gYWxsb3dlZCBzaXplIGlzIDUwMCBNQlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gQnVmZmVyLmFsbG9jKHNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuY29weShyZXN1bHQsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiA1MjQyODgwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKFwiTWF4aW11bSBhbGxvd2VkIHNpemUgaXMgNTAwIE1CXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQsIGNodW5rXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgcG9zaXRpb24gIT09IC0xICYmIHBvc2l0aW9uICE9PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBSZWNlaXZlZCBkYXRhIGxlbmd0aCAke3Bvc2l0aW9ufSBpcyBub3QgZXF1YWwgdG8gZXhwZWN0ZWQgJHtyZXN1bHQubGVuZ3RofWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0Rvd25sb2FkKHJlcXVlc3RPcHRpb25zLCBvcHRpb25zLCByZWRpcmVjdENvdW50KSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhuZXcgRXJyb3IoYENhbm5vdCBkb3dubG9hZCBcIiR7cmVxdWVzdE9wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwczpcIn0vLyR7cmVxdWVzdE9wdGlvbnMuaG9zdG5hbWV9JHtyZXF1ZXN0T3B0aW9ucy5wYXRofVwiLCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXNDb2RlfTogJHtyZXNwb25zZS5zdGF0dXNNZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHJlc3BvbnNlIHN0cmVhbSB0byBmYWlsLCBlLmcuIHdoZW4gYSBuZXR3b3JrIGlzIGxvc3Qgd2hpbGVcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIHN0cmVhbSBpcyBpbiBwcm9ncmVzcy4gU3RvcCB3YWl0aW5nIGFuZCByZWplY3Qgc28gY29uc3VtZXIgY2FuIGNhdGNoIHRoZSBlcnJvci5cbiAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZXJyb3JcIiwgb3B0aW9ucy5jYWxsYmFjayk7XG4gICAgICAgICAgICAvLyB0aGlzIGNvZGUgbm90IHJlbGV2YW50IGZvciBFbGVjdHJvbiAocmVkaXJlY3QgZXZlbnQgaW5zdGVhZCBoYW5kbGVkKVxuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVcmwgPSBzYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA8IHRoaXMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChIdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyhyZWRpcmVjdFVybCwgcmVxdWVzdE9wdGlvbnMpLCBvcHRpb25zLCByZWRpcmVjdENvdW50KyspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayh0aGlzLmNyZWF0ZU1heFJlZGlyZWN0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlc3BvbnNlSGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlUGlwZXMob3B0aW9ucywgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNwb25zZUhhbmRsZXIocmVzcG9uc2UsIG9wdGlvbnMuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCBvcHRpb25zLmNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5hZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIHJlcXVlc3RPcHRpb25zLCBvcHRpb25zLmNhbGxiYWNrLCByZWRpcmVjdENvdW50LCByZXF1ZXN0T3B0aW9ucyA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvRG93bmxvYWQocmVxdWVzdE9wdGlvbnMsIG9wdGlvbnMsIHJlZGlyZWN0Q291bnQrKyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH1cbiAgICBjcmVhdGVNYXhSZWRpcmVjdEVycm9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBUb28gbWFueSByZWRpcmVjdHMgKD4gJHt0aGlzLm1heFJlZGlyZWN0c30pYCk7XG4gICAgfVxuICAgIGFkZFRpbWVPdXRIYW5kbGVyKHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJlcXVlc3Qub24oXCJzb2NrZXRcIiwgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQoNjAgKiAxMDAwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIlJlcXVlc3QgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHByZXBhcmVSZWRpcmVjdFVybE9wdGlvbnMocmVkaXJlY3RVcmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zRnJvbVVybChyZWRpcmVjdFVybCwgeyAuLi5vcHRpb25zIH0pO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3T3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICBpZiAoaGVhZGVycyA9PT0gbnVsbCB8fCBoZWFkZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE5ld1VybCA9IG5ldyB1cmxfMS5VUkwocmVkaXJlY3RVcmwpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE5ld1VybC5ob3N0bmFtZS5lbmRzV2l0aChcIi5hbWF6b25hd3MuY29tXCIpIHx8IHBhcnNlZE5ld1VybC5zZWFyY2hQYXJhbXMuaGFzKFwiWC1BbXotQ3JlZGVudGlhbFwiKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XG4gICAgfVxuICAgIHN0YXRpYyByZXRyeU9uU2VydmVyRXJyb3IodGFzaywgbWF4UmV0cmllcyA9IDMpIHtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdE51bWJlciA9IDA7OyBhdHRlbXB0TnVtYmVyKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHROdW1iZXIgPCBtYXhSZXRyaWVzICYmICgoZSBpbnN0YW5jZW9mIEh0dHBFcnJvciAmJiBlLmlzU2VydmVyRXJyb3IoKSkgfHwgZS5jb2RlID09PSBcIkVQSVBFXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwRXhlY3V0b3IgPSBIdHRwRXhlY3V0b3I7XG5mdW5jdGlvbiBjb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uZmlndXJlUmVxdWVzdFVybChuZXcgdXJsXzEuVVJMKHVybCksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsID0gY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsO1xuZnVuY3Rpb24gY29uZmlndXJlUmVxdWVzdFVybCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnByb3RvY29sID0gdXJsLnByb3RvY29sO1xuICAgIG9wdGlvbnMuaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWU7XG4gICAgaWYgKHVybC5wb3J0KSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IHVybC5wb3J0O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMucG9ydDtcbiAgICB9XG4gICAgb3B0aW9ucy5wYXRoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbn1cbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdFVybCA9IGNvbmZpZ3VyZVJlcXVlc3RVcmw7XG5jbGFzcyBEaWdlc3RUcmFuc2Zvcm0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGV4cGVjdGVkLCBhbGdvcml0aG0gPSBcInNoYTUxMlwiLCBlbmNvZGluZyA9IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSBudWxsO1xuICAgICAgICB0aGlzLmlzVmFsaWRhdGVPbkVuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlnZXN0ZXIgPSBjcnlwdG9fMS5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgfVxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXQgYWN0dWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0dWFsO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZGlnZXN0ZXIudXBkYXRlKGNodW5rKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbCA9IHRoaXMuZGlnZXN0ZXIuZGlnZXN0KHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkYXRlT25FbmQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIHZhbGlkYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fYWN0dWFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoXCJOb3QgZmluaXNoZWQgeWV0XCIsIFwiRVJSX1NUUkVBTV9OT1RfRklOSVNIRURcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2FjdHVhbCAhPT0gdGhpcy5leHBlY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhfMS5uZXdFcnJvcihgJHt0aGlzLmFsZ29yaXRobX0gY2hlY2tzdW0gbWlzbWF0Y2gsIGV4cGVjdGVkICR7dGhpcy5leHBlY3RlZH0sIGdvdCAke3RoaXMuX2FjdHVhbH1gLCBcIkVSUl9DSEVDS1NVTV9NSVNNQVRDSFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkRpZ2VzdFRyYW5zZm9ybSA9IERpZ2VzdFRyYW5zZm9ybTtcbmZ1bmN0aW9uIGNoZWNrU2hhMihzaGEySGVhZGVyLCBzaGEyLCBjYWxsYmFjaykge1xuICAgIGlmIChzaGEySGVhZGVyICE9IG51bGwgJiYgc2hhMiAhPSBudWxsICYmIHNoYTJIZWFkZXIgIT09IHNoYTIpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGBjaGVja3N1bSBtaXNtYXRjaDogZXhwZWN0ZWQgJHtzaGEyfSBidXQgZ290ICR7c2hhMkhlYWRlcn0gKFgtQ2hlY2tzdW0tU2hhMiBoZWFkZXIpYCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2FmZUdldEhlYWRlcihyZXNwb25zZSwgaGVhZGVyS2V5KSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2hlYWRlcktleV07XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIC8vIGVsZWN0cm9uIEFQSVxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSAwID8gbnVsbCA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuc2FmZUdldEhlYWRlciA9IHNhZmVHZXRIZWFkZXI7XG5mdW5jdGlvbiBjb25maWd1cmVQaXBlcyhvcHRpb25zLCByZXNwb25zZSkge1xuICAgIGlmICghY2hlY2tTaGEyKHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiWC1DaGVja3N1bS1TaGEyXCIpLCBvcHRpb25zLm9wdGlvbnMuc2hhMiwgb3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgaWYgKG9wdGlvbnMub3B0aW9ucy5vblByb2dyZXNzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbXMucHVzaChuZXcgUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0ocGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApLCBvcHRpb25zLm9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sIG9wdGlvbnMub3B0aW9ucy5vblByb2dyZXNzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hhNTEyID0gb3B0aW9ucy5vcHRpb25zLnNoYTUxMjtcbiAgICBpZiAoc2hhNTEyICE9IG51bGwpIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKG5ldyBEaWdlc3RUcmFuc2Zvcm0oc2hhNTEyLCBcInNoYTUxMlwiLCBzaGE1MTIubGVuZ3RoID09PSAxMjggJiYgIXNoYTUxMi5pbmNsdWRlcyhcIitcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIlpcIikgJiYgIXNoYTUxMi5pbmNsdWRlcyhcIj1cIikgPyBcImhleFwiIDogXCJiYXNlNjRcIikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLm9wdGlvbnMuc2hhMiAhPSBudWxsKSB7XG4gICAgICAgIHN0cmVhbXMucHVzaChuZXcgRGlnZXN0VHJhbnNmb3JtKG9wdGlvbnMub3B0aW9ucy5zaGEyLCBcInNoYTI1NlwiLCBcImhleFwiKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVPdXQgPSBmc18xLmNyZWF0ZVdyaXRlU3RyZWFtKG9wdGlvbnMuZGVzdGluYXRpb24pO1xuICAgIHN0cmVhbXMucHVzaChmaWxlT3V0KTtcbiAgICBsZXQgbGFzdFN0cmVhbSA9IHJlc3BvbnNlO1xuICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMub3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RTdHJlYW0gPSBsYXN0U3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9XG4gICAgZmlsZU91dC5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgIDtcbiAgICAgICAgZmlsZU91dC5jbG9zZShvcHRpb25zLmNhbGxiYWNrKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMsIHRva2VuLCBtZXRob2QpIHtcbiAgICBpZiAobWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBtZXRob2Q7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgICBpZiAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICA7XG4gICAgICAgIGhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IHRva2VuLnN0YXJ0c1dpdGgoXCJCYXNpY1wiKSB8fCB0b2tlbi5zdGFydHNXaXRoKFwiQmVhcmVyXCIpID8gdG9rZW4gOiBgdG9rZW4gJHt0b2tlbn1gO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyc1tcIlVzZXItQWdlbnRcIl0gPT0gbnVsbCkge1xuICAgICAgICBoZWFkZXJzW1wiVXNlci1BZ2VudFwiXSA9IFwiZWxlY3Ryb24tYnVpbGRlclwiO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09IG51bGwgfHwgbWV0aG9kID09PSBcIkdFVFwiIHx8IGhlYWRlcnNbXCJDYWNoZS1Db250cm9sXCJdID09IG51bGwpIHtcbiAgICAgICAgaGVhZGVyc1tcIkNhY2hlLUNvbnRyb2xcIl0gPSBcIm5vLWNhY2hlXCI7XG4gICAgfVxuICAgIC8vIGRvIG5vdCBzcGVjaWZ5IGZvciBub2RlIChpbiBhbnkgY2FzZSB3ZSB1c2UgaHR0cHMgbW9kdWxlKVxuICAgIGlmIChvcHRpb25zLnByb3RvY29sID09IG51bGwgJiYgcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiAhPSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMucHJvdG9jb2wgPSBcImh0dHBzOlwiO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMgPSBjb25maWd1cmVSZXF1ZXN0T3B0aW9ucztcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnlKc29uKGRhdGEsIHNraXBwZWROYW1lcykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUuZW5kc1dpdGgoXCJBdXRob3JpemF0aW9uXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmVuZHNXaXRoKFwiYXV0aG9yaXphdGlvblwiKSB8fFxuICAgICAgICAgICAgbmFtZS5lbmRzV2l0aChcIlBhc3N3b3JkXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmVuZHNXaXRoKFwiUEFTU1dPUkRcIikgfHxcbiAgICAgICAgICAgIG5hbWUuZW5kc1dpdGgoXCJUb2tlblwiKSB8fFxuICAgICAgICAgICAgbmFtZS5pbmNsdWRlcyhcInBhc3N3b3JkXCIpIHx8XG4gICAgICAgICAgICBuYW1lLmluY2x1ZGVzKFwidG9rZW5cIikgfHxcbiAgICAgICAgICAgIChza2lwcGVkTmFtZXMgIT0gbnVsbCAmJiBza2lwcGVkTmFtZXMuaGFzKG5hbWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiPHN0cmlwcGVkIHNlbnNpdGl2ZSBkYXRhPlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCAyKTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeUpzb24gPSBzYWZlU3RyaW5naWZ5SnNvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBFeGVjdXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsID0gZXhwb3J0cy5naXRodWJVcmwgPSB2b2lkIDA7XG4vKiogQHByaXZhdGUgKi9cbmZ1bmN0aW9uIGdpdGh1YlVybChvcHRpb25zLCBkZWZhdWx0SG9zdCA9IFwiZ2l0aHViLmNvbVwiKSB7XG4gICAgcmV0dXJuIGAke29wdGlvbnMucHJvdG9jb2wgfHwgXCJodHRwc1wifTovLyR7b3B0aW9ucy5ob3N0IHx8IGRlZmF1bHRIb3N0fWA7XG59XG5leHBvcnRzLmdpdGh1YlVybCA9IGdpdGh1YlVybDtcbmZ1bmN0aW9uIGdldFMzTGlrZVByb3ZpZGVyQmFzZVVybChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb25maWd1cmF0aW9uLnByb3ZpZGVyO1xuICAgIGlmIChwcm92aWRlciA9PT0gXCJzM1wiKSB7XG4gICAgICAgIHJldHVybiBzM1VybChjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKHByb3ZpZGVyID09PSBcInNwYWNlc1wiKSB7XG4gICAgICAgIHJldHVybiBzcGFjZXNVcmwoY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbn1cbmV4cG9ydHMuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsID0gZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsO1xuZnVuY3Rpb24gczNVcmwob3B0aW9ucykge1xuICAgIGxldCB1cmw7XG4gICAgaWYgKG9wdGlvbnMuZW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICB1cmwgPSBgJHtvcHRpb25zLmVuZHBvaW50fS8ke29wdGlvbnMuYnVja2V0fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuYnVja2V0LmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZWdpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWNrZXQgbmFtZSBcIiR7b3B0aW9ucy5idWNrZXR9XCIgaW5jbHVkZXMgYSBkb3QsIGJ1dCBTMyByZWdpb24gaXMgbWlzc2luZ2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSwgc2VlIGh0dHA6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9kZXYvVXNpbmdCdWNrZXQuaHRtbCNhY2Nlc3MtYnVja2V0LWludHJvXG4gICAgICAgIGlmIChvcHRpb25zLnJlZ2lvbiA9PT0gXCJ1cy1lYXN0LTFcIikge1xuICAgICAgICAgICAgdXJsID0gYGh0dHBzOi8vczMuYW1hem9uYXdzLmNvbS8ke29wdGlvbnMuYnVja2V0fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmwgPSBgaHR0cHM6Ly9zMy0ke29wdGlvbnMucmVnaW9ufS5hbWF6b25hd3MuY29tLyR7b3B0aW9ucy5idWNrZXR9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zLnJlZ2lvbiA9PT0gXCJjbi1ub3J0aC0xXCIpIHtcbiAgICAgICAgdXJsID0gYGh0dHBzOi8vJHtvcHRpb25zLmJ1Y2tldH0uczMuJHtvcHRpb25zLnJlZ2lvbn0uYW1hem9uYXdzLmNvbS5jbmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmwgPSBgaHR0cHM6Ly8ke29wdGlvbnMuYnVja2V0fS5zMy5hbWF6b25hd3MuY29tYDtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGVuZFBhdGgodXJsLCBvcHRpb25zLnBhdGgpO1xufVxuZnVuY3Rpb24gYXBwZW5kUGF0aCh1cmwsIHApIHtcbiAgICBpZiAocCAhPSBudWxsICYmIHAubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIXAuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHVybCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICB1cmwgKz0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIHNwYWNlc1VybChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbmFtZSBpcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlZ2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVnaW9uIGlzIG1pc3NpbmdgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcGVuZFBhdGgoYGh0dHBzOi8vJHtvcHRpb25zLm5hbWV9LiR7b3B0aW9ucy5yZWdpb259LmRpZ2l0YWxvY2VhbnNwYWNlcy5jb21gLCBvcHRpb25zLnBhdGgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVibGlzaE9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlRG4gPSB2b2lkIDA7XG5mdW5jdGlvbiBwYXJzZURuKHNlcSkge1xuICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICBsZXQga2V5ID0gbnVsbDtcbiAgICBsZXQgdG9rZW4gPSBcIlwiO1xuICAgIGxldCBuZXh0Tm9uU3BhY2UgPSAwO1xuICAgIHNlcSA9IHNlcS50cmltKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNlcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gc2VxLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaCA9IHNlcVtpXTtcbiAgICAgICAgaWYgKHF1b3RlZCkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmQgPSBwYXJzZUludChzZXEuc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc05hTihvcmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuICs9IHNlcVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShvcmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwgJiYgY2ggPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoID09PSBcIixcIiB8fCBjaCA9PT0gXCI7XCIgfHwgY2ggPT09IFwiK1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09IFwiIFwiICYmICFxdW90ZWQpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gbmV4dE5vblNwYWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZXFbal0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dE5vblNwYWNlID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Tm9uU3BhY2UgPj0gc2VxLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIixcIiB8fFxuICAgICAgICAgICAgICAgIHNlcVtuZXh0Tm9uU3BhY2VdID09PSBcIjtcIiB8fFxuICAgICAgICAgICAgICAgIChrZXkgPT09IG51bGwgJiYgc2VxW25leHROb25TcGFjZV0gPT09IFwiPVwiKSB8fFxuICAgICAgICAgICAgICAgIChrZXkgIT09IG51bGwgJiYgc2VxW25leHROb25TcGFjZV0gPT09IFwiK1wiKSkge1xuICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9uU3BhY2UgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuICs9IGNoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZURuID0gcGFyc2VEbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJmYzIyNTNQYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5pbCA9IGV4cG9ydHMuVVVJRCA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleFwiKTtcbmNvbnN0IGludmFsaWROYW1lID0gXCJvcHRpb25zLm5hbWUgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBCdWZmZXJcIjtcbi8vIE5vZGUgSUQgYWNjb3JkaW5nIHRvIHJmYzQxMjIjc2VjdGlvbi00LjVcbmNvbnN0IHJhbmRvbUhvc3QgPSBjcnlwdG9fMS5yYW5kb21CeXRlcygxNik7XG5yYW5kb21Ib3N0WzBdID0gcmFuZG9tSG9zdFswXSB8IDB4MDE7XG4vLyBsb29rdXAgdGFibGUgaGV4IHRvIGJ5dGVcbmNvbnN0IGhleDJieXRlID0ge307XG4vLyBsb29rdXAgdGFibGUgYnl0ZSB0byBoZXhcbmNvbnN0IGJ5dGUyaGV4ID0gW107XG4vLyBwb3B1bGF0ZSBsb29rdXAgdGFibGVzXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgY29uc3QgaGV4ID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbiAgICBoZXgyYnl0ZVtoZXhdID0gaTtcbiAgICBieXRlMmhleFtpXSA9IGhleDtcbn1cbi8vIFVVSUQgY2xhc3NcbmNsYXNzIFVVSUQge1xuICAgIGNvbnN0cnVjdG9yKHV1aWQpIHtcbiAgICAgICAgdGhpcy5hc2NpaSA9IG51bGw7XG4gICAgICAgIHRoaXMuYmluYXJ5ID0gbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2sgPSBVVUlELmNoZWNrKHV1aWQpO1xuICAgICAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBVVUlEXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGNoZWNrLnZlcnNpb247XG4gICAgICAgIGlmIChjaGVjay5mb3JtYXQgPT09IFwiYXNjaWlcIikge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHV1aWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeSA9IHV1aWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHY1KG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gdXVpZE5hbWVkKG5hbWUsIFwic2hhMVwiLCAweDUwLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuYXNjaWkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hc2NpaSA9IHN0cmluZ2lmeSh0aGlzLmJpbmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNjaWk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiBgVVVJRCB2JHt0aGlzLnZlcnNpb259ICR7dGhpcy50b1N0cmluZygpfWA7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVjayh1dWlkLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXVpZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdXVpZCA9IHV1aWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghL15bYS1mMC05XXs4fSgtW2EtZjAtOV17NH0pezN9LShbYS1mMC05XXsxMn0pJC8udGVzdCh1dWlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1dWlkID09PSBcIjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVyc2lvbjogdW5kZWZpbmVkLCB2YXJpYW50OiBcIm5pbFwiLCBmb3JtYXQ6IFwiYXNjaWlcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAoaGV4MmJ5dGVbdXVpZFsxNF0gKyB1dWlkWzE1XV0gJiAweGYwKSA+PiA0LFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IGdldFZhcmlhbnQoKGhleDJieXRlW3V1aWRbMTldICsgdXVpZFsyMF1dICYgMHhlMCkgPj4gNSksXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImFzY2lpXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodXVpZCkpIHtcbiAgICAgICAgICAgIGlmICh1dWlkLmxlbmd0aCA8IG9mZnNldCArIDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV1aWRbb2Zmc2V0ICsgaV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmVyc2lvbjogdW5kZWZpbmVkLCB2YXJpYW50OiBcIm5pbFwiLCBmb3JtYXQ6IFwiYmluYXJ5XCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjogKHV1aWRbb2Zmc2V0ICsgNl0gJiAweGYwKSA+PiA0LFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IGdldFZhcmlhbnQoKHV1aWRbb2Zmc2V0ICsgOF0gJiAweGUwKSA+PiA1KSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiYmluYXJ5XCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoXCJVbmtub3duIHR5cGUgb2YgdXVpZFwiLCBcIkVSUl9VTktOT1dOX1VVSURfVFlQRVwiKTtcbiAgICB9XG4gICAgLy8gcmVhZCBzdHJpbmdpZmllZCB1dWlkIGludG8gYSBCdWZmZXJcbiAgICBzdGF0aWMgcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDE2KTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IGhleDJieXRlW2lucHV0W2orK10gKyBpbnB1dFtqKytdXTtcbiAgICAgICAgICAgIGlmIChpID09PSAzIHx8IGkgPT09IDUgfHwgaSA9PT0gNyB8fCBpID09PSA5KSB7XG4gICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxufVxuZXhwb3J0cy5VVUlEID0gVVVJRDtcbi8vIGZyb20gcmZjNDEyMiNhcHBlbmRpeC1DXG5VVUlELk9JRCA9IFVVSUQucGFyc2UoXCI2YmE3YjgxMi05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIik7XG4vLyBhY2NvcmRpbmcgdG8gcmZjNDEyMiNzZWN0aW9uLTQuMS4xXG5mdW5jdGlvbiBnZXRWYXJpYW50KGJpdHMpIHtcbiAgICBzd2l0Y2ggKGJpdHMpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBcIm5jc1wiO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBcInJmYzQxMjJcIjtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIFwibWljcm9zb2Z0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJmdXR1cmVcIjtcbiAgICB9XG59XG52YXIgVXVpZEVuY29kaW5nO1xuKGZ1bmN0aW9uIChVdWlkRW5jb2RpbmcpIHtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQVNDSUlcIl0gPSAwXSA9IFwiQVNDSUlcIjtcbiAgICBVdWlkRW5jb2RpbmdbVXVpZEVuY29kaW5nW1wiQklOQVJZXCJdID0gMV0gPSBcIkJJTkFSWVwiO1xuICAgIFV1aWRFbmNvZGluZ1tVdWlkRW5jb2RpbmdbXCJPQkpFQ1RcIl0gPSAyXSA9IFwiT0JKRUNUXCI7XG59KShVdWlkRW5jb2RpbmcgfHwgKFV1aWRFbmNvZGluZyA9IHt9KSk7XG4vLyB2MyArIHY1XG5mdW5jdGlvbiB1dWlkTmFtZWQobmFtZSwgaGFzaE1ldGhvZCwgdmVyc2lvbiwgbmFtZXNwYWNlLCBlbmNvZGluZyA9IFV1aWRFbmNvZGluZy5BU0NJSSkge1xuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9fMS5jcmVhdGVIYXNoKGhhc2hNZXRob2QpO1xuICAgIGNvbnN0IG5hbWVJc05vdEFTdHJpbmcgPSB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIjtcbiAgICBpZiAobmFtZUlzTm90QVN0cmluZyAmJiAhQnVmZmVyLmlzQnVmZmVyKG5hbWUpKSB7XG4gICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoaW52YWxpZE5hbWUsIFwiRVJSX0lOVkFMSURfVVVJRF9OQU1FXCIpO1xuICAgIH1cbiAgICBoYXNoLnVwZGF0ZShuYW1lc3BhY2UpO1xuICAgIGhhc2gudXBkYXRlKG5hbWUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGhhc2guZGlnZXN0KCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLkJJTkFSWTpcbiAgICAgICAgICAgIGJ1ZmZlcls2XSA9IChidWZmZXJbNl0gJiAweDBmKSB8IHZlcnNpb247XG4gICAgICAgICAgICBidWZmZXJbOF0gPSAoYnVmZmVyWzhdICYgMHgzZikgfCAweDgwO1xuICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVXVpZEVuY29kaW5nLk9CSkVDVDpcbiAgICAgICAgICAgIGJ1ZmZlcls2XSA9IChidWZmZXJbNl0gJiAweDBmKSB8IHZlcnNpb247XG4gICAgICAgICAgICBidWZmZXJbOF0gPSAoYnVmZmVyWzhdICYgMHgzZikgfCAweDgwO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMF1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzFdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsyXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbM11dICtcbiAgICAgICAgICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbNF1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzVdXSArXG4gICAgICAgICAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbKGJ1ZmZlcls2XSAmIDB4MGYpIHwgdmVyc2lvbl0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbN11dICtcbiAgICAgICAgICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFsoYnVmZmVyWzhdICYgMHgzZikgfCAweDgwXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls5XV0gK1xuICAgICAgICAgICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMF1dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzExXV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTJdXSArXG4gICAgICAgICAgICAgICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxM11dICtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzE0XV0gK1xuICAgICAgICAgICAgICAgICAgICBieXRlMmhleFtidWZmZXJbMTVdXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGJ1ZmZlcikge1xuICAgIHJldHVybiAoYnl0ZTJoZXhbYnVmZmVyWzBdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMl1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzNdXSArXG4gICAgICAgIFwiLVwiICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzRdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls1XV0gK1xuICAgICAgICBcIi1cIiArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlcls2XV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbN11dICtcbiAgICAgICAgXCItXCIgK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbOF1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzldXSArXG4gICAgICAgIFwiLVwiICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzEwXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTFdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxMl1dICtcbiAgICAgICAgYnl0ZTJoZXhbYnVmZmVyWzEzXV0gK1xuICAgICAgICBieXRlMmhleFtidWZmZXJbMTRdXSArXG4gICAgICAgIGJ5dGUyaGV4W2J1ZmZlclsxNV1dKTtcbn1cbi8vIGFjY29yZGluZyB0byByZmM0MTIyI3NlY3Rpb24tNC4xLjdcbmV4cG9ydHMubmlsID0gbmV3IFVVSUQoXCIwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDBcIik7XG4vLyBVVUlELnY0ID0gdXVpZFJhbmRvbVxuLy8gVVVJRC52NGZhc3QgPSB1dWlkUmFuZG9tRmFzdFxuLy8gVVVJRC52MyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIHV1aWROYW1lZChcIm1kNVwiLCAweDMwLCBvcHRpb25zLCBjYWxsYmFjaylcbi8vIH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV1aWQuanMubWFwIiwiOyhmdW5jdGlvbiAoc2F4KSB7IC8vIHdyYXBwZXIgZm9yIG5vbi1ub2RlIGVudnNcbiAgc2F4LnBhcnNlciA9IGZ1bmN0aW9uIChzdHJpY3QsIG9wdCkgeyByZXR1cm4gbmV3IFNBWFBhcnNlcihzdHJpY3QsIG9wdCkgfVxuICBzYXguU0FYUGFyc2VyID0gU0FYUGFyc2VyXG4gIHNheC5TQVhTdHJlYW0gPSBTQVhTdHJlYW1cbiAgc2F4LmNyZWF0ZVN0cmVhbSA9IGNyZWF0ZVN0cmVhbVxuXG4gIC8vIFdoZW4gd2UgcGFzcyB0aGUgTUFYX0JVRkZFUl9MRU5HVEggcG9zaXRpb24sIHN0YXJ0IGNoZWNraW5nIGZvciBidWZmZXIgb3ZlcnJ1bnMuXG4gIC8vIFdoZW4gd2UgY2hlY2ssIHNjaGVkdWxlIHRoZSBuZXh0IGNoZWNrIGZvciBNQVhfQlVGRkVSX0xFTkdUSCAtIChtYXgoYnVmZmVyIGxlbmd0aHMpKSxcbiAgLy8gc2luY2UgdGhhdCdzIHRoZSBlYXJsaWVzdCB0aGF0IGEgYnVmZmVyIG92ZXJydW4gY291bGQgb2NjdXIuICBUaGlzIHdheSwgY2hlY2tzIGFyZVxuICAvLyBhcyByYXJlIGFzIHJlcXVpcmVkLCBidXQgYXMgb2Z0ZW4gYXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBuZXZlciBjcm9zc2luZyB0aGlzIGJvdW5kLlxuICAvLyBGdXJ0aGVybW9yZSwgYnVmZmVycyBhcmUgb25seSB0ZXN0ZWQgYXQgbW9zdCBvbmNlIHBlciB3cml0ZSgpLCBzbyBwYXNzaW5nIGEgdmVyeVxuICAvLyBsYXJnZSBzdHJpbmcgaW50byB3cml0ZSgpIG1pZ2h0IGhhdmUgdW5kZXNpcmFibGUgZWZmZWN0cywgYnV0IHRoaXMgaXMgbWFuYWdlYWJsZSBieVxuICAvLyB0aGUgY2FsbGVyLCBzbyBpdCBpcyBhc3N1bWVkIHRvIGJlIHNhZmUuICBUaHVzLCBhIGNhbGwgdG8gd3JpdGUoKSBtYXksIGluIHRoZSBleHRyZW1lXG4gIC8vIGVkZ2UgY2FzZSwgcmVzdWx0IGluIGNyZWF0aW5nIGF0IG1vc3Qgb25lIGNvbXBsZXRlIGNvcHkgb2YgdGhlIHN0cmluZyBwYXNzZWQgaW4uXG4gIC8vIFNldCB0byBJbmZpbml0eSB0byBoYXZlIHVubGltaXRlZCBidWZmZXJzLlxuICBzYXguTUFYX0JVRkZFUl9MRU5HVEggPSA2NCAqIDEwMjRcblxuICB2YXIgYnVmZmVycyA9IFtcbiAgICAnY29tbWVudCcsICdzZ21sRGVjbCcsICd0ZXh0Tm9kZScsICd0YWdOYW1lJywgJ2RvY3R5cGUnLFxuICAgICdwcm9jSW5zdE5hbWUnLCAncHJvY0luc3RCb2R5JywgJ2VudGl0eScsICdhdHRyaWJOYW1lJyxcbiAgICAnYXR0cmliVmFsdWUnLCAnY2RhdGEnLCAnc2NyaXB0J1xuICBdXG5cbiAgc2F4LkVWRU5UUyA9IFtcbiAgICAndGV4dCcsXG4gICAgJ3Byb2Nlc3NpbmdpbnN0cnVjdGlvbicsXG4gICAgJ3NnbWxkZWNsYXJhdGlvbicsXG4gICAgJ2RvY3R5cGUnLFxuICAgICdjb21tZW50JyxcbiAgICAnb3BlbnRhZ3N0YXJ0JyxcbiAgICAnYXR0cmlidXRlJyxcbiAgICAnb3BlbnRhZycsXG4gICAgJ2Nsb3NldGFnJyxcbiAgICAnb3BlbmNkYXRhJyxcbiAgICAnY2RhdGEnLFxuICAgICdjbG9zZWNkYXRhJyxcbiAgICAnZXJyb3InLFxuICAgICdlbmQnLFxuICAgICdyZWFkeScsXG4gICAgJ3NjcmlwdCcsXG4gICAgJ29wZW5uYW1lc3BhY2UnLFxuICAgICdjbG9zZW5hbWVzcGFjZSdcbiAgXVxuXG4gIGZ1bmN0aW9uIFNBWFBhcnNlciAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYUGFyc2VyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhQYXJzZXIoc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgdmFyIHBhcnNlciA9IHRoaXNcbiAgICBjbGVhckJ1ZmZlcnMocGFyc2VyKVxuICAgIHBhcnNlci5xID0gcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIXG4gICAgcGFyc2VyLm9wdCA9IG9wdCB8fCB7fVxuICAgIHBhcnNlci5vcHQubG93ZXJjYXNlID0gcGFyc2VyLm9wdC5sb3dlcmNhc2UgfHwgcGFyc2VyLm9wdC5sb3dlcmNhc2V0YWdzXG4gICAgcGFyc2VyLmxvb3NlQ2FzZSA9IHBhcnNlci5vcHQubG93ZXJjYXNlID8gJ3RvTG93ZXJDYXNlJyA6ICd0b1VwcGVyQ2FzZSdcbiAgICBwYXJzZXIudGFncyA9IFtdXG4gICAgcGFyc2VyLmNsb3NlZCA9IHBhcnNlci5jbG9zZWRSb290ID0gcGFyc2VyLnNhd1Jvb3QgPSBmYWxzZVxuICAgIHBhcnNlci50YWcgPSBwYXJzZXIuZXJyb3IgPSBudWxsXG4gICAgcGFyc2VyLnN0cmljdCA9ICEhc3RyaWN0XG4gICAgcGFyc2VyLm5vc2NyaXB0ID0gISEoc3RyaWN0IHx8IHBhcnNlci5vcHQubm9zY3JpcHQpXG4gICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTlxuICAgIHBhcnNlci5zdHJpY3RFbnRpdGllcyA9IHBhcnNlci5vcHQuc3RyaWN0RW50aXRpZXNcbiAgICBwYXJzZXIuRU5USVRJRVMgPSBwYXJzZXIuc3RyaWN0RW50aXRpZXMgPyBPYmplY3QuY3JlYXRlKHNheC5YTUxfRU5USVRJRVMpIDogT2JqZWN0LmNyZWF0ZShzYXguRU5USVRJRVMpXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QgPSBbXVxuXG4gICAgLy8gbmFtZXNwYWNlcyBmb3JtIGEgcHJvdG90eXBlIGNoYWluLlxuICAgIC8vIGl0IGFsd2F5cyBwb2ludHMgYXQgdGhlIGN1cnJlbnQgdGFnLFxuICAgIC8vIHdoaWNoIHByb3RvcyB0byBpdHMgcGFyZW50IHRhZy5cbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgcGFyc2VyLm5zID0gT2JqZWN0LmNyZWF0ZShyb290TlMpXG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGp1c3QgZm9yIGVycm9yIHJlcG9ydGluZ1xuICAgIHBhcnNlci50cmFja1Bvc2l0aW9uID0gcGFyc2VyLm9wdC5wb3NpdGlvbiAhPT0gZmFsc2VcbiAgICBpZiAocGFyc2VyLnRyYWNrUG9zaXRpb24pIHtcbiAgICAgIHBhcnNlci5wb3NpdGlvbiA9IHBhcnNlci5saW5lID0gcGFyc2VyLmNvbHVtbiA9IDBcbiAgICB9XG4gICAgZW1pdChwYXJzZXIsICdvbnJlYWR5JylcbiAgfVxuXG4gIGlmICghT2JqZWN0LmNyZWF0ZSkge1xuICAgIE9iamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAobykge1xuICAgICAgZnVuY3Rpb24gRiAoKSB7fVxuICAgICAgRi5wcm90b3R5cGUgPSBvXG4gICAgICB2YXIgbmV3ZiA9IG5ldyBGKClcbiAgICAgIHJldHVybiBuZXdmXG4gICAgfVxuICB9XG5cbiAgaWYgKCFPYmplY3Qua2V5cykge1xuICAgIE9iamVjdC5rZXlzID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBhID0gW11cbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIGEucHVzaChpKVxuICAgICAgcmV0dXJuIGFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0J1ZmZlckxlbmd0aCAocGFyc2VyKSB7XG4gICAgdmFyIG1heEFsbG93ZWQgPSBNYXRoLm1heChzYXguTUFYX0JVRkZFUl9MRU5HVEgsIDEwKVxuICAgIHZhciBtYXhBY3R1YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGxlbiA9IHBhcnNlcltidWZmZXJzW2ldXS5sZW5ndGhcbiAgICAgIGlmIChsZW4gPiBtYXhBbGxvd2VkKSB7XG4gICAgICAgIC8vIFRleHQvY2RhdGEgbm9kZXMgY2FuIGdldCBiaWcsIGFuZCBzaW5jZSB0aGV5J3JlIGJ1ZmZlcmVkLFxuICAgICAgICAvLyB3ZSBjYW4gZ2V0IGhlcmUgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXG4gICAgICAgIC8vIEF2b2lkIGlzc3VlcyBieSBlbWl0dGluZyB0aGUgdGV4dCBub2RlIG5vdyxcbiAgICAgICAgLy8gc28gYXQgbGVhc3QgaXQgd29uJ3QgZ2V0IGFueSBiaWdnZXIuXG4gICAgICAgIHN3aXRjaCAoYnVmZmVyc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ3RleHROb2RlJzpcbiAgICAgICAgICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnY2RhdGEnOlxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jZGF0YScsIHBhcnNlci5jZGF0YSlcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgY2FzZSAnc2NyaXB0JzpcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uc2NyaXB0JywgcGFyc2VyLnNjcmlwdClcbiAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgPSAnJ1xuICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcihwYXJzZXIsICdNYXggYnVmZmVyIGxlbmd0aCBleGNlZWRlZDogJyArIGJ1ZmZlcnNbaV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1heEFjdHVhbCA9IE1hdGgubWF4KG1heEFjdHVhbCwgbGVuKVxuICAgIH1cbiAgICAvLyBzY2hlZHVsZSB0aGUgbmV4dCBjaGVjayBmb3IgdGhlIGVhcmxpZXN0IHBvc3NpYmxlIGJ1ZmZlciBvdmVycnVuLlxuICAgIHZhciBtID0gc2F4Lk1BWF9CVUZGRVJfTEVOR1RIIC0gbWF4QWN0dWFsXG4gICAgcGFyc2VyLmJ1ZmZlckNoZWNrUG9zaXRpb24gPSBtICsgcGFyc2VyLnBvc2l0aW9uXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckJ1ZmZlcnMgKHBhcnNlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcnNlcltidWZmZXJzW2ldXSA9ICcnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hCdWZmZXJzIChwYXJzZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIuY2RhdGEgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICB9XG4gICAgaWYgKHBhcnNlci5zY3JpcHQgIT09ICcnKSB7XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG4gIH1cblxuICBTQVhQYXJzZXIucHJvdG90eXBlID0ge1xuICAgIGVuZDogZnVuY3Rpb24gKCkgeyBlbmQodGhpcykgfSxcbiAgICB3cml0ZTogd3JpdGUsXG4gICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7IHRoaXMuZXJyb3IgPSBudWxsOyByZXR1cm4gdGhpcyB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLndyaXRlKG51bGwpIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICgpIHsgZmx1c2hCdWZmZXJzKHRoaXMpIH1cbiAgfVxuXG4gIHZhciBTdHJlYW1cbiAgdHJ5IHtcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBTdHJlYW0gPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgdmFyIHN0cmVhbVdyYXBzID0gc2F4LkVWRU5UUy5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgcmV0dXJuIGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnZW5kJ1xuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICByZXR1cm4gbmV3IFNBWFN0cmVhbShzdHJpY3QsIG9wdClcbiAgfVxuXG4gIGZ1bmN0aW9uIFNBWFN0cmVhbSAoc3RyaWN0LCBvcHQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0FYU3RyZWFtKSkge1xuICAgICAgcmV0dXJuIG5ldyBTQVhTdHJlYW0oc3RyaWN0LCBvcHQpXG4gICAgfVxuXG4gICAgU3RyZWFtLmFwcGx5KHRoaXMpXG5cbiAgICB0aGlzLl9wYXJzZXIgPSBuZXcgU0FYUGFyc2VyKHN0cmljdCwgb3B0KVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcblxuICAgIHZhciBtZSA9IHRoaXNcblxuICAgIHRoaXMuX3BhcnNlci5vbmVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1lLmVtaXQoJ2VuZCcpXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyc2VyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIG1lLmVtaXQoJ2Vycm9yJywgZXIpXG5cbiAgICAgIC8vIGlmIGRpZG4ndCB0aHJvdywgdGhlbiBtZWFucyBlcnJvciB3YXMgaGFuZGxlZC5cbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBjbGVhciBlcnJvciwgc28gd2UgY2FuIHdyaXRlIGFnYWluLlxuICAgICAgbWUuX3BhcnNlci5lcnJvciA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzLl9kZWNvZGVyID0gbnVsbFxuXG4gICAgc3RyZWFtV3JhcHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZSwgJ29uJyArIGV2LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZS5fcGFyc2VyWydvbicgKyBldl1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgIGlmICghaCkge1xuICAgICAgICAgICAgbWUucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgICAgICAgbWUuX3BhcnNlclsnb24nICsgZXZdID0gaFxuICAgICAgICAgICAgcmV0dXJuIGhcbiAgICAgICAgICB9XG4gICAgICAgICAgbWUub24oZXYsIGgpXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmVhbS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IFNBWFN0cmVhbVxuICAgIH1cbiAgfSlcblxuICBTQVhTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBpZiAoIXRoaXMuX2RlY29kZXIpIHtcbiAgICAgICAgdmFyIFNEID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG4gICAgICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU0QoJ3V0ZjgnKVxuICAgICAgfVxuICAgICAgZGF0YSA9IHRoaXMuX2RlY29kZXIud3JpdGUoZGF0YSlcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJzZXIud3JpdGUoZGF0YS50b1N0cmluZygpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgdGhpcy53cml0ZShjaHVuaylcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VyLmVuZCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFNBWFN0cmVhbS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGhhbmRsZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzXG4gICAgaWYgKCFtZS5fcGFyc2VyWydvbicgKyBldl0gJiYgc3RyZWFtV3JhcHMuaW5kZXhPZihldikgIT09IC0xKSB7XG4gICAgICBtZS5fcGFyc2VyWydvbicgKyBldl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFthcmd1bWVudHNbMF1dIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgICAgICBhcmdzLnNwbGljZSgwLCAwLCBldilcbiAgICAgICAgbWUuZW1pdC5hcHBseShtZSwgYXJncylcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKG1lLCBldiwgaGFuZGxlcilcbiAgfVxuXG4gIC8vIHRoaXMgcmVhbGx5IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggY2hhcmFjdGVyIGNsYXNzZXMuXG4gIC8vIFhNTCBhbGxvd3MgYWxsIG1hbm5lciBvZiByaWRpY3Vsb3VzIG51bWJlcnMgYW5kIGRpZ2l0cy5cbiAgdmFyIENEQVRBID0gJ1tDREFUQVsnXG4gIHZhciBET0NUWVBFID0gJ0RPQ1RZUEUnXG4gIHZhciBYTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbiAgdmFyIFhNTE5TX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcbiAgdmFyIHJvb3ROUyA9IHsgeG1sOiBYTUxfTkFNRVNQQUNFLCB4bWxuczogWE1MTlNfTkFNRVNQQUNFIH1cblxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lU3RhcnRDaGFyXG4gIC8vIFRoaXMgaW1wbGVtZW50YXRpb24gd29ya3Mgb24gc3RyaW5ncywgYSBzaW5nbGUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAvLyBhcyBzdWNoLCBpdCBjYW5ub3QgZXZlciBzdXBwb3J0IGFzdHJhbC1wbGFuZSBjaGFyYWN0ZXJzICgxMDAwMC1FRkZGRilcbiAgLy8gd2l0aG91dCBhIHNpZ25pZmljYW50IGJyZWFraW5nIGNoYW5nZSB0byBlaXRoZXIgdGhpcyAgcGFyc2VyLCBvciB0aGVcbiAgLy8gSmF2YVNjcmlwdCBsYW5ndWFnZS4gIEltcGxlbWVudGF0aW9uIG9mIGFuIGVtb2ppLWNhcGFibGUgeG1sIHBhcnNlclxuICAvLyBpcyBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICB2YXIgbmFtZVN0YXJ0ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vXG5cbiAgdmFyIG5hbWVCb2R5ID0gL1s6X0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDAuXFxkLV0vXG5cbiAgdmFyIGVudGl0eVN0YXJ0ID0gL1sjOl9BLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdL1xuICB2YXIgZW50aXR5Qm9keSA9IC9bIzpfQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MC5cXGQtXS9cblxuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMpIHtcbiAgICByZXR1cm4gYyA9PT0gJyAnIHx8IGMgPT09ICdcXG4nIHx8IGMgPT09ICdcXHInIHx8IGMgPT09ICdcXHQnXG4gIH1cblxuICBmdW5jdGlvbiBpc1F1b3RlIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICdcIicgfHwgYyA9PT0gJ1xcJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXR0cmliRW5kIChjKSB7XG4gICAgcmV0dXJuIGMgPT09ICc+JyB8fCBpc1doaXRlc3BhY2UoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWF0Y2ggKHJlZ2V4LCBjKSB7XG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoYylcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdE1hdGNoIChyZWdleCwgYykge1xuICAgIHJldHVybiAhaXNNYXRjaChyZWdleCwgYylcbiAgfVxuXG4gIHZhciBTID0gMFxuICBzYXguU1RBVEUgPSB7XG4gICAgQkVHSU46IFMrKywgLy8gbGVhZGluZyBieXRlIG9yZGVyIG1hcmsgb3Igd2hpdGVzcGFjZVxuICAgIEJFR0lOX1dISVRFU1BBQ0U6IFMrKywgLy8gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgVEVYVDogUysrLCAvLyBnZW5lcmFsIHN0dWZmXG4gICAgVEVYVF9FTlRJVFk6IFMrKywgLy8gJmFtcCBhbmQgc3VjaC5cbiAgICBPUEVOX1dBS0E6IFMrKywgLy8gPFxuICAgIFNHTUxfREVDTDogUysrLCAvLyA8IUJMQVJHXG4gICAgU0dNTF9ERUNMX1FVT1RFRDogUysrLCAvLyA8IUJMQVJHIGZvbyBcImJhclxuICAgIERPQ1RZUEU6IFMrKywgLy8gPCFET0NUWVBFXG4gICAgRE9DVFlQRV9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXG4gICAgRE9DVFlQRV9EVEQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyAuLi5cbiAgICBET0NUWVBFX0RURF9RVU9URUQ6IFMrKywgLy8gPCFET0NUWVBFIFwiLy9ibGFoXCIgWyBcImZvb1xuICAgIENPTU1FTlRfU1RBUlRJTkc6IFMrKywgLy8gPCEtXG4gICAgQ09NTUVOVDogUysrLCAvLyA8IS0tXG4gICAgQ09NTUVOVF9FTkRJTkc6IFMrKywgLy8gPCEtLSBibGFoIC1cbiAgICBDT01NRU5UX0VOREVEOiBTKyssIC8vIDwhLS0gYmxhaCAtLVxuICAgIENEQVRBOiBTKyssIC8vIDwhW0NEQVRBWyBzb21ldGhpbmdcbiAgICBDREFUQV9FTkRJTkc6IFMrKywgLy8gXVxuICAgIENEQVRBX0VORElOR18yOiBTKyssIC8vIF1dXG4gICAgUFJPQ19JTlNUOiBTKyssIC8vIDw/aGlcbiAgICBQUk9DX0lOU1RfQk9EWTogUysrLCAvLyA8P2hpIHRoZXJlXG4gICAgUFJPQ19JTlNUX0VORElORzogUysrLCAvLyA8P2hpIFwidGhlcmVcIiA/XG4gICAgT1BFTl9UQUc6IFMrKywgLy8gPHN0cm9uZ1xuICAgIE9QRU5fVEFHX1NMQVNIOiBTKyssIC8vIDxzdHJvbmcgL1xuICAgIEFUVFJJQjogUysrLCAvLyA8YVxuICAgIEFUVFJJQl9OQU1FOiBTKyssIC8vIDxhIGZvb1xuICAgIEFUVFJJQl9OQU1FX1NBV19XSElURTogUysrLCAvLyA8YSBmb28gX1xuICAgIEFUVFJJQl9WQUxVRTogUysrLCAvLyA8YSBmb289XG4gICAgQVRUUklCX1ZBTFVFX1FVT1RFRDogUysrLCAvLyA8YSBmb289XCJiYXJcbiAgICBBVFRSSUJfVkFMVUVfQ0xPU0VEOiBTKyssIC8vIDxhIGZvbz1cImJhclwiXG4gICAgQVRUUklCX1ZBTFVFX1VOUVVPVEVEOiBTKyssIC8vIDxhIGZvbz1iYXJcbiAgICBBVFRSSUJfVkFMVUVfRU5USVRZX1E6IFMrKywgLy8gPGZvbyBiYXI9XCImcXVvdDtcIlxuICAgIEFUVFJJQl9WQUxVRV9FTlRJVFlfVTogUysrLCAvLyA8Zm9vIGJhcj0mcXVvdFxuICAgIENMT1NFX1RBRzogUysrLCAvLyA8L2FcbiAgICBDTE9TRV9UQUdfU0FXX1dISVRFOiBTKyssIC8vIDwvYSAgID5cbiAgICBTQ1JJUFQ6IFMrKywgLy8gPHNjcmlwdD4gLi4uXG4gICAgU0NSSVBUX0VORElORzogUysrIC8vIDxzY3JpcHQ+IC4uLiA8XG4gIH1cblxuICBzYXguWE1MX0VOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIlxuICB9XG5cbiAgc2F4LkVOVElUSUVTID0ge1xuICAgICdhbXAnOiAnJicsXG4gICAgJ2d0JzogJz4nLFxuICAgICdsdCc6ICc8JyxcbiAgICAncXVvdCc6ICdcIicsXG4gICAgJ2Fwb3MnOiBcIidcIixcbiAgICAnQUVsaWcnOiAxOTgsXG4gICAgJ0FhY3V0ZSc6IDE5MyxcbiAgICAnQWNpcmMnOiAxOTQsXG4gICAgJ0FncmF2ZSc6IDE5MixcbiAgICAnQXJpbmcnOiAxOTcsXG4gICAgJ0F0aWxkZSc6IDE5NSxcbiAgICAnQXVtbCc6IDE5NixcbiAgICAnQ2NlZGlsJzogMTk5LFxuICAgICdFVEgnOiAyMDgsXG4gICAgJ0VhY3V0ZSc6IDIwMSxcbiAgICAnRWNpcmMnOiAyMDIsXG4gICAgJ0VncmF2ZSc6IDIwMCxcbiAgICAnRXVtbCc6IDIwMyxcbiAgICAnSWFjdXRlJzogMjA1LFxuICAgICdJY2lyYyc6IDIwNixcbiAgICAnSWdyYXZlJzogMjA0LFxuICAgICdJdW1sJzogMjA3LFxuICAgICdOdGlsZGUnOiAyMDksXG4gICAgJ09hY3V0ZSc6IDIxMSxcbiAgICAnT2NpcmMnOiAyMTIsXG4gICAgJ09ncmF2ZSc6IDIxMCxcbiAgICAnT3NsYXNoJzogMjE2LFxuICAgICdPdGlsZGUnOiAyMTMsXG4gICAgJ091bWwnOiAyMTQsXG4gICAgJ1RIT1JOJzogMjIyLFxuICAgICdVYWN1dGUnOiAyMTgsXG4gICAgJ1VjaXJjJzogMjE5LFxuICAgICdVZ3JhdmUnOiAyMTcsXG4gICAgJ1V1bWwnOiAyMjAsXG4gICAgJ1lhY3V0ZSc6IDIyMSxcbiAgICAnYWFjdXRlJzogMjI1LFxuICAgICdhY2lyYyc6IDIyNixcbiAgICAnYWVsaWcnOiAyMzAsXG4gICAgJ2FncmF2ZSc6IDIyNCxcbiAgICAnYXJpbmcnOiAyMjksXG4gICAgJ2F0aWxkZSc6IDIyNyxcbiAgICAnYXVtbCc6IDIyOCxcbiAgICAnY2NlZGlsJzogMjMxLFxuICAgICdlYWN1dGUnOiAyMzMsXG4gICAgJ2VjaXJjJzogMjM0LFxuICAgICdlZ3JhdmUnOiAyMzIsXG4gICAgJ2V0aCc6IDI0MCxcbiAgICAnZXVtbCc6IDIzNSxcbiAgICAnaWFjdXRlJzogMjM3LFxuICAgICdpY2lyYyc6IDIzOCxcbiAgICAnaWdyYXZlJzogMjM2LFxuICAgICdpdW1sJzogMjM5LFxuICAgICdudGlsZGUnOiAyNDEsXG4gICAgJ29hY3V0ZSc6IDI0MyxcbiAgICAnb2NpcmMnOiAyNDQsXG4gICAgJ29ncmF2ZSc6IDI0MixcbiAgICAnb3NsYXNoJzogMjQ4LFxuICAgICdvdGlsZGUnOiAyNDUsXG4gICAgJ291bWwnOiAyNDYsXG4gICAgJ3N6bGlnJzogMjIzLFxuICAgICd0aG9ybic6IDI1NCxcbiAgICAndWFjdXRlJzogMjUwLFxuICAgICd1Y2lyYyc6IDI1MSxcbiAgICAndWdyYXZlJzogMjQ5LFxuICAgICd1dW1sJzogMjUyLFxuICAgICd5YWN1dGUnOiAyNTMsXG4gICAgJ3l1bWwnOiAyNTUsXG4gICAgJ2NvcHknOiAxNjksXG4gICAgJ3JlZyc6IDE3NCxcbiAgICAnbmJzcCc6IDE2MCxcbiAgICAnaWV4Y2wnOiAxNjEsXG4gICAgJ2NlbnQnOiAxNjIsXG4gICAgJ3BvdW5kJzogMTYzLFxuICAgICdjdXJyZW4nOiAxNjQsXG4gICAgJ3llbic6IDE2NSxcbiAgICAnYnJ2YmFyJzogMTY2LFxuICAgICdzZWN0JzogMTY3LFxuICAgICd1bWwnOiAxNjgsXG4gICAgJ29yZGYnOiAxNzAsXG4gICAgJ2xhcXVvJzogMTcxLFxuICAgICdub3QnOiAxNzIsXG4gICAgJ3NoeSc6IDE3MyxcbiAgICAnbWFjcic6IDE3NSxcbiAgICAnZGVnJzogMTc2LFxuICAgICdwbHVzbW4nOiAxNzcsXG4gICAgJ3N1cDEnOiAxODUsXG4gICAgJ3N1cDInOiAxNzgsXG4gICAgJ3N1cDMnOiAxNzksXG4gICAgJ2FjdXRlJzogMTgwLFxuICAgICdtaWNybyc6IDE4MSxcbiAgICAncGFyYSc6IDE4MixcbiAgICAnbWlkZG90JzogMTgzLFxuICAgICdjZWRpbCc6IDE4NCxcbiAgICAnb3JkbSc6IDE4NixcbiAgICAncmFxdW8nOiAxODcsXG4gICAgJ2ZyYWMxNCc6IDE4OCxcbiAgICAnZnJhYzEyJzogMTg5LFxuICAgICdmcmFjMzQnOiAxOTAsXG4gICAgJ2lxdWVzdCc6IDE5MSxcbiAgICAndGltZXMnOiAyMTUsXG4gICAgJ2RpdmlkZSc6IDI0NyxcbiAgICAnT0VsaWcnOiAzMzgsXG4gICAgJ29lbGlnJzogMzM5LFxuICAgICdTY2Fyb24nOiAzNTIsXG4gICAgJ3NjYXJvbic6IDM1MyxcbiAgICAnWXVtbCc6IDM3NixcbiAgICAnZm5vZic6IDQwMixcbiAgICAnY2lyYyc6IDcxMCxcbiAgICAndGlsZGUnOiA3MzIsXG4gICAgJ0FscGhhJzogOTEzLFxuICAgICdCZXRhJzogOTE0LFxuICAgICdHYW1tYSc6IDkxNSxcbiAgICAnRGVsdGEnOiA5MTYsXG4gICAgJ0Vwc2lsb24nOiA5MTcsXG4gICAgJ1pldGEnOiA5MTgsXG4gICAgJ0V0YSc6IDkxOSxcbiAgICAnVGhldGEnOiA5MjAsXG4gICAgJ0lvdGEnOiA5MjEsXG4gICAgJ0thcHBhJzogOTIyLFxuICAgICdMYW1iZGEnOiA5MjMsXG4gICAgJ011JzogOTI0LFxuICAgICdOdSc6IDkyNSxcbiAgICAnWGknOiA5MjYsXG4gICAgJ09taWNyb24nOiA5MjcsXG4gICAgJ1BpJzogOTI4LFxuICAgICdSaG8nOiA5MjksXG4gICAgJ1NpZ21hJzogOTMxLFxuICAgICdUYXUnOiA5MzIsXG4gICAgJ1Vwc2lsb24nOiA5MzMsXG4gICAgJ1BoaSc6IDkzNCxcbiAgICAnQ2hpJzogOTM1LFxuICAgICdQc2knOiA5MzYsXG4gICAgJ09tZWdhJzogOTM3LFxuICAgICdhbHBoYSc6IDk0NSxcbiAgICAnYmV0YSc6IDk0NixcbiAgICAnZ2FtbWEnOiA5NDcsXG4gICAgJ2RlbHRhJzogOTQ4LFxuICAgICdlcHNpbG9uJzogOTQ5LFxuICAgICd6ZXRhJzogOTUwLFxuICAgICdldGEnOiA5NTEsXG4gICAgJ3RoZXRhJzogOTUyLFxuICAgICdpb3RhJzogOTUzLFxuICAgICdrYXBwYSc6IDk1NCxcbiAgICAnbGFtYmRhJzogOTU1LFxuICAgICdtdSc6IDk1NixcbiAgICAnbnUnOiA5NTcsXG4gICAgJ3hpJzogOTU4LFxuICAgICdvbWljcm9uJzogOTU5LFxuICAgICdwaSc6IDk2MCxcbiAgICAncmhvJzogOTYxLFxuICAgICdzaWdtYWYnOiA5NjIsXG4gICAgJ3NpZ21hJzogOTYzLFxuICAgICd0YXUnOiA5NjQsXG4gICAgJ3Vwc2lsb24nOiA5NjUsXG4gICAgJ3BoaSc6IDk2NixcbiAgICAnY2hpJzogOTY3LFxuICAgICdwc2knOiA5NjgsXG4gICAgJ29tZWdhJzogOTY5LFxuICAgICd0aGV0YXN5bSc6IDk3NyxcbiAgICAndXBzaWgnOiA5NzgsXG4gICAgJ3Bpdic6IDk4MixcbiAgICAnZW5zcCc6IDgxOTQsXG4gICAgJ2Vtc3AnOiA4MTk1LFxuICAgICd0aGluc3AnOiA4MjAxLFxuICAgICd6d25qJzogODIwNCxcbiAgICAnendqJzogODIwNSxcbiAgICAnbHJtJzogODIwNixcbiAgICAncmxtJzogODIwNyxcbiAgICAnbmRhc2gnOiA4MjExLFxuICAgICdtZGFzaCc6IDgyMTIsXG4gICAgJ2xzcXVvJzogODIxNixcbiAgICAncnNxdW8nOiA4MjE3LFxuICAgICdzYnF1byc6IDgyMTgsXG4gICAgJ2xkcXVvJzogODIyMCxcbiAgICAncmRxdW8nOiA4MjIxLFxuICAgICdiZHF1byc6IDgyMjIsXG4gICAgJ2RhZ2dlcic6IDgyMjQsXG4gICAgJ0RhZ2dlcic6IDgyMjUsXG4gICAgJ2J1bGwnOiA4MjI2LFxuICAgICdoZWxsaXAnOiA4MjMwLFxuICAgICdwZXJtaWwnOiA4MjQwLFxuICAgICdwcmltZSc6IDgyNDIsXG4gICAgJ1ByaW1lJzogODI0MyxcbiAgICAnbHNhcXVvJzogODI0OSxcbiAgICAncnNhcXVvJzogODI1MCxcbiAgICAnb2xpbmUnOiA4MjU0LFxuICAgICdmcmFzbCc6IDgyNjAsXG4gICAgJ2V1cm8nOiA4MzY0LFxuICAgICdpbWFnZSc6IDg0NjUsXG4gICAgJ3dlaWVycCc6IDg0NzIsXG4gICAgJ3JlYWwnOiA4NDc2LFxuICAgICd0cmFkZSc6IDg0ODIsXG4gICAgJ2FsZWZzeW0nOiA4NTAxLFxuICAgICdsYXJyJzogODU5MixcbiAgICAndWFycic6IDg1OTMsXG4gICAgJ3JhcnInOiA4NTk0LFxuICAgICdkYXJyJzogODU5NSxcbiAgICAnaGFycic6IDg1OTYsXG4gICAgJ2NyYXJyJzogODYyOSxcbiAgICAnbEFycic6IDg2NTYsXG4gICAgJ3VBcnInOiA4NjU3LFxuICAgICdyQXJyJzogODY1OCxcbiAgICAnZEFycic6IDg2NTksXG4gICAgJ2hBcnInOiA4NjYwLFxuICAgICdmb3JhbGwnOiA4NzA0LFxuICAgICdwYXJ0JzogODcwNixcbiAgICAnZXhpc3QnOiA4NzA3LFxuICAgICdlbXB0eSc6IDg3MDksXG4gICAgJ25hYmxhJzogODcxMSxcbiAgICAnaXNpbic6IDg3MTIsXG4gICAgJ25vdGluJzogODcxMyxcbiAgICAnbmknOiA4NzE1LFxuICAgICdwcm9kJzogODcxOSxcbiAgICAnc3VtJzogODcyMSxcbiAgICAnbWludXMnOiA4NzIyLFxuICAgICdsb3dhc3QnOiA4NzI3LFxuICAgICdyYWRpYyc6IDg3MzAsXG4gICAgJ3Byb3AnOiA4NzMzLFxuICAgICdpbmZpbic6IDg3MzQsXG4gICAgJ2FuZyc6IDg3MzYsXG4gICAgJ2FuZCc6IDg3NDMsXG4gICAgJ29yJzogODc0NCxcbiAgICAnY2FwJzogODc0NSxcbiAgICAnY3VwJzogODc0NixcbiAgICAnaW50JzogODc0NyxcbiAgICAndGhlcmU0JzogODc1NixcbiAgICAnc2ltJzogODc2NCxcbiAgICAnY29uZyc6IDg3NzMsXG4gICAgJ2FzeW1wJzogODc3NixcbiAgICAnbmUnOiA4ODAwLFxuICAgICdlcXVpdic6IDg4MDEsXG4gICAgJ2xlJzogODgwNCxcbiAgICAnZ2UnOiA4ODA1LFxuICAgICdzdWInOiA4ODM0LFxuICAgICdzdXAnOiA4ODM1LFxuICAgICduc3ViJzogODgzNixcbiAgICAnc3ViZSc6IDg4MzgsXG4gICAgJ3N1cGUnOiA4ODM5LFxuICAgICdvcGx1cyc6IDg4NTMsXG4gICAgJ290aW1lcyc6IDg4NTUsXG4gICAgJ3BlcnAnOiA4ODY5LFxuICAgICdzZG90JzogODkwMSxcbiAgICAnbGNlaWwnOiA4OTY4LFxuICAgICdyY2VpbCc6IDg5NjksXG4gICAgJ2xmbG9vcic6IDg5NzAsXG4gICAgJ3JmbG9vcic6IDg5NzEsXG4gICAgJ2xhbmcnOiA5MDAxLFxuICAgICdyYW5nJzogOTAwMixcbiAgICAnbG96JzogOTY3NCxcbiAgICAnc3BhZGVzJzogOTgyNCxcbiAgICAnY2x1YnMnOiA5ODI3LFxuICAgICdoZWFydHMnOiA5ODI5LFxuICAgICdkaWFtcyc6IDk4MzBcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNheC5FTlRJVElFUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGUgPSBzYXguRU5USVRJRVNba2V5XVxuICAgIHZhciBzID0gdHlwZW9mIGUgPT09ICdudW1iZXInID8gU3RyaW5nLmZyb21DaGFyQ29kZShlKSA6IGVcbiAgICBzYXguRU5USVRJRVNba2V5XSA9IHNcbiAgfSlcblxuICBmb3IgKHZhciBzIGluIHNheC5TVEFURSkge1xuICAgIHNheC5TVEFURVtzYXguU1RBVEVbc11dID0gc1xuICB9XG5cbiAgLy8gc2hvcnRoYW5kXG4gIFMgPSBzYXguU1RBVEVcblxuICBmdW5jdGlvbiBlbWl0IChwYXJzZXIsIGV2ZW50LCBkYXRhKSB7XG4gICAgcGFyc2VyW2V2ZW50XSAmJiBwYXJzZXJbZXZlbnRdKGRhdGEpXG4gIH1cblxuICBmdW5jdGlvbiBlbWl0Tm9kZSAocGFyc2VyLCBub2RlVHlwZSwgZGF0YSkge1xuICAgIGlmIChwYXJzZXIudGV4dE5vZGUpIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgZW1pdChwYXJzZXIsIG5vZGVUeXBlLCBkYXRhKVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUZXh0IChwYXJzZXIpIHtcbiAgICBwYXJzZXIudGV4dE5vZGUgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIudGV4dE5vZGUpXG4gICAgaWYgKHBhcnNlci50ZXh0Tm9kZSkgZW1pdChwYXJzZXIsICdvbnRleHQnLCBwYXJzZXIudGV4dE5vZGUpXG4gICAgcGFyc2VyLnRleHROb2RlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRvcHRzIChvcHQsIHRleHQpIHtcbiAgICBpZiAob3B0LnRyaW0pIHRleHQgPSB0ZXh0LnRyaW0oKVxuICAgIGlmIChvcHQubm9ybWFsaXplKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IgKHBhcnNlciwgZXIpIHtcbiAgICBjbG9zZVRleHQocGFyc2VyKVxuICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgZXIgKz0gJ1xcbkxpbmU6ICcgKyBwYXJzZXIubGluZSArXG4gICAgICAgICdcXG5Db2x1bW46ICcgKyBwYXJzZXIuY29sdW1uICtcbiAgICAgICAgJ1xcbkNoYXI6ICcgKyBwYXJzZXIuY1xuICAgIH1cbiAgICBlciA9IG5ldyBFcnJvcihlcilcbiAgICBwYXJzZXIuZXJyb3IgPSBlclxuICAgIGVtaXQocGFyc2VyLCAnb25lcnJvcicsIGVyKVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZCAocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5zYXdSb290ICYmICFwYXJzZXIuY2xvc2VkUm9vdCkgc3RyaWN0RmFpbChwYXJzZXIsICdVbmNsb3NlZCByb290IHRhZycpXG4gICAgaWYgKChwYXJzZXIuc3RhdGUgIT09IFMuQkVHSU4pICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLkJFR0lOX1dISVRFU1BBQ0UpICYmXG4gICAgICAocGFyc2VyLnN0YXRlICE9PSBTLlRFWFQpKSB7XG4gICAgICBlcnJvcihwYXJzZXIsICdVbmV4cGVjdGVkIGVuZCcpXG4gICAgfVxuICAgIGNsb3NlVGV4dChwYXJzZXIpXG4gICAgcGFyc2VyLmMgPSAnJ1xuICAgIHBhcnNlci5jbG9zZWQgPSB0cnVlXG4gICAgZW1pdChwYXJzZXIsICdvbmVuZCcpXG4gICAgU0FYUGFyc2VyLmNhbGwocGFyc2VyLCBwYXJzZXIuc3RyaWN0LCBwYXJzZXIub3B0KVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmljdEZhaWwgKHBhcnNlciwgbWVzc2FnZSkge1xuICAgIGlmICh0eXBlb2YgcGFyc2VyICE9PSAnb2JqZWN0JyB8fCAhKHBhcnNlciBpbnN0YW5jZW9mIFNBWFBhcnNlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwgdG8gc3RyaWN0RmFpbCcpXG4gICAgfVxuICAgIGlmIChwYXJzZXIuc3RyaWN0KSB7XG4gICAgICBlcnJvcihwYXJzZXIsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmV3VGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHBhcnNlci50YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVbcGFyc2VyLmxvb3NlQ2FzZV0oKVxuICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHsgbmFtZTogcGFyc2VyLnRhZ05hbWUsIGF0dHJpYnV0ZXM6IHt9IH1cblxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBpZiB0YWcgY29udGFpbHMgYW4geG1sbnM9XCJmb29cIiBvciB4bWxuczpmb289XCJiYXJcIlxuICAgIGlmIChwYXJzZXIub3B0LnhtbG5zKSB7XG4gICAgICB0YWcubnMgPSBwYXJlbnQubnNcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIGVtaXROb2RlKHBhcnNlciwgJ29ub3BlbnRhZ3N0YXJ0JywgdGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gcW5hbWUgKG5hbWUsIGF0dHJpYnV0ZSkge1xuICAgIHZhciBpID0gbmFtZS5pbmRleE9mKCc6JylcbiAgICB2YXIgcXVhbE5hbWUgPSBpIDwgMCA/IFsgJycsIG5hbWUgXSA6IG5hbWUuc3BsaXQoJzonKVxuICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZVswXVxuICAgIHZhciBsb2NhbCA9IHF1YWxOYW1lWzFdXG5cbiAgICAvLyA8eCBcInhtbG5zXCI9XCJodHRwOi8vZm9vXCI+XG4gICAgaWYgKGF0dHJpYnV0ZSAmJiBuYW1lID09PSAneG1sbnMnKSB7XG4gICAgICBwcmVmaXggPSAneG1sbnMnXG4gICAgICBsb2NhbCA9ICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIGxvY2FsOiBsb2NhbCB9XG4gIH1cblxuICBmdW5jdGlvbiBhdHRyaWIgKHBhcnNlcikge1xuICAgIGlmICghcGFyc2VyLnN0cmljdCkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliTmFtZVtwYXJzZXIubG9vc2VDYXNlXSgpXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hdHRyaWJMaXN0LmluZGV4T2YocGFyc2VyLmF0dHJpYk5hbWUpICE9PSAtMSB8fFxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHBhcnNlci5hdHRyaWJOYW1lKSkge1xuICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5vcHQueG1sbnMpIHtcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci5hdHRyaWJOYW1lLCB0cnVlKVxuICAgICAgdmFyIHByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdmFyIGxvY2FsID0gcW4ubG9jYWxcblxuICAgICAgaWYgKHByZWZpeCA9PT0gJ3htbG5zJykge1xuICAgICAgICAvLyBuYW1lc3BhY2UgYmluZGluZyBhdHRyaWJ1dGUuIHB1c2ggdGhlIGJpbmRpbmcgaW50byBzY29wZVxuICAgICAgICBpZiAobG9jYWwgPT09ICd4bWwnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLFxuICAgICAgICAgICAgJ3htbDogcHJlZml4IG11c3QgYmUgYm91bmQgdG8gJyArIFhNTF9OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsID09PSAneG1sbnMnICYmIHBhcnNlci5hdHRyaWJWYWx1ZSAhPT0gWE1MTlNfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsXG4gICAgICAgICAgICAneG1sbnM6IHByZWZpeCBtdXN0IGJlIGJvdW5kIHRvICcgKyBYTUxOU19OQU1FU1BBQ0UgKyAnXFxuJyArXG4gICAgICAgICAgICAnQWN0dWFsOiAnICsgcGFyc2VyLmF0dHJpYlZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcnNlci50YWdzW3BhcnNlci50YWdzLmxlbmd0aCAtIDFdIHx8IHBhcnNlclxuICAgICAgICAgIGlmICh0YWcubnMgPT09IHBhcmVudC5ucykge1xuICAgICAgICAgICAgdGFnLm5zID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQubnMpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhZy5uc1tsb2NhbF0gPSBwYXJzZXIuYXR0cmliVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZWZlciBvbmF0dHJpYnV0ZSBldmVudHMgdW50aWwgYWxsIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHNlZW5cbiAgICAgIC8vIHNvIGFueSBuZXcgYmluZGluZ3MgY2FuIHRha2UgZWZmZWN0LiBwcmVzZXJ2ZSBhdHRyaWJ1dGUgb3JkZXJcbiAgICAgIC8vIHNvIGRlZmVycmVkIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBpbiBkb2N1bWVudCBvcmRlclxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QucHVzaChbcGFyc2VyLmF0dHJpYk5hbWUsIHBhcnNlci5hdHRyaWJWYWx1ZV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluIG5vbi14bWxucyBtb2RlLCB3ZSBjYW4gZW1pdCB0aGUgZXZlbnQgcmlnaHQgYXdheVxuICAgICAgcGFyc2VyLnRhZy5hdHRyaWJ1dGVzW3BhcnNlci5hdHRyaWJOYW1lXSA9IHBhcnNlci5hdHRyaWJWYWx1ZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCB7XG4gICAgICAgIG5hbWU6IHBhcnNlci5hdHRyaWJOYW1lLFxuICAgICAgICB2YWx1ZTogcGFyc2VyLmF0dHJpYlZhbHVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHBhcnNlci5hdHRyaWJOYW1lID0gcGFyc2VyLmF0dHJpYlZhbHVlID0gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIG9wZW5UYWcgKHBhcnNlciwgc2VsZkNsb3NpbmcpIHtcbiAgICBpZiAocGFyc2VyLm9wdC54bWxucykge1xuICAgICAgLy8gZW1pdCBuYW1lc3BhY2UgYmluZGluZyBldmVudHNcbiAgICAgIHZhciB0YWcgPSBwYXJzZXIudGFnXG5cbiAgICAgIC8vIGFkZCBuYW1lc3BhY2UgaW5mbyB0byB0YWdcbiAgICAgIHZhciBxbiA9IHFuYW1lKHBhcnNlci50YWdOYW1lKVxuICAgICAgdGFnLnByZWZpeCA9IHFuLnByZWZpeFxuICAgICAgdGFnLmxvY2FsID0gcW4ubG9jYWxcbiAgICAgIHRhZy51cmkgPSB0YWcubnNbcW4ucHJlZml4XSB8fCAnJ1xuXG4gICAgICBpZiAodGFnLnByZWZpeCAmJiAhdGFnLnVyaSkge1xuICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VuYm91bmQgbmFtZXNwYWNlIHByZWZpeDogJyArXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGFyc2VyLnRhZ05hbWUpKVxuICAgICAgICB0YWcudXJpID0gcW4ucHJlZml4XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmICh0YWcubnMgJiYgcGFyZW50Lm5zICE9PSB0YWcubnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25vcGVubmFtZXNwYWNlJywge1xuICAgICAgICAgICAgcHJlZml4OiBwLFxuICAgICAgICAgICAgdXJpOiB0YWcubnNbcF1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgZGVmZXJyZWQgb25hdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAvLyBOb3RlOiBkbyBub3QgYXBwbHkgZGVmYXVsdCBucyB0byBhdHRyaWJ1dGVzOlxuICAgICAgLy8gICBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLW5hbWVzLyNkZWZhdWx0aW5nXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbnYgPSBwYXJzZXIuYXR0cmliTGlzdFtpXVxuICAgICAgICB2YXIgbmFtZSA9IG52WzBdXG4gICAgICAgIHZhciB2YWx1ZSA9IG52WzFdXG4gICAgICAgIHZhciBxdWFsTmFtZSA9IHFuYW1lKG5hbWUsIHRydWUpXG4gICAgICAgIHZhciBwcmVmaXggPSBxdWFsTmFtZS5wcmVmaXhcbiAgICAgICAgdmFyIGxvY2FsID0gcXVhbE5hbWUubG9jYWxcbiAgICAgICAgdmFyIHVyaSA9IHByZWZpeCA9PT0gJycgPyAnJyA6ICh0YWcubnNbcHJlZml4XSB8fCAnJylcbiAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgbG9jYWw6IGxvY2FsLFxuICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGFueSBhdHRyaWJ1dGVzIHdpdGggYW4gdW5kZWZpbmVkIG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlbiBmYWlsIG9uIHRoZW0gbm93LlxuICAgICAgICBpZiAocHJlZml4ICYmIHByZWZpeCAhPT0gJ3htbG5zJyAmJiAhdXJpKSB7XG4gICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmJvdW5kIG5hbWVzcGFjZSBwcmVmaXg6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocHJlZml4KSlcbiAgICAgICAgICBhLnVyaSA9IHByZWZpeFxuICAgICAgICB9XG4gICAgICAgIHBhcnNlci50YWcuYXR0cmlidXRlc1tuYW1lXSA9IGFcbiAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25hdHRyaWJ1dGUnLCBhKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIH1cblxuICAgIHBhcnNlci50YWcuaXNTZWxmQ2xvc2luZyA9ICEhc2VsZkNsb3NpbmdcblxuICAgIC8vIHByb2Nlc3MgdGhlIHRhZ1xuICAgIHBhcnNlci5zYXdSb290ID0gdHJ1ZVxuICAgIHBhcnNlci50YWdzLnB1c2gocGFyc2VyLnRhZylcbiAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW50YWcnLCBwYXJzZXIudGFnKVxuICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgPHNjcmlwdD4gaW4gbm9uLXN0cmljdCBtb2RlLlxuICAgICAgaWYgKCFwYXJzZXIubm9zY3JpcHQgJiYgcGFyc2VyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICAgICAgfVxuICAgICAgcGFyc2VyLnRhZyA9IG51bGxcbiAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICB9XG4gICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgIHBhcnNlci5hdHRyaWJMaXN0Lmxlbmd0aCA9IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlVGFnIChwYXJzZXIpIHtcbiAgICBpZiAoIXBhcnNlci50YWdOYW1lKSB7XG4gICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1dlaXJkIGVtcHR5IGNsb3NlIHRhZy4nKVxuICAgICAgcGFyc2VyLnRleHROb2RlICs9ICc8Lz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJzZXIuc2NyaXB0KSB7XG4gICAgICBpZiAocGFyc2VyLnRhZ05hbWUgIT09ICdzY3JpcHQnKSB7XG4gICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5TQ1JJUFRcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNjcmlwdCcsIHBhcnNlci5zY3JpcHQpXG4gICAgICBwYXJzZXIuc2NyaXB0ID0gJydcbiAgICB9XG5cbiAgICAvLyBmaXJzdCBtYWtlIHN1cmUgdGhhdCB0aGUgY2xvc2luZyB0YWcgYWN0dWFsbHkgZXhpc3RzLlxuICAgIC8vIDxhPjxiPjwvYz48L2I+PC9hPiB3aWxsIGNsb3NlIGV2ZXJ5dGhpbmcsIG90aGVyd2lzZS5cbiAgICB2YXIgdCA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHZhciB0YWdOYW1lID0gcGFyc2VyLnRhZ05hbWVcbiAgICBpZiAoIXBhcnNlci5zdHJpY3QpIHtcbiAgICAgIHRhZ05hbWUgPSB0YWdOYW1lW3BhcnNlci5sb29zZUNhc2VdKClcbiAgICB9XG4gICAgdmFyIGNsb3NlVG8gPSB0YWdOYW1lXG4gICAgd2hpbGUgKHQtLSkge1xuICAgICAgdmFyIGNsb3NlID0gcGFyc2VyLnRhZ3NbdF1cbiAgICAgIGlmIChjbG9zZS5uYW1lICE9PSBjbG9zZVRvKSB7XG4gICAgICAgIC8vIGZhaWwgdGhlIGZpcnN0IHRpbWUgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdVbmV4cGVjdGVkIGNsb3NlIHRhZycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpZG4ndCBmaW5kIGl0LiAgd2UgYWxyZWFkeSBmYWlsZWQgZm9yIHN0cmljdCwgc28ganVzdCBhYm9ydC5cbiAgICBpZiAodCA8IDApIHtcbiAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5tYXRjaGVkIGNsb3NpbmcgdGFnOiAnICsgcGFyc2VyLnRhZ05hbWUpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwvJyArIHBhcnNlci50YWdOYW1lICsgJz4nXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBwYXJzZXIudGFnTmFtZSA9IHRhZ05hbWVcbiAgICB2YXIgcyA9IHBhcnNlci50YWdzLmxlbmd0aFxuICAgIHdoaWxlIChzLS0gPiB0KSB7XG4gICAgICB2YXIgdGFnID0gcGFyc2VyLnRhZyA9IHBhcnNlci50YWdzLnBvcCgpXG4gICAgICBwYXJzZXIudGFnTmFtZSA9IHBhcnNlci50YWcubmFtZVxuICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZXRhZycsIHBhcnNlci50YWdOYW1lKVxuXG4gICAgICB2YXIgeCA9IHt9XG4gICAgICBmb3IgKHZhciBpIGluIHRhZy5ucykge1xuICAgICAgICB4W2ldID0gdGFnLm5zW2ldXG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBwYXJzZXIudGFnc1twYXJzZXIudGFncy5sZW5ndGggLSAxXSB8fCBwYXJzZXJcbiAgICAgIGlmIChwYXJzZXIub3B0LnhtbG5zICYmIHRhZy5ucyAhPT0gcGFyZW50Lm5zKSB7XG4gICAgICAgIC8vIHJlbW92ZSBuYW1lc3BhY2UgYmluZGluZ3MgaW50cm9kdWNlZCBieSB0YWdcbiAgICAgICAgT2JqZWN0LmtleXModGFnLm5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIG4gPSB0YWcubnNbcF1cbiAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNsb3NlbmFtZXNwYWNlJywgeyBwcmVmaXg6IHAsIHVyaTogbiB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodCA9PT0gMCkgcGFyc2VyLmNsb3NlZFJvb3QgPSB0cnVlXG4gICAgcGFyc2VyLnRhZ05hbWUgPSBwYXJzZXIuYXR0cmliVmFsdWUgPSBwYXJzZXIuYXR0cmliTmFtZSA9ICcnXG4gICAgcGFyc2VyLmF0dHJpYkxpc3QubGVuZ3RoID0gMFxuICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVFxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbnRpdHkgKHBhcnNlcikge1xuICAgIHZhciBlbnRpdHkgPSBwYXJzZXIuZW50aXR5XG4gICAgdmFyIGVudGl0eUxDID0gZW50aXR5LnRvTG93ZXJDYXNlKClcbiAgICB2YXIgbnVtXG4gICAgdmFyIG51bVN0ciA9ICcnXG5cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eV0pIHtcbiAgICAgIHJldHVybiBwYXJzZXIuRU5USVRJRVNbZW50aXR5XVxuICAgIH1cbiAgICBpZiAocGFyc2VyLkVOVElUSUVTW2VudGl0eUxDXSkge1xuICAgICAgcmV0dXJuIHBhcnNlci5FTlRJVElFU1tlbnRpdHlMQ11cbiAgICB9XG4gICAgZW50aXR5ID0gZW50aXR5TENcbiAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnKSB7XG4gICAgICAgIGVudGl0eSA9IGVudGl0eS5zbGljZSgyKVxuICAgICAgICBudW0gPSBwYXJzZUludChlbnRpdHksIDE2KVxuICAgICAgICBudW1TdHIgPSBudW0udG9TdHJpbmcoMTYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRpdHkgPSBlbnRpdHkuc2xpY2UoMSlcbiAgICAgICAgbnVtID0gcGFyc2VJbnQoZW50aXR5LCAxMClcbiAgICAgICAgbnVtU3RyID0gbnVtLnRvU3RyaW5nKDEwKVxuICAgICAgfVxuICAgIH1cbiAgICBlbnRpdHkgPSBlbnRpdHkucmVwbGFjZSgvXjArLywgJycpXG4gICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtU3RyLnRvTG93ZXJDYXNlKCkgIT09IGVudGl0eSkge1xuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBlbnRpdHknKVxuICAgICAgcmV0dXJuICcmJyArIHBhcnNlci5lbnRpdHkgKyAnOydcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQobnVtKVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5XaGl0ZVNwYWNlIChwYXJzZXIsIGMpIHtcbiAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLk9QRU5fV0FLQVxuICAgICAgcGFyc2VyLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIucG9zaXRpb25cbiAgICB9IGVsc2UgaWYgKCFpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgIC8vIGhhdmUgdG8gcHJvY2VzcyB0aGlzIGFzIGEgdGV4dCBub2RlLlxuICAgICAgLy8gd2VpcmQsIGJ1dCBoYXBwZW5zLlxuICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdOb24td2hpdGVzcGFjZSBiZWZvcmUgZmlyc3QgdGFnLicpXG4gICAgICBwYXJzZXIudGV4dE5vZGUgPSBjXG4gICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFyQXQgKGNodW5rLCBpKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgaWYgKGkgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rLmNoYXJBdChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSAoY2h1bmspIHtcbiAgICB2YXIgcGFyc2VyID0gdGhpc1xuICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yXG4gICAgfVxuICAgIGlmIChwYXJzZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gZXJyb3IocGFyc2VyLFxuICAgICAgICAnQ2Fubm90IHdyaXRlIGFmdGVyIGNsb3NlLiBBc3NpZ24gYW4gb25yZWFkeSBoYW5kbGVyLicpXG4gICAgfVxuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuZChwYXJzZXIpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdvYmplY3QnKSB7XG4gICAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGMgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjID0gY2hhckF0KGNodW5rLCBpKyspXG4gICAgICBwYXJzZXIuYyA9IGNcblxuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICBwYXJzZXIucG9zaXRpb24rK1xuICAgICAgICBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgcGFyc2VyLmNvbHVtbiA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHBhcnNlci5zdGF0ZSkge1xuICAgICAgICBjYXNlIFMuQkVHSU46XG4gICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5CRUdJTl9XSElURVNQQUNFXG4gICAgICAgICAgaWYgKGMgPT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYmVnaW5XaGl0ZVNwYWNlKHBhcnNlciwgYylcbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5CRUdJTl9XSElURVNQQUNFOlxuICAgICAgICAgIGJlZ2luV2hpdGVTcGFjZShwYXJzZXIsIGMpXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuVEVYVDpcbiAgICAgICAgICBpZiAocGFyc2VyLnNhd1Jvb3QgJiYgIXBhcnNlci5jbG9zZWRSb290KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRpID0gaSAtIDFcbiAgICAgICAgICAgIHdoaWxlIChjICYmIGMgIT09ICc8JyAmJiBjICE9PSAnJicpIHtcbiAgICAgICAgICAgICAgYyA9IGNoYXJBdChjaHVuaywgaSsrKVxuICAgICAgICAgICAgICBpZiAoYyAmJiBwYXJzZXIudHJhY2tQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHBhcnNlci5wb3NpdGlvbisrXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIubGluZSsrXG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uID0gMFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXIuY29sdW1uKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjaHVuay5zdWJzdHJpbmcoc3RhcnRpLCBpIC0gMSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICc8JyAmJiAhKHBhcnNlci5zYXdSb290ICYmIHBhcnNlci5jbG9zZWRSb290ICYmICFwYXJzZXIuc3RyaWN0KSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1dBS0FcbiAgICAgICAgICAgIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uID0gcGFyc2VyLnBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpICYmICghcGFyc2VyLnNhd1Jvb3QgfHwgcGFyc2VyLmNsb3NlZFJvb3QpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVGV4dCBkYXRhIG91dHNpZGUgb2Ygcm9vdCBub2RlLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuVEVYVF9FTlRJVFlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50ZXh0Tm9kZSArPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVDpcbiAgICAgICAgICAvLyBvbmx5IG5vbi1zdHJpY3RcbiAgICAgICAgICBpZiAoYyA9PT0gJzwnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNDUklQVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICcvJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DTE9TRV9UQUdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPCcgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5PUEVOX1dBS0E6XG4gICAgICAgICAgLy8gZWl0aGVyIGEgLywgPywgISwgb3IgdGV4dCBpcyBjb21pbmcgbmV4dC5cbiAgICAgICAgICBpZiAoYyA9PT0gJyEnKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNHTUxfREVDTFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgaXQuLi5cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5PUEVOX1RBR1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgPSBjXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHXG4gICAgICAgICAgICBwYXJzZXIudGFnTmFtZSA9ICcnXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnVW5lbmNvZGVkIDwnKVxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2FzIHNvbWUgd2hpdGVzcGFjZSwgdGhlbiBhZGQgdGhhdCBpbi5cbiAgICAgICAgICAgIGlmIChwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiArIDEgPCBwYXJzZXIucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IHBhcnNlci5wb3NpdGlvbiAtIHBhcnNlci5zdGFydFRhZ1Bvc2l0aW9uXG4gICAgICAgICAgICAgIGMgPSBuZXcgQXJyYXkocGFkKS5qb2luKCcgJykgKyBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIudGV4dE5vZGUgKz0gJzwnICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5URVhUXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlNHTUxfREVDTDpcbiAgICAgICAgICBpZiAoKHBhcnNlci5zZ21sRGVjbCArIGMpLnRvVXBwZXJDYXNlKCkgPT09IENEQVRBKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbm9wZW5jZGF0YScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkNEQVRBXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlci5zZ21sRGVjbCArIGMgPT09ICctLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsID0gJydcbiAgICAgICAgICB9IGVsc2UgaWYgKChwYXJzZXIuc2dtbERlY2wgKyBjKS50b1VwcGVyQ2FzZSgpID09PSBET0NUWVBFKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVcbiAgICAgICAgICAgIGlmIChwYXJzZXIuZG9jdHlwZSB8fCBwYXJzZXIuc2F3Um9vdCkge1xuICAgICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlcixcbiAgICAgICAgICAgICAgICAnSW5hcHByb3ByaWF0ZWx5IGxvY2F0ZWQgZG9jdHlwZSBkZWNsYXJhdGlvbicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuZG9jdHlwZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc2dtbERlY2wgPSAnJ1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbnNnbWxkZWNsYXJhdGlvbicsIHBhcnNlci5zZ21sRGVjbClcbiAgICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzUXVvdGUoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnNnbWxEZWNsICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuU0dNTF9ERUNMX1FVT1RFRDpcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0dNTF9ERUNMXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5zZ21sRGVjbCArPSBjXG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuRE9DVFlQRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgIGVtaXROb2RlKHBhcnNlciwgJ29uZG9jdHlwZScsIHBhcnNlci5kb2N0eXBlKVxuICAgICAgICAgICAgcGFyc2VyLmRvY3R5cGUgPSB0cnVlIC8vIGp1c3QgcmVtZW1iZXIgdGhhdCB3ZSBzYXcgaXQuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICAgIGlmIChjID09PSAnWycpIHtcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFX0RURFxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRV9RVU9URURcbiAgICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfUVVPVEVEOlxuICAgICAgICAgIHBhcnNlci5kb2N0eXBlICs9IGNcbiAgICAgICAgICBpZiAoYyA9PT0gcGFyc2VyLnEpIHtcbiAgICAgICAgICAgIHBhcnNlci5xID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuRE9DVFlQRVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5ET0NUWVBFX0RURDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5ET0NUWVBFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREX1FVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLnEgPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkRPQ1RZUEVfRFREX1FVT1RFRDpcbiAgICAgICAgICBwYXJzZXIuZG9jdHlwZSArPSBjXG4gICAgICAgICAgaWYgKGMgPT09IHBhcnNlci5xKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkRPQ1RZUEVfRFREXG4gICAgICAgICAgICBwYXJzZXIucSA9ICcnXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlQ6XG4gICAgICAgICAgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UX0VORElOR1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY29tbWVudCArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnLScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVF9FTkRFRFxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgPSB0ZXh0b3B0cyhwYXJzZXIub3B0LCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIGlmIChwYXJzZXIuY29tbWVudCkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNvbW1lbnQnLCBwYXJzZXIuY29tbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5jb21tZW50ID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0nICsgY1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DT01NRU5UXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkNPTU1FTlRfRU5ERUQ6XG4gICAgICAgICAgaWYgKGMgIT09ICc+Jykge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdNYWxmb3JtZWQgY29tbWVudCcpXG4gICAgICAgICAgICAvLyBhbGxvdyA8IS0tIGJsYWggLS0gYmxvbyAtLT4gaW4gbm9uLXN0cmljdCBtb2RlLFxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgYSBjb21tZW50IG9mIFwiIGJsYWggLS0gYmxvbyBcIlxuICAgICAgICAgICAgcGFyc2VyLmNvbW1lbnQgKz0gJy0tJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ09NTUVOVFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEE6XG4gICAgICAgICAgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5DREFUQV9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9IGNcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HOlxuICAgICAgICAgIGlmIChjID09PSAnXScpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFfRU5ESU5HXzJcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0RBVEFfRU5ESU5HXzI6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgaWYgKHBhcnNlci5jZGF0YSkge1xuICAgICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmNkYXRhJywgcGFyc2VyLmNkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25jbG9zZWNkYXRhJylcbiAgICAgICAgICAgIHBhcnNlci5jZGF0YSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICddJykge1xuICAgICAgICAgICAgcGFyc2VyLmNkYXRhICs9ICddJ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuY2RhdGEgKz0gJ11dJyArIGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0RBVEFcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuUFJPQ19JTlNUOlxuICAgICAgICAgIGlmIChjID09PSAnPycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuUFJPQ19JTlNUX0VORElOR1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5wcm9jSW5zdE5hbWUgKz0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5QUk9DX0lOU1RfQk9EWTpcbiAgICAgICAgICBpZiAoIXBhcnNlci5wcm9jSW5zdEJvZHkgJiYgaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz8nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9FTkRJTkdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSBjXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLlBST0NfSU5TVF9FTkRJTkc6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgZW1pdE5vZGUocGFyc2VyLCAnb25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24nLCB7XG4gICAgICAgICAgICAgIG5hbWU6IHBhcnNlci5wcm9jSW5zdE5hbWUsXG4gICAgICAgICAgICAgIGJvZHk6IHBhcnNlci5wcm9jSW5zdEJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBwYXJzZXIucHJvY0luc3ROYW1lID0gcGFyc2VyLnByb2NJbnN0Qm9keSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnByb2NJbnN0Qm9keSArPSAnPycgKyBjXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlBST0NfSU5TVF9CT0RZXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLk9QRU5fVEFHOlxuICAgICAgICAgIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdUYWcocGFyc2VyKVxuICAgICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiB0YWcgbmFtZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuT1BFTl9UQUdfU0xBU0g6XG4gICAgICAgICAgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIsIHRydWUpXG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnRm9yd2FyZC1zbGFzaCBpbiBvcGVuaW5nIHRhZyBub3QgZm9sbG93ZWQgYnkgPicpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQlxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUI6XG4gICAgICAgICAgLy8gaGF2ZW4ndCByZWFkIHRoZSBhdHRyaWJ1dGUgbmFtZSB5ZXQuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgPSBjXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRTpcbiAgICAgICAgICBpZiAoYyA9PT0gJz0nKSB7XG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0F0dHJpYnV0ZSB3aXRob3V0IHZhbHVlJylcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9IHBhcnNlci5hdHRyaWJOYW1lXG4gICAgICAgICAgICBhdHRyaWIocGFyc2VyKVxuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX05BTUVfU0FXX1dISVRFXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYk5hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfTkFNRV9TQVdfV0hJVEU6XG4gICAgICAgICAgaWYgKGMgPT09ICc9Jykge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfVkFMVUVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdBdHRyaWJ1dGUgd2l0aG91dCB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIudGFnLmF0dHJpYnV0ZXNbcGFyc2VyLmF0dHJpYk5hbWVdID0gJydcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBlbWl0Tm9kZShwYXJzZXIsICdvbmF0dHJpYnV0ZScsIHtcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VyLmF0dHJpYk5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJOYW1lID0gJydcbiAgICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJfTkFNRVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lJylcbiAgICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChpc1F1b3RlKGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIucSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHJpY3RGYWlsKHBhcnNlciwgJ1VucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZScpXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRFxuICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlID0gY1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfUVVPVEVEOlxuICAgICAgICAgIGlmIChjICE9PSBwYXJzZXIucSkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICcmJykge1xuICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGFyc2VyLmF0dHJpYlZhbHVlICs9IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYihwYXJzZXIpXG4gICAgICAgICAgcGFyc2VyLnEgPSAnJ1xuICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0NMT1NFRFxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9DTE9TRUQ6XG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZShjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+Jykge1xuICAgICAgICAgICAgb3BlblRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLycpIHtcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuT1BFTl9UQUdfU0xBU0hcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdObyB3aGl0ZXNwYWNlIGJldHdlZW4gYXR0cmlidXRlcycpXG4gICAgICAgICAgICBwYXJzZXIuYXR0cmliTmFtZSA9IGNcbiAgICAgICAgICAgIHBhcnNlci5hdHRyaWJWYWx1ZSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLkFUVFJJQl9OQU1FXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9VTlFVT1RFRDpcbiAgICAgICAgICBpZiAoIWlzQXR0cmliRW5kKGMpKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX0VOVElUWV9VXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJzZXIuYXR0cmliVmFsdWUgKz0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmliKHBhcnNlcilcbiAgICAgICAgICBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBvcGVuVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gUy5BVFRSSUJcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcblxuICAgICAgICBjYXNlIFMuQ0xPU0VfVEFHOlxuICAgICAgICAgIGlmICghcGFyc2VyLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm90TWF0Y2gobmFtZVN0YXJ0LCBjKSkge1xuICAgICAgICAgICAgICBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5zY3JpcHQgKz0gJzwvJyArIGNcbiAgICAgICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSBTLlNDUklQVFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnLicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gY1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJz4nKSB7XG4gICAgICAgICAgICBjbG9zZVRhZyhwYXJzZXIpXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01hdGNoKG5hbWVCb2R5LCBjKSkge1xuICAgICAgICAgICAgcGFyc2VyLnRhZ05hbWUgKz0gY1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLnNjcmlwdCkge1xuICAgICAgICAgICAgcGFyc2VyLnNjcmlwdCArPSAnPC8nICsgcGFyc2VyLnRhZ05hbWVcbiAgICAgICAgICAgIHBhcnNlci50YWdOYW1lID0gJydcbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuU0NSSVBUXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICAgIHN0cmljdEZhaWwocGFyc2VyLCAnSW52YWxpZCB0YWduYW1lIGluIGNsb3NpbmcgdGFnJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnNlci5zdGF0ZSA9IFMuQ0xPU0VfVEFHX1NBV19XSElURVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5DTE9TRV9UQUdfU0FXX1dISVRFOlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoYykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjID09PSAnPicpIHtcbiAgICAgICAgICAgIGNsb3NlVGFnKHBhcnNlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gY2xvc2luZyB0YWcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuXG4gICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfUTpcbiAgICAgICAgY2FzZSBTLkFUVFJJQl9WQUxVRV9FTlRJVFlfVTpcbiAgICAgICAgICB2YXIgcmV0dXJuU3RhdGVcbiAgICAgICAgICB2YXIgYnVmZmVyXG4gICAgICAgICAgc3dpdGNoIChwYXJzZXIuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgUy5URVhUX0VOVElUWTpcbiAgICAgICAgICAgICAgcmV0dXJuU3RhdGUgPSBTLlRFWFRcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ3RleHROb2RlJ1xuICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICBjYXNlIFMuQVRUUklCX1ZBTFVFX0VOVElUWV9ROlxuICAgICAgICAgICAgICByZXR1cm5TdGF0ZSA9IFMuQVRUUklCX1ZBTFVFX1FVT1RFRFxuICAgICAgICAgICAgICBidWZmZXIgPSAnYXR0cmliVmFsdWUnXG4gICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgIGNhc2UgUy5BVFRSSUJfVkFMVUVfRU5USVRZX1U6XG4gICAgICAgICAgICAgIHJldHVyblN0YXRlID0gUy5BVFRSSUJfVkFMVUVfVU5RVU9URURcbiAgICAgICAgICAgICAgYnVmZmVyID0gJ2F0dHJpYlZhbHVlJ1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09PSAnOycpIHtcbiAgICAgICAgICAgIHBhcnNlcltidWZmZXJdICs9IHBhcnNlRW50aXR5KHBhcnNlcilcbiAgICAgICAgICAgIHBhcnNlci5lbnRpdHkgPSAnJ1xuICAgICAgICAgICAgcGFyc2VyLnN0YXRlID0gcmV0dXJuU3RhdGVcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWF0Y2gocGFyc2VyLmVudGl0eS5sZW5ndGggPyBlbnRpdHlCb2R5IDogZW50aXR5U3RhcnQsIGMpKSB7XG4gICAgICAgICAgICBwYXJzZXIuZW50aXR5ICs9IGNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyaWN0RmFpbChwYXJzZXIsICdJbnZhbGlkIGNoYXJhY3RlciBpbiBlbnRpdHkgbmFtZScpXG4gICAgICAgICAgICBwYXJzZXJbYnVmZmVyXSArPSAnJicgKyBwYXJzZXIuZW50aXR5ICsgY1xuICAgICAgICAgICAgcGFyc2VyLmVudGl0eSA9ICcnXG4gICAgICAgICAgICBwYXJzZXIuc3RhdGUgPSByZXR1cm5TdGF0ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyLCAnVW5rbm93biBzdGF0ZTogJyArIHBhcnNlci5zdGF0ZSlcbiAgICAgIH1cbiAgICB9IC8vIHdoaWxlXG5cbiAgICBpZiAocGFyc2VyLnBvc2l0aW9uID49IHBhcnNlci5idWZmZXJDaGVja1Bvc2l0aW9uKSB7XG4gICAgICBjaGVja0J1ZmZlckxlbmd0aChwYXJzZXIpXG4gICAgfVxuICAgIHJldHVybiBwYXJzZXJcbiAgfVxuXG4gIC8qISBodHRwOi8vbXRocy5iZS9mcm9tY29kZXBvaW50IHYwLjEuMCBieSBAbWF0aGlhcyAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yXG4gICAgICB2YXIgZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwXG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXVxuICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZVxuICAgICAgICB2YXIgbG93U3Vycm9nYXRlXG4gICAgICAgIHZhciBpbmRleCA9IC0xXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFpc0Zpbml0ZShjb2RlUG9pbnQpIHx8IC8vIGBOYU5gLCBgK0luZmluaXR5YCwgb3IgYC1JbmZpbml0eWBcbiAgICAgICAgICAgIGNvZGVQb2ludCA8IDAgfHwgLy8gbm90IGEgdmFsaWQgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgICBjb2RlUG9pbnQgPiAweDEwRkZGRiB8fCAvLyBub3QgYSB2YWxpZCBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGZsb29yKGNvZGVQb2ludCkgIT09IGNvZGVQb2ludCAvLyBub3QgYW4gaW50ZWdlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCBjb2RlIHBvaW50OiAnICsgY29kZVBvaW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4RkZGRikgeyAvLyBCTVAgY29kZSBwb2ludFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goY29kZVBvaW50KVxuICAgICAgICAgIH0gZWxzZSB7IC8vIEFzdHJhbCBjb2RlIHBvaW50OyBzcGxpdCBpbiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgICAgICAvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgICAgICAgIGhpZ2hTdXJyb2dhdGUgPSAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMFxuICAgICAgICAgICAgbG93U3Vycm9nYXRlID0gKGNvZGVQb2ludCAlIDB4NDAwKSArIDB4REMwMFxuICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cylcbiAgICAgICAgICAgIGNvZGVVbml0cy5sZW5ndGggPSAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcsICdmcm9tQ29kZVBvaW50Jywge1xuICAgICAgICAgIHZhbHVlOiBmcm9tQ29kZVBvaW50LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3RyaW5nLmZyb21Db2RlUG9pbnQgPSBmcm9tQ29kZVBvaW50XG4gICAgICB9XG4gICAgfSgpKVxuICB9XG59KSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNheCA9IHt9IDogZXhwb3J0cylcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVhtbCA9IGV4cG9ydHMuWEVsZW1lbnQgPSB2b2lkIDA7XG5jb25zdCBzYXggPSByZXF1aXJlKFwic2F4XCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4XCIpO1xuY2xhc3MgWEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDRGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKFwiRWxlbWVudCBuYW1lIGNhbm5vdCBiZSBlbXB0eVwiLCBcIkVSUl9YTUxfRUxFTUVOVF9OQU1FX0VNUFRZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNWYWxpZE5hbWUobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IGluZGV4XzEubmV3RXJyb3IoYEludmFsaWQgZWxlbWVudCBuYW1lOiAke25hbWV9YCwgXCJFUlJfWE1MX0VMRU1FTlRfSU5WQUxJRF9OQU1FXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dHJpYnV0ZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXR0cmlidXRlcyA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhfMS5uZXdFcnJvcihgTm8gYXR0cmlidXRlIFwiJHtuYW1lfVwiYCwgXCJFUlJfWE1MX01JU1NFRF9BVFRSSUJVVEVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50KG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSwgZXJyb3JJZk1pc3NlZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lbGVtZW50T3JOdWxsKG5hbWUsIGlnbm9yZUNhc2UpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBpbmRleF8xLm5ld0Vycm9yKGVycm9ySWZNaXNzZWQgfHwgYE5vIGVsZW1lbnQgXCIke25hbWV9XCJgLCBcIkVSUl9YTUxfTUlTU0VEX0VMRU1FTlRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAoaXNOYW1lRXF1YWxzKGVsZW1lbnQsIG5hbWUsIGlnbm9yZUNhc2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzKG5hbWUsIGlnbm9yZUNhc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbHRlcihpdCA9PiBpc05hbWVFcXVhbHMoaXQsIG5hbWUsIGlnbm9yZUNhc2UpKTtcbiAgICB9XG4gICAgZWxlbWVudFZhbHVlT3JFbXB0eShuYW1lLCBpZ25vcmVDYXNlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudE9yTnVsbChuYW1lLCBpZ25vcmVDYXNlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IG51bGwgPyBcIlwiIDogZWxlbWVudC52YWx1ZTtcbiAgICB9XG59XG5leHBvcnRzLlhFbGVtZW50ID0gWEVsZW1lbnQ7XG5jb25zdCBOQU1FX1JFR19FWFAgPSBuZXcgUmVnRXhwKC9eW0EtWmEtel9dWzpBLVphLXowLTlfLV0qJC9pKTtcbmZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTkFNRV9SRUdfRVhQLnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBpc05hbWVFcXVhbHMoZWxlbWVudCwgbmFtZSwgaWdub3JlQ2FzZSkge1xuICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5uYW1lO1xuICAgIHJldHVybiBlbGVtZW50TmFtZSA9PT0gbmFtZSB8fCAoaWdub3JlQ2FzZSA9PT0gdHJ1ZSAmJiBlbGVtZW50TmFtZS5sZW5ndGggPT09IG5hbWUubGVuZ3RoICYmIGVsZW1lbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBwYXJzZVhtbChkYXRhKSB7XG4gICAgbGV0IHJvb3RFbGVtZW50ID0gbnVsbDtcbiAgICBjb25zdCBwYXJzZXIgPSBzYXgucGFyc2VyKHRydWUsIHt9KTtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHBhcnNlci5vbm9wZW50YWcgPSBzYXhFbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBYRWxlbWVudChzYXhFbGVtZW50Lm5hbWUpO1xuICAgICAgICBlbGVtZW50LmF0dHJpYnV0ZXMgPSBzYXhFbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocGFyZW50LmVsZW1lbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgfTtcbiAgICBwYXJzZXIub25jbG9zZXRhZyA9ICgpID0+IHtcbiAgICAgICAgZWxlbWVudHMucG9wKCk7XG4gICAgfTtcbiAgICBwYXJzZXIub250ZXh0ID0gdGV4dCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IHRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlci5vbmNkYXRhID0gY2RhdGEgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBjZGF0YTtcbiAgICAgICAgZWxlbWVudC5pc0NEYXRhID0gdHJ1ZTtcbiAgICB9O1xuICAgIHBhcnNlci5vbmVycm9yID0gZXJyID0+IHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgcGFyc2VyLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiByb290RWxlbWVudDtcbn1cbmV4cG9ydHMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhtbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmV3RXJyb3IgPSBleHBvcnRzLmFzQXJyYXkgPSBleHBvcnRzLkNVUlJFTlRfQVBQX1BBQ0tBR0VfRklMRV9OQU1FID0gZXhwb3J0cy5DVVJSRU5UX0FQUF9JTlNUQUxMRVJfRklMRV9OQU1FID0gZXhwb3J0cy5YRWxlbWVudCA9IGV4cG9ydHMucGFyc2VYbWwgPSBleHBvcnRzLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm0gPSBleHBvcnRzLlVVSUQgPSBleHBvcnRzLnBhcnNlRG4gPSBleHBvcnRzLmdpdGh1YlVybCA9IGV4cG9ydHMuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0VXJsID0gZXhwb3J0cy5wYXJzZUpzb24gPSBleHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gZXhwb3J0cy5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21VcmwgPSBleHBvcnRzLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zID0gZXhwb3J0cy5zYWZlR2V0SGVhZGVyID0gZXhwb3J0cy5EaWdlc3RUcmFuc2Zvcm0gPSBleHBvcnRzLkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuY3JlYXRlSHR0cEVycm9yID0gZXhwb3J0cy5IdHRwRXJyb3IgPSBleHBvcnRzLkNhbmNlbGxhdGlvbkVycm9yID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbnZhciBDYW5jZWxsYXRpb25Ub2tlbl8xID0gcmVxdWlyZShcIi4vQ2FuY2VsbGF0aW9uVG9rZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25Ub2tlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2FuY2VsbGF0aW9uVG9rZW5fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDYW5jZWxsYXRpb25Ub2tlbl8xLkNhbmNlbGxhdGlvbkVycm9yOyB9IH0pO1xudmFyIGh0dHBFeGVjdXRvcl8xID0gcmVxdWlyZShcIi4vaHR0cEV4ZWN1dG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSHR0cEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5IdHRwRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVIdHRwRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNyZWF0ZUh0dHBFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBFeGVjdXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuSHR0cEV4ZWN1dG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlnZXN0VHJhbnNmb3JtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5EaWdlc3RUcmFuc2Zvcm07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlR2V0SGVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5zYWZlR2V0SGVhZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uZmlndXJlUmVxdWVzdE9wdGlvbnNGcm9tVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBodHRwRXhlY3V0b3JfMS5jb25maWd1cmVSZXF1ZXN0T3B0aW9uc0Zyb21Vcmw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzYWZlU3RyaW5naWZ5SnNvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaHR0cEV4ZWN1dG9yXzEuc2FmZVN0cmluZ2lmeUpzb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUpzb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLnBhcnNlSnNvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmZpZ3VyZVJlcXVlc3RVcmxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGh0dHBFeGVjdXRvcl8xLmNvbmZpZ3VyZVJlcXVlc3RVcmw7IH0gfSk7XG52YXIgcHVibGlzaE9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3B1Ymxpc2hPcHRpb25zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwdWJsaXNoT3B0aW9uc18xLmdldFMzTGlrZVByb3ZpZGVyQmFzZVVybDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdpdGh1YlVybFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHVibGlzaE9wdGlvbnNfMS5naXRodWJVcmw7IH0gfSk7XG52YXIgcmZjMjI1M1BhcnNlcl8xID0gcmVxdWlyZShcIi4vcmZjMjI1M1BhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlRG5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJmYzIyNTNQYXJzZXJfMS5wYXJzZURuOyB9IH0pO1xudmFyIHV1aWRfMSA9IHJlcXVpcmUoXCIuL3V1aWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVVUlEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dWlkXzEuVVVJRDsgfSB9KTtcbnZhciBQcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0NhbGxiYWNrVHJhbnNmb3JtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xLlByb2dyZXNzQ2FsbGJhY2tUcmFuc2Zvcm07IH0gfSk7XG52YXIgeG1sXzEgPSByZXF1aXJlKFwiLi94bWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVhtbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geG1sXzEucGFyc2VYbWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYRWxlbWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geG1sXzEuWEVsZW1lbnQ7IH0gfSk7XG4vLyBuc2lzXG5leHBvcnRzLkNVUlJFTlRfQVBQX0lOU1RBTExFUl9GSUxFX05BTUUgPSBcImluc3RhbGxlci5leGVcIjtcbi8vIG5zaXMtd2ViXG5leHBvcnRzLkNVUlJFTlRfQVBQX1BBQ0tBR0VfRklMRV9OQU1FID0gXCJwYWNrYWdlLjd6XCI7XG5mdW5jdGlvbiBhc0FycmF5KHYpIHtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfVxufVxuZXhwb3J0cy5hc0FycmF5ID0gYXNBcnJheTtcbmZ1bmN0aW9uIG5ld0Vycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5leHBvcnRzLm5ld0Vycm9yID0gbmV3RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gaXNOb3RoaW5nKHN1YmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpIHx8IChzdWJqZWN0ID09PSBudWxsKTtcbn1cblxuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnKSAmJiAoc3ViamVjdCAhPT0gbnVsbCk7XG59XG5cblxuZnVuY3Rpb24gdG9BcnJheShzZXF1ZW5jZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzZXF1ZW5jZSkpIHJldHVybiBzZXF1ZW5jZTtcbiAgZWxzZSBpZiAoaXNOb3RoaW5nKHNlcXVlbmNlKSkgcmV0dXJuIFtdO1xuXG4gIHJldHVybiBbIHNlcXVlbmNlIF07XG59XG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBpbmRleCwgbGVuZ3RoLCBrZXksIHNvdXJjZUtleXM7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHNvdXJjZUtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAga2V5ID0gc291cmNlS2V5c1tpbmRleF07XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cblxuZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgY291bnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBjeWNsZTtcblxuICBmb3IgKGN5Y2xlID0gMDsgY3ljbGUgPCBjb3VudDsgY3ljbGUgKz0gMSkge1xuICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIGlzTmVnYXRpdmVaZXJvKG51bWJlcikge1xuICByZXR1cm4gKG51bWJlciA9PT0gMCkgJiYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gMSAvIG51bWJlcik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMuaXNOb3RoaW5nICAgICAgPSBpc05vdGhpbmc7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdCAgICAgICA9IGlzT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMudG9BcnJheSAgICAgICAgPSB0b0FycmF5O1xubW9kdWxlLmV4cG9ydHMucmVwZWF0ICAgICAgICAgPSByZXBlYXQ7XG5tb2R1bGUuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xubW9kdWxlLmV4cG9ydHMuZXh0ZW5kICAgICAgICAgPSBleHRlbmQ7XG4iLCIvLyBZQU1MIGVycm9yIGNsYXNzLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0NTg5ODRcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXhjZXB0aW9uLCBjb21wYWN0KSB7XG4gIHZhciB3aGVyZSA9ICcnLCBtZXNzYWdlID0gZXhjZXB0aW9uLnJlYXNvbiB8fCAnKHVua25vd24gcmVhc29uKSc7XG5cbiAgaWYgKCFleGNlcHRpb24ubWFyaykgcmV0dXJuIG1lc3NhZ2U7XG5cbiAgaWYgKGV4Y2VwdGlvbi5tYXJrLm5hbWUpIHtcbiAgICB3aGVyZSArPSAnaW4gXCInICsgZXhjZXB0aW9uLm1hcmsubmFtZSArICdcIiAnO1xuICB9XG5cbiAgd2hlcmUgKz0gJygnICsgKGV4Y2VwdGlvbi5tYXJrLmxpbmUgKyAxKSArICc6JyArIChleGNlcHRpb24ubWFyay5jb2x1bW4gKyAxKSArICcpJztcblxuICBpZiAoIWNvbXBhY3QgJiYgZXhjZXB0aW9uLm1hcmsuc25pcHBldCkge1xuICAgIHdoZXJlICs9ICdcXG5cXG4nICsgZXhjZXB0aW9uLm1hcmsuc25pcHBldDtcbiAgfVxuXG4gIHJldHVybiBtZXNzYWdlICsgJyAnICsgd2hlcmU7XG59XG5cblxuZnVuY3Rpb24gWUFNTEV4Y2VwdGlvbihyZWFzb24sIG1hcmspIHtcbiAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgRXJyb3IuY2FsbCh0aGlzKTtcblxuICB0aGlzLm5hbWUgPSAnWUFNTEV4Y2VwdGlvbic7XG4gIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRFcnJvcih0aGlzLCBmYWxzZSk7XG5cbiAgLy8gSW5jbHVkZSBzdGFjayB0cmFjZSBpbiBlcnJvciBvYmplY3RcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgLy8gQ2hyb21lIGFuZCBOb2RlSlNcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGRiwgSUUgMTArIGFuZCBTYWZhcmkgNisuIEZhbGxiYWNrIGZvciBvdGhlcnNcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjayB8fCAnJztcbiAgfVxufVxuXG5cbi8vIEluaGVyaXQgZnJvbSBFcnJvclxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5ZQU1MRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFlBTUxFeGNlcHRpb247XG5cblxuWUFNTEV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhjb21wYWN0KSB7XG4gIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgZm9ybWF0RXJyb3IodGhpcywgY29tcGFjdCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWUFNTEV4Y2VwdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBnZXQgc25pcHBldCBmb3IgYSBzaW5nbGUgbGluZSwgcmVzcGVjdGluZyBtYXhMZW5ndGhcbmZ1bmN0aW9uIGdldExpbmUoYnVmZmVyLCBsaW5lU3RhcnQsIGxpbmVFbmQsIHBvc2l0aW9uLCBtYXhMaW5lTGVuZ3RoKSB7XG4gIHZhciBoZWFkID0gJyc7XG4gIHZhciB0YWlsID0gJyc7XG4gIHZhciBtYXhIYWxmTGVuZ3RoID0gTWF0aC5mbG9vcihtYXhMaW5lTGVuZ3RoIC8gMikgLSAxO1xuXG4gIGlmIChwb3NpdGlvbiAtIGxpbmVTdGFydCA+IG1heEhhbGZMZW5ndGgpIHtcbiAgICBoZWFkID0gJyAuLi4gJztcbiAgICBsaW5lU3RhcnQgPSBwb3NpdGlvbiAtIG1heEhhbGZMZW5ndGggKyBoZWFkLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChsaW5lRW5kIC0gcG9zaXRpb24gPiBtYXhIYWxmTGVuZ3RoKSB7XG4gICAgdGFpbCA9ICcgLi4uJztcbiAgICBsaW5lRW5kID0gcG9zaXRpb24gKyBtYXhIYWxmTGVuZ3RoIC0gdGFpbC5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0cjogaGVhZCArIGJ1ZmZlci5zbGljZShsaW5lU3RhcnQsIGxpbmVFbmQpLnJlcGxhY2UoL1xcdC9nLCAn4oaSJykgKyB0YWlsLFxuICAgIHBvczogcG9zaXRpb24gLSBsaW5lU3RhcnQgKyBoZWFkLmxlbmd0aCAvLyByZWxhdGl2ZSBwb3NpdGlvblxuICB9O1xufVxuXG5cbmZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbWF4KSB7XG4gIHJldHVybiBjb21tb24ucmVwZWF0KCcgJywgbWF4IC0gc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG59XG5cblxuZnVuY3Rpb24gbWFrZVNuaXBwZXQobWFyaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zIHx8IG51bGwpO1xuXG4gIGlmICghbWFyay5idWZmZXIpIHJldHVybiBudWxsO1xuXG4gIGlmICghb3B0aW9ucy5tYXhMZW5ndGgpIG9wdGlvbnMubWF4TGVuZ3RoID0gNzk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmRlbnQgICAgICAhPT0gJ251bWJlcicpIG9wdGlvbnMuaW5kZW50ICAgICAgPSAxO1xuICBpZiAodHlwZW9mIG9wdGlvbnMubGluZXNCZWZvcmUgIT09ICdudW1iZXInKSBvcHRpb25zLmxpbmVzQmVmb3JlID0gMztcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbmVzQWZ0ZXIgICE9PSAnbnVtYmVyJykgb3B0aW9ucy5saW5lc0FmdGVyICA9IDI7XG5cbiAgdmFyIHJlID0gL1xccj9cXG58XFxyfFxcMC9nO1xuICB2YXIgbGluZVN0YXJ0cyA9IFsgMCBdO1xuICB2YXIgbGluZUVuZHMgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB2YXIgZm91bmRMaW5lTm8gPSAtMTtcblxuICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhtYXJrLmJ1ZmZlcikpKSB7XG4gICAgbGluZUVuZHMucHVzaChtYXRjaC5pbmRleCk7XG4gICAgbGluZVN0YXJ0cy5wdXNoKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgIGlmIChtYXJrLnBvc2l0aW9uIDw9IG1hdGNoLmluZGV4ICYmIGZvdW5kTGluZU5vIDwgMCkge1xuICAgICAgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZvdW5kTGluZU5vIDwgMCkgZm91bmRMaW5lTm8gPSBsaW5lU3RhcnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIHJlc3VsdCA9ICcnLCBpLCBsaW5lO1xuICB2YXIgbGluZU5vTGVuZ3RoID0gTWF0aC5taW4obWFyay5saW5lICsgb3B0aW9ucy5saW5lc0FmdGVyLCBsaW5lRW5kcy5sZW5ndGgpLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgbWF4TGluZUxlbmd0aCA9IG9wdGlvbnMubWF4TGVuZ3RoIC0gKG9wdGlvbnMuaW5kZW50ICsgbGluZU5vTGVuZ3RoICsgMyk7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQmVmb3JlOyBpKyspIHtcbiAgICBpZiAoZm91bmRMaW5lTm8gLSBpIDwgMCkgYnJlYWs7XG4gICAgbGluZSA9IGdldExpbmUoXG4gICAgICBtYXJrLmJ1ZmZlcixcbiAgICAgIGxpbmVTdGFydHNbZm91bmRMaW5lTm8gLSBpXSxcbiAgICAgIGxpbmVFbmRzW2ZvdW5kTGluZU5vIC0gaV0sXG4gICAgICBtYXJrLnBvc2l0aW9uIC0gKGxpbmVTdGFydHNbZm91bmRMaW5lTm9dIC0gbGluZVN0YXJ0c1tmb3VuZExpbmVObyAtIGldKSxcbiAgICAgIG1heExpbmVMZW5ndGhcbiAgICApO1xuICAgIHJlc3VsdCA9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lIC0gaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nICsgcmVzdWx0O1xuICB9XG5cbiAgbGluZSA9IGdldExpbmUobWFyay5idWZmZXIsIGxpbmVTdGFydHNbZm91bmRMaW5lTm9dLCBsaW5lRW5kc1tmb3VuZExpbmVOb10sIG1hcmsucG9zaXRpb24sIG1heExpbmVMZW5ndGgpO1xuICByZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnICcsIG9wdGlvbnMuaW5kZW50KSArIHBhZFN0YXJ0KChtYXJrLmxpbmUgKyAxKS50b1N0cmluZygpLCBsaW5lTm9MZW5ndGgpICtcbiAgICAnIHwgJyArIGxpbmUuc3RyICsgJ1xcbic7XG4gIHJlc3VsdCArPSBjb21tb24ucmVwZWF0KCctJywgb3B0aW9ucy5pbmRlbnQgKyBsaW5lTm9MZW5ndGggKyAzICsgbGluZS5wb3MpICsgJ14nICsgJ1xcbic7XG5cbiAgZm9yIChpID0gMTsgaSA8PSBvcHRpb25zLmxpbmVzQWZ0ZXI7IGkrKykge1xuICAgIGlmIChmb3VuZExpbmVObyArIGkgPj0gbGluZUVuZHMubGVuZ3RoKSBicmVhaztcbiAgICBsaW5lID0gZ2V0TGluZShcbiAgICAgIG1hcmsuYnVmZmVyLFxuICAgICAgbGluZVN0YXJ0c1tmb3VuZExpbmVObyArIGldLFxuICAgICAgbGluZUVuZHNbZm91bmRMaW5lTm8gKyBpXSxcbiAgICAgIG1hcmsucG9zaXRpb24gLSAobGluZVN0YXJ0c1tmb3VuZExpbmVOb10gLSBsaW5lU3RhcnRzW2ZvdW5kTGluZU5vICsgaV0pLFxuICAgICAgbWF4TGluZUxlbmd0aFxuICAgICk7XG4gICAgcmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJyAnLCBvcHRpb25zLmluZGVudCkgKyBwYWRTdGFydCgobWFyay5saW5lICsgaSArIDEpLnRvU3RyaW5nKCksIGxpbmVOb0xlbmd0aCkgK1xuICAgICAgJyB8ICcgKyBsaW5lLnN0ciArICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXG4kLywgJycpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gbWFrZVNuaXBwZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcblxudmFyIFRZUEVfQ09OU1RSVUNUT1JfT1BUSU9OUyA9IFtcbiAgJ2tpbmQnLFxuICAnbXVsdGknLFxuICAncmVzb2x2ZScsXG4gICdjb25zdHJ1Y3QnLFxuICAnaW5zdGFuY2VPZicsXG4gICdwcmVkaWNhdGUnLFxuICAncmVwcmVzZW50JyxcbiAgJ3JlcHJlc2VudE5hbWUnLFxuICAnZGVmYXVsdFN0eWxlJyxcbiAgJ3N0eWxlQWxpYXNlcydcbl07XG5cbnZhciBZQU1MX05PREVfS0lORFMgPSBbXG4gICdzY2FsYXInLFxuICAnc2VxdWVuY2UnLFxuICAnbWFwcGluZydcbl07XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZUFsaWFzZXMobWFwKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgbWFwW3N0eWxlXS5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXN1bHRbU3RyaW5nKGFsaWFzKV0gPSBzdHlsZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gVHlwZSh0YWcsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChUWVBFX0NPTlNUUlVDVE9SX09QVElPTlMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiIGlzIG1ldCBpbiBkZWZpbml0aW9uIG9mIFwiJyArIHRhZyArICdcIiBZQU1MIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUT0RPOiBBZGQgdGFnIGZvcm1hdCBjaGVjay5cbiAgdGhpcy5vcHRpb25zICAgICAgID0gb3B0aW9uczsgLy8ga2VlcCBvcmlnaW5hbCBvcHRpb25zIGluIGNhc2UgdXNlciB3YW50cyB0byBleHRlbmQgdGhpcyB0eXBlIGxhdGVyXG4gIHRoaXMudGFnICAgICAgICAgICA9IHRhZztcbiAgdGhpcy5raW5kICAgICAgICAgID0gb3B0aW9uc1sna2luZCddICAgICAgICAgIHx8IG51bGw7XG4gIHRoaXMucmVzb2x2ZSAgICAgICA9IG9wdGlvbnNbJ3Jlc29sdmUnXSAgICAgICB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9O1xuICB0aGlzLmNvbnN0cnVjdCAgICAgPSBvcHRpb25zWydjb25zdHJ1Y3QnXSAgICAgfHwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGE7IH07XG4gIHRoaXMuaW5zdGFuY2VPZiAgICA9IG9wdGlvbnNbJ2luc3RhbmNlT2YnXSAgICB8fCBudWxsO1xuICB0aGlzLnByZWRpY2F0ZSAgICAgPSBvcHRpb25zWydwcmVkaWNhdGUnXSAgICAgfHwgbnVsbDtcbiAgdGhpcy5yZXByZXNlbnQgICAgID0gb3B0aW9uc1sncmVwcmVzZW50J10gICAgIHx8IG51bGw7XG4gIHRoaXMucmVwcmVzZW50TmFtZSA9IG9wdGlvbnNbJ3JlcHJlc2VudE5hbWUnXSB8fCBudWxsO1xuICB0aGlzLmRlZmF1bHRTdHlsZSAgPSBvcHRpb25zWydkZWZhdWx0U3R5bGUnXSAgfHwgbnVsbDtcbiAgdGhpcy5tdWx0aSAgICAgICAgID0gb3B0aW9uc1snbXVsdGknXSAgICAgICAgIHx8IGZhbHNlO1xuICB0aGlzLnN0eWxlQWxpYXNlcyAgPSBjb21waWxlU3R5bGVBbGlhc2VzKG9wdGlvbnNbJ3N0eWxlQWxpYXNlcyddIHx8IG51bGwpO1xuXG4gIGlmIChZQU1MX05PREVfS0lORFMuaW5kZXhPZih0aGlzLmtpbmQpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdVbmtub3duIGtpbmQgXCInICsgdGhpcy5raW5kICsgJ1wiIGlzIHNwZWNpZmllZCBmb3IgXCInICsgdGFnICsgJ1wiIFlBTUwgdHlwZS4nKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG5cbnZhciBZQU1MRXhjZXB0aW9uID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBUeXBlICAgICAgICAgID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cblxuZnVuY3Rpb24gY29tcGlsZUxpc3Qoc2NoZW1hLCBuYW1lKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBzY2hlbWFbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudFR5cGUpIHtcbiAgICB2YXIgbmV3SW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHByZXZpb3VzVHlwZSwgcHJldmlvdXNJbmRleCkge1xuICAgICAgaWYgKHByZXZpb3VzVHlwZS50YWcgPT09IGN1cnJlbnRUeXBlLnRhZyAmJlxuICAgICAgICAgIHByZXZpb3VzVHlwZS5raW5kID09PSBjdXJyZW50VHlwZS5raW5kICYmXG4gICAgICAgICAgcHJldmlvdXNUeXBlLm11bHRpID09PSBjdXJyZW50VHlwZS5tdWx0aSkge1xuXG4gICAgICAgIG5ld0luZGV4ID0gcHJldmlvdXNJbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3VsdFtuZXdJbmRleF0gPSBjdXJyZW50VHlwZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiBjb21waWxlTWFwKC8qIGxpc3RzLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHNjYWxhcjoge30sXG4gICAgICAgIHNlcXVlbmNlOiB7fSxcbiAgICAgICAgbWFwcGluZzoge30sXG4gICAgICAgIGZhbGxiYWNrOiB7fSxcbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICBzY2FsYXI6IFtdLFxuICAgICAgICAgIHNlcXVlbmNlOiBbXSxcbiAgICAgICAgICBtYXBwaW5nOiBbXSxcbiAgICAgICAgICBmYWxsYmFjazogW11cbiAgICAgICAgfVxuICAgICAgfSwgaW5kZXgsIGxlbmd0aDtcblxuICBmdW5jdGlvbiBjb2xsZWN0VHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUubXVsdGkpIHtcbiAgICAgIHJlc3VsdC5tdWx0aVt0eXBlLmtpbmRdLnB1c2godHlwZSk7XG4gICAgICByZXN1bHQubXVsdGlbJ2ZhbGxiYWNrJ10ucHVzaCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3R5cGUua2luZF1bdHlwZS50YWddID0gcmVzdWx0WydmYWxsYmFjayddW3R5cGUudGFnXSA9IHR5cGU7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgYXJndW1lbnRzW2luZGV4XS5mb3JFYWNoKGNvbGxlY3RUeXBlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbmZ1bmN0aW9uIFNjaGVtYShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0aGlzLmV4dGVuZChkZWZpbml0aW9uKTtcbn1cblxuXG5TY2hlbWEucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZWZpbml0aW9uKSB7XG4gIHZhciBpbXBsaWNpdCA9IFtdO1xuICB2YXIgZXhwbGljaXQgPSBbXTtcblxuICBpZiAoZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKHR5cGUpXG4gICAgZXhwbGljaXQucHVzaChkZWZpbml0aW9uKTtcblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKFsgdHlwZTEsIHR5cGUyLCAuLi4gXSlcbiAgICBleHBsaWNpdCA9IGV4cGxpY2l0LmNvbmNhdChkZWZpbml0aW9uKTtcblxuICB9IGVsc2UgaWYgKGRlZmluaXRpb24gJiYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi5pbXBsaWNpdCkgfHwgQXJyYXkuaXNBcnJheShkZWZpbml0aW9uLmV4cGxpY2l0KSkpIHtcbiAgICAvLyBTY2hlbWEuZXh0ZW5kKHsgZXhwbGljaXQ6IFsgdHlwZTEsIHR5cGUyLCAuLi4gXSwgaW1wbGljaXQ6IFsgdHlwZTEsIHR5cGUyLCAuLi4gXSB9KVxuICAgIGlmIChkZWZpbml0aW9uLmltcGxpY2l0KSBpbXBsaWNpdCA9IGltcGxpY2l0LmNvbmNhdChkZWZpbml0aW9uLmltcGxpY2l0KTtcbiAgICBpZiAoZGVmaW5pdGlvbi5leHBsaWNpdCkgZXhwbGljaXQgPSBleHBsaWNpdC5jb25jYXQoZGVmaW5pdGlvbi5leHBsaWNpdCk7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignU2NoZW1hLmV4dGVuZCBhcmd1bWVudCBzaG91bGQgYmUgYSBUeXBlLCBbIFR5cGUgXSwgJyArXG4gICAgICAnb3IgYSBzY2hlbWEgZGVmaW5pdGlvbiAoeyBpbXBsaWNpdDogWy4uLl0sIGV4cGxpY2l0OiBbLi4uXSB9KScpO1xuICB9XG5cbiAgaW1wbGljaXQuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICghKHR5cGUgaW5zdGFuY2VvZiBUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1NwZWNpZmllZCBsaXN0IG9mIFlBTUwgdHlwZXMgKG9yIGEgc2luZ2xlIFR5cGUgb2JqZWN0KSBjb250YWlucyBhIG5vbi1UeXBlIG9iamVjdC4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5sb2FkS2luZCAmJiB0eXBlLmxvYWRLaW5kICE9PSAnc2NhbGFyJykge1xuICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ1RoZXJlIGlzIGEgbm9uLXNjYWxhciB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBJbXBsaWNpdCByZXNvbHZpbmcgb2Ygc3VjaCB0eXBlcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLm11bHRpKSB7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignVGhlcmUgaXMgYSBtdWx0aSB0eXBlIGluIHRoZSBpbXBsaWNpdCBsaXN0IG9mIGEgc2NoZW1hLiBNdWx0aSB0YWdzIGNhbiBvbmx5IGJlIGxpc3RlZCBhcyBleHBsaWNpdC4nKTtcbiAgICB9XG4gIH0pO1xuXG4gIGV4cGxpY2l0LmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAoISh0eXBlIGluc3RhbmNlb2YgVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdTcGVjaWZpZWQgbGlzdCBvZiBZQU1MIHR5cGVzIChvciBhIHNpbmdsZSBUeXBlIG9iamVjdCkgY29udGFpbnMgYSBub24tVHlwZSBvYmplY3QuJyk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEucHJvdG90eXBlKTtcblxuICByZXN1bHQuaW1wbGljaXQgPSAodGhpcy5pbXBsaWNpdCB8fCBbXSkuY29uY2F0KGltcGxpY2l0KTtcbiAgcmVzdWx0LmV4cGxpY2l0ID0gKHRoaXMuZXhwbGljaXQgfHwgW10pLmNvbmNhdChleHBsaWNpdCk7XG5cbiAgcmVzdWx0LmNvbXBpbGVkSW1wbGljaXQgPSBjb21waWxlTGlzdChyZXN1bHQsICdpbXBsaWNpdCcpO1xuICByZXN1bHQuY29tcGlsZWRFeHBsaWNpdCA9IGNvbXBpbGVMaXN0KHJlc3VsdCwgJ2V4cGxpY2l0Jyk7XG4gIHJlc3VsdC5jb21waWxlZFR5cGVNYXAgID0gY29tcGlsZU1hcChyZXN1bHQuY29tcGlsZWRJbXBsaWNpdCwgcmVzdWx0LmNvbXBpbGVkRXhwbGljaXQpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiAnJzsgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDogW107IH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkYXRhIDoge307IH1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfSxcbiAgICBlbXB0eTogICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuICcnOyAgICAgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQm9vbGVhbihkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIG1heCA9IGRhdGEubGVuZ3RoO1xuXG4gIHJldHVybiAobWF4ID09PSA0ICYmIChkYXRhID09PSAndHJ1ZScgfHwgZGF0YSA9PT0gJ1RydWUnIHx8IGRhdGEgPT09ICdUUlVFJykpIHx8XG4gICAgICAgICAobWF4ID09PSA1ICYmIChkYXRhID09PSAnZmFsc2UnIHx8IGRhdGEgPT09ICdGYWxzZScgfHwgZGF0YSA9PT0gJ0ZBTFNFJykpO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQm9vbGVhbihkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAndHJ1ZScgfHxcbiAgICAgICAgIGRhdGEgPT09ICdUcnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RSVUUnO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2xlYW4ob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCb29sZWFuLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCb29sZWFuLFxuICBwcmVkaWNhdGU6IGlzQm9vbGVhbixcbiAgcmVwcmVzZW50OiB7XG4gICAgbG93ZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAndHJ1ZScgOiAnZmFsc2UnOyB9LFxuICAgIHVwcGVyY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RSVUUnIDogJ0ZBTFNFJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICdUcnVlJyA6ICdGYWxzZSc7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHJldHVybiBmYWxzZTtcblxuICBjaCA9IGRhdGFbaW5kZXhdO1xuXG4gIC8vIHNpZ25cbiAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgIGNoID0gZGF0YVsrK2luZGV4XTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJzAnKSB7XG4gICAgLy8gMFxuICAgIGlmIChpbmRleCArIDEgPT09IG1heCkgcmV0dXJuIHRydWU7XG4gICAgY2ggPSBkYXRhWysraW5kZXhdO1xuXG4gICAgLy8gYmFzZSAyLCBiYXNlIDgsIGJhc2UgMTZcblxuICAgIGlmIChjaCA9PT0gJ2InKSB7XG4gICAgICAvLyBiYXNlIDJcbiAgICAgIGluZGV4Kys7XG5cbiAgICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoY2ggPT09ICdfJykgY29udGludWU7XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG5cblxuICAgIGlmIChjaCA9PT0gJ3gnKSB7XG4gICAgICAvLyBiYXNlIDE2XG4gICAgICBpbmRleCsrO1xuXG4gICAgICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWlzSGV4Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc0RpZ2l0cyAmJiBjaCAhPT0gJ18nO1xuICAgIH1cblxuXG4gICAgaWYgKGNoID09PSAnbycpIHtcbiAgICAgIC8vIGJhc2UgOFxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFpc09jdENvZGUoZGF0YS5jaGFyQ29kZUF0KGluZGV4KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHMgJiYgY2ggIT09ICdfJztcbiAgICB9XG4gIH1cblxuICAvLyBiYXNlIDEwIChleGNlcHQgMClcblxuICAvLyB2YWx1ZSBzaG91bGQgbm90IHN0YXJ0IHdpdGggYF9gO1xuICBpZiAoY2ggPT09ICdfJykgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgaWYgKGNoID09PSAnXycpIGNvbnRpbnVlO1xuICAgIGlmICghaXNEZWNDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gIH1cblxuICAvLyBTaG91bGQgaGF2ZSBkaWdpdHMgYW5kIHNob3VsZCBub3QgZW5kIHdpdGggYF9gXG4gIGlmICghaGFzRGlnaXRzIHx8IGNoID09PSAnXycpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEludGVnZXIoZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLCBzaWduID0gMSwgY2g7XG5cbiAgaWYgKHZhbHVlLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICB9XG5cbiAgY2ggPSB2YWx1ZVswXTtcblxuICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgaWYgKGNoID09PSAnLScpIHNpZ24gPSAtMTtcbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAodmFsdWUgPT09ICcwJykgcmV0dXJuIDA7XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgaWYgKHZhbHVlWzFdID09PSAneCcpIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdvJykgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgOCk7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZWdlcihvYmplY3QpIHtcbiAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmXG4gICAgICAgICAob2JqZWN0ICUgMSA9PT0gMCAmJiAhY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEludGVnZXIsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEludGVnZXIsXG4gIHByZWRpY2F0ZTogaXNJbnRlZ2VyLFxuICByZXByZXNlbnQ6IHtcbiAgICBiaW5hcnk6ICAgICAgZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqID49IDAgPyAnMGInICsgb2JqLnRvU3RyaW5nKDIpIDogJy0wYicgKyBvYmoudG9TdHJpbmcoMikuc2xpY2UoMSk7IH0sXG4gICAgb2N0YWw6ICAgICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiA+PSAwID8gJzBvJyAgKyBvYmoudG9TdHJpbmcoOCkgOiAnLTBvJyAgKyBvYmoudG9TdHJpbmcoOCkuc2xpY2UoMSk7IH0sXG4gICAgZGVjaW1hbDogICAgIGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iai50b1N0cmluZygxMCk7IH0sXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgIGhleGFkZWNpbWFsOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogPj0gMCA/ICcweCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgOiAgJy0weCcgKyBvYmoudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkuc2xpY2UoMSk7IH1cbiAgfSxcbiAgZGVmYXVsdFN0eWxlOiAnZGVjaW1hbCcsXG4gIHN0eWxlQWxpYXNlczoge1xuICAgIGJpbmFyeTogICAgICBbIDIsICAnYmluJyBdLFxuICAgIG9jdGFsOiAgICAgICBbIDgsICAnb2N0JyBdLFxuICAgIGRlY2ltYWw6ICAgICBbIDEwLCAnZGVjJyBdLFxuICAgIGhleGFkZWNpbWFsOiBbIDE2LCAnaGV4JyBdXG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgVHlwZSAgID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9GTE9BVF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgLy8gMi41ZTQsIDIuNSBhbmQgaW50ZWdlcnNcbiAgJ14oPzpbLStdPyg/OlswLTldWzAtOV9dKikoPzpcXFxcLlswLTlfXSopPyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC4yZTQsIC4yXG4gIC8vIHNwZWNpYWwgY2FzZSwgc2VlbXMgbm90IGZyb20gc3BlY1xuICAnfFxcXFwuWzAtOV9dKyg/OltlRV1bLStdP1swLTldKyk/JyArXG4gIC8vIC5pbmZcbiAgJ3xbLStdP1xcXFwuKD86aW5mfEluZnxJTkYpJyArXG4gIC8vIC5uYW5cbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkgfHxcbiAgICAgIC8vIFF1aWNrIGhhY2sgdG8gbm90IGFsbG93IGludGVnZXJzIGVuZCB3aXRoIGBfYFxuICAgICAgLy8gUHJvYmFibHkgc2hvdWxkIHVwZGF0ZSByZWdleHAgJiBjaGVjayBzcGVlZFxuICAgICAgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbEZsb2F0KGRhdGEpIHtcbiAgdmFyIHZhbHVlLCBzaWduO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcblxuICBpZiAoJystJy5pbmRleE9mKHZhbHVlWzBdKSA+PSAwKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gJy5pbmYnKSB7XG4gICAgcmV0dXJuIChzaWduID09PSAxKSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICB9IGVsc2UgaWYgKHZhbHVlID09PSAnLm5hbicpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5cbnZhciBTQ0lFTlRJRklDX1dJVEhPVVRfRE9UID0gL15bLStdP1swLTldK2UvO1xuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sRmxvYXQob2JqZWN0LCBzdHlsZSkge1xuICB2YXIgcmVzO1xuXG4gIGlmIChpc05hTihvYmplY3QpKSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgY2FzZSAnbG93ZXJjYXNlJzogcmV0dXJuICcubmFuJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLk5BTic7XG4gICAgICBjYXNlICdjYW1lbGNhc2UnOiByZXR1cm4gJy5OYU4nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgIGNhc2UgJ2xvd2VyY2FzZSc6IHJldHVybiAnLmluZic7XG4gICAgICBjYXNlICd1cHBlcmNhc2UnOiByZXR1cm4gJy5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICcuSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZID09PSBvYmplY3QpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICBjYXNlICdsb3dlcmNhc2UnOiByZXR1cm4gJy0uaW5mJztcbiAgICAgIGNhc2UgJ3VwcGVyY2FzZSc6IHJldHVybiAnLS5JTkYnO1xuICAgICAgY2FzZSAnY2FtZWxjYXNlJzogcmV0dXJuICctLkluZic7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKSB7XG4gICAgcmV0dXJuICctMC4wJztcbiAgfVxuXG4gIHJlcyA9IG9iamVjdC50b1N0cmluZygxMCk7XG5cbiAgLy8gSlMgc3RyaW5naWZpZXIgY2FuIGJ1aWxkIHNjaWVudGlmaWMgZm9ybWF0IHdpdGhvdXQgZG90czogNWUtMTAwLFxuICAvLyB3aGlsZSBZQU1MIHJlcXVyZXMgZG90OiA1LmUtMTAwLiBGaXggaXQgd2l0aCBzaW1wbGUgaGFja1xuXG4gIHJldHVybiBTQ0lFTlRJRklDX1dJVEhPVVRfRE9ULnRlc3QocmVzKSA/IHJlcy5yZXBsYWNlKCdlJywgJy5lJykgOiByZXM7XG59XG5cbmZ1bmN0aW9uIGlzRmxvYXQob2JqZWN0KSB7XG4gIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE51bWJlcl0nKSAmJlxuICAgICAgICAgKG9iamVjdCAlIDEgIT09IDAgfHwgY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sRmxvYXQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEZsb2F0LFxuICBwcmVkaWNhdGU6IGlzRmxvYXQsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEZsb2F0LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiIsIi8vIFN0YW5kYXJkIFlBTUwncyBKU09OIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMzIzMVxuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIHRoaXMgc2NoZW1hIGlzIG5vdCBzdWNoIHN0cmljdCBhcyBkZWZpbmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFpbHNhZmUnKS5leHRlbmQoe1xuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvbnVsbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvaW50JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9mbG9hdCcpXG4gIF1cbn0pO1xuIiwiLy8gU3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODA0OTIzXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgQ29yZSBzY2hlbWEgaGFzIG5vIGRpc3RpbmN0aW9ucyBmcm9tIEpTT04gc2NoZW1hIGlzIEpTLVlBTUwuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9qc29uJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9EQVRFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG4gICdeKFswLTldWzAtOV1bMC05XVswLTldKScgICAgICAgICAgKyAvLyBbMV0geWVhclxuICAnLShbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzJdIG1vbnRoXG4gICctKFswLTldWzAtOV0pJCcpOyAgICAgICAgICAgICAgICAgICAvLyBbM10gZGF5XG5cbnZhciBZQU1MX1RJTUVTVEFNUF9SRUdFWFAgPSBuZXcgUmVnRXhwKFxuICAnXihbMC05XVswLTldWzAtOV1bMC05XSknICAgICAgICAgICsgLy8gWzFdIHllYXJcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFsyXSBtb250aFxuICAnLShbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICsgLy8gWzNdIGRheVxuICAnKD86W1R0XXxbIFxcXFx0XSspJyAgICAgICAgICAgICAgICAgKyAvLyAuLi5cbiAgJyhbMC05XVswLTldPyknICAgICAgICAgICAgICAgICAgICArIC8vIFs0XSBob3VyXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNV0gbWludXRlXG4gICc6KFswLTldWzAtOV0pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNl0gc2Vjb25kXG4gICcoPzpcXFxcLihbMC05XSopKT8nICAgICAgICAgICAgICAgICArIC8vIFs3XSBmcmFjdGlvblxuICAnKD86WyBcXFxcdF0qKFp8KFstK10pKFswLTldWzAtOV0/KScgKyAvLyBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyXG4gICcoPzo6KFswLTldWzAtOV0pKT8pKT8kJyk7ICAgICAgICAgICAvLyBbMTFdIHR6X21pbnV0ZVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbFRpbWVzdGFtcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChZQU1MX0RBVEVfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICBpZiAoWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSkgIT09IG51bGwpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbiA9IDAsXG4gICAgICBkZWx0YSA9IG51bGwsIHR6X2hvdXIsIHR6X21pbnV0ZSwgZGF0ZTtcblxuICBtYXRjaCA9IFlBTUxfREFURV9SRUdFWFAuZXhlYyhkYXRhKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSBtYXRjaCA9IFlBTUxfVElNRVNUQU1QX1JFR0VYUC5leGVjKGRhdGEpO1xuXG4gIGlmIChtYXRjaCA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcblxuICAvLyBtYXRjaDogWzFdIHllYXIgWzJdIG1vbnRoIFszXSBkYXlcblxuICB5ZWFyID0gKyhtYXRjaFsxXSk7XG4gIG1vbnRoID0gKyhtYXRjaFsyXSkgLSAxOyAvLyBKUyBtb250aCBzdGFydHMgd2l0aCAwXG4gIGRheSA9ICsobWF0Y2hbM10pO1xuXG4gIGlmICghbWF0Y2hbNF0pIHsgLy8gbm8gaG91clxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5KSk7XG4gIH1cblxuICAvLyBtYXRjaDogWzRdIGhvdXIgWzVdIG1pbnV0ZSBbNl0gc2Vjb25kIFs3XSBmcmFjdGlvblxuXG4gIGhvdXIgPSArKG1hdGNoWzRdKTtcbiAgbWludXRlID0gKyhtYXRjaFs1XSk7XG4gIHNlY29uZCA9ICsobWF0Y2hbNl0pO1xuXG4gIGlmIChtYXRjaFs3XSkge1xuICAgIGZyYWN0aW9uID0gbWF0Y2hbN10uc2xpY2UoMCwgMyk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gKz0gJzAnO1xuICAgIH1cbiAgICBmcmFjdGlvbiA9ICtmcmFjdGlvbjtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbOF0gdHogWzldIHR6X3NpZ24gWzEwXSB0el9ob3VyIFsxMV0gdHpfbWludXRlXG5cbiAgaWYgKG1hdGNoWzldKSB7XG4gICAgdHpfaG91ciA9ICsobWF0Y2hbMTBdKTtcbiAgICB0el9taW51dGUgPSArKG1hdGNoWzExXSB8fCAwKTtcbiAgICBkZWx0YSA9ICh0el9ob3VyICogNjAgKyB0el9taW51dGUpICogNjAwMDA7IC8vIGRlbHRhIGluIG1pbGktc2Vjb25kc1xuICAgIGlmIChtYXRjaFs5XSA9PT0gJy0nKSBkZWx0YSA9IC1kZWx0YTtcbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhY3Rpb24pKTtcblxuICBpZiAoZGVsdGEpIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbFRpbWVzdGFtcChvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgcmV0dXJuIG9iamVjdC50b0lTT1N0cmluZygpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFRpbWVzdGFtcCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sVGltZXN0YW1wLFxuICBpbnN0YW5jZU9mOiBEYXRlLFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxUaW1lc3RhbXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxNZXJnZShkYXRhKSB7XG4gIHJldHVybiBkYXRhID09PSAnPDwnIHx8IGRhdGEgPT09IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxNZXJnZVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSovXG5cblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSBjb250aW51ZTtcblxuICAgIC8vIEZhaWwgb24gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICBiaXRsZW4gKz0gNjtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhbnkgYml0cyBsZWZ0LCBzb3VyY2Ugd2FzIGNvcnJ1cHRlZFxuICByZXR1cm4gKGJpdGxlbiAlIDgpID09PSAwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sQmluYXJ5KGRhdGEpIHtcbiAgdmFyIGlkeCwgdGFpbGJpdHMsXG4gICAgICBpbnB1dCA9IGRhdGEucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggPSBpbnB1dC5sZW5ndGgsXG4gICAgICBtYXAgPSBCQVNFNjRfTUFQLFxuICAgICAgYml0cyA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICAvLyBDb2xsZWN0IGJ5IDYqNCBiaXRzICgzIGJ5dGVzKVxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICByZXN1bHQucHVzaCgoYml0cyA+PiAxNikgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgbWFwLmluZGV4T2YoaW5wdXQuY2hhckF0KGlkeCkpO1xuICB9XG5cbiAgLy8gRHVtcCB0YWlsXG5cbiAgdGFpbGJpdHMgPSAobWF4ICUgNCkgKiA2O1xuXG4gIGlmICh0YWlsYml0cyA9PT0gMCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDgpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goYml0cyAmIDB4RkYpO1xuICB9IGVsc2UgaWYgKHRhaWxiaXRzID09PSAxOCkge1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDEwKSAmIDB4RkYpO1xuICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDIpICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDEyKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gNCkgJiAweEZGKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sQmluYXJ5KG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJycsIGJpdHMgPSAwLCBpZHgsIHRhaWwsXG4gICAgICBtYXggPSBvYmplY3QubGVuZ3RoLFxuICAgICAgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IGV2ZXJ5IHRocmVlIGJ5dGVzIHRvIDQgQVNDSUkgY2hhcmFjdGVycy5cblxuICBmb3IgKGlkeCA9IDA7IGlkeCA8IG1heDsgaWR4KyspIHtcbiAgICBpZiAoKGlkeCAlIDMgPT09IDApICYmIGlkeCkge1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTIpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgOCkgKyBvYmplY3RbaWR4XTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHRhaWwgPSBtYXggJSAzO1xuXG4gIGlmICh0YWlsID09PSAwKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxOCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gNikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwW2JpdHMgJiAweDNGXTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAyKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDQpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9IGVsc2UgaWYgKHRhaWwgPT09IDEpIHtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDIpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA8PCA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICAgIHJlc3VsdCArPSBtYXBbNjRdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5Jywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxCaW5hcnksXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJpbmFyeSxcbiAgcHJlZGljYXRlOiBpc0JpbmFyeSxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRZYW1sQmluYXJ5XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sT21hcChkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgb2JqZWN0S2V5cyA9IFtdLCBpbmRleCwgbGVuZ3RoLCBwYWlyLCBwYWlyS2V5LCBwYWlySGFzS2V5LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICBwYWlyID0gb2JqZWN0W2luZGV4XTtcbiAgICBwYWlySGFzS2V5ID0gZmFsc2U7XG5cbiAgICBpZiAoX3RvU3RyaW5nLmNhbGwocGFpcikgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHBhaXJLZXkgaW4gcGFpcikge1xuICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXIsIHBhaXJLZXkpKSB7XG4gICAgICAgIGlmICghcGFpckhhc0tleSkgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFpckhhc0tleSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9iamVjdEtleXMuaW5kZXhPZihwYWlyS2V5KSA9PT0gLTEpIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBkYXRhICE9PSBudWxsID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sUGFpcnMoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAgaWYgKF90b1N0cmluZy5jYWxsKHBhaXIpICE9PSAnW29iamVjdCBPYmplY3RdJykgcmV0dXJuIGZhbHNlO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbFBhaXJzKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMocGFpcik7XG5cbiAgICByZXN1bHRbaW5kZXhdID0gWyBrZXlzWzBdLCBwYWlyW2tleXNbMF1dIF07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHtcbiAga2luZDogJ3NlcXVlbmNlJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZVlhbWxQYWlycyxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sUGFpcnNcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sU2V0KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHZhciBrZXksIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgaWYgKG9iamVjdFtrZXldICE9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxTZXQoZGF0YSkge1xuICByZXR1cm4gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6c2V0Jywge1xuICBraW5kOiAnbWFwcGluZycsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sU2V0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxTZXRcbn0pO1xuIiwiLy8gSlMtWUFNTCdzIGRlZmF1bHQgc2NoZW1hIGZvciBgc2FmZUxvYWRgIGZ1bmN0aW9uLlxuLy8gSXQgaXMgbm90IGRlc2NyaWJlZCBpbiB0aGUgWUFNTCBzcGVjaWZpY2F0aW9uLlxuLy9cbi8vIFRoaXMgc2NoZW1hIGlzIGJhc2VkIG9uIHN0YW5kYXJkIFlBTUwncyBDb3JlIHNjaGVtYSBhbmQgaW5jbHVkZXMgbW9zdCBvZlxuLy8gZXh0cmEgdHlwZXMgZGVzY3JpYmVkIGF0IFlBTUwgdGFnIHJlcG9zaXRvcnkuIChodHRwOi8veWFtbC5vcmcvdHlwZS8pXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlJykuZXh0ZW5kKHtcbiAgaW1wbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3RpbWVzdGFtcCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvbWVyZ2UnKVxuICBdLFxuICBleHBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvYmluYXJ5JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9vbWFwJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9wYWlycycpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2V0JylcbiAgXVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbixuby11c2UtYmVmb3JlLWRlZmluZSovXG5cbnZhciBjb21tb24gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9leGNlcHRpb24nKTtcbnZhciBtYWtlU25pcHBldCAgICAgICAgID0gcmVxdWlyZSgnLi9zbmlwcGV0Jyk7XG52YXIgREVGQVVMVF9TQ0hFTUEgICAgICA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHQnKTtcblxuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXG52YXIgQ09OVEVYVF9GTE9XX0lOICAgPSAxO1xudmFyIENPTlRFWFRfRkxPV19PVVQgID0gMjtcbnZhciBDT05URVhUX0JMT0NLX0lOICA9IDM7XG52YXIgQ09OVEVYVF9CTE9DS19PVVQgPSA0O1xuXG5cbnZhciBDSE9NUElOR19DTElQICA9IDE7XG52YXIgQ0hPTVBJTkdfU1RSSVAgPSAyO1xudmFyIENIT01QSU5HX0tFRVAgID0gMztcblxuXG52YXIgUEFUVEVSTl9OT05fUFJJTlRBQkxFICAgICAgICAgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXFx4N0YtXFx4ODRcXHg4Ni1cXHg5RlxcdUZGRkVcXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG52YXIgUEFUVEVSTl9OT05fQVNDSUlfTElORV9CUkVBS1MgPSAvW1xceDg1XFx1MjAyOFxcdTIwMjldLztcbnZhciBQQVRURVJOX0ZMT1dfSU5ESUNBVE9SUyAgICAgICA9IC9bLFxcW1xcXVxce1xcfV0vO1xudmFyIFBBVFRFUk5fVEFHX0hBTkRMRSAgICAgICAgICAgID0gL14oPzohfCEhfCFbYS16XFwtXSshKSQvaTtcbnZhciBQQVRURVJOX1RBR19VUkkgICAgICAgICAgICAgICA9IC9eKD86IXxbXixcXFtcXF1cXHtcXH1dKSg/OiVbMC05YS1mXXsyfXxbMC05YS16XFwtIztcXC9cXD86QCY9XFwrXFwkLF9cXC4hflxcKidcXChcXClcXFtcXF1dKSokL2k7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNfRU9MKGMpIHtcbiAgcmV0dXJuIChjID09PSAweDBBLyogTEYgKi8pIHx8IChjID09PSAweDBELyogQ1IgKi8pO1xufVxuXG5mdW5jdGlvbiBpc19XSElURV9TUEFDRShjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHwgKGMgPT09IDB4MjAvKiBTcGFjZSAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX1dTX09SX0VPTChjKSB7XG4gIHJldHVybiAoYyA9PT0gMHgwOS8qIFRhYiAqLykgfHxcbiAgICAgICAgIChjID09PSAweDIwLyogU3BhY2UgKi8pIHx8XG4gICAgICAgICAoYyA9PT0gMHgwQS8qIExGICovKSB8fFxuICAgICAgICAgKGMgPT09IDB4MEQvKiBDUiAqLyk7XG59XG5cbmZ1bmN0aW9uIGlzX0ZMT1dfSU5ESUNBVE9SKGMpIHtcbiAgcmV0dXJuIGMgPT09IDB4MkMvKiAsICovIHx8XG4gICAgICAgICBjID09PSAweDVCLyogWyAqLyB8fFxuICAgICAgICAgYyA9PT0gMHg1RC8qIF0gKi8gfHxcbiAgICAgICAgIGMgPT09IDB4N0IvKiB7ICovIHx8XG4gICAgICAgICBjID09PSAweDdELyogfSAqLztcbn1cblxuZnVuY3Rpb24gZnJvbUhleENvZGUoYykge1xuICB2YXIgbGM7XG5cbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICAvKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuICBsYyA9IGMgfCAweDIwO1xuXG4gIGlmICgoMHg2MS8qIGEgKi8gPD0gbGMpICYmIChsYyA8PSAweDY2LyogZiAqLykpIHtcbiAgICByZXR1cm4gbGMgLSAweDYxICsgMTA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRIZXhMZW4oYykge1xuICBpZiAoYyA9PT0gMHg3OC8qIHggKi8pIHsgcmV0dXJuIDI7IH1cbiAgaWYgKGMgPT09IDB4NzUvKiB1ICovKSB7IHJldHVybiA0OyB9XG4gIGlmIChjID09PSAweDU1LyogVSAqLykgeyByZXR1cm4gODsgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnJvbURlY2ltYWxDb2RlKGMpIHtcbiAgaWYgKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpIHtcbiAgICByZXR1cm4gYyAtIDB4MzA7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVzY2FwZVNlcXVlbmNlKGMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gIHJldHVybiAoYyA9PT0gMHgzMC8qIDAgKi8pID8gJ1xceDAwJyA6XG4gICAgICAgIChjID09PSAweDYxLyogYSAqLykgPyAnXFx4MDcnIDpcbiAgICAgICAgKGMgPT09IDB4NjIvKiBiICovKSA/ICdcXHgwOCcgOlxuICAgICAgICAoYyA9PT0gMHg3NC8qIHQgKi8pID8gJ1xceDA5JyA6XG4gICAgICAgIChjID09PSAweDA5LyogVGFiICovKSA/ICdcXHgwOScgOlxuICAgICAgICAoYyA9PT0gMHg2RS8qIG4gKi8pID8gJ1xceDBBJyA6XG4gICAgICAgIChjID09PSAweDc2LyogdiAqLykgPyAnXFx4MEInIDpcbiAgICAgICAgKGMgPT09IDB4NjYvKiBmICovKSA/ICdcXHgwQycgOlxuICAgICAgICAoYyA9PT0gMHg3Mi8qIHIgKi8pID8gJ1xceDBEJyA6XG4gICAgICAgIChjID09PSAweDY1LyogZSAqLykgPyAnXFx4MUInIDpcbiAgICAgICAgKGMgPT09IDB4MjAvKiBTcGFjZSAqLykgPyAnICcgOlxuICAgICAgICAoYyA9PT0gMHgyMi8qIFwiICovKSA/ICdcXHgyMicgOlxuICAgICAgICAoYyA9PT0gMHgyRi8qIC8gKi8pID8gJy8nIDpcbiAgICAgICAgKGMgPT09IDB4NUMvKiBcXCAqLykgPyAnXFx4NUMnIDpcbiAgICAgICAgKGMgPT09IDB4NEUvKiBOICovKSA/ICdcXHg4NScgOlxuICAgICAgICAoYyA9PT0gMHg1Ri8qIF8gKi8pID8gJ1xceEEwJyA6XG4gICAgICAgIChjID09PSAweDRDLyogTCAqLykgPyAnXFx1MjAyOCcgOlxuICAgICAgICAoYyA9PT0gMHg1MC8qIFAgKi8pID8gJ1xcdTIwMjknIDogJyc7XG59XG5cbmZ1bmN0aW9uIGNoYXJGcm9tQ29kZXBvaW50KGMpIHtcbiAgaWYgKGMgPD0gMHhGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gIH1cbiAgLy8gRW5jb2RlIFVURi0xNiBzdXJyb2dhdGUgcGFpclxuICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYjQ29kZV9wb2ludHNfVS4yQjAxMDAwMF90b19VLjJCMTBGRkZGXG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICgoYyAtIDB4MDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsXG4gICAgKChjIC0gMHgwMTAwMDApICYgMHgwM0ZGKSArIDB4REMwMFxuICApO1xufVxuXG52YXIgc2ltcGxlRXNjYXBlQ2hlY2sgPSBuZXcgQXJyYXkoMjU2KTsgLy8gaW50ZWdlciwgZm9yIGZhc3QgYWNjZXNzXG52YXIgc2ltcGxlRXNjYXBlTWFwID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIHNpbXBsZUVzY2FwZUNoZWNrW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSkgPyAxIDogMDtcbiAgc2ltcGxlRXNjYXBlTWFwW2ldID0gc2ltcGxlRXNjYXBlU2VxdWVuY2UoaSk7XG59XG5cblxuZnVuY3Rpb24gU3RhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gIHRoaXMuZmlsZW5hbWUgID0gb3B0aW9uc1snZmlsZW5hbWUnXSAgfHwgbnVsbDtcbiAgdGhpcy5zY2hlbWEgICAgPSBvcHRpb25zWydzY2hlbWEnXSAgICB8fCBERUZBVUxUX1NDSEVNQTtcbiAgdGhpcy5vbldhcm5pbmcgPSBvcHRpb25zWydvbldhcm5pbmcnXSB8fCBudWxsO1xuICAvLyAoSGlkZGVuKSBSZW1vdmU/IG1ha2VzIHRoZSBsb2FkZXIgdG8gZXhwZWN0IFlBTUwgMS4xIGRvY3VtZW50c1xuICAvLyBpZiBzdWNoIGRvY3VtZW50cyBoYXZlIG5vIGV4cGxpY2l0ICVZQU1MIGRpcmVjdGl2ZVxuICB0aGlzLmxlZ2FjeSAgICA9IG9wdGlvbnNbJ2xlZ2FjeSddICAgIHx8IGZhbHNlO1xuXG4gIHRoaXMuanNvbiAgICAgID0gb3B0aW9uc1snanNvbiddICAgICAgfHwgZmFsc2U7XG4gIHRoaXMubGlzdGVuZXIgID0gb3B0aW9uc1snbGlzdGVuZXInXSAgfHwgbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLnR5cGVNYXAgICAgICAgPSB0aGlzLnNjaGVtYS5jb21waWxlZFR5cGVNYXA7XG5cbiAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnBvc2l0aW9uICAgPSAwO1xuICB0aGlzLmxpbmUgICAgICAgPSAwO1xuICB0aGlzLmxpbmVTdGFydCAgPSAwO1xuICB0aGlzLmxpbmVJbmRlbnQgPSAwO1xuXG4gIC8vIHBvc2l0aW9uIG9mIGZpcnN0IGxlYWRpbmcgdGFiIGluIHRoZSBjdXJyZW50IGxpbmUsXG4gIC8vIHVzZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBubyB0YWJzIGluIHRoZSBpbmRlbnRhdGlvblxuICB0aGlzLmZpcnN0VGFiSW5MaW5lID0gLTE7XG5cbiAgdGhpcy5kb2N1bWVudHMgPSBbXTtcblxuICAvKlxuICB0aGlzLnZlcnNpb247XG4gIHRoaXMuY2hlY2tMaW5lQnJlYWtzO1xuICB0aGlzLnRhZ01hcDtcbiAgdGhpcy5hbmNob3JNYXA7XG4gIHRoaXMudGFnO1xuICB0aGlzLmFuY2hvcjtcbiAgdGhpcy5raW5kO1xuICB0aGlzLnJlc3VsdDsqL1xuXG59XG5cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcnJvcihzdGF0ZSwgbWVzc2FnZSkge1xuICB2YXIgbWFyayA9IHtcbiAgICBuYW1lOiAgICAgc3RhdGUuZmlsZW5hbWUsXG4gICAgYnVmZmVyOiAgIHN0YXRlLmlucHV0LnNsaWNlKDAsIC0xKSwgLy8gb21pdCB0cmFpbGluZyBcXDBcbiAgICBwb3NpdGlvbjogc3RhdGUucG9zaXRpb24sXG4gICAgbGluZTogICAgIHN0YXRlLmxpbmUsXG4gICAgY29sdW1uOiAgIHN0YXRlLnBvc2l0aW9uIC0gc3RhdGUubGluZVN0YXJ0XG4gIH07XG5cbiAgbWFyay5zbmlwcGV0ID0gbWFrZVNuaXBwZXQobWFyayk7XG5cbiAgcmV0dXJuIG5ldyBZQU1MRXhjZXB0aW9uKG1lc3NhZ2UsIG1hcmspO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKHN0YXRlLCBtZXNzYWdlKSB7XG4gIHRocm93IGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0aHJvd1dhcm5pbmcoc3RhdGUsIG1lc3NhZ2UpIHtcbiAgaWYgKHN0YXRlLm9uV2FybmluZykge1xuICAgIHN0YXRlLm9uV2FybmluZy5jYWxsKG51bGwsIGdlbmVyYXRlRXJyb3Ioc3RhdGUsIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5cbnZhciBkaXJlY3RpdmVIYW5kbGVycyA9IHtcblxuICBZQU1MOiBmdW5jdGlvbiBoYW5kbGVZYW1sRGlyZWN0aXZlKHN0YXRlLCBuYW1lLCBhcmdzKSB7XG5cbiAgICB2YXIgbWF0Y2gsIG1ham9yLCBtaW5vcjtcblxuICAgIGlmIChzdGF0ZS52ZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgJVlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnWUFNTCBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IG9uZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIG1hdGNoID0gL14oWzAtOV0rKVxcLihbMC05XSspJC8uZXhlYyhhcmdzWzBdKTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgYXJndW1lbnQgb2YgdGhlIFlBTUwgZGlyZWN0aXZlJyk7XG4gICAgfVxuXG4gICAgbWFqb3IgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIG1pbm9yID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcblxuICAgIGlmIChtYWpvciAhPT0gMSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBZQU1MIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG4gICAgfVxuXG4gICAgc3RhdGUudmVyc2lvbiA9IGFyZ3NbMF07XG4gICAgc3RhdGUuY2hlY2tMaW5lQnJlYWtzID0gKG1pbm9yIDwgMik7XG5cbiAgICBpZiAobWlub3IgIT09IDEgJiYgbWlub3IgIT09IDIpIHtcbiAgICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ3Vuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiBvZiB0aGUgZG9jdW1lbnQnKTtcbiAgICB9XG4gIH0sXG5cbiAgVEFHOiBmdW5jdGlvbiBoYW5kbGVUYWdEaXJlY3RpdmUoc3RhdGUsIG5hbWUsIGFyZ3MpIHtcblxuICAgIHZhciBoYW5kbGUsIHByZWZpeDtcblxuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ1RBRyBkaXJlY3RpdmUgYWNjZXB0cyBleGFjdGx5IHR3byBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBoYW5kbGUgPSBhcmdzWzBdO1xuICAgIHByZWZpeCA9IGFyZ3NbMV07XG5cbiAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbGwtZm9ybWVkIHRhZyBoYW5kbGUgKGZpcnN0IGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50YWdNYXAsIGhhbmRsZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGVyZSBpcyBhIHByZXZpb3VzbHkgZGVjbGFyZWQgc3VmZml4IGZvciBcIicgKyBoYW5kbGUgKyAnXCIgdGFnIGhhbmRsZScpO1xuICAgIH1cblxuICAgIGlmICghUEFUVEVSTl9UQUdfVVJJLnRlc3QocHJlZml4KSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2lsbC1mb3JtZWQgdGFnIHByZWZpeCAoc2Vjb25kIGFyZ3VtZW50KSBvZiB0aGUgVEFHIGRpcmVjdGl2ZScpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcmVmaXggPSBkZWNvZGVVUklDb21wb25lbnQocHJlZml4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgcHJlZml4IGlzIG1hbGZvcm1lZDogJyArIHByZWZpeCk7XG4gICAgfVxuXG4gICAgc3RhdGUudGFnTWFwW2hhbmRsZV0gPSBwcmVmaXg7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gY2FwdHVyZVNlZ21lbnQoc3RhdGUsIHN0YXJ0LCBlbmQsIGNoZWNrSnNvbikge1xuICB2YXIgX3Bvc2l0aW9uLCBfbGVuZ3RoLCBfY2hhcmFjdGVyLCBfcmVzdWx0O1xuXG4gIGlmIChzdGFydCA8IGVuZCkge1xuICAgIF9yZXN1bHQgPSBzdGF0ZS5pbnB1dC5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChjaGVja0pzb24pIHtcbiAgICAgIGZvciAoX3Bvc2l0aW9uID0gMCwgX2xlbmd0aCA9IF9yZXN1bHQubGVuZ3RoOyBfcG9zaXRpb24gPCBfbGVuZ3RoOyBfcG9zaXRpb24gKz0gMSkge1xuICAgICAgICBfY2hhcmFjdGVyID0gX3Jlc3VsdC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG4gICAgICAgIGlmICghKF9jaGFyYWN0ZXIgPT09IDB4MDkgfHxcbiAgICAgICAgICAgICAgKDB4MjAgPD0gX2NoYXJhY3RlciAmJiBfY2hhcmFjdGVyIDw9IDB4MTBGRkZGKSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgdmFsaWQgSlNPTiBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoUEFUVEVSTl9OT05fUFJJTlRBQkxFLnRlc3QoX3Jlc3VsdCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0aGUgc3RyZWFtIGNvbnRhaW5zIG5vbi1wcmludGFibGUgY2hhcmFjdGVycycpO1xuICAgIH1cblxuICAgIHN0YXRlLnJlc3VsdCArPSBfcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlTWFwcGluZ3Moc3RhdGUsIGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJyaWRhYmxlS2V5cykge1xuICB2YXIgc291cmNlS2V5cywga2V5LCBpbmRleCwgcXVhbnRpdHk7XG5cbiAgaWYgKCFjb21tb24uaXNPYmplY3Qoc291cmNlKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICdjYW5ub3QgbWVyZ2UgbWFwcGluZ3M7IHRoZSBwcm92aWRlZCBzb3VyY2Ugb2JqZWN0IGlzIHVuYWNjZXB0YWJsZScpO1xuICB9XG5cbiAgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cbiAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gc291cmNlS2V5cy5sZW5ndGg7IGluZGV4IDwgcXVhbnRpdHk7IGluZGV4ICs9IDEpIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2luZGV4XTtcblxuICAgIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoZGVzdGluYXRpb24sIGtleSkpIHtcbiAgICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIG92ZXJyaWRhYmxlS2V5c1trZXldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSxcbiAgc3RhcnRMaW5lLCBzdGFydExpbmVTdGFydCwgc3RhcnRQb3MpIHtcblxuICB2YXIgaW5kZXgsIHF1YW50aXR5O1xuXG4gIC8vIFRoZSBvdXRwdXQgaXMgYSBwbGFpbiBvYmplY3QgaGVyZSwgc28ga2V5cyBjYW4gb25seSBiZSBzdHJpbmdzLlxuICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQga2V5Tm9kZSB0byBhIHN0cmluZywgYnV0IGRvaW5nIHNvIGNhbiBoYW5nIHRoZSBwcm9jZXNzXG4gIC8vIChkZWVwbHkgbmVzdGVkIGFycmF5cyB0aGF0IGV4cGxvZGUgZXhwb25lbnRpYWxseSB1c2luZyBhbGlhc2VzKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZSkpIHtcbiAgICBrZXlOb2RlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoa2V5Tm9kZSk7XG5cbiAgICBmb3IgKGluZGV4ID0gMCwgcXVhbnRpdHkgPSBrZXlOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Tm9kZVtpbmRleF0pKSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduZXN0ZWQgYXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBrZXlzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Yga2V5Tm9kZSA9PT0gJ29iamVjdCcgJiYgX2NsYXNzKGtleU5vZGVbaW5kZXhdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAga2V5Tm9kZVtpbmRleF0gPSAnW29iamVjdCBPYmplY3RdJztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBdm9pZCBjb2RlIGV4ZWN1dGlvbiBpbiBsb2FkKCkgdmlhIHRvU3RyaW5nIHByb3BlcnR5XG4gIC8vIChzdGlsbCB1c2UgaXRzIG93biB0b1N0cmluZyBmb3IgYXJyYXlzLCB0aW1lc3RhbXBzLFxuICAvLyBhbmQgd2hhdGV2ZXIgdXNlciBzY2hlbWEgZXh0ZW5zaW9ucyBoYXBwZW4gdG8gaGF2ZSBAQHRvU3RyaW5nVGFnKVxuICBpZiAodHlwZW9mIGtleU5vZGUgPT09ICdvYmplY3QnICYmIF9jbGFzcyhrZXlOb2RlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBrZXlOb2RlID0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuXG4gIGtleU5vZGUgPSBTdHJpbmcoa2V5Tm9kZSk7XG5cbiAgaWYgKF9yZXN1bHQgPT09IG51bGwpIHtcbiAgICBfcmVzdWx0ID0ge307XG4gIH1cblxuICBpZiAoa2V5VGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVOb2RlKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIHF1YW50aXR5ID0gdmFsdWVOb2RlLmxlbmd0aDsgaW5kZXggPCBxdWFudGl0eTsgaW5kZXggKz0gMSkge1xuICAgICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGVbaW5kZXhdLCBvdmVycmlkYWJsZUtleXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZU1hcHBpbmdzKHN0YXRlLCBfcmVzdWx0LCB2YWx1ZU5vZGUsIG92ZXJyaWRhYmxlS2V5cyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghc3RhdGUuanNvbiAmJlxuICAgICAgICAhX2hhc093blByb3BlcnR5LmNhbGwob3ZlcnJpZGFibGVLZXlzLCBrZXlOb2RlKSAmJlxuICAgICAgICBfaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBrZXlOb2RlKSkge1xuICAgICAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSB8fCBzdGF0ZS5saW5lO1xuICAgICAgc3RhdGUubGluZVN0YXJ0ID0gc3RhcnRMaW5lU3RhcnQgfHwgc3RhdGUubGluZVN0YXJ0O1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGFydFBvcyB8fCBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdkdXBsaWNhdGVkIG1hcHBpbmcga2V5Jyk7XG4gICAgfVxuXG4gICAgLy8gdXNlZCBmb3IgdGhpcyBzcGVjaWZpYyBrZXkgb25seSBiZWNhdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBzbG93XG4gICAgaWYgKGtleU5vZGUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3Jlc3VsdCwga2V5Tm9kZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWVOb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdFtrZXlOb2RlXSA9IHZhbHVlTm9kZTtcbiAgICB9XG4gICAgZGVsZXRlIG92ZXJyaWRhYmxlS2V5c1trZXlOb2RlXTtcbiAgfVxuXG4gIHJldHVybiBfcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkTGluZUJyZWFrKHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHgwQS8qIExGICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgfSBlbHNlIGlmIChjaCA9PT0gMHgwRC8qIENSICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24rKztcbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MEEvKiBMRiAqLykge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2EgbGluZSBicmVhayBpcyBleHBlY3RlZCcpO1xuICB9XG5cbiAgc3RhdGUubGluZSArPSAxO1xuICBzdGF0ZS5saW5lU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgYWxsb3dDb21tZW50cywgY2hlY2tJbmRlbnQpIHtcbiAgdmFyIGxpbmVCcmVha3MgPSAwLFxuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICBpZiAoY2ggPT09IDB4MDkvKiBUYWIgKi8gJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgPT09IC0xKSB7XG4gICAgICAgIHN0YXRlLmZpcnN0VGFiSW5MaW5lID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93Q29tbWVudHMgJiYgY2ggPT09IDB4MjMvKiAjICovKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH0gd2hpbGUgKGNoICE9PSAweDBBLyogTEYgKi8gJiYgY2ggIT09IDB4MEQvKiBDUiAqLyAmJiBjaCAhPT0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgbGluZUJyZWFrcysrO1xuICAgICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICAgIHdoaWxlIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSB7XG4gICAgICAgIHN0YXRlLmxpbmVJbmRlbnQrKztcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tJbmRlbnQgIT09IC0xICYmIGxpbmVCcmVha3MgIT09IDAgJiYgc3RhdGUubGluZUluZGVudCA8IGNoZWNrSW5kZW50KSB7XG4gICAgdGhyb3dXYXJuaW5nKHN0YXRlLCAnZGVmaWNpZW50IGluZGVudGF0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbGluZUJyZWFrcztcbn1cblxuZnVuY3Rpb24gdGVzdERvY3VtZW50U2VwYXJhdG9yKHN0YXRlKSB7XG4gIHZhciBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24pO1xuXG4gIC8vIENvbmRpdGlvbiBzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0IGlzIHRlc3RlZFxuICAvLyBpbiBwYXJlbnQgb24gZWFjaCBjYWxsLCBmb3IgZWZmaWNpZW5jeS4gTm8gbmVlZHMgdG8gdGVzdCBoZXJlIGFnYWluLlxuICBpZiAoKGNoID09PSAweDJELyogLSAqLyB8fCBjaCA9PT0gMHgyRS8qIC4gKi8pICYmXG4gICAgICBjaCA9PT0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChfcG9zaXRpb24gKyAxKSAmJlxuICAgICAgY2ggPT09IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoX3Bvc2l0aW9uICsgMikpIHtcblxuICAgIF9wb3NpdGlvbiArPSAzO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KF9wb3NpdGlvbik7XG5cbiAgICBpZiAoY2ggPT09IDAgfHwgaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBjb3VudCkge1xuICBpZiAoY291bnQgPT09IDEpIHtcbiAgICBzdGF0ZS5yZXN1bHQgKz0gJyAnO1xuICB9IGVsc2UgaWYgKGNvdW50ID4gMSkge1xuICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBjb3VudCAtIDEpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gcmVhZFBsYWluU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50LCB3aXRoaW5GbG93Q29sbGVjdGlvbikge1xuICB2YXIgcHJlY2VkaW5nLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgY2FwdHVyZVN0YXJ0LFxuICAgICAgY2FwdHVyZUVuZCxcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50LFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX2xpbmVJbmRlbnQsXG4gICAgICBfa2luZCA9IHN0YXRlLmtpbmQsXG4gICAgICBfcmVzdWx0ID0gc3RhdGUucmVzdWx0LFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoaXNfV1NfT1JfRU9MKGNoKSAgICAgIHx8XG4gICAgICBpc19GTE9XX0lORElDQVRPUihjaCkgfHxcbiAgICAgIGNoID09PSAweDIzLyogIyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjYvKiAmICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgyQS8qICogKi8gICAgfHxcbiAgICAgIGNoID09PSAweDIxLyogISAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4N0MvKiB8ICovICAgIHx8XG4gICAgICBjaCA9PT0gMHgzRS8qID4gKi8gICAgfHxcbiAgICAgIGNoID09PSAweDI3LyogJyAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjIvKiBcIiAqLyAgICB8fFxuICAgICAgY2ggPT09IDB4MjUvKiAlICovICAgIHx8XG4gICAgICBjaCA9PT0gMHg0MC8qIEAgKi8gICAgfHxcbiAgICAgIGNoID09PSAweDYwLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMHgzRi8qID8gKi8gfHwgY2ggPT09IDB4MkQvKiAtICovKSB7XG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKGlzX1dTX09SX0VPTChmb2xsb3dpbmcpIHx8XG4gICAgICAgIHdpdGhpbkZsb3dDb2xsZWN0aW9uICYmIGlzX0ZMT1dfSU5ESUNBVE9SKGZvbGxvd2luZykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG4gIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDNBLyogOiAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykgfHxcbiAgICAgICAgICB3aXRoaW5GbG93Q29sbGVjdGlvbiAmJiBpc19GTE9XX0lORElDQVRPUihmb2xsb3dpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIHByZWNlZGluZyA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24gLSAxKTtcblxuICAgICAgaWYgKGlzX1dTX09SX0VPTChwcmVjZWRpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB8fFxuICAgICAgICAgICAgICAgd2l0aGluRmxvd0NvbGxlY3Rpb24gJiYgaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgICBicmVhaztcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2xpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9saW5lSW5kZW50ID0gc3RhdGUubGluZUluZGVudDtcbiAgICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIGZhbHNlLCAtMSk7XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID49IG5vZGVJbmRlbnQpIHtcbiAgICAgICAgaGFzUGVuZGluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uID0gY2FwdHVyZUVuZDtcbiAgICAgICAgc3RhdGUubGluZSA9IF9saW5lO1xuICAgICAgICBzdGF0ZS5saW5lU3RhcnQgPSBfbGluZVN0YXJ0O1xuICAgICAgICBzdGF0ZS5saW5lSW5kZW50ID0gX2xpbmVJbmRlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nQ29udGVudCkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc3RhdGUubGluZSAtIF9saW5lKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgIGhhc1BlbmRpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbiArIDE7XG4gICAgfVxuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgZmFsc2UpO1xuXG4gIGlmIChzdGF0ZS5yZXN1bHQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSBfa2luZDtcbiAgc3RhdGUucmVzdWx0ID0gX3Jlc3VsdDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkU2luZ2xlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyNy8qICcgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5raW5kID0gJ3NjYWxhcic7XG4gIHN0YXRlLnJlc3VsdCA9ICcnO1xuICBzdGF0ZS5wb3NpdGlvbisrO1xuICBjYXB0dXJlU3RhcnQgPSBjYXB0dXJlRW5kID0gc3RhdGUucG9zaXRpb247XG5cbiAgd2hpbGUgKChjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pKSAhPT0gMCkge1xuICAgIGlmIChjaCA9PT0gMHgyNy8qICcgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICAgICAgaWYgKGNoID09PSAweDI3LyogJyAqLykge1xuICAgICAgICBjYXB0dXJlU3RhcnQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGlzX0VPTChjaCkpIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIGNhcHR1cmVFbmQsIHRydWUpO1xuICAgICAgd3JpdGVGb2xkZWRMaW5lcyhzdGF0ZSwgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgZmFsc2UsIG5vZGVJbmRlbnQpKTtcbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIGRvY3VtZW50IHdpdGhpbiBhIHNpbmdsZSBxdW90ZWQgc2NhbGFyJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBzaW5nbGUgcXVvdGVkIHNjYWxhcicpO1xufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBjYXB0dXJlRW5kLFxuICAgICAgaGV4TGVuZ3RoLFxuICAgICAgaGV4UmVzdWx0LFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggIT09IDB4MjIvKiBcIiAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG4gIHN0YXRlLnBvc2l0aW9uKys7XG4gIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgaWYgKGNoID09PSAweDIyLyogXCIgKi8pIHtcbiAgICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIHN0YXRlLnBvc2l0aW9uKys7XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgc3RhdGUucG9zaXRpb24sIHRydWUpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCk7XG5cbiAgICAgICAgLy8gVE9ETzogcmV3b3JrIHRvIGlubGluZSBmbiB3aXRoIG5vIHR5cGUgY2FzdD9cbiAgICAgIH0gZWxzZSBpZiAoY2ggPCAyNTYgJiYgc2ltcGxlRXNjYXBlQ2hlY2tbY2hdKSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBzaW1wbGVFc2NhcGVNYXBbY2hdO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2UgaWYgKCh0bXAgPSBlc2NhcGVkSGV4TGVuKGNoKSkgPiAwKSB7XG4gICAgICAgIGhleExlbmd0aCA9IHRtcDtcbiAgICAgICAgaGV4UmVzdWx0ID0gMDtcblxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoID4gMDsgaGV4TGVuZ3RoLS0pIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICAgICAgICBpZiAoKHRtcCA9IGZyb21IZXhDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgICAgICAgaGV4UmVzdWx0ID0gKGhleFJlc3VsdCA8PCA0KSArIHRtcDtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZXhwZWN0ZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNoYXJGcm9tQ29kZXBvaW50KGhleFJlc3VsdCk7XG5cbiAgICAgICAgc3RhdGUucG9zaXRpb24rKztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3Vua25vd24gZXNjYXBlIHNlcXVlbmNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNhcHR1cmVTdGFydCA9IGNhcHR1cmVFbmQgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIH0gZWxzZSBpZiAoaXNfRU9MKGNoKSkge1xuICAgICAgY2FwdHVyZVNlZ21lbnQoc3RhdGUsIGNhcHR1cmVTdGFydCwgY2FwdHVyZUVuZCwgdHJ1ZSk7XG4gICAgICB3cml0ZUZvbGRlZExpbmVzKHN0YXRlLCBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCBmYWxzZSwgbm9kZUluZGVudCkpO1xuICAgICAgY2FwdHVyZVN0YXJ0ID0gY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbiA9PT0gc3RhdGUubGluZVN0YXJ0ICYmIHRlc3REb2N1bWVudFNlcGFyYXRvcihzdGF0ZSkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgZG9jdW1lbnQgd2l0aGluIGEgZG91YmxlIHF1b3RlZCBzY2FsYXInKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgY2FwdHVyZUVuZCA9IHN0YXRlLnBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHRocm93RXJyb3Ioc3RhdGUsICd1bmV4cGVjdGVkIGVuZCBvZiB0aGUgc3RyZWFtIHdpdGhpbiBhIGRvdWJsZSBxdW90ZWQgc2NhbGFyJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRGbG93Q29sbGVjdGlvbihzdGF0ZSwgbm9kZUluZGVudCkge1xuICB2YXIgcmVhZE5leHQgPSB0cnVlLFxuICAgICAgX2xpbmUsXG4gICAgICBfbGluZVN0YXJ0LFxuICAgICAgX3BvcyxcbiAgICAgIF90YWcgICAgID0gc3RhdGUudGFnLFxuICAgICAgX3Jlc3VsdCxcbiAgICAgIF9hbmNob3IgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgZm9sbG93aW5nLFxuICAgICAgdGVybWluYXRvcixcbiAgICAgIGlzUGFpcixcbiAgICAgIGlzRXhwbGljaXRQYWlyLFxuICAgICAgaXNNYXBwaW5nLFxuICAgICAgb3ZlcnJpZGFibGVLZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIGtleU5vZGUsXG4gICAgICBrZXlUYWcsXG4gICAgICB2YWx1ZU5vZGUsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICB0ZXJtaW5hdG9yID0gMHg1RDsvKiBdICovXG4gICAgaXNNYXBwaW5nID0gZmFsc2U7XG4gICAgX3Jlc3VsdCA9IFtdO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDdCLyogeyAqLykge1xuICAgIHRlcm1pbmF0b3IgPSAweDdEOy8qIH0gKi9cbiAgICBpc01hcHBpbmcgPSB0cnVlO1xuICAgIF9yZXN1bHQgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIHdoaWxlIChjaCAhPT0gMCkge1xuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gdGVybWluYXRvcikge1xuICAgICAgc3RhdGUucG9zaXRpb24rKztcbiAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICBzdGF0ZS5hbmNob3IgPSBfYW5jaG9yO1xuICAgICAgc3RhdGUua2luZCA9IGlzTWFwcGluZyA/ICdtYXBwaW5nJyA6ICdzZXF1ZW5jZSc7XG4gICAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghcmVhZE5leHQpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdtaXNzZWQgY29tbWEgYmV0d2VlbiBmbG93IGNvbGxlY3Rpb24gZW50cmllcycpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MkMvKiAsICovKSB7XG4gICAgICAvLyBcImZsb3cgY29sbGVjdGlvbiBlbnRyaWVzIGNhbiBuZXZlciBiZSBjb21wbGV0ZWx5IGVtcHR5XCIsIGFzIHBlciBZQU1MIDEuMiwgc2VjdGlvbiA3LjRcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsIFwiZXhwZWN0ZWQgdGhlIG5vZGUgY29udGVudCwgYnV0IGZvdW5kICcsJ1wiKTtcbiAgICB9XG5cbiAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICBpc1BhaXIgPSBpc0V4cGxpY2l0UGFpciA9IGZhbHNlO1xuXG4gICAgaWYgKGNoID09PSAweDNGLyogPyAqLykge1xuICAgICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgICBpZiAoaXNfV1NfT1JfRU9MKGZvbGxvd2luZykpIHtcbiAgICAgICAgaXNQYWlyID0gaXNFeHBsaWNpdFBhaXIgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbisrO1xuICAgICAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCBub2RlSW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfbGluZSA9IHN0YXRlLmxpbmU7IC8vIFNhdmUgdGhlIGN1cnJlbnQgbGluZS5cbiAgICBfbGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgIF9wb3MgPSBzdGF0ZS5wb3NpdGlvbjtcbiAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAga2V5VGFnID0gc3RhdGUudGFnO1xuICAgIGtleU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKChpc0V4cGxpY2l0UGFpciB8fCBzdGF0ZS5saW5lID09PSBfbGluZSkgJiYgY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBpc1BhaXIgPSB0cnVlO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgbm9kZUluZGVudCk7XG4gICAgICBjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9GTE9XX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB2YWx1ZU5vZGUgPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzTWFwcGluZykge1xuICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpO1xuICAgIH0gZWxzZSBpZiAoaXNQYWlyKSB7XG4gICAgICBfcmVzdWx0LnB1c2goc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgbnVsbCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2xpbmUsIF9saW5lU3RhcnQsIF9wb3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3Jlc3VsdC5wdXNoKGtleU5vZGUpO1xuICAgIH1cblxuICAgIHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIG5vZGVJbmRlbnQpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChjaCA9PT0gMHgyQy8qICwgKi8pIHtcbiAgICAgIHJlYWROZXh0ID0gdHJ1ZTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVhZE5leHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aHJvd0Vycm9yKHN0YXRlLCAndW5leHBlY3RlZCBlbmQgb2YgdGhlIHN0cmVhbSB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBub2RlSW5kZW50KSB7XG4gIHZhciBjYXB0dXJlU3RhcnQsXG4gICAgICBmb2xkaW5nLFxuICAgICAgY2hvbXBpbmcgICAgICAgPSBDSE9NUElOR19DTElQLFxuICAgICAgZGlkUmVhZENvbnRlbnQgPSBmYWxzZSxcbiAgICAgIGRldGVjdGVkSW5kZW50ID0gZmFsc2UsXG4gICAgICB0ZXh0SW5kZW50ICAgICA9IG5vZGVJbmRlbnQsXG4gICAgICBlbXB0eUxpbmVzICAgICA9IDAsXG4gICAgICBhdE1vcmVJbmRlbnRlZCA9IGZhbHNlLFxuICAgICAgdG1wLFxuICAgICAgY2g7XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4N0MvKiB8ICovKSB7XG4gICAgZm9sZGluZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGNoID09PSAweDNFLyogPiAqLykge1xuICAgIGZvbGRpbmcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmtpbmQgPSAnc2NhbGFyJztcbiAgc3RhdGUucmVzdWx0ID0gJyc7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgaWYgKGNoID09PSAweDJCLyogKyAqLyB8fCBjaCA9PT0gMHgyRC8qIC0gKi8pIHtcbiAgICAgIGlmIChDSE9NUElOR19DTElQID09PSBjaG9tcGluZykge1xuICAgICAgICBjaG9tcGluZyA9IChjaCA9PT0gMHgyQi8qICsgKi8pID8gQ0hPTVBJTkdfS0VFUCA6IENIT01QSU5HX1NUUklQO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3JlcGVhdCBvZiBhIGNob21waW5nIG1vZGUgaWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICgodG1wID0gZnJvbURlY2ltYWxDb2RlKGNoKSkgPj0gMCkge1xuICAgICAgaWYgKHRtcCA9PT0gMCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGV4cGxpY2l0IGluZGVudGF0aW9uIHdpZHRoIG9mIGEgYmxvY2sgc2NhbGFyOyBpdCBjYW5ub3QgYmUgbGVzcyB0aGFuIG9uZScpO1xuICAgICAgfSBlbHNlIGlmICghZGV0ZWN0ZWRJbmRlbnQpIHtcbiAgICAgICAgdGV4dEluZGVudCA9IG5vZGVJbmRlbnQgKyB0bXAgLSAxO1xuICAgICAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAncmVwZWF0IG9mIGFuIGluZGVudGF0aW9uIHdpZHRoIGlkZW50aWZpZXInKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgZG8geyBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7IH1cbiAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKTtcblxuICAgIGlmIChjaCA9PT0gMHgyMy8qICMgKi8pIHtcbiAgICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgcmVhZExpbmVCcmVhayhzdGF0ZSk7XG4gICAgc3RhdGUubGluZUluZGVudCA9IDA7XG5cbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgd2hpbGUgKCghZGV0ZWN0ZWRJbmRlbnQgfHwgc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpICYmXG4gICAgICAgICAgIChjaCA9PT0gMHgyMC8qIFNwYWNlICovKSkge1xuICAgICAgc3RhdGUubGluZUluZGVudCsrO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGlmICghZGV0ZWN0ZWRJbmRlbnQgJiYgc3RhdGUubGluZUluZGVudCA+IHRleHRJbmRlbnQpIHtcbiAgICAgIHRleHRJbmRlbnQgPSBzdGF0ZS5saW5lSW5kZW50O1xuICAgIH1cblxuICAgIGlmIChpc19FT0woY2gpKSB7XG4gICAgICBlbXB0eUxpbmVzKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBFbmQgb2YgdGhlIHNjYWxhci5cbiAgICBpZiAoc3RhdGUubGluZUluZGVudCA8IHRleHRJbmRlbnQpIHtcblxuICAgICAgLy8gUGVyZm9ybSB0aGUgY2hvbXBpbmcuXG4gICAgICBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0tFRVApIHtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGRpZFJlYWRDb250ZW50ID8gMSArIGVtcHR5TGluZXMgOiBlbXB0eUxpbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hvbXBpbmcgPT09IENIT01QSU5HX0NMSVApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB0aGUgc2NhbGFyIGlzIG5vdCBlbXB0eS5cbiAgICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnJlYWsgdGhpcyBgd2hpbGVgIGN5Y2xlIGFuZCBnbyB0byB0aGUgZnVuY2l0b24ncyBlcGlsb2d1ZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIEZvbGRlZCBzdHlsZTogdXNlIGZhbmN5IHJ1bGVzIHRvIGhhbmRsZSBsaW5lIGJyZWFrcy5cbiAgICBpZiAoZm9sZGluZykge1xuXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoIHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMgKG1vcmUtaW5kZW50ZWQgbGluZXMpIGFyZSBub3QgZm9sZGVkLlxuICAgICAgaWYgKGlzX1dISVRFX1NQQUNFKGNoKSkge1xuICAgICAgICBhdE1vcmVJbmRlbnRlZCA9IHRydWU7XG4gICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSAoY2YuIEV4YW1wbGUgOC4xKVxuICAgICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuXG4gICAgICAvLyBFbmQgb2YgbW9yZS1pbmRlbnRlZCBibG9jay5cbiAgICAgIH0gZWxzZSBpZiAoYXRNb3JlSW5kZW50ZWQpIHtcbiAgICAgICAgYXRNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucmVzdWx0ICs9IGNvbW1vbi5yZXBlYXQoJ1xcbicsIGVtcHR5TGluZXMgKyAxKTtcblxuICAgICAgLy8gSnVzdCBvbmUgbGluZSBicmVhayAtIHBlcmNlaXZlIGFzIHRoZSBzYW1lIGxpbmUuXG4gICAgICB9IGVsc2UgaWYgKGVtcHR5TGluZXMgPT09IDApIHtcbiAgICAgICAgaWYgKGRpZFJlYWRDb250ZW50KSB7IC8vIGkuZS4gb25seSBpZiB3ZSBoYXZlIGFscmVhZHkgcmVhZCBzb21lIHNjYWxhciBjb250ZW50LlxuICAgICAgICAgIHN0YXRlLnJlc3VsdCArPSAnICc7XG4gICAgICAgIH1cblxuICAgICAgLy8gU2V2ZXJhbCBsaW5lIGJyZWFrcyAtIHBlcmNlaXZlIGFzIGRpZmZlcmVudCBsaW5lcy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlc3VsdCArPSBjb21tb24ucmVwZWF0KCdcXG4nLCBlbXB0eUxpbmVzKTtcbiAgICAgIH1cblxuICAgIC8vIExpdGVyYWwgc3R5bGU6IGp1c3QgYWRkIGV4YWN0IG51bWJlciBvZiBsaW5lIGJyZWFrcyBiZXR3ZWVuIGNvbnRlbnQgbGluZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgYWxsIGxpbmUgYnJlYWtzIGV4Y2VwdCB0aGUgaGVhZGVyIGxpbmUgYnJlYWsuXG4gICAgICBzdGF0ZS5yZXN1bHQgKz0gY29tbW9uLnJlcGVhdCgnXFxuJywgZGlkUmVhZENvbnRlbnQgPyAxICsgZW1wdHlMaW5lcyA6IGVtcHR5TGluZXMpO1xuICAgIH1cblxuICAgIGRpZFJlYWRDb250ZW50ID0gdHJ1ZTtcbiAgICBkZXRlY3RlZEluZGVudCA9IHRydWU7XG4gICAgZW1wdHlMaW5lcyA9IDA7XG4gICAgY2FwdHVyZVN0YXJ0ID0gc3RhdGUucG9zaXRpb247XG5cbiAgICB3aGlsZSAoIWlzX0VPTChjaCkgJiYgKGNoICE9PSAwKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGNhcHR1cmVTZWdtZW50KHN0YXRlLCBjYXB0dXJlU3RhcnQsIHN0YXRlLnBvc2l0aW9uLCBmYWxzZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIG5vZGVJbmRlbnQpIHtcbiAgdmFyIF9saW5lLFxuICAgICAgX3RhZyAgICAgID0gc3RhdGUudGFnLFxuICAgICAgX2FuY2hvciAgID0gc3RhdGUuYW5jaG9yLFxuICAgICAgX3Jlc3VsdCAgID0gW10sXG4gICAgICBmb2xsb3dpbmcsXG4gICAgICBkZXRlY3RlZCAgPSBmYWxzZSxcbiAgICAgIGNoO1xuXG4gIC8vIHRoZXJlIGlzIGEgbGVhZGluZyB0YWIgYmVmb3JlIHRoaXMgdG9rZW4sIHNvIGl0IGNhbid0IGJlIGEgYmxvY2sgc2VxdWVuY2UvbWFwcGluZztcbiAgLy8gaXQgY2FuIHN0aWxsIGJlIGZsb3cgc2VxdWVuY2UvbWFwcGluZyBvciBhIHNjYWxhclxuICBpZiAoc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gX3Jlc3VsdDtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgaWYgKHN0YXRlLmZpcnN0VGFiSW5MaW5lICE9PSAtMSkge1xuICAgICAgc3RhdGUucG9zaXRpb24gPSBzdGF0ZS5maXJzdFRhYkluTGluZTtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWIgY2hhcmFjdGVycyBtdXN0IG5vdCBiZSB1c2VkIGluIGluZGVudGF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNoICE9PSAweDJELyogLSAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZm9sbG93aW5nID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKCFpc19XU19PUl9FT0woZm9sbG93aW5nKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnBvc2l0aW9uKys7XG5cbiAgICBpZiAoc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpKSB7XG4gICAgICBpZiAoc3RhdGUubGluZUluZGVudCA8PSBub2RlSW5kZW50KSB7XG4gICAgICAgIF9yZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lO1xuICAgIGNvbXBvc2VOb2RlKHN0YXRlLCBub2RlSW5kZW50LCBDT05URVhUX0JMT0NLX0lOLCBmYWxzZSwgdHJ1ZSk7XG4gICAgX3Jlc3VsdC5wdXNoKHN0YXRlLnJlc3VsdCk7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmICgoc3RhdGUubGluZSA9PT0gX2xpbmUgfHwgc3RhdGUubGluZUluZGVudCA+IG5vZGVJbmRlbnQpICYmIChjaCAhPT0gMCkpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdiYWQgaW5kZW50YXRpb24gb2YgYSBzZXF1ZW5jZSBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ3NlcXVlbmNlJztcbiAgICBzdGF0ZS5yZXN1bHQgPSBfcmVzdWx0O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2NrTWFwcGluZyhzdGF0ZSwgbm9kZUluZGVudCwgZmxvd0luZGVudCkge1xuICB2YXIgZm9sbG93aW5nLFxuICAgICAgYWxsb3dDb21wYWN0LFxuICAgICAgX2xpbmUsXG4gICAgICBfa2V5TGluZSxcbiAgICAgIF9rZXlMaW5lU3RhcnQsXG4gICAgICBfa2V5UG9zLFxuICAgICAgX3RhZyAgICAgICAgICA9IHN0YXRlLnRhZyxcbiAgICAgIF9hbmNob3IgICAgICAgPSBzdGF0ZS5hbmNob3IsXG4gICAgICBfcmVzdWx0ICAgICAgID0ge30sXG4gICAgICBvdmVycmlkYWJsZUtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5VGFnICAgICAgICA9IG51bGwsXG4gICAgICBrZXlOb2RlICAgICAgID0gbnVsbCxcbiAgICAgIHZhbHVlTm9kZSAgICAgPSBudWxsLFxuICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlLFxuICAgICAgZGV0ZWN0ZWQgICAgICA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgLy8gdGhlcmUgaXMgYSBsZWFkaW5nIHRhYiBiZWZvcmUgdGhpcyB0b2tlbiwgc28gaXQgY2FuJ3QgYmUgYSBibG9jayBzZXF1ZW5jZS9tYXBwaW5nO1xuICAvLyBpdCBjYW4gc3RpbGwgYmUgZmxvdyBzZXF1ZW5jZS9tYXBwaW5nIG9yIGEgc2NhbGFyXG4gIGlmIChzdGF0ZS5maXJzdFRhYkluTGluZSAhPT0gLTEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBfcmVzdWx0O1xuICB9XG5cbiAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICB3aGlsZSAoY2ggIT09IDApIHtcbiAgICBpZiAoIWF0RXhwbGljaXRLZXkgJiYgc3RhdGUuZmlyc3RUYWJJbkxpbmUgIT09IC0xKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiA9IHN0YXRlLmZpcnN0VGFiSW5MaW5lO1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhYiBjaGFyYWN0ZXJzIG11c3Qgbm90IGJlIHVzZWQgaW4gaW5kZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICBmb2xsb3dpbmcgPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSk7XG4gICAgX2xpbmUgPSBzdGF0ZS5saW5lOyAvLyBTYXZlIHRoZSBjdXJyZW50IGxpbmUuXG5cbiAgICAvL1xuICAgIC8vIEV4cGxpY2l0IG5vdGF0aW9uIGNhc2UuIFRoZXJlIGFyZSB0d28gc2VwYXJhdGUgYmxvY2tzOlxuICAgIC8vIGZpcnN0IGZvciB0aGUga2V5IChkZW5vdGVkIGJ5IFwiP1wiKSBhbmQgc2Vjb25kIGZvciB0aGUgdmFsdWUgKGRlbm90ZWQgYnkgXCI6XCIpXG4gICAgLy9cbiAgICBpZiAoKGNoID09PSAweDNGLyogPyAqLyB8fCBjaCA9PT0gMHgzQS8qIDogKi8pICYmIGlzX1dTX09SX0VPTChmb2xsb3dpbmcpKSB7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgzRi8qID8gKi8pIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBzdG9yZU1hcHBpbmdQYWlyKHN0YXRlLCBfcmVzdWx0LCBvdmVycmlkYWJsZUtleXMsIGtleVRhZywga2V5Tm9kZSwgbnVsbCwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICAgIGtleVRhZyA9IGtleU5vZGUgPSB2YWx1ZU5vZGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dDb21wYWN0ID0gdHJ1ZTtcblxuICAgICAgfSBlbHNlIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgICAgIC8vIGkuZS4gMHgzQS8qIDogKi8gPT09IGNoYXJhY3RlciBhZnRlciB0aGUgZXhwbGljaXQga2V5LlxuICAgICAgICBhdEV4cGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgICAgIGFsbG93Q29tcGFjdCA9IHRydWU7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdpbmNvbXBsZXRlIGV4cGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBrZXkgbm9kZSBpcyBtaXNzZWQ7IG9yIGZvbGxvd2VkIGJ5IGEgbm9uLXRhYnVsYXRlZCBlbXB0eSBsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvc2l0aW9uICs9IDE7XG4gICAgICBjaCA9IGZvbGxvd2luZztcblxuICAgIC8vXG4gICAgLy8gSW1wbGljaXQgbm90YXRpb24gY2FzZS4gRmxvdy1zdHlsZSBub2RlIGFzIHRoZSBrZXkgZmlyc3QsIHRoZW4gXCI6XCIsIGFuZCB0aGUgdmFsdWUuXG4gICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgX2tleUxpbmVTdGFydCA9IHN0YXRlLmxpbmVTdGFydDtcbiAgICAgIF9rZXlQb3MgPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYgKCFjb21wb3NlTm9kZShzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX09VVCwgZmFsc2UsIHRydWUpKSB7XG4gICAgICAgIC8vIE5laXRoZXIgaW1wbGljaXQgbm9yIGV4cGxpY2l0IG5vdGF0aW9uLlxuICAgICAgICAvLyBSZWFkaW5nIGlzIGRvbmUuIEdvIHRvIHRoZSBlcGlsb2d1ZS5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSkge1xuICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgIHdoaWxlIChpc19XSElURV9TUEFDRShjaCkpIHtcbiAgICAgICAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2ggPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBleHBlY3RlZCBhZnRlciB0aGUga2V5LXZhbHVlIHNlcGFyYXRvciB3aXRoaW4gYSBibG9jayBtYXBwaW5nJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICAgIHN0b3JlTWFwcGluZ1BhaXIoc3RhdGUsIF9yZXN1bHQsIG92ZXJyaWRhYmxlS2V5cywga2V5VGFnLCBrZXlOb2RlLCBudWxsLCBfa2V5TGluZSwgX2tleUxpbmVTdGFydCwgX2tleVBvcyk7XG4gICAgICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYXRFeHBsaWNpdEtleSA9IGZhbHNlO1xuICAgICAgICAgIGFsbG93Q29tcGFjdCA9IGZhbHNlO1xuICAgICAgICAgIGtleVRhZyA9IHN0YXRlLnRhZztcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGFuIGltcGxpY2l0IG1hcHBpbmcgcGFpcjsgYSBjb2xvbiBpcyBtaXNzZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgcmVzdWx0IG9mIGBjb21wb3NlTm9kZWAuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChkZXRlY3RlZCkge1xuICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2FuIG5vdCByZWFkIGEgYmxvY2sgbWFwcGluZyBlbnRyeTsgYSBtdWx0aWxpbmUga2V5IG1heSBub3QgYmUgYW4gaW1wbGljaXQga2V5Jyk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgICAgIHN0YXRlLmFuY2hvciA9IF9hbmNob3I7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSByZXN1bHQgb2YgYGNvbXBvc2VOb2RlYC5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIENvbW1vbiByZWFkaW5nIGNvZGUgZm9yIGJvdGggZXhwbGljaXQgYW5kIGltcGxpY2l0IG5vdGF0aW9ucy5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5saW5lID09PSBfbGluZSB8fCBzdGF0ZS5saW5lSW5kZW50ID4gbm9kZUluZGVudCkge1xuICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgX2tleUxpbmUgPSBzdGF0ZS5saW5lO1xuICAgICAgICBfa2V5TGluZVN0YXJ0ID0gc3RhdGUubGluZVN0YXJ0O1xuICAgICAgICBfa2V5UG9zID0gc3RhdGUucG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3NlTm9kZShzdGF0ZSwgbm9kZUluZGVudCwgQ09OVEVYVF9CTE9DS19PVVQsIHRydWUsIGFsbG93Q29tcGFjdCkpIHtcbiAgICAgICAgaWYgKGF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgICBrZXlOb2RlID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlTm9kZSA9IHN0YXRlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0RXhwbGljaXRLZXkpIHtcbiAgICAgICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIHZhbHVlTm9kZSwgX2tleUxpbmUsIF9rZXlMaW5lU3RhcnQsIF9rZXlQb3MpO1xuICAgICAgICBrZXlUYWcgPSBrZXlOb2RlID0gdmFsdWVOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoKHN0YXRlLmxpbmUgPT09IF9saW5lIHx8IHN0YXRlLmxpbmVJbmRlbnQgPiBub2RlSW5kZW50KSAmJiAoY2ggIT09IDApKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnYmFkIGluZGVudGF0aW9uIG9mIGEgbWFwcGluZyBlbnRyeScpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA8IG5vZGVJbmRlbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIEVwaWxvZ3VlLlxuICAvL1xuXG4gIC8vIFNwZWNpYWwgY2FzZTogbGFzdCBtYXBwaW5nJ3Mgbm9kZSBjb250YWlucyBvbmx5IHRoZSBrZXkgaW4gZXhwbGljaXQgbm90YXRpb24uXG4gIGlmIChhdEV4cGxpY2l0S2V5KSB7XG4gICAgc3RvcmVNYXBwaW5nUGFpcihzdGF0ZSwgX3Jlc3VsdCwgb3ZlcnJpZGFibGVLZXlzLCBrZXlUYWcsIGtleU5vZGUsIG51bGwsIF9rZXlMaW5lLCBfa2V5TGluZVN0YXJ0LCBfa2V5UG9zKTtcbiAgfVxuXG4gIC8vIEV4cG9zZSB0aGUgcmVzdWx0aW5nIG1hcHBpbmcuXG4gIGlmIChkZXRlY3RlZCkge1xuICAgIHN0YXRlLnRhZyA9IF90YWc7XG4gICAgc3RhdGUuYW5jaG9yID0gX2FuY2hvcjtcbiAgICBzdGF0ZS5raW5kID0gJ21hcHBpbmcnO1xuICAgIHN0YXRlLnJlc3VsdCA9IF9yZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZGV0ZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdQcm9wZXJ0eShzdGF0ZSkge1xuICB2YXIgX3Bvc2l0aW9uLFxuICAgICAgaXNWZXJiYXRpbSA9IGZhbHNlLFxuICAgICAgaXNOYW1lZCAgICA9IGZhbHNlLFxuICAgICAgdGFnSGFuZGxlLFxuICAgICAgdGFnTmFtZSxcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDIxLyogISAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS50YWcgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYSB0YWcgcHJvcGVydHknKTtcbiAgfVxuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcblxuICBpZiAoY2ggPT09IDB4M0MvKiA8ICovKSB7XG4gICAgaXNWZXJiYXRpbSA9IHRydWU7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuXG4gIH0gZWxzZSBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgaXNOYW1lZCA9IHRydWU7XG4gICAgdGFnSGFuZGxlID0gJyEhJztcbiAgICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG5cbiAgfSBlbHNlIHtcbiAgICB0YWdIYW5kbGUgPSAnISc7XG4gIH1cblxuICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICBpZiAoaXNWZXJiYXRpbSkge1xuICAgIGRvIHsgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pOyB9XG4gICAgd2hpbGUgKGNoICE9PSAwICYmIGNoICE9PSAweDNFLyogPiAqLyk7XG5cbiAgICBpZiAoc3RhdGUucG9zaXRpb24gPCBzdGF0ZS5sZW5ndGgpIHtcbiAgICAgIHRhZ05hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZXhwZWN0ZWQgZW5kIG9mIHRoZSBzdHJlYW0gd2l0aGluIGEgdmVyYmF0aW0gdGFnJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuXG4gICAgICBpZiAoY2ggPT09IDB4MjEvKiAhICovKSB7XG4gICAgICAgIGlmICghaXNOYW1lZCkge1xuICAgICAgICAgIHRhZ0hhbmRsZSA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiAtIDEsIHN0YXRlLnBvc2l0aW9uICsgMSk7XG5cbiAgICAgICAgICBpZiAoIVBBVFRFUk5fVEFHX0hBTkRMRS50ZXN0KHRhZ0hhbmRsZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICduYW1lZCB0YWcgaGFuZGxlIGNhbm5vdCBjb250YWluIHN1Y2ggY2hhcmFjdGVycycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzTmFtZWQgPSB0cnVlO1xuICAgICAgICAgIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndGFnIHN1ZmZpeCBjYW5ub3QgY29udGFpbiBleGNsYW1hdGlvbiBtYXJrcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICB0YWdOYW1lID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG5cbiAgICBpZiAoUEFUVEVSTl9GTE9XX0lORElDQVRPUlMudGVzdCh0YWdOYW1lKSkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBzdWZmaXggY2Fubm90IGNvbnRhaW4gZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0YWdOYW1lICYmICFQQVRURVJOX1RBR19VUkkudGVzdCh0YWdOYW1lKSkge1xuICAgIHRocm93RXJyb3Ioc3RhdGUsICd0YWcgbmFtZSBjYW5ub3QgY29udGFpbiBzdWNoIGNoYXJhY3RlcnM6ICcgKyB0YWdOYW1lKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdGFnTmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0YWdOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3RhZyBuYW1lIGlzIG1hbGZvcm1lZDogJyArIHRhZ05hbWUpO1xuICB9XG5cbiAgaWYgKGlzVmVyYmF0aW0pIHtcbiAgICBzdGF0ZS50YWcgPSB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAoX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUudGFnTWFwLCB0YWdIYW5kbGUpKSB7XG4gICAgc3RhdGUudGFnID0gc3RhdGUudGFnTWFwW3RhZ0hhbmRsZV0gKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnIScpIHtcbiAgICBzdGF0ZS50YWcgPSAnIScgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSBpZiAodGFnSGFuZGxlID09PSAnISEnKSB7XG4gICAgc3RhdGUudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOicgKyB0YWdOYW1lO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuZGVjbGFyZWQgdGFnIGhhbmRsZSBcIicgKyB0YWdIYW5kbGUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQW5jaG9yUHJvcGVydHkoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbixcbiAgICAgIGNoO1xuXG4gIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbik7XG5cbiAgaWYgKGNoICE9PSAweDI2LyogJiAqLykgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZHVwbGljYXRpb24gb2YgYW4gYW5jaG9yIHByb3BlcnR5Jyk7XG4gIH1cblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbmNob3Igbm9kZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGNoYXJhY3RlcicpO1xuICB9XG5cbiAgc3RhdGUuYW5jaG9yID0gc3RhdGUuaW5wdXQuc2xpY2UoX3Bvc2l0aW9uLCBzdGF0ZS5wb3NpdGlvbik7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWFkQWxpYXMoc3RhdGUpIHtcbiAgdmFyIF9wb3NpdGlvbiwgYWxpYXMsXG4gICAgICBjaDtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmIChjaCAhPT0gMHgyQS8qICogKi8pIHJldHVybiBmYWxzZTtcblxuICBjaCA9IHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoKytzdGF0ZS5wb3NpdGlvbik7XG4gIF9wb3NpdGlvbiA9IHN0YXRlLnBvc2l0aW9uO1xuXG4gIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSAmJiAhaXNfRkxPV19JTkRJQ0FUT1IoY2gpKSB7XG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBvc2l0aW9uID09PSBfcG9zaXRpb24pIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnbmFtZSBvZiBhbiBhbGlhcyBub2RlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyJyk7XG4gIH1cblxuICBhbGlhcyA9IHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pO1xuXG4gIGlmICghX2hhc093blByb3BlcnR5LmNhbGwoc3RhdGUuYW5jaG9yTWFwLCBhbGlhcykpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5pZGVudGlmaWVkIGFsaWFzIFwiJyArIGFsaWFzICsgJ1wiJyk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bHQgPSBzdGF0ZS5hbmNob3JNYXBbYWxpYXNdO1xuICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb21wb3NlTm9kZShzdGF0ZSwgcGFyZW50SW5kZW50LCBub2RlQ29udGV4dCwgYWxsb3dUb1NlZWssIGFsbG93Q29tcGFjdCkge1xuICB2YXIgYWxsb3dCbG9ja1N0eWxlcyxcbiAgICAgIGFsbG93QmxvY2tTY2FsYXJzLFxuICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zLFxuICAgICAgaW5kZW50U3RhdHVzID0gMSwgLy8gMTogdGhpcz5wYXJlbnQsIDA6IHRoaXM9cGFyZW50LCAtMTogdGhpczxwYXJlbnRcbiAgICAgIGF0TmV3TGluZSAgPSBmYWxzZSxcbiAgICAgIGhhc0NvbnRlbnQgPSBmYWxzZSxcbiAgICAgIHR5cGVJbmRleCxcbiAgICAgIHR5cGVRdWFudGl0eSxcbiAgICAgIHR5cGVMaXN0LFxuICAgICAgdHlwZSxcbiAgICAgIGZsb3dJbmRlbnQsXG4gICAgICBibG9ja0luZGVudDtcblxuICBpZiAoc3RhdGUubGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICBzdGF0ZS5saXN0ZW5lcignb3BlbicsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnRhZyAgICA9IG51bGw7XG4gIHN0YXRlLmFuY2hvciA9IG51bGw7XG4gIHN0YXRlLmtpbmQgICA9IG51bGw7XG4gIHN0YXRlLnJlc3VsdCA9IG51bGw7XG5cbiAgYWxsb3dCbG9ja1N0eWxlcyA9IGFsbG93QmxvY2tTY2FsYXJzID0gYWxsb3dCbG9ja0NvbGxlY3Rpb25zID1cbiAgICBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQgfHxcbiAgICBDT05URVhUX0JMT0NLX0lOICA9PT0gbm9kZUNvbnRleHQ7XG5cbiAgaWYgKGFsbG93VG9TZWVrKSB7XG4gICAgaWYgKHNraXBTZXBhcmF0aW9uU3BhY2Uoc3RhdGUsIHRydWUsIC0xKSkge1xuICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPiBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgIGluZGVudFN0YXR1cyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxpbmVJbmRlbnQgPCBwYXJlbnRJbmRlbnQpIHtcbiAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSkge1xuICAgIHdoaWxlIChyZWFkVGFnUHJvcGVydHkoc3RhdGUpIHx8IHJlYWRBbmNob3JQcm9wZXJ0eShzdGF0ZSkpIHtcbiAgICAgIGlmIChza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSkpIHtcbiAgICAgICAgYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dCbG9ja0NvbGxlY3Rpb25zID0gYWxsb3dCbG9ja1N0eWxlcztcblxuICAgICAgICBpZiAoc3RhdGUubGluZUluZGVudCA+IHBhcmVudEluZGVudCkge1xuICAgICAgICAgIGluZGVudFN0YXR1cyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGluZUluZGVudCA9PT0gcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS5saW5lSW5kZW50IDwgcGFyZW50SW5kZW50KSB7XG4gICAgICAgICAgaW5kZW50U3RhdHVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbG93QmxvY2tDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMpIHtcbiAgICBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgPSBhdE5ld0xpbmUgfHwgYWxsb3dDb21wYWN0O1xuICB9XG5cbiAgaWYgKGluZGVudFN0YXR1cyA9PT0gMSB8fCBDT05URVhUX0JMT0NLX09VVCA9PT0gbm9kZUNvbnRleHQpIHtcbiAgICBpZiAoQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCB8fCBDT05URVhUX0ZMT1dfT1VUID09PSBub2RlQ29udGV4dCkge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxvd0luZGVudCA9IHBhcmVudEluZGVudCArIDE7XG4gICAgfVxuXG4gICAgYmxvY2tJbmRlbnQgPSBzdGF0ZS5wb3NpdGlvbiAtIHN0YXRlLmxpbmVTdGFydDtcblxuICAgIGlmIChpbmRlbnRTdGF0dXMgPT09IDEpIHtcbiAgICAgIGlmIChhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiZcbiAgICAgICAgICAocmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KSB8fFxuICAgICAgICAgICByZWFkQmxvY2tNYXBwaW5nKHN0YXRlLCBibG9ja0luZGVudCwgZmxvd0luZGVudCkpIHx8XG4gICAgICAgICAgcmVhZEZsb3dDb2xsZWN0aW9uKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgoYWxsb3dCbG9ja1NjYWxhcnMgJiYgcmVhZEJsb2NrU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkgfHxcbiAgICAgICAgICAgIHJlYWRTaW5nbGVRdW90ZWRTY2FsYXIoc3RhdGUsIGZsb3dJbmRlbnQpIHx8XG4gICAgICAgICAgICByZWFkRG91YmxlUXVvdGVkU2NhbGFyKHN0YXRlLCBmbG93SW5kZW50KSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVhZEFsaWFzKHN0YXRlKSkge1xuICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gbnVsbCB8fCBzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioc3RhdGUsICdhbGlhcyBub2RlIHNob3VsZCBub3QgaGF2ZSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKHJlYWRQbGFpblNjYWxhcihzdGF0ZSwgZmxvd0luZGVudCwgQ09OVEVYVF9GTE9XX0lOID09PSBub2RlQ29udGV4dCkpIHtcbiAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzdGF0ZS50YWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhZyA9ICc/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuYW5jaG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGVudFN0YXR1cyA9PT0gMCkge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBibG9jayBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgdG8gaGF2ZSBzYW1lIGluZGVudGF0aW9uIGxldmVsIGFzIHRoZSBwYXJlbnQuXG4gICAgICAvLyBodHRwOi8vd3d3LnlhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNpZDI3OTk3ODRcbiAgICAgIGhhc0NvbnRlbnQgPSBhbGxvd0Jsb2NrQ29sbGVjdGlvbnMgJiYgcmVhZEJsb2NrU2VxdWVuY2Uoc3RhdGUsIGJsb2NrSW5kZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUudGFnID09PSBudWxsKSB7XG4gICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RhdGUudGFnID09PSAnPycpIHtcbiAgICAvLyBJbXBsaWNpdCByZXNvbHZpbmcgaXMgbm90IGFsbG93ZWQgZm9yIG5vbi1zY2FsYXIgdHlwZXMsIGFuZCAnPydcbiAgICAvLyBub24tc3BlY2lmaWMgdGFnIGlzIG9ubHkgYXV0b21hdGljYWxseSBhc3NpZ25lZCB0byBwbGFpbiBzY2FsYXJzLlxuICAgIC8vXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGtpbmQgY29uZm9ybWl0eSBpbiBjYXNlIHVzZXIgZXhwbGljaXRseSBhc3NpZ25zICc/J1xuICAgIC8vIHRhZywgZm9yIGV4YW1wbGUgbGlrZSB0aGlzOiBcIiE8Pz4gWzBdXCJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5yZXN1bHQgIT09IG51bGwgJiYgc3RhdGUua2luZCAhPT0gJ3NjYWxhcicpIHtcbiAgICAgIHRocm93RXJyb3Ioc3RhdGUsICd1bmFjY2VwdGFibGUgbm9kZSBraW5kIGZvciAhPD8+IHRhZzsgaXQgc2hvdWxkIGJlIFwic2NhbGFyXCIsIG5vdCBcIicgKyBzdGF0ZS5raW5kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzLmxlbmd0aDsgdHlwZUluZGV4IDwgdHlwZVF1YW50aXR5OyB0eXBlSW5kZXggKz0gMSkge1xuICAgICAgdHlwZSA9IHN0YXRlLmltcGxpY2l0VHlwZXNbdHlwZUluZGV4XTtcblxuICAgICAgaWYgKHR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQpKSB7IC8vIGBzdGF0ZS5yZXN1bHRgIHVwZGF0ZWQgaW4gcmVzb2x2ZXIgaWYgbWF0Y2hlZFxuICAgICAgICBzdGF0ZS5yZXN1bHQgPSB0eXBlLmNvbnN0cnVjdChzdGF0ZS5yZXN1bHQpO1xuICAgICAgICBzdGF0ZS50YWcgPSB0eXBlLnRhZztcbiAgICAgICAgaWYgKHN0YXRlLmFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YXRlLmFuY2hvck1hcFtzdGF0ZS5hbmNob3JdID0gc3RhdGUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdGF0ZS50YWcgIT09ICchJykge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ10sIHN0YXRlLnRhZykpIHtcbiAgICAgIHR5cGUgPSBzdGF0ZS50eXBlTWFwW3N0YXRlLmtpbmQgfHwgJ2ZhbGxiYWNrJ11bc3RhdGUudGFnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9va2luZyBmb3IgbXVsdGkgdHlwZVxuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB0eXBlTGlzdCA9IHN0YXRlLnR5cGVNYXAubXVsdGlbc3RhdGUua2luZCB8fCAnZmFsbGJhY2snXTtcblxuICAgICAgZm9yICh0eXBlSW5kZXggPSAwLCB0eXBlUXVhbnRpdHkgPSB0eXBlTGlzdC5sZW5ndGg7IHR5cGVJbmRleCA8IHR5cGVRdWFudGl0eTsgdHlwZUluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZy5zbGljZSgwLCB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZy5sZW5ndGgpID09PSB0eXBlTGlzdFt0eXBlSW5kZXhdLnRhZykge1xuICAgICAgICAgIHR5cGUgPSB0eXBlTGlzdFt0eXBlSW5kZXhdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAndW5rbm93biB0YWcgITwnICsgc3RhdGUudGFnICsgJz4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUucmVzdWx0ICE9PSBudWxsICYmIHR5cGUua2luZCAhPT0gc3RhdGUua2luZCkge1xuICAgICAgdGhyb3dFcnJvcihzdGF0ZSwgJ3VuYWNjZXB0YWJsZSBub2RlIGtpbmQgZm9yICE8JyArIHN0YXRlLnRhZyArICc+IHRhZzsgaXQgc2hvdWxkIGJlIFwiJyArIHR5cGUua2luZCArICdcIiwgbm90IFwiJyArIHN0YXRlLmtpbmQgKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXR5cGUucmVzb2x2ZShzdGF0ZS5yZXN1bHQsIHN0YXRlLnRhZykpIHsgLy8gYHN0YXRlLnJlc3VsdGAgdXBkYXRlZCBpbiByZXNvbHZlciBpZiBtYXRjaGVkXG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnY2Fubm90IHJlc29sdmUgYSBub2RlIHdpdGggITwnICsgc3RhdGUudGFnICsgJz4gZXhwbGljaXQgdGFnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnJlc3VsdCA9IHR5cGUuY29uc3RydWN0KHN0YXRlLnJlc3VsdCwgc3RhdGUudGFnKTtcbiAgICAgIGlmIChzdGF0ZS5hbmNob3IgIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGUuYW5jaG9yTWFwW3N0YXRlLmFuY2hvcl0gPSBzdGF0ZS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgc3RhdGUubGlzdGVuZXIoJ2Nsb3NlJywgc3RhdGUpO1xuICB9XG4gIHJldHVybiBzdGF0ZS50YWcgIT09IG51bGwgfHwgIHN0YXRlLmFuY2hvciAhPT0gbnVsbCB8fCBoYXNDb250ZW50O1xufVxuXG5mdW5jdGlvbiByZWFkRG9jdW1lbnQoc3RhdGUpIHtcbiAgdmFyIGRvY3VtZW50U3RhcnQgPSBzdGF0ZS5wb3NpdGlvbixcbiAgICAgIF9wb3NpdGlvbixcbiAgICAgIGRpcmVjdGl2ZU5hbWUsXG4gICAgICBkaXJlY3RpdmVBcmdzLFxuICAgICAgaGFzRGlyZWN0aXZlcyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgc3RhdGUudmVyc2lvbiA9IG51bGw7XG4gIHN0YXRlLmNoZWNrTGluZUJyZWFrcyA9IHN0YXRlLmxlZ2FjeTtcbiAgc3RhdGUudGFnTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RhdGUuYW5jaG9yTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB3aGlsZSAoKGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikpICE9PSAwKSB7XG4gICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKTtcblxuICAgIGlmIChzdGF0ZS5saW5lSW5kZW50ID4gMCB8fCBjaCAhPT0gMHgyNS8qICUgKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgIHdoaWxlIChjaCAhPT0gMCAmJiAhaXNfV1NfT1JfRU9MKGNoKSkge1xuICAgICAgY2ggPSBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KCsrc3RhdGUucG9zaXRpb24pO1xuICAgIH1cblxuICAgIGRpcmVjdGl2ZU5hbWUgPSBzdGF0ZS5pbnB1dC5zbGljZShfcG9zaXRpb24sIHN0YXRlLnBvc2l0aW9uKTtcbiAgICBkaXJlY3RpdmVBcmdzID0gW107XG5cbiAgICBpZiAoZGlyZWN0aXZlTmFtZS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZGlyZWN0aXZlIG5hbWUgbXVzdCBub3QgYmUgbGVzcyB0aGFuIG9uZSBjaGFyYWN0ZXIgaW4gbGVuZ3RoJyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGNoICE9PSAwKSB7XG4gICAgICB3aGlsZSAoaXNfV0hJVEVfU1BBQ0UoY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAweDIzLyogIyAqLykge1xuICAgICAgICBkbyB7IGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTsgfVxuICAgICAgICB3aGlsZSAoY2ggIT09IDAgJiYgIWlzX0VPTChjaCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzX0VPTChjaCkpIGJyZWFrO1xuXG4gICAgICBfcG9zaXRpb24gPSBzdGF0ZS5wb3NpdGlvbjtcblxuICAgICAgd2hpbGUgKGNoICE9PSAwICYmICFpc19XU19PUl9FT0woY2gpKSB7XG4gICAgICAgIGNoID0gc3RhdGUuaW5wdXQuY2hhckNvZGVBdCgrK3N0YXRlLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGlyZWN0aXZlQXJncy5wdXNoKHN0YXRlLmlucHV0LnNsaWNlKF9wb3NpdGlvbiwgc3RhdGUucG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoY2ggIT09IDApIHJlYWRMaW5lQnJlYWsoc3RhdGUpO1xuXG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpcmVjdGl2ZUhhbmRsZXJzLCBkaXJlY3RpdmVOYW1lKSkge1xuICAgICAgZGlyZWN0aXZlSGFuZGxlcnNbZGlyZWN0aXZlTmFtZV0oc3RhdGUsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd1dhcm5pbmcoc3RhdGUsICd1bmtub3duIGRvY3VtZW50IGRpcmVjdGl2ZSBcIicgKyBkaXJlY3RpdmVOYW1lICsgJ1wiJyk7XG4gICAgfVxuICB9XG5cbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5saW5lSW5kZW50ID09PSAwICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uKSAgICAgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMSkgPT09IDB4MkQvKiAtICovICYmXG4gICAgICBzdGF0ZS5pbnB1dC5jaGFyQ29kZUF0KHN0YXRlLnBvc2l0aW9uICsgMikgPT09IDB4MkQvKiAtICovKSB7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMztcbiAgICBza2lwU2VwYXJhdGlvblNwYWNlKHN0YXRlLCB0cnVlLCAtMSk7XG5cbiAgfSBlbHNlIGlmIChoYXNEaXJlY3RpdmVzKSB7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ2RpcmVjdGl2ZXMgZW5kIG1hcmsgaXMgZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGNvbXBvc2VOb2RlKHN0YXRlLCBzdGF0ZS5saW5lSW5kZW50IC0gMSwgQ09OVEVYVF9CTE9DS19PVVQsIGZhbHNlLCB0cnVlKTtcbiAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuXG4gIGlmIChzdGF0ZS5jaGVja0xpbmVCcmVha3MgJiZcbiAgICAgIFBBVFRFUk5fTk9OX0FTQ0lJX0xJTkVfQlJFQUtTLnRlc3Qoc3RhdGUuaW5wdXQuc2xpY2UoZG9jdW1lbnRTdGFydCwgc3RhdGUucG9zaXRpb24pKSkge1xuICAgIHRocm93V2FybmluZyhzdGF0ZSwgJ25vbi1BU0NJSSBsaW5lIGJyZWFrcyBhcmUgaW50ZXJwcmV0ZWQgYXMgY29udGVudCcpO1xuICB9XG5cbiAgc3RhdGUuZG9jdW1lbnRzLnB1c2goc3RhdGUucmVzdWx0KTtcblxuICBpZiAoc3RhdGUucG9zaXRpb24gPT09IHN0YXRlLmxpbmVTdGFydCAmJiB0ZXN0RG9jdW1lbnRTZXBhcmF0b3Ioc3RhdGUpKSB7XG5cbiAgICBpZiAoc3RhdGUuaW5wdXQuY2hhckNvZGVBdChzdGF0ZS5wb3NpdGlvbikgPT09IDB4MkUvKiAuICovKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbiArPSAzO1xuICAgICAgc2tpcFNlcGFyYXRpb25TcGFjZShzdGF0ZSwgdHJ1ZSwgLTEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc3RhdGUucG9zaXRpb24gPCAoc3RhdGUubGVuZ3RoIC0gMSkpIHtcbiAgICB0aHJvd0Vycm9yKHN0YXRlLCAnZW5kIG9mIHRoZSBzdHJlYW0gb3IgYSBkb2N1bWVudCBzZXBhcmF0b3IgaXMgZXhwZWN0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKSB7XG4gIGlucHV0ID0gU3RyaW5nKGlucHV0KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuXG4gICAgLy8gQWRkIHRhaWxpbmcgYFxcbmAgaWYgbm90IGV4aXN0c1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGlucHV0Lmxlbmd0aCAtIDEpICE9PSAweDBBLyogTEYgKi8gJiZcbiAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpbnB1dC5sZW5ndGggLSAxKSAhPT0gMHgwRC8qIENSICovKSB7XG4gICAgICBpbnB1dCArPSAnXFxuJztcbiAgICB9XG5cbiAgICAvLyBTdHJpcCBCT01cbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgdmFyIG51bGxwb3MgPSBpbnB1dC5pbmRleE9mKCdcXDAnKTtcblxuICBpZiAobnVsbHBvcyAhPT0gLTEpIHtcbiAgICBzdGF0ZS5wb3NpdGlvbiA9IG51bGxwb3M7XG4gICAgdGhyb3dFcnJvcihzdGF0ZSwgJ251bGwgYnl0ZSBpcyBub3QgYWxsb3dlZCBpbiBpbnB1dCcpO1xuICB9XG5cbiAgLy8gVXNlIDAgYXMgc3RyaW5nIHRlcm1pbmF0b3IuIFRoYXQgc2lnbmlmaWNhbnRseSBzaW1wbGlmaWVzIGJvdW5kcyBjaGVjay5cbiAgc3RhdGUuaW5wdXQgKz0gJ1xcMCc7XG5cbiAgd2hpbGUgKHN0YXRlLmlucHV0LmNoYXJDb2RlQXQoc3RhdGUucG9zaXRpb24pID09PSAweDIwLyogU3BhY2UgKi8pIHtcbiAgICBzdGF0ZS5saW5lSW5kZW50ICs9IDE7XG4gICAgc3RhdGUucG9zaXRpb24gKz0gMTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5wb3NpdGlvbiA8IChzdGF0ZS5sZW5ndGggLSAxKSkge1xuICAgIHJlYWREb2N1bWVudChzdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGUuZG9jdW1lbnRzO1xufVxuXG5cbmZ1bmN0aW9uIGxvYWRBbGwoaW5wdXQsIGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGlmIChpdGVyYXRvciAhPT0gbnVsbCAmJiB0eXBlb2YgaXRlcmF0b3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBpdGVyYXRvcjtcbiAgICBpdGVyYXRvciA9IG51bGw7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRzID0gbG9hZERvY3VtZW50cyhpbnB1dCwgb3B0aW9ucyk7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBkb2N1bWVudHM7XG4gIH1cblxuICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGRvY3VtZW50cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgaXRlcmF0b3IoZG9jdW1lbnRzW2luZGV4XSk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBsb2FkKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBkb2N1bWVudHMgPSBsb2FkRG9jdW1lbnRzKGlucHV0LCBvcHRpb25zKTtcblxuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRzWzBdO1xuICB9XG4gIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdleHBlY3RlZCBhIHNpbmdsZSBkb2N1bWVudCBpbiB0aGUgc3RyZWFtLCBidXQgZm91bmQgbW9yZScpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLmxvYWRBbGwgPSBsb2FkQWxsO1xubW9kdWxlLmV4cG9ydHMubG9hZCAgICA9IGxvYWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUqL1xuXG52YXIgY29tbW9uICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG52YXIgWUFNTEV4Y2VwdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vZXhjZXB0aW9uJyk7XG52YXIgREVGQVVMVF9TQ0hFTUEgICAgICA9IHJlcXVpcmUoJy4vc2NoZW1hL2RlZmF1bHQnKTtcblxudmFyIF90b1N0cmluZyAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIENIQVJfQk9NICAgICAgICAgICAgICAgICAgPSAweEZFRkY7XG52YXIgQ0hBUl9UQUIgICAgICAgICAgICAgICAgICA9IDB4MDk7IC8qIFRhYiAqL1xudmFyIENIQVJfTElORV9GRUVEICAgICAgICAgICAgPSAweDBBOyAvKiBMRiAqL1xudmFyIENIQVJfQ0FSUklBR0VfUkVUVVJOICAgICAgPSAweDBEOyAvKiBDUiAqL1xudmFyIENIQVJfU1BBQ0UgICAgICAgICAgICAgICAgPSAweDIwOyAvKiBTcGFjZSAqL1xudmFyIENIQVJfRVhDTEFNQVRJT04gICAgICAgICAgPSAweDIxOyAvKiAhICovXG52YXIgQ0hBUl9ET1VCTEVfUVVPVEUgICAgICAgICA9IDB4MjI7IC8qIFwiICovXG52YXIgQ0hBUl9TSEFSUCAgICAgICAgICAgICAgICA9IDB4MjM7IC8qICMgKi9cbnZhciBDSEFSX1BFUkNFTlQgICAgICAgICAgICAgID0gMHgyNTsgLyogJSAqL1xudmFyIENIQVJfQU1QRVJTQU5EICAgICAgICAgICAgPSAweDI2OyAvKiAmICovXG52YXIgQ0hBUl9TSU5HTEVfUVVPVEUgICAgICAgICA9IDB4Mjc7IC8qICcgKi9cbnZhciBDSEFSX0FTVEVSSVNLICAgICAgICAgICAgID0gMHgyQTsgLyogKiAqL1xudmFyIENIQVJfQ09NTUEgICAgICAgICAgICAgICAgPSAweDJDOyAvKiAsICovXG52YXIgQ0hBUl9NSU5VUyAgICAgICAgICAgICAgICA9IDB4MkQ7IC8qIC0gKi9cbnZhciBDSEFSX0NPTE9OICAgICAgICAgICAgICAgID0gMHgzQTsgLyogOiAqL1xudmFyIENIQVJfRVFVQUxTICAgICAgICAgICAgICAgPSAweDNEOyAvKiA9ICovXG52YXIgQ0hBUl9HUkVBVEVSX1RIQU4gICAgICAgICA9IDB4M0U7IC8qID4gKi9cbnZhciBDSEFSX1FVRVNUSU9OICAgICAgICAgICAgID0gMHgzRjsgLyogPyAqL1xudmFyIENIQVJfQ09NTUVSQ0lBTF9BVCAgICAgICAgPSAweDQwOyAvKiBAICovXG52YXIgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUICA9IDB4NUI7IC8qIFsgKi9cbnZhciBDSEFSX1JJR0hUX1NRVUFSRV9CUkFDS0VUID0gMHg1RDsgLyogXSAqL1xudmFyIENIQVJfR1JBVkVfQUNDRU5UICAgICAgICAgPSAweDYwOyAvKiBgICovXG52YXIgQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVQgICA9IDB4N0I7IC8qIHsgKi9cbnZhciBDSEFSX1ZFUlRJQ0FMX0xJTkUgICAgICAgID0gMHg3QzsgLyogfCAqL1xudmFyIENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVCAgPSAweDdEOyAvKiB9ICovXG5cbnZhciBFU0NBUEVfU0VRVUVOQ0VTID0ge307XG5cbkVTQ0FQRV9TRVFVRU5DRVNbMHgwMF0gICA9ICdcXFxcMCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MDddICAgPSAnXFxcXGEnO1xuRVNDQVBFX1NFUVVFTkNFU1sweDA4XSAgID0gJ1xcXFxiJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwOV0gICA9ICdcXFxcdCc7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MEFdICAgPSAnXFxcXG4nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDBCXSAgID0gJ1xcXFx2JztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgwQ10gICA9ICdcXFxcZic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4MERdICAgPSAnXFxcXHInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDFCXSAgID0gJ1xcXFxlJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMl0gICA9ICdcXFxcXCInO1xuRVNDQVBFX1NFUVVFTkNFU1sweDVDXSAgID0gJ1xcXFxcXFxcJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHg4NV0gICA9ICdcXFxcTic7XG5FU0NBUEVfU0VRVUVOQ0VTWzB4QTBdICAgPSAnXFxcXF8nO1xuRVNDQVBFX1NFUVVFTkNFU1sweDIwMjhdID0gJ1xcXFxMJztcbkVTQ0FQRV9TRVFVRU5DRVNbMHgyMDI5XSA9ICdcXFxcUCc7XG5cbnZhciBERVBSRUNBVEVEX0JPT0xFQU5TX1NZTlRBWCA9IFtcbiAgJ3knLCAnWScsICd5ZXMnLCAnWWVzJywgJ1lFUycsICdvbicsICdPbicsICdPTicsXG4gICduJywgJ04nLCAnbm8nLCAnTm8nLCAnTk8nLCAnb2ZmJywgJ09mZicsICdPRkYnXG5dO1xuXG52YXIgREVQUkVDQVRFRF9CQVNFNjBfU1lOVEFYID0gL15bLStdP1swLTlfXSsoPzo6WzAtOV9dKykrKD86XFwuWzAtOV9dKik/JC87XG5cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZU1hcChzY2hlbWEsIG1hcCkge1xuICB2YXIgcmVzdWx0LCBrZXlzLCBpbmRleCwgbGVuZ3RoLCB0YWcsIHN0eWxlLCB0eXBlO1xuXG4gIGlmIChtYXAgPT09IG51bGwpIHJldHVybiB7fTtcblxuICByZXN1bHQgPSB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHRhZyA9IGtleXNbaW5kZXhdO1xuICAgIHN0eWxlID0gU3RyaW5nKG1hcFt0YWddKTtcblxuICAgIGlmICh0YWcuc2xpY2UoMCwgMikgPT09ICchIScpIHtcbiAgICAgIHRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjonICsgdGFnLnNsaWNlKDIpO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLmNvbXBpbGVkVHlwZU1hcFsnZmFsbGJhY2snXVt0YWddO1xuXG4gICAgaWYgKHR5cGUgJiYgX2hhc093blByb3BlcnR5LmNhbGwodHlwZS5zdHlsZUFsaWFzZXMsIHN0eWxlKSkge1xuICAgICAgc3R5bGUgPSB0eXBlLnN0eWxlQWxpYXNlc1tzdHlsZV07XG4gICAgfVxuXG4gICAgcmVzdWx0W3RhZ10gPSBzdHlsZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUhleChjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0cmluZywgaGFuZGxlLCBsZW5ndGg7XG5cbiAgc3RyaW5nID0gY2hhcmFjdGVyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXG4gIGlmIChjaGFyYWN0ZXIgPD0gMHhGRikge1xuICAgIGhhbmRsZSA9ICd4JztcbiAgICBsZW5ndGggPSAyO1xuICB9IGVsc2UgaWYgKGNoYXJhY3RlciA8PSAweEZGRkYpIHtcbiAgICBoYW5kbGUgPSAndSc7XG4gICAgbGVuZ3RoID0gNDtcbiAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPD0gMHhGRkZGRkZGRikge1xuICAgIGhhbmRsZSA9ICdVJztcbiAgICBsZW5ndGggPSA4O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCdjb2RlIHBvaW50IHdpdGhpbiBhIHN0cmluZyBtYXkgbm90IGJlIGdyZWF0ZXIgdGhhbiAweEZGRkZGRkZGJyk7XG4gIH1cblxuICByZXR1cm4gJ1xcXFwnICsgaGFuZGxlICsgY29tbW9uLnJlcGVhdCgnMCcsIGxlbmd0aCAtIHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufVxuXG5cbnZhciBRVU9USU5HX1RZUEVfU0lOR0xFID0gMSxcbiAgICBRVU9USU5HX1RZUEVfRE9VQkxFID0gMjtcblxuZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICB0aGlzLnNjaGVtYSAgICAgICAgPSBvcHRpb25zWydzY2hlbWEnXSB8fCBERUZBVUxUX1NDSEVNQTtcbiAgdGhpcy5pbmRlbnQgICAgICAgID0gTWF0aC5tYXgoMSwgKG9wdGlvbnNbJ2luZGVudCddIHx8IDIpKTtcbiAgdGhpcy5ub0FycmF5SW5kZW50ID0gb3B0aW9uc1snbm9BcnJheUluZGVudCddIHx8IGZhbHNlO1xuICB0aGlzLnNraXBJbnZhbGlkICAgPSBvcHRpb25zWydza2lwSW52YWxpZCddIHx8IGZhbHNlO1xuICB0aGlzLmZsb3dMZXZlbCAgICAgPSAoY29tbW9uLmlzTm90aGluZyhvcHRpb25zWydmbG93TGV2ZWwnXSkgPyAtMSA6IG9wdGlvbnNbJ2Zsb3dMZXZlbCddKTtcbiAgdGhpcy5zdHlsZU1hcCAgICAgID0gY29tcGlsZVN0eWxlTWFwKHRoaXMuc2NoZW1hLCBvcHRpb25zWydzdHlsZXMnXSB8fCBudWxsKTtcbiAgdGhpcy5zb3J0S2V5cyAgICAgID0gb3B0aW9uc1snc29ydEtleXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5saW5lV2lkdGggICAgID0gb3B0aW9uc1snbGluZVdpZHRoJ10gfHwgODA7XG4gIHRoaXMubm9SZWZzICAgICAgICA9IG9wdGlvbnNbJ25vUmVmcyddIHx8IGZhbHNlO1xuICB0aGlzLm5vQ29tcGF0TW9kZSAgPSBvcHRpb25zWydub0NvbXBhdE1vZGUnXSB8fCBmYWxzZTtcbiAgdGhpcy5jb25kZW5zZUZsb3cgID0gb3B0aW9uc1snY29uZGVuc2VGbG93J10gfHwgZmFsc2U7XG4gIHRoaXMucXVvdGluZ1R5cGUgICA9IG9wdGlvbnNbJ3F1b3RpbmdUeXBlJ10gPT09ICdcIicgPyBRVU9USU5HX1RZUEVfRE9VQkxFIDogUVVPVElOR19UWVBFX1NJTkdMRTtcbiAgdGhpcy5mb3JjZVF1b3RlcyAgID0gb3B0aW9uc1snZm9yY2VRdW90ZXMnXSB8fCBmYWxzZTtcbiAgdGhpcy5yZXBsYWNlciAgICAgID0gdHlwZW9mIG9wdGlvbnNbJ3JlcGxhY2VyJ10gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zWydyZXBsYWNlciddIDogbnVsbDtcblxuICB0aGlzLmltcGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEltcGxpY2l0O1xuICB0aGlzLmV4cGxpY2l0VHlwZXMgPSB0aGlzLnNjaGVtYS5jb21waWxlZEV4cGxpY2l0O1xuXG4gIHRoaXMudGFnID0gbnVsbDtcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICB0aGlzLmR1cGxpY2F0ZXMgPSBbXTtcbiAgdGhpcy51c2VkRHVwbGljYXRlcyA9IG51bGw7XG59XG5cbi8vIEluZGVudHMgZXZlcnkgbGluZSBpbiBhIHN0cmluZy4gRW1wdHkgbGluZXMgKFxcbiBvbmx5KSBhcmUgbm90IGluZGVudGVkLlxuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0cmluZywgc3BhY2VzKSB7XG4gIHZhciBpbmQgPSBjb21tb24ucmVwZWF0KCcgJywgc3BhY2VzKSxcbiAgICAgIHBvc2l0aW9uID0gMCxcbiAgICAgIG5leHQgPSAtMSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbGluZSxcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgbmV4dCA9IHN0cmluZy5pbmRleE9mKCdcXG4nLCBwb3NpdGlvbik7XG4gICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgIHBvc2l0aW9uID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lID0gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBuZXh0ICsgMSk7XG4gICAgICBwb3NpdGlvbiA9IG5leHQgKyAxO1xuICAgIH1cblxuICAgIGlmIChsaW5lLmxlbmd0aCAmJiBsaW5lICE9PSAnXFxuJykgcmVzdWx0ICs9IGluZDtcblxuICAgIHJlc3VsdCArPSBsaW5lO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVOZXh0TGluZShzdGF0ZSwgbGV2ZWwpIHtcbiAgcmV0dXJuICdcXG4nICsgY29tbW9uLnJlcGVhdCgnICcsIHN0YXRlLmluZGVudCAqIGxldmVsKTtcbn1cblxuZnVuY3Rpb24gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHIpIHtcbiAgdmFyIGluZGV4LCBsZW5ndGgsIHR5cGU7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHN0YXRlLmltcGxpY2l0VHlwZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSBzdGF0ZS5pbXBsaWNpdFR5cGVzW2luZGV4XTtcblxuICAgIGlmICh0eXBlLnJlc29sdmUoc3RyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBbMzNdIHMtd2hpdGUgOjo9IHMtc3BhY2UgfCBzLXRhYlxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGMgPT09IENIQVJfU1BBQ0UgfHwgYyA9PT0gQ0hBUl9UQUI7XG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGNhbiBiZSBwcmludGVkIHdpdGhvdXQgZXNjYXBpbmcuXG4vLyBGcm9tIFlBTUwgMS4yOiBcImFueSBhbGxvd2VkIGNoYXJhY3RlcnMga25vd24gdG8gYmUgbm9uLXByaW50YWJsZVxuLy8gc2hvdWxkIGFsc28gYmUgZXNjYXBlZC4gW0hvd2V2ZXIsXSBUaGlzIGlzbuKAmXQgbWFuZGF0b3J5XCJcbi8vIERlcml2ZWQgZnJvbSBuYi1jaGFyIC0gXFx0IC0gI3g4NSAtICN4QTAgLSAjeDIwMjggLSAjeDIwMjkuXG5mdW5jdGlvbiBpc1ByaW50YWJsZShjKSB7XG4gIHJldHVybiAgKDB4MDAwMjAgPD0gYyAmJiBjIDw9IDB4MDAwMDdFKVxuICAgICAgfHwgKCgweDAwMEExIDw9IGMgJiYgYyA8PSAweDAwRDdGRikgJiYgYyAhPT0gMHgyMDI4ICYmIGMgIT09IDB4MjAyOSlcbiAgICAgIHx8ICgoMHgwRTAwMCA8PSBjICYmIGMgPD0gMHgwMEZGRkQpICYmIGMgIT09IENIQVJfQk9NKVxuICAgICAgfHwgICgweDEwMDAwIDw9IGMgJiYgYyA8PSAweDEwRkZGRik7XG59XG5cbi8vIFszNF0gbnMtY2hhciA6Oj0gbmItY2hhciAtIHMtd2hpdGVcbi8vIFsyN10gbmItY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWNoYXIgLSBjLWJ5dGUtb3JkZXItbWFya1xuLy8gWzI2XSBiLWNoYXIgIDo6PSBiLWxpbmUtZmVlZCB8IGItY2FycmlhZ2UtcmV0dXJuXG4vLyBJbmNsdWRpbmcgcy13aGl0ZSAoZm9yIHNvbWUgcmVhc29uLCBleGFtcGxlcyBkb2Vzbid0IG1hdGNoIHNwZWNzIGluIHRoaXMgYXNwZWN0KVxuLy8gbnMtY2hhciA6Oj0gYy1wcmludGFibGUgLSBiLWxpbmUtZmVlZCAtIGItY2FycmlhZ2UtcmV0dXJuIC0gYy1ieXRlLW9yZGVyLW1hcmtcbmZ1bmN0aW9uIGlzTnNDaGFyT3JXaGl0ZXNwYWNlKGMpIHtcbiAgcmV0dXJuIGlzUHJpbnRhYmxlKGMpXG4gICAgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAvLyAtIGItY2hhclxuICAgICYmIGMgIT09IENIQVJfQ0FSUklBR0VfUkVUVVJOXG4gICAgJiYgYyAhPT0gQ0hBUl9MSU5FX0ZFRUQ7XG59XG5cbi8vIFsxMjddICBucy1wbGFpbi1zYWZlKGMpIDo6PSBjID0gZmxvdy1vdXQgIOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWluICAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gYmxvY2sta2V5IOKHkiBucy1wbGFpbi1zYWZlLW91dFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBmbG93LWtleSAg4oeSIG5zLXBsYWluLXNhZmUtaW5cbi8vIFsxMjhdIG5zLXBsYWluLXNhZmUtb3V0IDo6PSBucy1jaGFyXG4vLyBbMTI5XSAgbnMtcGxhaW4tc2FmZS1pbiA6Oj0gbnMtY2hhciAtIGMtZmxvdy1pbmRpY2F0b3Jcbi8vIFsxMzBdICBucy1wbGFpbi1jaGFyKGMpIDo6PSAgKCBucy1wbGFpbi1zYWZlKGMpIC0g4oCcOuKAnSAtIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIC8qIEFuIG5zLWNoYXIgcHJlY2VkaW5nICovIOKAnCPigJ0gKVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoIOKAnDrigJ0gLyogRm9sbG93ZWQgYnkgYW4gbnMtcGxhaW4tc2FmZShjKSAqLyApXG5mdW5jdGlvbiBpc1BsYWluU2FmZShjLCBwcmV2LCBpbmJsb2NrKSB7XG4gIHZhciBjSXNOc0NoYXJPcldoaXRlc3BhY2UgPSBpc05zQ2hhck9yV2hpdGVzcGFjZShjKTtcbiAgdmFyIGNJc05zQ2hhciA9IGNJc05zQ2hhck9yV2hpdGVzcGFjZSAmJiAhaXNXaGl0ZXNwYWNlKGMpO1xuICByZXR1cm4gKFxuICAgIC8vIG5zLXBsYWluLXNhZmVcbiAgICBpbmJsb2NrID8gLy8gYyA9IGZsb3ctaW5cbiAgICAgIGNJc05zQ2hhck9yV2hpdGVzcGFjZVxuICAgICAgOiBjSXNOc0NoYXJPcldoaXRlc3BhY2VcbiAgICAgICAgLy8gLSBjLWZsb3ctaW5kaWNhdG9yXG4gICAgICAgICYmIGMgIT09IENIQVJfQ09NTUFcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUXG4gICAgICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNLRVRcbiAgICAgICAgJiYgYyAhPT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDS0VUXG4gIClcbiAgICAvLyBucy1wbGFpbi1jaGFyXG4gICAgJiYgYyAhPT0gQ0hBUl9TSEFSUCAvLyBmYWxzZSBvbiAnIydcbiAgICAmJiAhKHByZXYgPT09IENIQVJfQ09MT04gJiYgIWNJc05zQ2hhcikgLy8gZmFsc2Ugb24gJzogJ1xuICAgIHx8IChpc05zQ2hhck9yV2hpdGVzcGFjZShwcmV2KSAmJiAhaXNXaGl0ZXNwYWNlKHByZXYpICYmIGMgPT09IENIQVJfU0hBUlApIC8vIGNoYW5nZSB0byB0cnVlIG9uICdbXiBdIydcbiAgICB8fCAocHJldiA9PT0gQ0hBUl9DT0xPTiAmJiBjSXNOc0NoYXIpOyAvLyBjaGFuZ2UgdG8gdHJ1ZSBvbiAnOlteIF0nXG59XG5cbi8vIFNpbXBsaWZpZWQgdGVzdCBmb3IgdmFsdWVzIGFsbG93ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBwbGFpbiBzdHlsZS5cbmZ1bmN0aW9uIGlzUGxhaW5TYWZlRmlyc3QoYykge1xuICAvLyBVc2VzIGEgc3Vic2V0IG9mIG5zLWNoYXIgLSBjLWluZGljYXRvclxuICAvLyB3aGVyZSBucy1jaGFyID0gbmItY2hhciAtIHMtd2hpdGUuXG4gIC8vIE5vIHN1cHBvcnQgb2YgKCAoIOKAnD/igJ0gfCDigJw64oCdIHwg4oCcLeKAnSApIC8qIEZvbGxvd2VkIGJ5IGFuIG5zLXBsYWluLXNhZmUoYykpICovICkgcGFydFxuICByZXR1cm4gaXNQcmludGFibGUoYykgJiYgYyAhPT0gQ0hBUl9CT01cbiAgICAmJiAhaXNXaGl0ZXNwYWNlKGMpIC8vIC0gcy13aGl0ZVxuICAgIC8vIC0gKGMtaW5kaWNhdG9yIDo6PVxuICAgIC8vIOKAnC3igJ0gfCDigJw/4oCdIHwg4oCcOuKAnSB8IOKAnCzigJ0gfCDigJxb4oCdIHwg4oCcXeKAnSB8IOKAnHvigJ0gfCDigJx94oCdXG4gICAgJiYgYyAhPT0gQ0hBUl9NSU5VU1xuICAgICYmIGMgIT09IENIQVJfUVVFU1RJT05cbiAgICAmJiBjICE9PSBDSEFSX0NPTE9OXG4gICAgJiYgYyAhPT0gQ0hBUl9DT01NQVxuICAgICYmIGMgIT09IENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVRcbiAgICAmJiBjICE9PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0tFVFxuICAgICYmIGMgIT09IENIQVJfUklHSFRfQ1VSTFlfQlJBQ0tFVFxuICAgIC8vIHwg4oCcI+KAnSB8IOKAnCbigJ0gfCDigJwq4oCdIHwg4oCcIeKAnSB8IOKAnHzigJ0gfCDigJw94oCdIHwg4oCcPuKAnSB8IOKAnCfigJ0gfCDigJxcIuKAnVxuICAgICYmIGMgIT09IENIQVJfU0hBUlBcbiAgICAmJiBjICE9PSBDSEFSX0FNUEVSU0FORFxuICAgICYmIGMgIT09IENIQVJfQVNURVJJU0tcbiAgICAmJiBjICE9PSBDSEFSX0VYQ0xBTUFUSU9OXG4gICAgJiYgYyAhPT0gQ0hBUl9WRVJUSUNBTF9MSU5FXG4gICAgJiYgYyAhPT0gQ0hBUl9FUVVBTFNcbiAgICAmJiBjICE9PSBDSEFSX0dSRUFURVJfVEhBTlxuICAgICYmIGMgIT09IENIQVJfU0lOR0xFX1FVT1RFXG4gICAgJiYgYyAhPT0gQ0hBUl9ET1VCTEVfUVVPVEVcbiAgICAvLyB8IOKAnCXigJ0gfCDigJxA4oCdIHwg4oCcYOKAnSlcbiAgICAmJiBjICE9PSBDSEFSX1BFUkNFTlRcbiAgICAmJiBjICE9PSBDSEFSX0NPTU1FUkNJQUxfQVRcbiAgICAmJiBjICE9PSBDSEFSX0dSQVZFX0FDQ0VOVDtcbn1cblxuLy8gU2ltcGxpZmllZCB0ZXN0IGZvciB2YWx1ZXMgYWxsb3dlZCBhcyB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gcGxhaW4gc3R5bGUuXG5mdW5jdGlvbiBpc1BsYWluU2FmZUxhc3QoYykge1xuICAvLyBqdXN0IG5vdCB3aGl0ZXNwYWNlIG9yIGNvbG9uLCBpdCB3aWxsIGJlIGNoZWNrZWQgdG8gYmUgcGxhaW4gY2hhcmFjdGVyIGxhdGVyXG4gIHJldHVybiAhaXNXaGl0ZXNwYWNlKGMpICYmIGMgIT09IENIQVJfQ09MT047XG59XG5cbi8vIFNhbWUgYXMgJ3N0cmluZycuY29kZVBvaW50QXQocG9zKSwgYnV0IHdvcmtzIGluIG9sZGVyIGJyb3dzZXJzLlxuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyaW5nLCBwb3MpIHtcbiAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQocG9zKSwgc2Vjb25kO1xuICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRiAmJiBwb3MgKyAxIDwgc3RyaW5nLmxlbmd0aCkge1xuICAgIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxuICAgICAgcmV0dXJuIChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cblxuLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBpcyByZXF1aXJlZC5cbmZ1bmN0aW9uIG5lZWRJbmRlbnRJbmRpY2F0b3Ioc3RyaW5nKSB7XG4gIHZhciBsZWFkaW5nU3BhY2VSZSA9IC9eXFxuKiAvO1xuICByZXR1cm4gbGVhZGluZ1NwYWNlUmUudGVzdChzdHJpbmcpO1xufVxuXG52YXIgU1RZTEVfUExBSU4gICA9IDEsXG4gICAgU1RZTEVfU0lOR0xFICA9IDIsXG4gICAgU1RZTEVfTElURVJBTCA9IDMsXG4gICAgU1RZTEVfRk9MREVEICA9IDQsXG4gICAgU1RZTEVfRE9VQkxFICA9IDU7XG5cbi8vIERldGVybWluZXMgd2hpY2ggc2NhbGFyIHN0eWxlcyBhcmUgcG9zc2libGUgYW5kIHJldHVybnMgdGhlIHByZWZlcnJlZCBzdHlsZS5cbi8vIGxpbmVXaWR0aCA9IC0xID0+IG5vIGxpbWl0LlxuLy8gUHJlLWNvbmRpdGlvbnM6IHN0ci5sZW5ndGggPiAwLlxuLy8gUG9zdC1jb25kaXRpb25zOlxuLy8gICAgU1RZTEVfUExBSU4gb3IgU1RZTEVfU0lOR0xFID0+IG5vIFxcbiBhcmUgaW4gdGhlIHN0cmluZy5cbi8vICAgIFNUWUxFX0xJVEVSQUwgPT4gbm8gbGluZXMgYXJlIHN1aXRhYmxlIGZvciBmb2xkaW5nIChvciBsaW5lV2lkdGggaXMgLTEpLlxuLy8gICAgU1RZTEVfRk9MREVEID0+IGEgbGluZSA+IGxpbmVXaWR0aCBhbmQgY2FuIGJlIGZvbGRlZCAoYW5kIGxpbmVXaWR0aCAhPSAtMSkuXG5mdW5jdGlvbiBjaG9vc2VTY2FsYXJTdHlsZShzdHJpbmcsIHNpbmdsZUxpbmVPbmx5LCBpbmRlbnRQZXJMZXZlbCwgbGluZVdpZHRoLFxuICB0ZXN0QW1iaWd1b3VzVHlwZSwgcXVvdGluZ1R5cGUsIGZvcmNlUXVvdGVzLCBpbmJsb2NrKSB7XG5cbiAgdmFyIGk7XG4gIHZhciBjaGFyID0gMDtcbiAgdmFyIHByZXZDaGFyID0gbnVsbDtcbiAgdmFyIGhhc0xpbmVCcmVhayA9IGZhbHNlO1xuICB2YXIgaGFzRm9sZGFibGVMaW5lID0gZmFsc2U7IC8vIG9ubHkgY2hlY2tlZCBpZiBzaG91bGRUcmFja1dpZHRoXG4gIHZhciBzaG91bGRUcmFja1dpZHRoID0gbGluZVdpZHRoICE9PSAtMTtcbiAgdmFyIHByZXZpb3VzTGluZUJyZWFrID0gLTE7IC8vIGNvdW50IHRoZSBmaXJzdCBsaW5lIGNvcnJlY3RseVxuICB2YXIgcGxhaW4gPSBpc1BsYWluU2FmZUZpcnN0KGNvZGVQb2ludEF0KHN0cmluZywgMCkpXG4gICAgICAgICAgJiYgaXNQbGFpblNhZmVMYXN0KGNvZGVQb2ludEF0KHN0cmluZywgc3RyaW5nLmxlbmd0aCAtIDEpKTtcblxuICBpZiAoc2luZ2xlTGluZU9ubHkgfHwgZm9yY2VRdW90ZXMpIHtcbiAgICAvLyBDYXNlOiBubyBibG9jayBzdHlsZXMuXG4gICAgLy8gQ2hlY2sgZm9yIGRpc2FsbG93ZWQgY2hhcmFjdGVycyB0byBydWxlIG91dCBwbGFpbiBhbmQgc2luZ2xlLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICAgIGNoYXIgPSBjb2RlUG9pbnRBdChzdHJpbmcsIGkpO1xuICAgICAgaWYgKCFpc1ByaW50YWJsZShjaGFyKSkge1xuICAgICAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICAgICAgfVxuICAgICAgcGxhaW4gPSBwbGFpbiAmJiBpc1BsYWluU2FmZShjaGFyLCBwcmV2Q2hhciwgaW5ibG9jayk7XG4gICAgICBwcmV2Q2hhciA9IGNoYXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIENhc2U6IGJsb2NrIHN0eWxlcyBwZXJtaXR0ZWQuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGNoYXIgPj0gMHgxMDAwMCA/IGkgKz0gMiA6IGkrKykge1xuICAgICAgY2hhciA9IGNvZGVQb2ludEF0KHN0cmluZywgaSk7XG4gICAgICBpZiAoY2hhciA9PT0gQ0hBUl9MSU5FX0ZFRUQpIHtcbiAgICAgICAgaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGxpbmUgY2FuIGJlIGZvbGRlZC5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrV2lkdGgpIHtcbiAgICAgICAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHxcbiAgICAgICAgICAgIC8vIEZvbGRhYmxlIGxpbmUgPSB0b28gbG9uZywgYW5kIG5vdCBtb3JlLWluZGVudGVkLlxuICAgICAgICAgICAgKGkgLSBwcmV2aW91c0xpbmVCcmVhayAtIDEgPiBsaW5lV2lkdGggJiZcbiAgICAgICAgICAgICBzdHJpbmdbcHJldmlvdXNMaW5lQnJlYWsgKyAxXSAhPT0gJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0xpbmVCcmVhayA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzUHJpbnRhYmxlKGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBTVFlMRV9ET1VCTEU7XG4gICAgICB9XG4gICAgICBwbGFpbiA9IHBsYWluICYmIGlzUGxhaW5TYWZlKGNoYXIsIHByZXZDaGFyLCBpbmJsb2NrKTtcbiAgICAgIHByZXZDaGFyID0gY2hhcjtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSB0aGUgZW5kIGlzIG1pc3NpbmcgYSBcXG5cbiAgICBoYXNGb2xkYWJsZUxpbmUgPSBoYXNGb2xkYWJsZUxpbmUgfHwgKHNob3VsZFRyYWNrV2lkdGggJiZcbiAgICAgIChpIC0gcHJldmlvdXNMaW5lQnJlYWsgLSAxID4gbGluZVdpZHRoICYmXG4gICAgICAgc3RyaW5nW3ByZXZpb3VzTGluZUJyZWFrICsgMV0gIT09ICcgJykpO1xuICB9XG4gIC8vIEFsdGhvdWdoIGV2ZXJ5IHN0eWxlIGNhbiByZXByZXNlbnQgXFxuIHdpdGhvdXQgZXNjYXBpbmcsIHByZWZlciBibG9jayBzdHlsZXNcbiAgLy8gZm9yIG11bHRpbGluZSwgc2luY2UgdGhleSdyZSBtb3JlIHJlYWRhYmxlIGFuZCB0aGV5IGRvbid0IGFkZCBlbXB0eSBsaW5lcy5cbiAgLy8gQWxzbyBwcmVmZXIgZm9sZGluZyBhIHN1cGVyLWxvbmcgbGluZS5cbiAgaWYgKCFoYXNMaW5lQnJlYWsgJiYgIWhhc0ZvbGRhYmxlTGluZSkge1xuICAgIC8vIFN0cmluZ3MgaW50ZXJwcmV0YWJsZSBhcyBhbm90aGVyIHR5cGUgaGF2ZSB0byBiZSBxdW90ZWQ7XG4gICAgLy8gZS5nLiB0aGUgc3RyaW5nICd0cnVlJyB2cy4gdGhlIGJvb2xlYW4gdHJ1ZS5cbiAgICBpZiAocGxhaW4gJiYgIWZvcmNlUXVvdGVzICYmICF0ZXN0QW1iaWd1b3VzVHlwZShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gU1RZTEVfUExBSU47XG4gICAgfVxuICAgIHJldHVybiBxdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/IFNUWUxFX0RPVUJMRSA6IFNUWUxFX1NJTkdMRTtcbiAgfVxuICAvLyBFZGdlIGNhc2U6IGJsb2NrIGluZGVudGF0aW9uIGluZGljYXRvciBjYW4gb25seSBoYXZlIG9uZSBkaWdpdC5cbiAgaWYgKGluZGVudFBlckxldmVsID4gOSAmJiBuZWVkSW5kZW50SW5kaWNhdG9yKHN0cmluZykpIHtcbiAgICByZXR1cm4gU1RZTEVfRE9VQkxFO1xuICB9XG4gIC8vIEF0IHRoaXMgcG9pbnQgd2Uga25vdyBibG9jayBzdHlsZXMgYXJlIHZhbGlkLlxuICAvLyBQcmVmZXIgbGl0ZXJhbCBzdHlsZSB1bmxlc3Mgd2Ugd2FudCB0byBmb2xkLlxuICBpZiAoIWZvcmNlUXVvdGVzKSB7XG4gICAgcmV0dXJuIGhhc0ZvbGRhYmxlTGluZSA/IFNUWUxFX0ZPTERFRCA6IFNUWUxFX0xJVEVSQUw7XG4gIH1cbiAgcmV0dXJuIHF1b3RpbmdUeXBlID09PSBRVU9USU5HX1RZUEVfRE9VQkxFID8gU1RZTEVfRE9VQkxFIDogU1RZTEVfU0lOR0xFO1xufVxuXG4vLyBOb3RlOiBsaW5lIGJyZWFraW5nL2ZvbGRpbmcgaXMgaW1wbGVtZW50ZWQgZm9yIG9ubHkgdGhlIGZvbGRlZCBzdHlsZS5cbi8vIE5CLiBXZSBkcm9wIHRoZSBsYXN0IHRyYWlsaW5nIG5ld2xpbmUgKGlmIGFueSkgb2YgYSByZXR1cm5lZCBibG9jayBzY2FsYXJcbi8vICBzaW5jZSB0aGUgZHVtcGVyIGFkZHMgaXRzIG93biBuZXdsaW5lLiBUaGlzIGFsd2F5cyB3b3Jrczpcbi8vICAgIOKAoiBObyBlbmRpbmcgbmV3bGluZSA9PiB1bmFmZmVjdGVkOyBhbHJlYWR5IHVzaW5nIHN0cmlwIFwiLVwiIGNob21waW5nLlxuLy8gICAg4oCiIEVuZGluZyBuZXdsaW5lICAgID0+IHJlbW92ZWQgdGhlbiByZXN0b3JlZC5cbi8vICBJbXBvcnRhbnRseSwgdGhpcyBrZWVwcyB0aGUgXCIrXCIgY2hvbXAgaW5kaWNhdG9yIGZyb20gZ2FpbmluZyBhbiBleHRyYSBsaW5lLlxuZnVuY3Rpb24gd3JpdGVTY2FsYXIoc3RhdGUsIHN0cmluZywgbGV2ZWwsIGlza2V5LCBpbmJsb2NrKSB7XG4gIHN0YXRlLmR1bXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gc3RhdGUucXVvdGluZ1R5cGUgPT09IFFVT1RJTkdfVFlQRV9ET1VCTEUgPyAnXCJcIicgOiBcIicnXCI7XG4gICAgfVxuICAgIGlmICghc3RhdGUubm9Db21wYXRNb2RlKSB7XG4gICAgICBpZiAoREVQUkVDQVRFRF9CT09MRUFOU19TWU5UQVguaW5kZXhPZihzdHJpbmcpICE9PSAtMSB8fCBERVBSRUNBVEVEX0JBU0U2MF9TWU5UQVgudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5xdW90aW5nVHlwZSA9PT0gUVVPVElOR19UWVBFX0RPVUJMRSA/ICgnXCInICsgc3RyaW5nICsgJ1wiJykgOiAoXCInXCIgKyBzdHJpbmcgKyBcIidcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGVudCA9IHN0YXRlLmluZGVudCAqIE1hdGgubWF4KDEsIGxldmVsKTsgLy8gbm8gMC1pbmRlbnQgc2NhbGFyc1xuICAgIC8vIEFzIGluZGVudGF0aW9uIGdldHMgZGVlcGVyLCBsZXQgdGhlIHdpZHRoIGRlY3JlYXNlIG1vbm90b25pY2FsbHlcbiAgICAvLyB0byB0aGUgbG93ZXIgYm91bmQgbWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcGxpZXNcbiAgICAvLyAgc3RhdGUubGluZVdpZHRoIOKJpCA0MCArIHN0YXRlLmluZGVudDogd2lkdGggaXMgZml4ZWQgYXQgdGhlIGxvd2VyIGJvdW5kLlxuICAgIC8vICBzdGF0ZS5saW5lV2lkdGggPiA0MCArIHN0YXRlLmluZGVudDogd2lkdGggZGVjcmVhc2VzIHVudGlsIHRoZSBsb3dlciBib3VuZC5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgYmV0dGVyIHRoYW4gYSBjb25zdGFudCBtaW5pbXVtIHdpZHRoIHdoaWNoIGRpc2FsbG93cyBuYXJyb3dlciBvcHRpb25zLFxuICAgIC8vIG9yIGFuIGluZGVudCB0aHJlc2hvbGQgd2hpY2ggY2F1c2VzIHRoZSB3aWR0aCB0byBzdWRkZW5seSBpbmNyZWFzZS5cbiAgICB2YXIgbGluZVdpZHRoID0gc3RhdGUubGluZVdpZHRoID09PSAtMVxuICAgICAgPyAtMSA6IE1hdGgubWF4KE1hdGgubWluKHN0YXRlLmxpbmVXaWR0aCwgNDApLCBzdGF0ZS5saW5lV2lkdGggLSBpbmRlbnQpO1xuXG4gICAgLy8gV2l0aG91dCBrbm93aW5nIGlmIGtleXMgYXJlIGltcGxpY2l0L2V4cGxpY2l0LCBhc3N1bWUgaW1wbGljaXQgZm9yIHNhZmV0eS5cbiAgICB2YXIgc2luZ2xlTGluZU9ubHkgPSBpc2tleVxuICAgICAgLy8gTm8gYmxvY2sgc3R5bGVzIGluIGZsb3cgbW9kZS5cbiAgICAgIHx8IChzdGF0ZS5mbG93TGV2ZWwgPiAtMSAmJiBsZXZlbCA+PSBzdGF0ZS5mbG93TGV2ZWwpO1xuICAgIGZ1bmN0aW9uIHRlc3RBbWJpZ3VpdHkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGVzdEltcGxpY2l0UmVzb2x2aW5nKHN0YXRlLCBzdHJpbmcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY2hvb3NlU2NhbGFyU3R5bGUoc3RyaW5nLCBzaW5nbGVMaW5lT25seSwgc3RhdGUuaW5kZW50LCBsaW5lV2lkdGgsXG4gICAgICB0ZXN0QW1iaWd1aXR5LCBzdGF0ZS5xdW90aW5nVHlwZSwgc3RhdGUuZm9yY2VRdW90ZXMgJiYgIWlza2V5LCBpbmJsb2NrKSkge1xuXG4gICAgICBjYXNlIFNUWUxFX1BMQUlOOlxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgY2FzZSBTVFlMRV9TSU5HTEU6XG4gICAgICAgIHJldHVybiBcIidcIiArIHN0cmluZy5yZXBsYWNlKC8nL2csIFwiJydcIikgKyBcIidcIjtcbiAgICAgIGNhc2UgU1RZTEVfTElURVJBTDpcbiAgICAgICAgcmV0dXJuICd8JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKHN0cmluZywgaW5kZW50KSk7XG4gICAgICBjYXNlIFNUWUxFX0ZPTERFRDpcbiAgICAgICAgcmV0dXJuICc+JyArIGJsb2NrSGVhZGVyKHN0cmluZywgc3RhdGUuaW5kZW50KVxuICAgICAgICAgICsgZHJvcEVuZGluZ05ld2xpbmUoaW5kZW50U3RyaW5nKGZvbGRTdHJpbmcoc3RyaW5nLCBsaW5lV2lkdGgpLCBpbmRlbnQpKTtcbiAgICAgIGNhc2UgU1RZTEVfRE9VQkxFOlxuICAgICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZVN0cmluZyhzdHJpbmcsIGxpbmVXaWR0aCkgKyAnXCInO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFlBTUxFeGNlcHRpb24oJ2ltcG9zc2libGUgZXJyb3I6IGludmFsaWQgc2NhbGFyIHN0eWxlJyk7XG4gICAgfVxuICB9KCkpO1xufVxuXG4vLyBQcmUtY29uZGl0aW9uczogc3RyaW5nIGlzIHZhbGlkIGZvciBhIGJsb2NrIHNjYWxhciwgMSA8PSBpbmRlbnRQZXJMZXZlbCA8PSA5LlxuZnVuY3Rpb24gYmxvY2tIZWFkZXIoc3RyaW5nLCBpbmRlbnRQZXJMZXZlbCkge1xuICB2YXIgaW5kZW50SW5kaWNhdG9yID0gbmVlZEluZGVudEluZGljYXRvcihzdHJpbmcpID8gU3RyaW5nKGluZGVudFBlckxldmVsKSA6ICcnO1xuXG4gIC8vIG5vdGUgdGhlIHNwZWNpYWwgY2FzZTogdGhlIHN0cmluZyAnXFxuJyBjb3VudHMgYXMgYSBcInRyYWlsaW5nXCIgZW1wdHkgbGluZS5cbiAgdmFyIGNsaXAgPSAgICAgICAgICBzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnXFxuJztcbiAgdmFyIGtlZXAgPSBjbGlwICYmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDJdID09PSAnXFxuJyB8fCBzdHJpbmcgPT09ICdcXG4nKTtcbiAgdmFyIGNob21wID0ga2VlcCA/ICcrJyA6IChjbGlwID8gJycgOiAnLScpO1xuXG4gIHJldHVybiBpbmRlbnRJbmRpY2F0b3IgKyBjaG9tcCArICdcXG4nO1xufVxuXG4vLyAoU2VlIHRoZSBub3RlIGZvciB3cml0ZVNjYWxhci4pXG5mdW5jdGlvbiBkcm9wRW5kaW5nTmV3bGluZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1tzdHJpbmcubGVuZ3RoIC0gMV0gPT09ICdcXG4nID8gc3RyaW5nLnNsaWNlKDAsIC0xKSA6IHN0cmluZztcbn1cblxuLy8gTm90ZTogYSBsb25nIGxpbmUgd2l0aG91dCBhIHN1aXRhYmxlIGJyZWFrIHBvaW50IHdpbGwgZXhjZWVkIHRoZSB3aWR0aCBsaW1pdC5cbi8vIFByZS1jb25kaXRpb25zOiBldmVyeSBjaGFyIGluIHN0ciBpc1ByaW50YWJsZSwgc3RyLmxlbmd0aCA+IDAsIHdpZHRoID4gMC5cbmZ1bmN0aW9uIGZvbGRTdHJpbmcoc3RyaW5nLCB3aWR0aCkge1xuICAvLyBJbiBmb2xkZWQgc3R5bGUsICRrJCBjb25zZWN1dGl2ZSBuZXdsaW5lcyBvdXRwdXQgYXMgJGsrMSQgbmV3bGluZXPigJRcbiAgLy8gdW5sZXNzIHRoZXkncmUgYmVmb3JlIG9yIGFmdGVyIGEgbW9yZS1pbmRlbnRlZCBsaW5lLCBvciBhdCB0aGUgdmVyeVxuICAvLyBiZWdpbm5pbmcgb3IgZW5kLCBpbiB3aGljaCBjYXNlICRrJCBtYXBzIHRvICRrJC5cbiAgLy8gVGhlcmVmb3JlLCBwYXJzZSBlYWNoIGNodW5rIGFzIG5ld2xpbmUocykgZm9sbG93ZWQgYnkgYSBjb250ZW50IGxpbmUuXG4gIHZhciBsaW5lUmUgPSAvKFxcbispKFteXFxuXSopL2c7XG5cbiAgLy8gZmlyc3QgbGluZSAocG9zc2libHkgYW4gZW1wdHkgbGluZSlcbiAgdmFyIHJlc3VsdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5leHRMRiA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcbiAgICBuZXh0TEYgPSBuZXh0TEYgIT09IC0xID8gbmV4dExGIDogc3RyaW5nLmxlbmd0aDtcbiAgICBsaW5lUmUubGFzdEluZGV4ID0gbmV4dExGO1xuICAgIHJldHVybiBmb2xkTGluZShzdHJpbmcuc2xpY2UoMCwgbmV4dExGKSwgd2lkdGgpO1xuICB9KCkpO1xuICAvLyBJZiB3ZSBoYXZlbid0IHJlYWNoZWQgdGhlIGZpcnN0IGNvbnRlbnQgbGluZSB5ZXQsIGRvbid0IGFkZCBhbiBleHRyYSBcXG4uXG4gIHZhciBwcmV2TW9yZUluZGVudGVkID0gc3RyaW5nWzBdID09PSAnXFxuJyB8fCBzdHJpbmdbMF0gPT09ICcgJztcbiAgdmFyIG1vcmVJbmRlbnRlZDtcblxuICAvLyByZXN0IG9mIHRoZSBsaW5lc1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBsaW5lUmUuZXhlYyhzdHJpbmcpKSkge1xuICAgIHZhciBwcmVmaXggPSBtYXRjaFsxXSwgbGluZSA9IG1hdGNoWzJdO1xuICAgIG1vcmVJbmRlbnRlZCA9IChsaW5lWzBdID09PSAnICcpO1xuICAgIHJlc3VsdCArPSBwcmVmaXhcbiAgICAgICsgKCFwcmV2TW9yZUluZGVudGVkICYmICFtb3JlSW5kZW50ZWQgJiYgbGluZSAhPT0gJydcbiAgICAgICAgPyAnXFxuJyA6ICcnKVxuICAgICAgKyBmb2xkTGluZShsaW5lLCB3aWR0aCk7XG4gICAgcHJldk1vcmVJbmRlbnRlZCA9IG1vcmVJbmRlbnRlZDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdyZWVkeSBsaW5lIGJyZWFraW5nLlxuLy8gUGlja3MgdGhlIGxvbmdlc3QgbGluZSB1bmRlciB0aGUgbGltaXQgZWFjaCB0aW1lLFxuLy8gb3RoZXJ3aXNlIHNldHRsZXMgZm9yIHRoZSBzaG9ydGVzdCBsaW5lIG92ZXIgdGhlIGxpbWl0LlxuLy8gTkIuIE1vcmUtaW5kZW50ZWQgbGluZXMgKmNhbm5vdCogYmUgZm9sZGVkLCBhcyB0aGF0IHdvdWxkIGFkZCBhbiBleHRyYSBcXG4uXG5mdW5jdGlvbiBmb2xkTGluZShsaW5lLCB3aWR0aCkge1xuICBpZiAobGluZSA9PT0gJycgfHwgbGluZVswXSA9PT0gJyAnKSByZXR1cm4gbGluZTtcblxuICAvLyBTaW5jZSBhIG1vcmUtaW5kZW50ZWQgbGluZSBhZGRzIGEgXFxuLCBicmVha3MgY2FuJ3QgYmUgZm9sbG93ZWQgYnkgYSBzcGFjZS5cbiAgdmFyIGJyZWFrUmUgPSAvIFteIF0vZzsgLy8gbm90ZTogdGhlIG1hdGNoIGluZGV4IHdpbGwgYWx3YXlzIGJlIDw9IGxlbmd0aC0yLlxuICB2YXIgbWF0Y2g7XG4gIC8vIHN0YXJ0IGlzIGFuIGluY2x1c2l2ZSBpbmRleC4gZW5kLCBjdXJyLCBhbmQgbmV4dCBhcmUgZXhjbHVzaXZlLlxuICB2YXIgc3RhcnQgPSAwLCBlbmQsIGN1cnIgPSAwLCBuZXh0ID0gMDtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIC8vIEludmFyaWFudHM6IDAgPD0gc3RhcnQgPD0gbGVuZ3RoLTEuXG4gIC8vICAgMCA8PSBjdXJyIDw9IG5leHQgPD0gbWF4KDAsIGxlbmd0aC0yKS4gY3VyciAtIHN0YXJ0IDw9IHdpZHRoLlxuICAvLyBJbnNpZGUgdGhlIGxvb3A6XG4gIC8vICAgQSBtYXRjaCBpbXBsaWVzIGxlbmd0aCA+PSAyLCBzbyBjdXJyIGFuZCBuZXh0IGFyZSA8PSBsZW5ndGgtMi5cbiAgd2hpbGUgKChtYXRjaCA9IGJyZWFrUmUuZXhlYyhsaW5lKSkpIHtcbiAgICBuZXh0ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gbWFpbnRhaW4gaW52YXJpYW50OiBjdXJyIC0gc3RhcnQgPD0gd2lkdGhcbiAgICBpZiAobmV4dCAtIHN0YXJ0ID4gd2lkdGgpIHtcbiAgICAgIGVuZCA9IChjdXJyID4gc3RhcnQpID8gY3VyciA6IG5leHQ7IC8vIGRlcml2ZSBlbmQgPD0gbGVuZ3RoLTJcbiAgICAgIHJlc3VsdCArPSAnXFxuJyArIGxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAvLyBza2lwIHRoZSBzcGFjZSB0aGF0IHdhcyBvdXRwdXQgYXMgXFxuXG4gICAgICBzdGFydCA9IGVuZCArIDE7ICAgICAgICAgICAgICAgICAgICAvLyBkZXJpdmUgc3RhcnQgPD0gbGVuZ3RoLTFcbiAgICB9XG4gICAgY3VyciA9IG5leHQ7XG4gIH1cblxuICAvLyBCeSB0aGUgaW52YXJpYW50cywgc3RhcnQgPD0gbGVuZ3RoLTEsIHNvIHRoZXJlIGlzIHNvbWV0aGluZyBsZWZ0IG92ZXIuXG4gIC8vIEl0IGlzIGVpdGhlciB0aGUgd2hvbGUgc3RyaW5nIG9yIGEgcGFydCBzdGFydGluZyBmcm9tIG5vbi13aGl0ZXNwYWNlLlxuICByZXN1bHQgKz0gJ1xcbic7XG4gIC8vIEluc2VydCBhIGJyZWFrIGlmIHRoZSByZW1haW5kZXIgaXMgdG9vIGxvbmcgYW5kIHRoZXJlIGlzIGEgYnJlYWsgYXZhaWxhYmxlLlxuICBpZiAobGluZS5sZW5ndGggLSBzdGFydCA+IHdpZHRoICYmIGN1cnIgPiBzdGFydCkge1xuICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKHN0YXJ0LCBjdXJyKSArICdcXG4nICsgbGluZS5zbGljZShjdXJyICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGxpbmUuc2xpY2Uoc3RhcnQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5zbGljZSgxKTsgLy8gZHJvcCBleHRyYSBcXG4gam9pbmVyXG59XG5cbi8vIEVzY2FwZXMgYSBkb3VibGUtcXVvdGVkIHN0cmluZy5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY2hhciA9IDA7XG4gIHZhciBlc2NhcGVTZXE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBjaGFyID49IDB4MTAwMDAgPyBpICs9IDIgOiBpKyspIHtcbiAgICBjaGFyID0gY29kZVBvaW50QXQoc3RyaW5nLCBpKTtcbiAgICBlc2NhcGVTZXEgPSBFU0NBUEVfU0VRVUVOQ0VTW2NoYXJdO1xuXG4gICAgaWYgKCFlc2NhcGVTZXEgJiYgaXNQcmludGFibGUoY2hhcikpIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdbaV07XG4gICAgICBpZiAoY2hhciA+PSAweDEwMDAwKSByZXN1bHQgKz0gc3RyaW5nW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGVzY2FwZVNlcSB8fCBlbmNvZGVIZXgoY2hhcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgPSAnJyxcbiAgICAgIF90YWcgICAgPSBzdGF0ZS50YWcsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHZhbHVlID0gb2JqZWN0W2luZGV4XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgdmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgU3RyaW5nKGluZGV4KSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIG9ubHkgdmFsaWQgZWxlbWVudHMsIHB1dCBudWxsIGluc3RlYWQgb2YgaW52YWxpZCBlbGVtZW50cy5cbiAgICBpZiAod3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgdmFsdWUsIGZhbHNlLCBmYWxzZSkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgIHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG51bGwsIGZhbHNlLCBmYWxzZSkpKSB7XG5cbiAgICAgIGlmIChfcmVzdWx0ICE9PSAnJykgX3Jlc3VsdCArPSAnLCcgKyAoIXN0YXRlLmNvbmRlbnNlRmxvdyA/ICcgJyA6ICcnKTtcbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gJ1snICsgX3Jlc3VsdCArICddJztcbn1cblxuZnVuY3Rpb24gd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ID0gJycsXG4gICAgICBfdGFnICAgID0gc3RhdGUudGFnLFxuICAgICAgaW5kZXgsXG4gICAgICBsZW5ndGgsXG4gICAgICB2YWx1ZTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICB2YWx1ZSA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIHZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIFN0cmluZyhpbmRleCksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBvbmx5IHZhbGlkIGVsZW1lbnRzLCBwdXQgbnVsbCBpbnN0ZWFkIG9mIGludmFsaWQgZWxlbWVudHMuXG4gICAgaWYgKHdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICB3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgbnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUpKSkge1xuXG4gICAgICBpZiAoIWNvbXBhY3QgfHwgX3Jlc3VsdCAhPT0gJycpIHtcbiAgICAgICAgX3Jlc3VsdCArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5kdW1wICYmIENIQVJfTElORV9GRUVEID09PSBzdGF0ZS5kdW1wLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgX3Jlc3VsdCArPSAnLSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVzdWx0ICs9ICctICc7XG4gICAgICB9XG5cbiAgICAgIF9yZXN1bHQgKz0gc3RhdGUuZHVtcDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS50YWcgPSBfdGFnO1xuICBzdGF0ZS5kdW1wID0gX3Jlc3VsdCB8fCAnW10nOyAvLyBFbXB0eSBzZXF1ZW5jZSBpZiBubyB2YWxpZCB2YWx1ZXMuXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvd01hcHBpbmcoc3RhdGUsIGxldmVsLCBvYmplY3QpIHtcbiAgdmFyIF9yZXN1bHQgICAgICAgPSAnJyxcbiAgICAgIF90YWcgICAgICAgICAgPSBzdGF0ZS50YWcsXG4gICAgICBvYmplY3RLZXlMaXN0ID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgIGluZGV4LFxuICAgICAgbGVuZ3RoLFxuICAgICAgb2JqZWN0S2V5LFxuICAgICAgb2JqZWN0VmFsdWUsXG4gICAgICBwYWlyQnVmZmVyO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgIHBhaXJCdWZmZXIgPSAnJztcbiAgICBpZiAoX3Jlc3VsdCAhPT0gJycpIHBhaXJCdWZmZXIgKz0gJywgJztcblxuICAgIGlmIChzdGF0ZS5jb25kZW5zZUZsb3cpIHBhaXJCdWZmZXIgKz0gJ1wiJztcblxuICAgIG9iamVjdEtleSA9IG9iamVjdEtleUxpc3RbaW5kZXhdO1xuICAgIG9iamVjdFZhbHVlID0gb2JqZWN0W29iamVjdEtleV07XG5cbiAgICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICAgIG9iamVjdFZhbHVlID0gc3RhdGUucmVwbGFjZXIuY2FsbChvYmplY3QsIG9iamVjdEtleSwgb2JqZWN0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghd3JpdGVOb2RlKHN0YXRlLCBsZXZlbCwgb2JqZWN0S2V5LCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIGtleTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcC5sZW5ndGggPiAxMDI0KSBwYWlyQnVmZmVyICs9ICc/ICc7XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXAgKyAoc3RhdGUuY29uZGVuc2VGbG93ID8gJ1wiJyA6ICcnKSArICc6JyArIChzdGF0ZS5jb25kZW5zZUZsb3cgPyAnJyA6ICcgJyk7XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwsIG9iamVjdFZhbHVlLCBmYWxzZSwgZmFsc2UpKSB7XG4gICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHBhaXIgYmVjYXVzZSBvZiBpbnZhbGlkIHZhbHVlLlxuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9ICd7JyArIF9yZXN1bHQgKyAnfSc7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQmxvY2tNYXBwaW5nKHN0YXRlLCBsZXZlbCwgb2JqZWN0LCBjb21wYWN0KSB7XG4gIHZhciBfcmVzdWx0ICAgICAgID0gJycsXG4gICAgICBfdGFnICAgICAgICAgID0gc3RhdGUudGFnLFxuICAgICAgb2JqZWN0S2V5TGlzdCA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIG9iamVjdEtleSxcbiAgICAgIG9iamVjdFZhbHVlLFxuICAgICAgZXhwbGljaXRQYWlyLFxuICAgICAgcGFpckJ1ZmZlcjtcblxuICAvLyBBbGxvdyBzb3J0aW5nIGtleXMgc28gdGhhdCB0aGUgb3V0cHV0IGZpbGUgaXMgZGV0ZXJtaW5pc3RpY1xuICBpZiAoc3RhdGUuc29ydEtleXMgPT09IHRydWUpIHtcbiAgICAvLyBEZWZhdWx0IHNvcnRpbmdcbiAgICBvYmplY3RLZXlMaXN0LnNvcnQoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhdGUuc29ydEtleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBDdXN0b20gc29ydCBmdW5jdGlvblxuICAgIG9iamVjdEtleUxpc3Quc29ydChzdGF0ZS5zb3J0S2V5cyk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc29ydEtleXMpIHtcbiAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmdcbiAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbignc29ydEtleXMgbXVzdCBiZSBhIGJvb2xlYW4gb3IgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdEtleUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXJCdWZmZXIgPSAnJztcblxuICAgIGlmICghY29tcGFjdCB8fCBfcmVzdWx0ICE9PSAnJykge1xuICAgICAgcGFpckJ1ZmZlciArPSBnZW5lcmF0ZU5leHRMaW5lKHN0YXRlLCBsZXZlbCk7XG4gICAgfVxuXG4gICAgb2JqZWN0S2V5ID0gb2JqZWN0S2V5TGlzdFtpbmRleF07XG4gICAgb2JqZWN0VmFsdWUgPSBvYmplY3Rbb2JqZWN0S2V5XTtcblxuICAgIGlmIChzdGF0ZS5yZXBsYWNlcikge1xuICAgICAgb2JqZWN0VmFsdWUgPSBzdGF0ZS5yZXBsYWNlci5jYWxsKG9iamVjdCwgb2JqZWN0S2V5LCBvYmplY3RWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCF3cml0ZU5vZGUoc3RhdGUsIGxldmVsICsgMSwgb2JqZWN0S2V5LCB0cnVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCBrZXkuXG4gICAgfVxuXG4gICAgZXhwbGljaXRQYWlyID0gKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHxcbiAgICAgICAgICAgICAgICAgICAoc3RhdGUuZHVtcCAmJiBzdGF0ZS5kdW1wLmxlbmd0aCA+IDEwMjQpO1xuXG4gICAgaWYgKGV4cGxpY2l0UGFpcikge1xuICAgICAgaWYgKHN0YXRlLmR1bXAgJiYgQ0hBUl9MSU5FX0ZFRUQgPT09IHN0YXRlLmR1bXAuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICBwYWlyQnVmZmVyICs9ICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhaXJCdWZmZXIgKz0gJz8gJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYWlyQnVmZmVyICs9IHN0YXRlLmR1bXA7XG5cbiAgICBpZiAoZXhwbGljaXRQYWlyKSB7XG4gICAgICBwYWlyQnVmZmVyICs9IGdlbmVyYXRlTmV4dExpbmUoc3RhdGUsIGxldmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXdyaXRlTm9kZShzdGF0ZSwgbGV2ZWwgKyAxLCBvYmplY3RWYWx1ZSwgdHJ1ZSwgZXhwbGljaXRQYWlyKSkge1xuICAgICAgY29udGludWU7IC8vIFNraXAgdGhpcyBwYWlyIGJlY2F1c2Ugb2YgaW52YWxpZCB2YWx1ZS5cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuZHVtcCAmJiBDSEFSX0xJTkVfRkVFRCA9PT0gc3RhdGUuZHVtcC5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBwYWlyQnVmZmVyICs9ICc6JztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpckJ1ZmZlciArPSAnOiAnO1xuICAgIH1cblxuICAgIHBhaXJCdWZmZXIgKz0gc3RhdGUuZHVtcDtcblxuICAgIC8vIEJvdGgga2V5IGFuZCB2YWx1ZSBhcmUgdmFsaWQuXG4gICAgX3Jlc3VsdCArPSBwYWlyQnVmZmVyO1xuICB9XG5cbiAgc3RhdGUudGFnID0gX3RhZztcbiAgc3RhdGUuZHVtcCA9IF9yZXN1bHQgfHwgJ3t9JzsgLy8gRW1wdHkgbWFwcGluZyBpZiBubyB2YWxpZCBwYWlycy5cbn1cblxuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBleHBsaWNpdCkge1xuICB2YXIgX3Jlc3VsdCwgdHlwZUxpc3QsIGluZGV4LCBsZW5ndGgsIHR5cGUsIHN0eWxlO1xuXG4gIHR5cGVMaXN0ID0gZXhwbGljaXQgPyBzdGF0ZS5leHBsaWNpdFR5cGVzIDogc3RhdGUuaW1wbGljaXRUeXBlcztcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdHlwZUxpc3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHR5cGUgPSB0eXBlTGlzdFtpbmRleF07XG5cbiAgICBpZiAoKHR5cGUuaW5zdGFuY2VPZiAgfHwgdHlwZS5wcmVkaWNhdGUpICYmXG4gICAgICAgICghdHlwZS5pbnN0YW5jZU9mIHx8ICgodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcpICYmIChvYmplY3QgaW5zdGFuY2VvZiB0eXBlLmluc3RhbmNlT2YpKSkgJiZcbiAgICAgICAgKCF0eXBlLnByZWRpY2F0ZSAgfHwgdHlwZS5wcmVkaWNhdGUob2JqZWN0KSkpIHtcblxuICAgICAgaWYgKGV4cGxpY2l0KSB7XG4gICAgICAgIGlmICh0eXBlLm11bHRpICYmIHR5cGUucmVwcmVzZW50TmFtZSkge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IHR5cGUucmVwcmVzZW50TmFtZShvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnRhZyA9IHR5cGUudGFnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS50YWcgPSAnPyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLnJlcHJlc2VudCkge1xuICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlTWFwW3R5cGUudGFnXSB8fCB0eXBlLmRlZmF1bHRTdHlsZTtcblxuICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwodHlwZS5yZXByZXNlbnQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XG4gICAgICAgICAgX3Jlc3VsdCA9IHR5cGUucmVwcmVzZW50KG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2UgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGUucmVwcmVzZW50LCBzdHlsZSkpIHtcbiAgICAgICAgICBfcmVzdWx0ID0gdHlwZS5yZXByZXNlbnRbc3R5bGVdKG9iamVjdCwgc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBZQU1MRXhjZXB0aW9uKCchPCcgKyB0eXBlLnRhZyArICc+IHRhZyByZXNvbHZlciBhY2NlcHRzIG5vdCBcIicgKyBzdHlsZSArICdcIiBzdHlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZHVtcCA9IF9yZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gU2VyaWFsaXplcyBgb2JqZWN0YCBhbmQgd3JpdGVzIGl0IHRvIGdsb2JhbCBgcmVzdWx0YC5cbi8vIFJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBvciBmYWxzZSBvbiBpbnZhbGlkIG9iamVjdC5cbi8vXG5mdW5jdGlvbiB3cml0ZU5vZGUoc3RhdGUsIGxldmVsLCBvYmplY3QsIGJsb2NrLCBjb21wYWN0LCBpc2tleSwgaXNibG9ja3NlcSkge1xuICBzdGF0ZS50YWcgPSBudWxsO1xuICBzdGF0ZS5kdW1wID0gb2JqZWN0O1xuXG4gIGlmICghZGV0ZWN0VHlwZShzdGF0ZSwgb2JqZWN0LCBmYWxzZSkpIHtcbiAgICBkZXRlY3RUeXBlKHN0YXRlLCBvYmplY3QsIHRydWUpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBfdG9TdHJpbmcuY2FsbChzdGF0ZS5kdW1wKTtcbiAgdmFyIGluYmxvY2sgPSBibG9jaztcbiAgdmFyIHRhZ1N0cjtcblxuICBpZiAoYmxvY2spIHtcbiAgICBibG9jayA9IChzdGF0ZS5mbG93TGV2ZWwgPCAwIHx8IHN0YXRlLmZsb3dMZXZlbCA+IGxldmVsKTtcbiAgfVxuXG4gIHZhciBvYmplY3RPckFycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICAgIGR1cGxpY2F0ZUluZGV4LFxuICAgICAgZHVwbGljYXRlO1xuXG4gIGlmIChvYmplY3RPckFycmF5KSB7XG4gICAgZHVwbGljYXRlSW5kZXggPSBzdGF0ZS5kdXBsaWNhdGVzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBkdXBsaWNhdGUgPSBkdXBsaWNhdGVJbmRleCAhPT0gLTE7XG4gIH1cblxuICBpZiAoKHN0YXRlLnRhZyAhPT0gbnVsbCAmJiBzdGF0ZS50YWcgIT09ICc/JykgfHwgZHVwbGljYXRlIHx8IChzdGF0ZS5pbmRlbnQgIT09IDIgJiYgbGV2ZWwgPiAwKSkge1xuICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChkdXBsaWNhdGUgJiYgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdKSB7XG4gICAgc3RhdGUuZHVtcCA9ICcqcmVmXycgKyBkdXBsaWNhdGVJbmRleDtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2JqZWN0T3JBcnJheSAmJiBkdXBsaWNhdGUgJiYgIXN0YXRlLnVzZWREdXBsaWNhdGVzW2R1cGxpY2F0ZUluZGV4XSkge1xuICAgICAgc3RhdGUudXNlZER1cGxpY2F0ZXNbZHVwbGljYXRlSW5kZXhdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBpZiAoYmxvY2sgJiYgKE9iamVjdC5rZXlzKHN0YXRlLmR1bXApLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgd3JpdGVCbG9ja01hcHBpbmcoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wLCBjb21wYWN0KTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZsb3dNYXBwaW5nKHN0YXRlLCBsZXZlbCwgc3RhdGUuZHVtcCk7XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgJyAnICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKGJsb2NrICYmIChzdGF0ZS5kdW1wLmxlbmd0aCAhPT0gMCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLm5vQXJyYXlJbmRlbnQgJiYgIWlzYmxvY2tzZXEgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgd3JpdGVCbG9ja1NlcXVlbmNlKHN0YXRlLCBsZXZlbCAtIDEsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdyaXRlQmxvY2tTZXF1ZW5jZShzdGF0ZSwgbGV2ZWwsIHN0YXRlLmR1bXAsIGNvbXBhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkdXBsaWNhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5kdW1wID0gJyZyZWZfJyArIGR1cGxpY2F0ZUluZGV4ICsgc3RhdGUuZHVtcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVGbG93U2VxdWVuY2Uoc3RhdGUsIGxldmVsLCBzdGF0ZS5kdW1wKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgICAgIHN0YXRlLmR1bXAgPSAnJnJlZl8nICsgZHVwbGljYXRlSW5kZXggKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgICAgaWYgKHN0YXRlLnRhZyAhPT0gJz8nKSB7XG4gICAgICAgIHdyaXRlU2NhbGFyKHN0YXRlLCBzdGF0ZS5kdW1wLCBsZXZlbCwgaXNrZXksIGluYmxvY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLnNraXBJbnZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBuZXcgWUFNTEV4Y2VwdGlvbigndW5hY2NlcHRhYmxlIGtpbmQgb2YgYW4gb2JqZWN0IHRvIGR1bXAgJyArIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50YWcgIT09IG51bGwgJiYgc3RhdGUudGFnICE9PSAnPycpIHtcbiAgICAgIC8vIE5lZWQgdG8gZW5jb2RlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCB0aG9zZSBhbGxvd2VkIGJ5IHRoZSBzcGVjOlxuICAgICAgLy9cbiAgICAgIC8vIFszNV0gbnMtZGVjLWRpZ2l0ICAgIDo6PSAgWyN4MzAtI3gzOV0gLyogMC05ICovXG4gICAgICAvLyBbMzZdIG5zLWhleC1kaWdpdCAgICA6Oj0gIG5zLWRlYy1kaWdpdFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCBbI3g0MS0jeDQ2XSAvKiBBLUYgKi8gfCBbI3g2MS0jeDY2XSAvKiBhLWYgKi9cbiAgICAgIC8vIFszN10gbnMtYXNjaWktbGV0dGVyIDo6PSAgWyN4NDEtI3g1QV0gLyogQS1aICovIHwgWyN4NjEtI3g3QV0gLyogYS16ICovXG4gICAgICAvLyBbMzhdIG5zLXdvcmQtY2hhciAgICA6Oj0gIG5zLWRlYy1kaWdpdCB8IG5zLWFzY2lpLWxldHRlciB8IOKAnC3igJ1cbiAgICAgIC8vIFszOV0gbnMtdXJpLWNoYXIgICAgIDo6PSAg4oCcJeKAnSBucy1oZXgtZGlnaXQgbnMtaGV4LWRpZ2l0IHwgbnMtd29yZC1jaGFyIHwg4oCcI+KAnVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfCDigJw74oCdIHwg4oCcL+KAnSB8IOKAnD/igJ0gfCDigJw64oCdIHwg4oCcQOKAnSB8IOKAnCbigJ0gfCDigJw94oCdIHwg4oCcK+KAnSB8IOKAnCTigJ0gfCDigJws4oCdXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB8IOKAnF/igJ0gfCDigJwu4oCdIHwg4oCcIeKAnSB8IOKAnH7igJ0gfCDigJwq4oCdIHwg4oCcJ+KAnSB8IOKAnCjigJ0gfCDigJwp4oCdIHwg4oCcW+KAnSB8IOKAnF3igJ1cbiAgICAgIC8vXG4gICAgICAvLyBBbHNvIG5lZWQgdG8gZW5jb2RlICchJyBiZWNhdXNlIGl0IGhhcyBzcGVjaWFsIG1lYW5pbmcgKGVuZCBvZiB0YWcgcHJlZml4KS5cbiAgICAgIC8vXG4gICAgICB0YWdTdHIgPSBlbmNvZGVVUkkoXG4gICAgICAgIHN0YXRlLnRhZ1swXSA9PT0gJyEnID8gc3RhdGUudGFnLnNsaWNlKDEpIDogc3RhdGUudGFnXG4gICAgICApLnJlcGxhY2UoLyEvZywgJyUyMScpO1xuXG4gICAgICBpZiAoc3RhdGUudGFnWzBdID09PSAnIScpIHtcbiAgICAgICAgdGFnU3RyID0gJyEnICsgdGFnU3RyO1xuICAgICAgfSBlbHNlIGlmICh0YWdTdHIuc2xpY2UoMCwgMTgpID09PSAndGFnOnlhbWwub3JnLDIwMDI6Jykge1xuICAgICAgICB0YWdTdHIgPSAnISEnICsgdGFnU3RyLnNsaWNlKDE4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ1N0ciA9ICchPCcgKyB0YWdTdHIgKyAnPic7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmR1bXAgPSB0YWdTdHIgKyAnICcgKyBzdGF0ZS5kdW1wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXREdXBsaWNhdGVSZWZlcmVuY2VzKG9iamVjdCwgc3RhdGUpIHtcbiAgdmFyIG9iamVjdHMgPSBbXSxcbiAgICAgIGR1cGxpY2F0ZXNJbmRleGVzID0gW10sXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpbnNwZWN0Tm9kZShvYmplY3QsIG9iamVjdHMsIGR1cGxpY2F0ZXNJbmRleGVzKTtcblxuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZHVwbGljYXRlc0luZGV4ZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHN0YXRlLmR1cGxpY2F0ZXMucHVzaChvYmplY3RzW2R1cGxpY2F0ZXNJbmRleGVzW2luZGV4XV0pO1xuICB9XG4gIHN0YXRlLnVzZWREdXBsaWNhdGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG9iamVjdCwgb2JqZWN0cywgZHVwbGljYXRlc0luZGV4ZXMpIHtcbiAgdmFyIG9iamVjdEtleUxpc3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnKSB7XG4gICAgaW5kZXggPSBvYmplY3RzLmluZGV4T2Yob2JqZWN0KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoZHVwbGljYXRlc0luZGV4ZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGR1cGxpY2F0ZXNJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzLnB1c2gob2JqZWN0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3RbaW5kZXhdLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdEtleUxpc3QgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3RLZXlMaXN0Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICBpbnNwZWN0Tm9kZShvYmplY3Rbb2JqZWN0S2V5TGlzdFtpbmRleF1dLCBvYmplY3RzLCBkdXBsaWNhdGVzSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHVtcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUob3B0aW9ucyk7XG5cbiAgaWYgKCFzdGF0ZS5ub1JlZnMpIGdldER1cGxpY2F0ZVJlZmVyZW5jZXMoaW5wdXQsIHN0YXRlKTtcblxuICB2YXIgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAoc3RhdGUucmVwbGFjZXIpIHtcbiAgICB2YWx1ZSA9IHN0YXRlLnJlcGxhY2VyLmNhbGwoeyAnJzogdmFsdWUgfSwgJycsIHZhbHVlKTtcbiAgfVxuXG4gIGlmICh3cml0ZU5vZGUoc3RhdGUsIDAsIHZhbHVlLCB0cnVlLCB0cnVlKSkgcmV0dXJuIHN0YXRlLmR1bXAgKyAnXFxuJztcblxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzLmR1bXAgPSBkdW1wO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBsb2FkZXIgPSByZXF1aXJlKCcuL2xpYi9sb2FkZXInKTtcbnZhciBkdW1wZXIgPSByZXF1aXJlKCcuL2xpYi9kdW1wZXInKTtcblxuXG5mdW5jdGlvbiByZW5hbWVkKGZyb20sIHRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiB5YW1sLicgKyBmcm9tICsgJyBpcyByZW1vdmVkIGluIGpzLXlhbWwgNC4gJyArXG4gICAgICAnVXNlIHlhbWwuJyArIHRvICsgJyBpbnN0ZWFkLCB3aGljaCBpcyBub3cgc2FmZSBieSBkZWZhdWx0LicpO1xuICB9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzLlR5cGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi90eXBlJyk7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hJyk7XG5tb2R1bGUuZXhwb3J0cy5GQUlMU0FGRV9TQ0hFTUEgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hL2ZhaWxzYWZlJyk7XG5tb2R1bGUuZXhwb3J0cy5KU09OX1NDSEVNQSAgICAgICAgID0gcmVxdWlyZSgnLi9saWIvc2NoZW1hL2pzb24nKTtcbm1vZHVsZS5leHBvcnRzLkNPUkVfU0NIRU1BICAgICAgICAgPSByZXF1aXJlKCcuL2xpYi9zY2hlbWEvY29yZScpO1xubW9kdWxlLmV4cG9ydHMuREVGQVVMVF9TQ0hFTUEgICAgICA9IHJlcXVpcmUoJy4vbGliL3NjaGVtYS9kZWZhdWx0Jyk7XG5tb2R1bGUuZXhwb3J0cy5sb2FkICAgICAgICAgICAgICAgID0gbG9hZGVyLmxvYWQ7XG5tb2R1bGUuZXhwb3J0cy5sb2FkQWxsICAgICAgICAgICAgID0gbG9hZGVyLmxvYWRBbGw7XG5tb2R1bGUuZXhwb3J0cy5kdW1wICAgICAgICAgICAgICAgID0gZHVtcGVyLmR1bXA7XG5tb2R1bGUuZXhwb3J0cy5ZQU1MRXhjZXB0aW9uICAgICAgID0gcmVxdWlyZSgnLi9saWIvZXhjZXB0aW9uJyk7XG5cbi8vIFJlLWV4cG9ydCBhbGwgdHlwZXMgaW4gY2FzZSB1c2VyIHdhbnRzIHRvIGNyZWF0ZSBjdXN0b20gc2NoZW1hXG5tb2R1bGUuZXhwb3J0cy50eXBlcyA9IHtcbiAgYmluYXJ5OiAgICByZXF1aXJlKCcuL2xpYi90eXBlL2JpbmFyeScpLFxuICBmbG9hdDogICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvZmxvYXQnKSxcbiAgbWFwOiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL21hcCcpLFxuICBudWxsOiAgICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvbnVsbCcpLFxuICBwYWlyczogICAgIHJlcXVpcmUoJy4vbGliL3R5cGUvcGFpcnMnKSxcbiAgc2V0OiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL3NldCcpLFxuICB0aW1lc3RhbXA6IHJlcXVpcmUoJy4vbGliL3R5cGUvdGltZXN0YW1wJyksXG4gIGJvb2w6ICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9ib29sJyksXG4gIGludDogICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9pbnQnKSxcbiAgbWVyZ2U6ICAgICByZXF1aXJlKCcuL2xpYi90eXBlL21lcmdlJyksXG4gIG9tYXA6ICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9vbWFwJyksXG4gIHNlcTogICAgICAgcmVxdWlyZSgnLi9saWIvdHlwZS9zZXEnKSxcbiAgc3RyOiAgICAgICByZXF1aXJlKCcuL2xpYi90eXBlL3N0cicpXG59O1xuXG4vLyBSZW1vdmVkIGZ1bmN0aW9ucyBmcm9tIEpTLVlBTUwgMy4wLnhcbm1vZHVsZS5leHBvcnRzLnNhZmVMb2FkICAgICAgICAgICAgPSByZW5hbWVkKCdzYWZlTG9hZCcsICdsb2FkJyk7XG5tb2R1bGUuZXhwb3J0cy5zYWZlTG9hZEFsbCAgICAgICAgID0gcmVuYW1lZCgnc2FmZUxvYWRBbGwnLCAnbG9hZEFsbCcpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUR1bXAgICAgICAgICAgICA9IHJlbmFtZWQoJ3NhZmVEdW1wJywgJ2R1bXAnKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MYXp5ID0gdm9pZCAwO1xuY2xhc3MgTGF6eSB7XG4gICAgY29uc3RydWN0b3IoY3JlYXRvcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3JlYXRvciA9IGNyZWF0b3I7XG4gICAgfVxuICAgIGdldCBoYXNWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRvciA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNyZWF0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRvcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXAiLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0IHNvIHdlIGFsd2F5cyBnZXQgYSBjb25zaXN0ZW50XG4vLyBvYmogd2l0aCBrZXlzIGluIGEgY29uc2lzdGVudCBvcmRlci5cbmNvbnN0IG9wdHMgPSBbJ2luY2x1ZGVQcmVyZWxlYXNlJywgJ2xvb3NlJywgJ3J0bCddXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+XG4gICFvcHRpb25zID8ge31cbiAgOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IGxvb3NlOiB0cnVlIH1cbiAgOiBvcHRzLmZpbHRlcihrID0+IG9wdGlvbnNba10pLnJlZHVjZSgob3B0aW9ucywgaykgPT4ge1xuICAgIG9wdGlvbnNba10gPSB0cnVlXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfSwge30pXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyc1xufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlfWApXG4gICAgfVxuICAgIHRoaXMuZm9ybWF0KClcbiAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IHtNQVhfTEVOR1RIfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChZYWxsaXN0KSB7XG4gIFlhbGxpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiogKCkge1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyOyB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgICAgeWllbGQgd2Fsa2VyLnZhbHVlXG4gICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG5cbiAgcmV0dXJuIG5leHRcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQsIC4uLm5vZGVzKSB7XG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCAtIDFcbiAgfVxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBzdGFydDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHZhciByZXQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICYmIGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKVxuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpXG4gIH1cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbFxuICB9XG5cbiAgaWYgKHdhbGtlciAhPT0gdGhpcy5oZWFkICYmIHdhbGtlciAhPT0gdGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBub2Rlc1tpXSlcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0IChzZWxmLCBub2RlLCB2YWx1ZSkge1xuICB2YXIgaW5zZXJ0ZWQgPSBub2RlID09PSBzZWxmLmhlYWQgP1xuICAgIG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6XG4gICAgbmV3IE5vZGUodmFsdWUsIG5vZGUsIG5vZGUubmV4dCwgc2VsZilcblxuICBpZiAoaW5zZXJ0ZWQubmV4dCA9PT0gbnVsbCkge1xuICAgIHNlbGYudGFpbCA9IGluc2VydGVkXG4gIH1cbiAgaWYgKGluc2VydGVkLnByZXYgPT09IG51bGwpIHtcbiAgICBzZWxmLmhlYWQgPSBpbnNlcnRlZFxuICB9XG5cbiAgc2VsZi5sZW5ndGgrK1xuXG4gIHJldHVybiBpbnNlcnRlZFxufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuXG50cnkge1xuICAvLyBhZGQgaWYgc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yIGlzIHByZXNlbnRcbiAgcmVxdWlyZSgnLi9pdGVyYXRvci5qcycpKFlhbGxpc3QpXG59IGNhdGNoIChlcikge31cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBBIGxpbmtlZCBsaXN0IHRvIGtlZXAgdHJhY2sgb2YgcmVjZW50bHktdXNlZC1uZXNzXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbmNvbnN0IE1BWCA9IFN5bWJvbCgnbWF4JylcbmNvbnN0IExFTkdUSCA9IFN5bWJvbCgnbGVuZ3RoJylcbmNvbnN0IExFTkdUSF9DQUxDVUxBVE9SID0gU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbmNvbnN0IEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJylcbmNvbnN0IE1BWF9BR0UgPSBTeW1ib2woJ21heEFnZScpXG5jb25zdCBESVNQT1NFID0gU3ltYm9sKCdkaXNwb3NlJylcbmNvbnN0IE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpXG5jb25zdCBMUlVfTElTVCA9IFN5bWJvbCgnbHJ1TGlzdCcpXG5jb25zdCBDQUNIRSA9IFN5bWJvbCgnY2FjaGUnKVxuY29uc3QgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0JylcblxuY29uc3QgbmFpdmVMZW5ndGggPSAoKSA9PiAxXG5cbi8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9XG5cbiAgICBpZiAob3B0aW9ucy5tYXggJiYgKHR5cGVvZiBvcHRpb25zLm1heCAhPT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXggPCAwKSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpXG4gICAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICAgIGNvbnN0IG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4IHx8IEluZmluaXR5XG5cbiAgICBjb25zdCBsYyA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSA/IG5haXZlTGVuZ3RoIDogbGNcbiAgICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heEFnZSBtdXN0IGJlIGEgbnVtYmVyJylcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMFxuICAgIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2VcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG4gIHNldCBtYXggKG1MKSB7XG4gICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5XG4gICAgdHJpbSh0aGlzKVxuICB9XG4gIGdldCBtYXggKCkge1xuICAgIHJldHVybiB0aGlzW01BWF1cbiAgfVxuXG4gIHNldCBhbGxvd1N0YWxlIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfVxuICBnZXQgYWxsb3dTdGFsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH1cblxuICBzZXQgbWF4QWdlIChtQSkge1xuICAgIGlmICh0eXBlb2YgbUEgIT09ICdudW1iZXInKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJylcblxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfVxuICBnZXQgbWF4QWdlICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhfQUdFXVxuICB9XG5cbiAgLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG4gIHNldCBsZW5ndGhDYWxjdWxhdG9yIChsQykge1xuICAgIGlmICh0eXBlb2YgbEMgIT09ICdmdW5jdGlvbicpXG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG5cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGhpdCA9PiB7XG4gICAgICAgIGhpdC5sZW5ndGggPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpXG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBoaXQubGVuZ3RoXG4gICAgICB9KVxuICAgIH1cbiAgICB0cmltKHRoaXMpXG4gIH1cbiAgZ2V0IGxlbmd0aENhbGN1bGF0b3IgKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gfVxuXG4gIGdldCBsZW5ndGggKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH1cbiAgZ2V0IGl0ZW1Db3VudCAoKSB7IHJldHVybiB0aGlzW0xSVV9MSVNUXS5sZW5ndGggfVxuXG4gIHJmb3JFYWNoIChmbiwgdGhpc3ApIHtcbiAgICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICBjb25zdCBwcmV2ID0gd2Fsa2VyLnByZXZcbiAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2ggKGZuLCB0aGlzcCkge1xuICAgIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICAgIGZvciAobGV0IHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIGNvbnN0IG5leHQgPSB3YWxrZXIubmV4dFxuICAgICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgICB3YWxrZXIgPSBuZXh0XG4gICAgfVxuICB9XG5cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLmtleSlcbiAgfVxuXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoayA9PiBrLnZhbHVlKVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgdGhpc1tMUlVfTElTVF0uZm9yRWFjaChoaXQgPT4gdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpKVxuICAgIH1cblxuICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gICAgdGhpc1tMUlVfTElTVF0gPSBuZXcgWWFsbGlzdCgpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB9XG5cbiAgZHVtcCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChoaXQgPT5cbiAgICAgIGlzU3RhbGUodGhpcywgaGl0KSA/IGZhbHNlIDoge1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSkudG9BcnJheSgpLmZpbHRlcihoID0+IGgpXG4gIH1cblxuICBkdW1wTHJ1ICgpIHtcbiAgICByZXR1cm4gdGhpc1tMUlVfTElTVF1cbiAgfVxuXG4gIHNldCAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gICAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICAgIGlmIChtYXhBZ2UgJiYgdHlwZW9mIG1heEFnZSAhPT0gJ251bWJlcicpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhBZ2UgbXVzdCBiZSBhIG51bWJlcicpXG5cbiAgICBjb25zdCBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICAgIGNvbnN0IGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgICBpZiAodGhpc1tDQUNIRV0uaGFzKGtleSkpIHtcbiAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbQ0FDSEVdLmdldChrZXkpXG4gICAgICBjb25zdCBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgICAvLyBkaXNwb3NlIG9mIHRoZSBvbGQgb25lIGJlZm9yZSBvdmVyd3JpdGluZ1xuICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSlcbiAgICAgICAgICB0aGlzW0RJU1BPU0VdKGtleSwgaXRlbS52YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaXRlbS5ub3cgPSBub3dcbiAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlXG4gICAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgICAgaXRlbS5sZW5ndGggPSBsZW5cbiAgICAgIHRoaXMuZ2V0KGtleSlcbiAgICAgIHRyaW0odGhpcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgY29uc3QgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICAgIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgICBpZiAodGhpc1tESVNQT1NFXSlcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KVxuICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gICAgdHJpbSh0aGlzKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBoYXMgKGtleSkge1xuICAgIGlmICghdGhpc1tDQUNIRV0uaGFzKGtleSkpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdClcbiAgfVxuXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG4gIH1cblxuICBwZWVrIChrZXkpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG4gIH1cblxuICBwb3AgKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gICAgaWYgKCFub2RlKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGRlbCh0aGlzLCBub2RlKVxuICAgIHJldHVybiBub2RlLnZhbHVlXG4gIH1cblxuICBkZWwgKGtleSkge1xuICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgfVxuXG4gIGxvYWQgKGFycikge1xuICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgIHRoaXMucmVzZXQoKVxuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG4gICAgZm9yIChsZXQgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgICAgY29uc3QgaGl0ID0gYXJyW2xdXG4gICAgICBjb25zdCBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgICBpZiAoZXhwaXJlc0F0ID09PSAwKVxuICAgICAgICAvLyB0aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJ1bmUgKCkge1xuICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IGdldCh0aGlzLCBrZXksIGZhbHNlKSlcbiAgfVxufVxuXG5jb25zdCBnZXQgPSAoc2VsZiwga2V5LCBkb1VzZSkgPT4ge1xuICBjb25zdCBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBpZiAoc2VsZltVUERBVEVfQUdFX09OX0dFVF0pXG4gICAgICAgICAgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpXG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaXQudmFsdWVcbiAgfVxufVxuXG5jb25zdCBpc1N0YWxlID0gKHNlbGYsIGhpdCkgPT4ge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICByZXR1cm4gaGl0Lm1heEFnZSA/IGRpZmYgPiBoaXQubWF4QWdlXG4gICAgOiBzZWxmW01BWF9BR0VdICYmIChkaWZmID4gc2VsZltNQVhfQUdFXSlcbn1cblxuY29uc3QgdHJpbSA9IHNlbGYgPT4ge1xuICBpZiAoc2VsZltMRU5HVEhdID4gc2VsZltNQVhdKSB7XG4gICAgZm9yIChsZXQgd2Fsa2VyID0gc2VsZltMUlVfTElTVF0udGFpbDtcbiAgICAgIHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIGNvbnN0IHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVsID0gKHNlbGYsIG5vZGUpID0+IHtcbiAgaWYgKG5vZGUpIHtcbiAgICBjb25zdCBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKHNlbGZbRElTUE9TRV0pXG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcblxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbmNsYXNzIEVudHJ5IHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gICAgdGhpcy5ub3cgPSBub3dcbiAgICB0aGlzLm1heEFnZSA9IG1heEFnZSB8fCAwXG4gIH1cbn1cblxuY29uc3QgZm9yRWFjaFN0ZXAgPSAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSA9PiB7XG4gIGxldCBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKVxuICAgICAgaGl0ID0gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKGhpdClcbiAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHNlbGYpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbiIsIi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBSYW5nZSB7XG4gIGNvbnN0cnVjdG9yIChyYW5nZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByYW5nZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgLy8ganVzdCBwdXQgaXQgaW4gdGhlIHNldCBhbmQgcmV0dXJuXG4gICAgICB0aGlzLnJhdyA9IHJhbmdlLnZhbHVlXG4gICAgICB0aGlzLnNldCA9IFtbcmFuZ2VdXVxuICAgICAgdGhpcy5mb3JtYXQoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gICAgdGhpcy5yYXcgPSByYW5nZVxuICAgIHRoaXMuc2V0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgvXFxzKlxcfFxcfFxccyovKVxuICAgICAgLy8gbWFwIHRoZSByYW5nZSB0byBhIDJkIGFycmF5IG9mIGNvbXBhcmF0b3JzXG4gICAgICAubWFwKHJhbmdlID0+IHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpKVxuICAgICAgLy8gdGhyb3cgb3V0IGFueSBjb21wYXJhdG9yIGxpc3RzIHRoYXQgYXJlIGVtcHR5XG4gICAgICAvLyB0aGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IGl0IHdhcyBub3QgYSB2YWxpZCByYW5nZSwgd2hpY2ggaXMgYWxsb3dlZFxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgYnV0IHdpbGwgc3RpbGwgdGhyb3cgaWYgdGhlIFdIT0xFIHJhbmdlIGlzIGludmFsaWQuXG4gICAgICAuZmlsdGVyKGMgPT4gYy5sZW5ndGgpXG5cbiAgICBpZiAoIXRoaXMuc2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7cmFuZ2V9YClcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSBub3QgdGhlIG51bGwgc2V0LCB0aHJvdyBvdXQgbnVsbCBzZXRzLlxuICAgIGlmICh0aGlzLnNldC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBrZWVwIHRoZSBmaXJzdCBvbmUsIGluIGNhc2UgdGhleSdyZSBhbGwgbnVsbCBzZXRzXG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuc2V0WzBdXG4gICAgICB0aGlzLnNldCA9IHRoaXMuc2V0LmZpbHRlcihjID0+ICFpc051bGxTZXQoY1swXSkpXG4gICAgICBpZiAodGhpcy5zZXQubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnNldCA9IFtmaXJzdF1cbiAgICAgIGVsc2UgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbnkgdGhhdCBhcmUgKiwgdGhlbiB0aGUgcmFuZ2UgaXMganVzdCAqXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnNldCkge1xuICAgICAgICAgIGlmIChjLmxlbmd0aCA9PT0gMSAmJiBpc0FueShjWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBbY11cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQoKVxuICB9XG5cbiAgZm9ybWF0ICgpIHtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zZXRcbiAgICAgIC5tYXAoKGNvbXBzKSA9PiB7XG4gICAgICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ3x8JylcbiAgICAgIC50cmltKClcbiAgICByZXR1cm4gdGhpcy5yYW5nZVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICBwYXJzZVJhbmdlIChyYW5nZSkge1xuICAgIHJhbmdlID0gcmFuZ2UudHJpbSgpXG5cbiAgICAvLyBtZW1vaXplIHJhbmdlIHBhcnNpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIHRoaXMgaXMgYSB2ZXJ5IGhvdCBwYXRoLCBhbmQgZnVsbHkgZGV0ZXJtaW5pc3RpYy5cbiAgICBjb25zdCBtZW1vT3B0cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucykuam9pbignLCcpXG4gICAgY29uc3QgbWVtb0tleSA9IGBwYXJzZVJhbmdlOiR7bWVtb09wdHN9OiR7cmFuZ2V9YFxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChtZW1vS2V5KVxuICAgIGlmIChjYWNoZWQpXG4gICAgICByZXR1cm4gY2FjaGVkXG5cbiAgICBjb25zdCBsb29zZSA9IHRoaXMub3B0aW9ucy5sb29zZVxuICAgIC8vIGAxLjIuMyAtIDEuMi40YCA9PiBgPj0xLjIuMyA8PTEuMi40YFxuICAgIGNvbnN0IGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV1cbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UoaHIsIGh5cGhlblJlcGxhY2UodGhpcy5vcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSlcbiAgICBkZWJ1ZygnaHlwaGVuIHJlcGxhY2UnLCByYW5nZSlcbiAgICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5DT01QQVJBVE9SVFJJTV0sIGNvbXBhcmF0b3JUcmltUmVwbGFjZSlcbiAgICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW3QuQ09NUEFSQVRPUlRSSU1dKVxuXG4gICAgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSlcblxuICAgIC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpXG5cbiAgICAvLyBub3JtYWxpemUgc3BhY2VzXG4gICAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgICAvLyByZWFkeSB0byBiZSBzcGxpdCBpbnRvIGNvbXBhcmF0b3JzLlxuXG4gICAgY29uc3QgY29tcFJlID0gbG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdXG4gICAgY29uc3QgcmFuZ2VMaXN0ID0gcmFuZ2VcbiAgICAgIC5zcGxpdCgnICcpXG4gICAgICAubWFwKGNvbXAgPT4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAuam9pbignICcpXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLy8gPj0wLjAuMCBpcyBlcXVpdmFsZW50IHRvICpcbiAgICAgIC5tYXAoY29tcCA9PiByZXBsYWNlR1RFMChjb21wLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgLy8gaW4gbG9vc2UgbW9kZSwgdGhyb3cgb3V0IGFueSB0aGF0IGFyZSBub3QgdmFsaWQgY29tcGFyYXRvcnNcbiAgICAgIC5maWx0ZXIodGhpcy5vcHRpb25zLmxvb3NlID8gY29tcCA9PiAhIWNvbXAubWF0Y2goY29tcFJlKSA6ICgpID0+IHRydWUpXG4gICAgICAubWFwKGNvbXAgPT4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcblxuICAgIC8vIGlmIGFueSBjb21wYXJhdG9ycyBhcmUgdGhlIG51bGwgc2V0LCB0aGVuIHJlcGxhY2Ugd2l0aCBKVVNUIG51bGwgc2V0XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBjb21wYXJhdG9yLCByZW1vdmUgYW55ICogY29tcGFyYXRvcnNcbiAgICAvLyBhbHNvLCBkb24ndCBpbmNsdWRlIHRoZSBzYW1lIGNvbXBhcmF0b3IgbW9yZSB0aGFuIG9uY2VcbiAgICBjb25zdCBsID0gcmFuZ2VMaXN0Lmxlbmd0aFxuICAgIGNvbnN0IHJhbmdlTWFwID0gbmV3IE1hcCgpXG4gICAgZm9yIChjb25zdCBjb21wIG9mIHJhbmdlTGlzdCkge1xuICAgICAgaWYgKGlzTnVsbFNldChjb21wKSlcbiAgICAgICAgcmV0dXJuIFtjb21wXVxuICAgICAgcmFuZ2VNYXAuc2V0KGNvbXAudmFsdWUsIGNvbXApXG4gICAgfVxuICAgIGlmIChyYW5nZU1hcC5zaXplID4gMSAmJiByYW5nZU1hcC5oYXMoJycpKVxuICAgICAgcmFuZ2VNYXAuZGVsZXRlKCcnKVxuXG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLnJhbmdlTWFwLnZhbHVlcygpXVxuICAgIGNhY2hlLnNldChtZW1vS2V5LCByZXN1bHQpXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgaW50ZXJzZWN0cyAocmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoKHRoaXNDb21wYXJhdG9ycykgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmXG4gICAgICAgIHJhbmdlLnNldC5zb21lKChyYW5nZUNvbXBhcmF0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzU2F0aXNmaWFibGUocmFuZ2VDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgICAgIHRoaXNDb21wYXJhdG9ycy5ldmVyeSgodGhpc0NvbXBhcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoKHJhbmdlQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ29tcGFyYXRvci5pbnRlcnNlY3RzKHJhbmdlQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICAvLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBpZiAoIXZlcnNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlXG5cbmNvbnN0IExSVSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpXG5jb25zdCBjYWNoZSA9IG5ldyBMUlUoeyBtYXg6IDEwMDAgfSlcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi9jb21wYXJhdG9yJylcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvZGVidWcnKVxuY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi9zZW12ZXInKVxuY29uc3Qge1xuICByZSxcbiAgdCxcbiAgY29tcGFyYXRvclRyaW1SZXBsYWNlLFxuICB0aWxkZVRyaW1SZXBsYWNlLFxuICBjYXJldFRyaW1SZXBsYWNlXG59ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuXG5jb25zdCBpc051bGxTZXQgPSBjID0+IGMudmFsdWUgPT09ICc8MC4wLjAtMCdcbmNvbnN0IGlzQW55ID0gYyA9PiBjLnZhbHVlID09PSAnJ1xuXG4vLyB0YWtlIGEgc2V0IG9mIGNvbXBhcmF0b3JzIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGVyZVxuLy8gZXhpc3RzIGEgdmVyc2lvbiB3aGljaCBjYW4gc2F0aXNmeSBpdFxuY29uc3QgaXNTYXRpc2ZpYWJsZSA9IChjb21wYXJhdG9ycywgb3B0aW9ucykgPT4ge1xuICBsZXQgcmVzdWx0ID0gdHJ1ZVxuICBjb25zdCByZW1haW5pbmdDb21wYXJhdG9ycyA9IGNvbXBhcmF0b3JzLnNsaWNlKClcbiAgbGV0IHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKClcblxuICB3aGlsZSAocmVzdWx0ICYmIHJlbWFpbmluZ0NvbXBhcmF0b3JzLmxlbmd0aCkge1xuICAgIHJlc3VsdCA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLmV2ZXJ5KChvdGhlckNvbXBhcmF0b3IpID0+IHtcbiAgICAgIHJldHVybiB0ZXN0Q29tcGFyYXRvci5pbnRlcnNlY3RzKG90aGVyQ29tcGFyYXRvciwgb3B0aW9ucylcbiAgICB9KVxuXG4gICAgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5jb25zdCBwYXJzZUNvbXBhcmF0b3IgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygnY29tcCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbXAgPSByZXBsYWNlQ2FyZXRzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCdjYXJldCcsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpXG4gIGRlYnVnKCd0aWxkZXMnLCBjb21wKVxuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3hyYW5nZScsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlU3RhcnMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3N0YXJzJywgY29tcClcbiAgcmV0dXJuIGNvbXBcbn1cblxuY29uc3QgaXNYID0gaWQgPT4gIWlkIHx8IGlkLnRvTG93ZXJDYXNlKCkgPT09ICd4JyB8fCBpZCA9PT0gJyonXG5cbi8vIH4sIH4+IC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMC0wXG4vLyB+MS4yLCB+MS4yLngsIH4+MS4yLCB+PjEuMi54IC0tPiA+PTEuMi4wIDwxLjMuMC0wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0+ID49MS4yLjMgPDEuMy4wLTBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjAtMFxuY29uc3QgcmVwbGFjZVRpbGRlcyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VUaWxkZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5USUxERUxPT1NFXSA6IHJlW3QuVElMREVdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAgPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgLy8gfjEuMiA9PSA+PTEuMi4wIDwxLjMuMC0wXG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcilcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygndGlsZGUgcmV0dXJuJywgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gXiAtLT4gKiAoYW55LCBraW5kYSBzaWxseSlcbi8vIF4yLCBeMi54LCBeMi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIF4yLjAsIF4yLjAueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMC0wXG4vLyBeMS4yLjMgLS0+ID49MS4yLjMgPDIuMC4wLTBcbi8vIF4xLjIuMCAtLT4gPj0xLjIuMCA8Mi4wLjAtMFxuY29uc3QgcmVwbGFjZUNhcmV0cyA9IChjb21wLCBvcHRpb25zKSA9PlxuICBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcCgoY29tcCkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG5cbmNvbnN0IHJlcGxhY2VDYXJldCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5DQVJFVExPT1NFXSA6IHJlW3QuQ0FSRVRdXG4gIGNvbnN0IHogPSBvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlID8gJy0wJyA6ICcnXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKF8sIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpXG4gICAgbGV0IHJldFxuXG4gICAgaWYgKGlzWChNKSkge1xuICAgICAgcmV0ID0gJydcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gYD49JHtNfS4wLjAke3p9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwfS0ke3ByXG4gICAgICAgICAgfSA8JHtNfS4ke219LiR7K3AgKyAxfS0wYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKVxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICAgIH0ke3p9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3BcbiAgICAgICAgfSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjYXJldCByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG5jb25zdCByZXBsYWNlWFJhbmdlcyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlWFJhbmdlcycsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VYUmFuZ2UoY29tcCwgb3B0aW9ucylcbiAgfSkuam9pbignICcpXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2UgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBjb21wID0gY29tcC50cmltKClcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXVxuICByZXR1cm4gY29tcC5yZXBsYWNlKHIsIChyZXQsIGd0bHQsIE0sIG0sIHAsIHByKSA9PiB7XG4gICAgZGVidWcoJ3hSYW5nZScsIGNvbXAsIHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpXG4gICAgY29uc3QgeE0gPSBpc1goTSlcbiAgICBjb25zdCB4bSA9IHhNIHx8IGlzWChtKVxuICAgIGNvbnN0IHhwID0geG0gfHwgaXNYKHApXG4gICAgY29uc3QgYW55WCA9IHhwXG5cbiAgICBpZiAoZ3RsdCA9PT0gJz0nICYmIGFueVgpIHtcbiAgICAgIGd0bHQgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGluY2x1ZGluZyBwcmVyZWxlYXNlcyBpbiB0aGUgbWF0Y2gsIHRoZW4gd2UgbmVlZFxuICAgIC8vIHRvIGZpeCB0aGlzIHRvIC0wLCB0aGUgbG93ZXN0IHBvc3NpYmxlIHByZXJlbGVhc2UgdmFsdWVcbiAgICBwciA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgaXMgZm9yYmlkZGVuXG4gICAgICAgIHJldCA9ICcqJ1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3RsdCAmJiBhbnlYKSB7XG4gICAgICAvLyB3ZSBrbm93IHBhdGNoIGlzIGFuIHgsIGJlY2F1c2Ugd2UgaGF2ZSBhbnkgeCBhdCBhbGwuXG4gICAgICAvLyByZXBsYWNlIFggd2l0aCAwXG4gICAgICBpZiAoeG0pIHtcbiAgICAgICAgbSA9IDBcbiAgICAgIH1cbiAgICAgIHAgPSAwXG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgZ3RsdCA9ICc+PSdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICAgIG0gPSAwXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgICAgcCA9IDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtID0gK20gKyAxXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGd0bHQgPT09ICc8JylcbiAgICAgICAgcHIgPSAnLTAnXG5cbiAgICAgIHJldCA9IGAke2d0bHQgKyBNfS4ke219LiR7cH0ke3ByfWBcbiAgICB9IGVsc2UgaWYgKHhtKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7cHJ9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgcmV0ID0gYD49JHtNfS4ke219LjAke3ByXG4gICAgICB9IDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpXG5cbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbi8vIEJlY2F1c2UgKiBpcyBBTkQtZWQgd2l0aCBldmVyeXRoaW5nIGVsc2UgaW4gdGhlIGNvbXBhcmF0b3IsXG4vLyBhbmQgJycgbWVhbnMgXCJhbnkgdmVyc2lvblwiLCBqdXN0IHJlbW92ZSB0aGUgKnMgZW50aXJlbHkuXG5jb25zdCByZXBsYWNlU3RhcnMgPSAoY29tcCwgb3B0aW9ucykgPT4ge1xuICBkZWJ1ZygncmVwbGFjZVN0YXJzJywgY29tcCwgb3B0aW9ucylcbiAgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG4gIHJldHVybiBjb21wLnRyaW0oKS5yZXBsYWNlKHJlW3QuU1RBUl0sICcnKVxufVxuXG5jb25zdCByZXBsYWNlR1RFMCA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlR1RFMCcsIGNvbXAsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wLnRyaW0oKVxuICAgIC5yZXBsYWNlKHJlW29wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyB0LkdURTBQUkUgOiB0LkdURTBdLCAnJylcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbdC5IWVBIRU5SQU5HRV0pXG4vLyBNLCBtLCBwYXRjaCwgcHJlcmVsZWFzZSwgYnVpbGRcbi8vIDEuMiAtIDMuNC41ID0+ID49MS4yLjAgPD0zLjQuNVxuLy8gMS4yLjMgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wLTBcbmNvbnN0IGh5cGhlblJlcGxhY2UgPSBpbmNQciA9PiAoJDAsXG4gIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSA9PiB7XG4gIGlmIChpc1goZk0pKSB7XG4gICAgZnJvbSA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSBgPj0ke2ZNfS4wLjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChpc1goZnApKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LiR7Zm19LjAke2luY1ByID8gJy0wJyA6ICcnfWBcbiAgfSBlbHNlIGlmIChmcHIpIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfWBcbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYD49JHtmcm9tfSR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnXG4gIH0gZWxzZSBpZiAoaXNYKHRtKSkge1xuICAgIHRvID0gYDwkeyt0TSArIDF9LjAuMC0wYFxuICB9IGVsc2UgaWYgKGlzWCh0cCkpIHtcbiAgICB0byA9IGA8JHt0TX0uJHsrdG0gKyAxfS4wLTBgXG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSBgPD0ke3RNfS4ke3RtfS4ke3RwfS0ke3Rwcn1gXG4gIH0gZWxzZSBpZiAoaW5jUHIpIHtcbiAgICB0byA9IGA8JHt0TX0uJHt0bX0uJHsrdHAgKyAxfS0wYFxuICB9IGVsc2Uge1xuICAgIHRvID0gYDw9JHt0b31gXG4gIH1cblxuICByZXR1cm4gKGAke2Zyb219ICR7dG99YCkudHJpbSgpXG59XG5cbmNvbnN0IHRlc3RTZXQgPSAoc2V0LCB2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFzZXRbaV0udGVzdCh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggJiYgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAvLyBGaW5kIHRoZSBzZXQgb2YgdmVyc2lvbnMgdGhhdCBhcmUgYWxsb3dlZCB0byBoYXZlIHByZXJlbGVhc2VzXG4gICAgLy8gRm9yIGV4YW1wbGUsIF4xLjIuMy1wci4xIGRlc3VnYXJzIHRvID49MS4yLjMtcHIuMSA8Mi4wLjBcbiAgICAvLyBUaGF0IHNob3VsZCBhbGxvdyBgMS4yLjMtcHIuMmAgdG8gcGFzcy5cbiAgICAvLyBIb3dldmVyLCBgMS4yLjQtYWxwaGEubm90cmVhZHlgIHNob3VsZCBOT1QgYmUgYWxsb3dlZCxcbiAgICAvLyBldmVuIHRob3VnaCBpdCdzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGJ5IHRoZSBjb21wYXJhdG9ycy5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgZGVidWcoc2V0W2ldLnNlbXZlcilcbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyID09PSBDb21wYXJhdG9yLkFOWSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXJcbiAgICAgICAgaWYgKGFsbG93ZWQubWFqb3IgPT09IHZlcnNpb24ubWFqb3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiZcbiAgICAgICAgICAgIGFsbG93ZWQucGF0Y2ggPT09IHZlcnNpb24ucGF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiBoYXMgYSAtcHJlLCBidXQgaXQncyBub3Qgb25lIG9mIHRoZSBvbmVzIHdlIGxpa2UuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuIiwiY29uc3QgQU5ZID0gU3ltYm9sKCdTZW1WZXIgQU5ZJylcbi8vIGhvaXN0ZWQgY2xhc3MgZm9yIGN5Y2xpYyBkZXBlbmRlbmN5XG5jbGFzcyBDb21wYXJhdG9yIHtcbiAgc3RhdGljIGdldCBBTlkgKCkge1xuICAgIHJldHVybiBBTllcbiAgfVxuICBjb25zdHJ1Y3RvciAoY29tcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBwYXJzZU9wdGlvbnMob3B0aW9ucylcblxuICAgIGlmIChjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSkge1xuICAgICAgICByZXR1cm4gY29tcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcCA9IGNvbXAudmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICB0aGlzLnBhcnNlKGNvbXApXG5cbiAgICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgdGhpcy52YWx1ZSA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvblxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wJywgdGhpcylcbiAgfVxuXG4gIHBhcnNlIChjb21wKSB7XG4gICAgY29uc3QgciA9IHRoaXMub3B0aW9ucy5sb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCBtID0gY29tcC5tYXRjaChyKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7Y29tcH1gKVxuICAgIH1cblxuICAgIHRoaXMub3BlcmF0b3IgPSBtWzFdICE9PSB1bmRlZmluZWQgPyBtWzFdIDogJydcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICB0aGlzLm9wZXJhdG9yID0gJydcbiAgICB9XG5cbiAgICAvLyBpZiBpdCBsaXRlcmFsbHkgaXMganVzdCAnPicgb3IgJycgdGhlbiBhbGxvdyBhbnl0aGluZy5cbiAgICBpZiAoIW1bMl0pIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gQU5ZXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtdmVyID0gbmV3IFNlbVZlcihtWzJdLCB0aGlzLm9wdGlvbnMubG9vc2UpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlXG4gIH1cblxuICB0ZXN0ICh2ZXJzaW9uKSB7XG4gICAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSlcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21wKHZlcnNpb24sIHRoaXMub3BlcmF0b3IsIHRoaXMuc2VtdmVyLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbnRlcnNlY3RzIChjb21wLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxvb3NlOiAhIW9wdGlvbnMsXG4gICAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnJykge1xuICAgICAgaWYgKHRoaXMudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpLnRlc3QodGhpcy52YWx1ZSlcbiAgICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAoY29tcC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy52YWx1ZSwgb3B0aW9ucykudGVzdChjb21wLnNlbXZlcilcbiAgICB9XG5cbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpXG4gICAgY29uc3Qgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICAgKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uXG4gICAgY29uc3QgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzw9JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JylcbiAgICBjb25zdCBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhbiA9XG4gICAgICBjbXAodGhpcy5zZW12ZXIsICc+JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmXG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcblxuICAgIHJldHVybiAoXG4gICAgICBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fFxuICAgICAgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgfHxcbiAgICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNMZXNzVGhhbiB8fFxuICAgICAgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW5cbiAgICApXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wYXJhdG9yXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3Qge3JlLCB0fSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3JlJylcbmNvbnN0IGNtcCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jbXAnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4vcmFuZ2UnKVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiByYW5nZS50ZXN0KHZlcnNpb24pXG59XG5tb2R1bGUuZXhwb3J0cyA9IHNhdGlzZmllc1xuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuLy8gTW9zdGx5IGp1c3QgZm9yIHRlc3RpbmcgYW5kIGxlZ2FjeSBBUEkgcmVhc29uc1xuY29uc3QgdG9Db21wYXJhdG9ycyA9IChyYW5nZSwgb3B0aW9ucykgPT5cbiAgbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXRcbiAgICAubWFwKGNvbXAgPT4gY29tcC5tYXAoYyA9PiBjLnZhbHVlKS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJykpXG5cbm1vZHVsZS5leHBvcnRzID0gdG9Db21wYXJhdG9yc1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcblxuY29uc3QgbWF4U2F0aXNmeWluZyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgbGV0IG1heCA9IG51bGxcbiAgbGV0IG1heFNWID0gbnVsbFxuICBsZXQgcmFuZ2VPYmogPSBudWxsXG4gIHRyeSB7XG4gICAgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHtcbiAgICAgIC8vIHNhdGlzZmllcyh2LCByYW5nZSwgb3B0aW9ucylcbiAgICAgIGlmICghbWF4IHx8IG1heFNWLmNvbXBhcmUodikgPT09IC0xKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWF4LCB2LCB0cnVlKVxuICAgICAgICBtYXggPSB2XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4XG59XG5tb2R1bGUuZXhwb3J0cyA9IG1heFNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBtaW5TYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWluID0gbnVsbFxuICBsZXQgbWluU1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdlxuICAgICAgICBtaW5TViA9IG5ldyBTZW1WZXIobWluLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG1pblxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5TYXRpc2Z5aW5nXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuXG5jb25zdCBtaW5WZXJzaW9uID0gKHJhbmdlLCBsb29zZSkgPT4ge1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgbG9vc2UpXG5cbiAgbGV0IG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJylcbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXJcbiAgfVxuXG4gIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wLTAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbnVsbFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgc2V0TWluID0gbnVsbFxuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goKGNvbXBhcmF0b3IpID0+IHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICBjb25zdCBjb21wdmVyID0gbmV3IFNlbVZlcihjb21wYXJhdG9yLnNlbXZlci52ZXJzaW9uKVxuICAgICAgc3dpdGNoIChjb21wYXJhdG9yLm9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgIGlmIChjb21wdmVyLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb21wdmVyLnBhdGNoKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHZlci5wcmVyZWxlYXNlLnB1c2goMClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcHZlci5yYXcgPSBjb21wdmVyLmZvcm1hdCgpXG4gICAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIGlmICghc2V0TWluIHx8IGd0KGNvbXB2ZXIsIHNldE1pbikpIHtcbiAgICAgICAgICAgIHNldE1pbiA9IGNvbXB2ZXJcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAvKiBJZ25vcmUgbWF4aW11bSB2ZXJzaW9ucyAqL1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG9wZXJhdGlvbjogJHtjb21wYXJhdG9yLm9wZXJhdG9yfWApXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoc2V0TWluICYmICghbWludmVyIHx8IGd0KG1pbnZlciwgc2V0TWluKSkpXG4gICAgICBtaW52ZXIgPSBzZXRNaW5cbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gbWluVmVyc2lvblxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHZhbGlkUmFuZ2UgPSAocmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gJyonIGluc3RlYWQgb2YgJycgc28gdGhhdCB0cnV0aGluZXNzIHdvcmtzLlxuICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiBpdCdzIGludmFsaWQgYW55d2F5XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucykucmFuZ2UgfHwgJyonXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZFJhbmdlXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBDb21wYXJhdG9yID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9jb21wYXJhdG9yJylcbmNvbnN0IHtBTll9ID0gQ29tcGFyYXRvclxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3QnKVxuY29uc3QgbHQgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHQnKVxuY29uc3QgbHRlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2x0ZScpXG5jb25zdCBndGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvZ3RlJylcblxuY29uc3Qgb3V0c2lkZSA9ICh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykgPT4ge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKVxuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcblxuICBsZXQgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0XG4gICAgICBsdGVmbiA9IGx0ZVxuICAgICAgbHRmbiA9IGx0XG4gICAgICBjb21wID0gJz4nXG4gICAgICBlY29tcCA9ICc+PSdcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnPCc6XG4gICAgICBndGZuID0gbHRcbiAgICAgIGx0ZWZuID0gZ3RlXG4gICAgICBsdGZuID0gZ3RcbiAgICAgIGNvbXAgPSAnPCdcbiAgICAgIGVjb21wID0gJzw9J1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCBwcm92aWRlIGEgaGlsbyB2YWwgb2YgXCI8XCIgb3IgXCI+XCInKVxuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNmaWVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnNldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldXG5cbiAgICBsZXQgaGlnaCA9IG51bGxcbiAgICBsZXQgbG93ID0gbnVsbFxuXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgaWYgKGNvbXBhcmF0b3Iuc2VtdmVyID09PSBBTlkpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJylcbiAgICAgIH1cbiAgICAgIGhpZ2ggPSBoaWdoIHx8IGNvbXBhcmF0b3JcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yXG4gICAgICB9IGVsc2UgaWYgKGx0Zm4oY29tcGFyYXRvci5zZW12ZXIsIGxvdy5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGxvdyA9IGNvbXBhcmF0b3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBsb3dlc3QgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhbiBvcGVyYXRvciBhbmQgb3VyIHZlcnNpb25cbiAgICAvLyBpcyBsZXNzIHRoYW4gaXQgdGhlbiBpdCBpc24ndCBoaWdoZXIgdGhhbiB0aGUgcmFuZ2VcbiAgICBpZiAoKCFsb3cub3BlcmF0b3IgfHwgbG93Lm9wZXJhdG9yID09PSBjb21wKSAmJlxuICAgICAgICBsdGVmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG91dHNpZGVcbiIsIi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGdyZWF0ZXIgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZS5cbmNvbnN0IG91dHNpZGUgPSByZXF1aXJlKCcuL291dHNpZGUnKVxuY29uc3QgZ3RyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPicsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGd0clxuIiwiY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG4vLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcbmNvbnN0IGx0ciA9ICh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykgPT4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKVxubW9kdWxlLmV4cG9ydHMgPSBsdHJcbiIsImNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBpbnRlcnNlY3RzID0gKHIxLCByMiwgb3B0aW9ucykgPT4ge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnNlY3RzXG4iLCIvLyBnaXZlbiBhIHNldCBvZiB2ZXJzaW9ucyBhbmQgYSByYW5nZSwgY3JlYXRlIGEgXCJzaW1wbGlmaWVkXCIgcmFuZ2Vcbi8vIHRoYXQgaW5jbHVkZXMgdGhlIHNhbWUgdmVyc2lvbnMgdGhhdCB0aGUgb3JpZ2luYWwgcmFuZ2UgZG9lc1xuLy8gSWYgdGhlIG9yaWdpbmFsIHJhbmdlIGlzIHNob3J0ZXIgdGhhbiB0aGUgc2ltcGxpZmllZCBvbmUsIHJldHVybiB0aGF0LlxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxubW9kdWxlLmV4cG9ydHMgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHNldCA9IFtdXG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBwcmV2ID0gbnVsbFxuICBjb25zdCB2ID0gdmVyc2lvbnMuc29ydCgoYSwgYikgPT4gY29tcGFyZShhLCBiLCBvcHRpb25zKSlcbiAgZm9yIChjb25zdCB2ZXJzaW9uIG9mIHYpIHtcbiAgICBjb25zdCBpbmNsdWRlZCA9IHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucylcbiAgICBpZiAoaW5jbHVkZWQpIHtcbiAgICAgIHByZXYgPSB2ZXJzaW9uXG4gICAgICBpZiAoIW1pbilcbiAgICAgICAgbWluID0gdmVyc2lvblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJldikge1xuICAgICAgICBzZXQucHVzaChbbWluLCBwcmV2XSlcbiAgICAgIH1cbiAgICAgIHByZXYgPSBudWxsXG4gICAgICBtaW4gPSBudWxsXG4gICAgfVxuICB9XG4gIGlmIChtaW4pXG4gICAgc2V0LnB1c2goW21pbiwgbnVsbF0pXG5cbiAgY29uc3QgcmFuZ2VzID0gW11cbiAgZm9yIChjb25zdCBbbWluLCBtYXhdIG9mIHNldCkge1xuICAgIGlmIChtaW4gPT09IG1heClcbiAgICAgIHJhbmdlcy5wdXNoKG1pbilcbiAgICBlbHNlIGlmICghbWF4ICYmIG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKCcqJylcbiAgICBlbHNlIGlmICghbWF4KVxuICAgICAgcmFuZ2VzLnB1c2goYD49JHttaW59YClcbiAgICBlbHNlIGlmIChtaW4gPT09IHZbMF0pXG4gICAgICByYW5nZXMucHVzaChgPD0ke21heH1gKVxuICAgIGVsc2VcbiAgICAgIHJhbmdlcy5wdXNoKGAke21pbn0gLSAke21heH1gKVxuICB9XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSByYW5nZXMuam9pbignIHx8ICcpXG4gIGNvbnN0IG9yaWdpbmFsID0gdHlwZW9mIHJhbmdlLnJhdyA9PT0gJ3N0cmluZycgPyByYW5nZS5yYXcgOiBTdHJpbmcocmFuZ2UpXG4gIHJldHVybiBzaW1wbGlmaWVkLmxlbmd0aCA8IG9yaWdpbmFsLmxlbmd0aCA/IHNpbXBsaWZpZWQgOiByYW5nZVxufVxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlLmpzJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3IuanMnKVxuY29uc3QgeyBBTlkgfSA9IENvbXBhcmF0b3JcbmNvbnN0IHNhdGlzZmllcyA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9zYXRpc2ZpZXMuanMnKVxuY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9jb21wYXJlLmpzJylcblxuLy8gQ29tcGxleCByYW5nZSBgcjEgfHwgcjIgfHwgLi4uYCBpcyBhIHN1YnNldCBvZiBgUjEgfHwgUjIgfHwgLi4uYCBpZmY6XG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIGlzIGEgbnVsbCBzZXQsIE9SXG4vLyAtIEV2ZXJ5IHNpbXBsZSByYW5nZSBgcjEsIHIyLCAuLi5gIHdoaWNoIGlzIG5vdCBhIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mXG4vLyAgIHNvbWUgYFIxLCBSMiwgLi4uYFxuLy9cbi8vIFNpbXBsZSByYW5nZSBgYzEgYzIgLi4uYCBpcyBhIHN1YnNldCBvZiBzaW1wbGUgcmFuZ2UgYEMxIEMyIC4uLmAgaWZmOlxuLy8gLSBJZiBjIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gSWYgQyBpcyBvbmx5IHRoZSBBTlkgY29tcGFyYXRvciwgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIGlmIGluIHByZXJlbGVhc2UgbW9kZSwgcmV0dXJuIGZhbHNlXG4vLyAgIC0gZWxzZSByZXBsYWNlIGMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yXG4vLyAgIC0gaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gdHJ1ZVxuLy8gICAtIGVsc2UgcmVwbGFjZSBDIHdpdGggYFs+PTAuMC4wXWBcbi8vIC0gTGV0IEVRIGJlIHRoZSBzZXQgb2YgPSBjb21wYXJhdG9ycyBpbiBjXG4vLyAtIElmIEVRIGlzIG1vcmUgdGhhbiBvbmUsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vIC0gTGV0IEdUIGJlIHRoZSBoaWdoZXN0ID4gb3IgPj0gY29tcGFyYXRvciBpbiBjXG4vLyAtIExldCBMVCBiZSB0aGUgbG93ZXN0IDwgb3IgPD0gY29tcGFyYXRvciBpbiBjXG4vLyAtIElmIEdUIGFuZCBMVCwgYW5kIEdULnNlbXZlciA+IExULnNlbXZlciwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBJZiBhbnkgQyBpcyBhID0gcmFuZ2UsIGFuZCBHVCBvciBMVCBhcmUgc2V0LCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgRVFcbi8vICAgLSBJZiBHVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgR1QsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBMVCwgYW5kIEVRIGRvZXMgbm90IHNhdGlzZnkgTFQsIHJldHVybiB0cnVlIChudWxsIHNldClcbi8vICAgLSBJZiBFUSBzYXRpc2ZpZXMgZXZlcnkgQywgcmV0dXJuIHRydWVcbi8vICAgLSBFbHNlIHJldHVybiBmYWxzZVxuLy8gLSBJZiBHVFxuLy8gICAtIElmIEdULnNlbXZlciBpcyBsb3dlciB0aGFuIGFueSA+IG9yID49IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1QgaXMgPj0sIGFuZCBHVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIEdULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIElmIExUXG4vLyAgIC0gSWYgTFQuc2VtdmVyIGlzIGdyZWF0ZXIgdGhhbiBhbnkgPCBvciA8PSBjb21wIGluIEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIExUIGlzIDw9LCBhbmQgTFQuc2VtdmVyIGRvZXMgbm90IHNhdGlzZnkgZXZlcnkgQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGhhcyBhIHByZXJlbGVhc2UsIGFuZCBub3QgaW4gcHJlcmVsZWFzZSBtb2RlXG4vLyAgICAgLSBJZiBubyBDIGhhcyBhIHByZXJlbGVhc2UgYW5kIHRoZSBMVC5zZW12ZXIgdHVwbGUsIHJldHVybiBmYWxzZVxuLy8gLSBFbHNlIHJldHVybiB0cnVlXG5cbmNvbnN0IHN1YnNldCA9IChzdWIsIGRvbSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIHN1YiA9IG5ldyBSYW5nZShzdWIsIG9wdGlvbnMpXG4gIGRvbSA9IG5ldyBSYW5nZShkb20sIG9wdGlvbnMpXG4gIGxldCBzYXdOb25OdWxsID0gZmFsc2VcblxuICBPVVRFUjogZm9yIChjb25zdCBzaW1wbGVTdWIgb2Ygc3ViLnNldCkge1xuICAgIGZvciAoY29uc3Qgc2ltcGxlRG9tIG9mIGRvbS5zZXQpIHtcbiAgICAgIGNvbnN0IGlzU3ViID0gc2ltcGxlU3Vic2V0KHNpbXBsZVN1Yiwgc2ltcGxlRG9tLCBvcHRpb25zKVxuICAgICAgc2F3Tm9uTnVsbCA9IHNhd05vbk51bGwgfHwgaXNTdWIgIT09IG51bGxcbiAgICAgIGlmIChpc1N1YilcbiAgICAgICAgY29udGludWUgT1VURVJcbiAgICB9XG4gICAgLy8gdGhlIG51bGwgc2V0IGlzIGEgc3Vic2V0IG9mIGV2ZXJ5dGhpbmcsIGJ1dCBudWxsIHNpbXBsZSByYW5nZXMgaW5cbiAgICAvLyBhIGNvbXBsZXggcmFuZ2Ugc2hvdWxkIGJlIGlnbm9yZWQuICBzbyBpZiB3ZSBzYXcgYSBub24tbnVsbCByYW5nZSxcbiAgICAvLyB0aGVuIHdlIGtub3cgdGhpcyBpc24ndCBhIHN1YnNldCwgYnV0IGlmIEVWRVJZIHNpbXBsZSByYW5nZSB3YXMgbnVsbCxcbiAgICAvLyB0aGVuIGl0IGlzIGEgc3Vic2V0LlxuICAgIGlmIChzYXdOb25OdWxsKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3Qgc2ltcGxlU3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zKSA9PiB7XG4gIGlmIChzdWIgPT09IGRvbSlcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIGlmIChzdWIubGVuZ3RoID09PSAxICYmIHN1YlswXS5zZW12ZXIgPT09IEFOWSkge1xuICAgIGlmIChkb20ubGVuZ3RoID09PSAxICYmIGRvbVswXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZSBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAtMCcpIF1cbiAgICBlbHNlXG4gICAgICBzdWIgPSBbIG5ldyBDb21wYXJhdG9yKCc+PTAuMC4wJykgXVxuICB9XG5cbiAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGVsc2VcbiAgICAgIGRvbSA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBjb25zdCBlcVNldCA9IG5ldyBTZXQoKVxuICBsZXQgZ3QsIGx0XG4gIGZvciAoY29uc3QgYyBvZiBzdWIpIHtcbiAgICBpZiAoYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PScpXG4gICAgICBndCA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgIGVsc2UgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKVxuICAgICAgbHQgPSBsb3dlckxUKGx0LCBjLCBvcHRpb25zKVxuICAgIGVsc2VcbiAgICAgIGVxU2V0LmFkZChjLnNlbXZlcilcbiAgfVxuXG4gIGlmIChlcVNldC5zaXplID4gMSlcbiAgICByZXR1cm4gbnVsbFxuXG4gIGxldCBndGx0Q29tcFxuICBpZiAoZ3QgJiYgbHQpIHtcbiAgICBndGx0Q29tcCA9IGNvbXBhcmUoZ3Quc2VtdmVyLCBsdC5zZW12ZXIsIG9wdGlvbnMpXG4gICAgaWYgKGd0bHRDb21wID4gMClcbiAgICAgIHJldHVybiBudWxsXG4gICAgZWxzZSBpZiAoZ3RsdENvbXAgPT09IDAgJiYgKGd0Lm9wZXJhdG9yICE9PSAnPj0nIHx8IGx0Lm9wZXJhdG9yICE9PSAnPD0nKSlcbiAgICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyB3aWxsIGl0ZXJhdGUgb25lIG9yIHplcm8gdGltZXNcbiAgZm9yIChjb25zdCBlcSBvZiBlcVNldCkge1xuICAgIGlmIChndCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcoZ3QpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBpZiAobHQgJiYgIXNhdGlzZmllcyhlcSwgU3RyaW5nKGx0KSwgb3B0aW9ucykpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgICAgaWYgKCFzYXRpc2ZpZXMoZXEsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBsZXQgaGlnaGVyLCBsb3dlclxuICBsZXQgaGFzRG9tTFQsIGhhc0RvbUdUXG4gIC8vIGlmIHRoZSBzdWJzZXQgaGFzIGEgcHJlcmVsZWFzZSwgd2UgbmVlZCBhIGNvbXBhcmF0b3IgaW4gdGhlIHN1cGVyc2V0XG4gIC8vIHdpdGggdGhlIHNhbWUgdHVwbGUgYW5kIGEgcHJlcmVsZWFzZSwgb3IgaXQncyBub3QgYSBzdWJzZXRcbiAgbGV0IG5lZWREb21MVFByZSA9IGx0ICYmXG4gICAgIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgJiZcbiAgICBsdC5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGggPyBsdC5zZW12ZXIgOiBmYWxzZVxuICBsZXQgbmVlZERvbUdUUHJlID0gZ3QgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGd0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGd0LnNlbXZlciA6IGZhbHNlXG4gIC8vIGV4Y2VwdGlvbjogPDEuMi4zLTAgaXMgdGhlIHNhbWUgYXMgPDEuMi4zXG4gIGlmIChuZWVkRG9tTFRQcmUgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2UubGVuZ3RoID09PSAxICYmXG4gICAgICBsdC5vcGVyYXRvciA9PT0gJzwnICYmIG5lZWREb21MVFByZS5wcmVyZWxlYXNlWzBdID09PSAwKSB7XG4gICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgfVxuXG4gIGZvciAoY29uc3QgYyBvZiBkb20pIHtcbiAgICBoYXNEb21HVCA9IGhhc0RvbUdUIHx8IGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nXG4gICAgaGFzRG9tTFQgPSBoYXNEb21MVCB8fCBjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9J1xuICAgIGlmIChndCkge1xuICAgICAgaWYgKG5lZWREb21HVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21HVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21HVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21HVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21HVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49Jykge1xuICAgICAgICBoaWdoZXIgPSBoaWdoZXJHVChndCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGhpZ2hlciA9PT0gYyAmJiBoaWdoZXIgIT09IGd0KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChndC5vcGVyYXRvciA9PT0gJz49JyAmJiAhc2F0aXNmaWVzKGd0LnNlbXZlciwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChsdCkge1xuICAgICAgaWYgKG5lZWREb21MVFByZSkge1xuICAgICAgICBpZiAoYy5zZW12ZXIucHJlcmVsZWFzZSAmJiBjLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWFqb3IgPT09IG5lZWREb21MVFByZS5tYWpvciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIubWlub3IgPT09IG5lZWREb21MVFByZS5taW5vciAmJlxuICAgICAgICAgICAgYy5zZW12ZXIucGF0Y2ggPT09IG5lZWREb21MVFByZS5wYXRjaCkge1xuICAgICAgICAgIG5lZWREb21MVFByZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjLm9wZXJhdG9yID09PSAnPCcgfHwgYy5vcGVyYXRvciA9PT0gJzw9Jykge1xuICAgICAgICBsb3dlciA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgICAgIGlmIChsb3dlciA9PT0gYyAmJiBsb3dlciAhPT0gbHQpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGx0Lm9wZXJhdG9yID09PSAnPD0nICYmICFzYXRpc2ZpZXMobHQuc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFjLm9wZXJhdG9yICYmIChsdCB8fCBndCkgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGlmIHRoZXJlIHdhcyBhIDwgb3IgPiwgYW5kIG5vdGhpbmcgaW4gdGhlIGRvbSwgdGhlbiBtdXN0IGJlIGZhbHNlXG4gIC8vIFVOTEVTUyBpdCB3YXMgbGltaXRlZCBieSBhbm90aGVyIHJhbmdlIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gIC8vIEVnLCA+MS4wLjAgPDEuMC4xIGlzIHN0aWxsIGEgc3Vic2V0IG9mIDwyLjAuMFxuICBpZiAoZ3QgJiYgaGFzRG9tTFQgJiYgIWx0ICYmIGd0bHRDb21wICE9PSAwKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIGlmIChsdCAmJiBoYXNEb21HVCAmJiAhZ3QgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gd2UgbmVlZGVkIGEgcHJlcmVsZWFzZSByYW5nZSBpbiBhIHNwZWNpZmljIHR1cGxlLCBidXQgZGlkbid0IGdldCBvbmVcbiAgLy8gdGhlbiB0aGlzIGlzbid0IGEgc3Vic2V0LiAgZWcgPj0xLjIuMy1wcmUgaXMgbm90IGEgc3Vic2V0IG9mID49MS4wLjAsXG4gIC8vIGJlY2F1c2UgaXQgaW5jbHVkZXMgcHJlcmVsZWFzZXMgaW4gdGhlIDEuMi4zIHR1cGxlXG4gIGlmIChuZWVkRG9tR1RQcmUgfHwgbmVlZERvbUxUUHJlKVxuICAgIHJldHVybiBmYWxzZVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vID49MS4yLjMgaXMgbG93ZXIgdGhhbiA+MS4yLjNcbmNvbnN0IGhpZ2hlckdUID0gKGEsIGIsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFhKVxuICAgIHJldHVybiBiXG4gIGNvbnN0IGNvbXAgPSBjb21wYXJlKGEuc2VtdmVyLCBiLnNlbXZlciwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAgPiAwID8gYVxuICAgIDogY29tcCA8IDAgPyBiXG4gICAgOiBiLm9wZXJhdG9yID09PSAnPicgJiYgYS5vcGVyYXRvciA9PT0gJz49JyA/IGJcbiAgICA6IGFcbn1cblxuLy8gPD0xLjIuMyBpcyBoaWdoZXIgdGhhbiA8MS4yLjNcbmNvbnN0IGxvd2VyTFQgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA8IDAgPyBhXG4gICAgOiBjb21wID4gMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc8JyAmJiBhLm9wZXJhdG9yID09PSAnPD0nID8gYlxuICAgIDogYVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YnNldFxuIiwiLy8ganVzdCBwcmUtbG9hZCBhbGwgdGhlIHN0dWZmIHRoYXQgaW5kZXguanMgbGF6aWx5IGV4cG9ydHNcbmNvbnN0IGludGVybmFsUmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3JlJylcbm1vZHVsZS5leHBvcnRzID0ge1xuICByZTogaW50ZXJuYWxSZS5yZSxcbiAgc3JjOiBpbnRlcm5hbFJlLnNyYyxcbiAgdG9rZW5zOiBpbnRlcm5hbFJlLnQsXG4gIFNFTVZFUl9TUEVDX1ZFUlNJT046IHJlcXVpcmUoJy4vaW50ZXJuYWwvY29uc3RhbnRzJykuU0VNVkVSX1NQRUNfVkVSU0lPTixcbiAgU2VtVmVyOiByZXF1aXJlKCcuL2NsYXNzZXMvc2VtdmVyJyksXG4gIGNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyczogcmVxdWlyZSgnLi9pbnRlcm5hbC9pZGVudGlmaWVycycpLnJjb21wYXJlSWRlbnRpZmllcnMsXG4gIHBhcnNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXJzZScpLFxuICB2YWxpZDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvdmFsaWQnKSxcbiAgY2xlYW46IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NsZWFuJyksXG4gIGluYzogcmVxdWlyZSgnLi9mdW5jdGlvbnMvaW5jJyksXG4gIGRpZmY6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2RpZmYnKSxcbiAgbWFqb3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21ham9yJyksXG4gIG1pbm9yOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9taW5vcicpLFxuICBwYXRjaDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcGF0Y2gnKSxcbiAgcHJlcmVsZWFzZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcHJlcmVsZWFzZScpLFxuICBjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlJyksXG4gIHJjb21wYXJlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9yY29tcGFyZScpLFxuICBjb21wYXJlTG9vc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtbG9vc2UnKSxcbiAgY29tcGFyZUJ1aWxkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb21wYXJlLWJ1aWxkJyksXG4gIHNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NvcnQnKSxcbiAgcnNvcnQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jzb3J0JyksXG4gIGd0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndCcpLFxuICBsdDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHQnKSxcbiAgZXE6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2VxJyksXG4gIG5lcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbmVxJyksXG4gIGd0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZ3RlJyksXG4gIGx0ZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbHRlJyksXG4gIGNtcDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY21wJyksXG4gIGNvZXJjZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29lcmNlJyksXG4gIENvbXBhcmF0b3I6IHJlcXVpcmUoJy4vY2xhc3Nlcy9jb21wYXJhdG9yJyksXG4gIFJhbmdlOiByZXF1aXJlKCcuL2NsYXNzZXMvcmFuZ2UnKSxcbiAgc2F0aXNmaWVzOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9zYXRpc2ZpZXMnKSxcbiAgdG9Db21wYXJhdG9yczogcmVxdWlyZSgnLi9yYW5nZXMvdG8tY29tcGFyYXRvcnMnKSxcbiAgbWF4U2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWF4LXNhdGlzZnlpbmcnKSxcbiAgbWluU2F0aXNmeWluZzogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXNhdGlzZnlpbmcnKSxcbiAgbWluVmVyc2lvbjogcmVxdWlyZSgnLi9yYW5nZXMvbWluLXZlcnNpb24nKSxcbiAgdmFsaWRSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvdmFsaWQnKSxcbiAgb3V0c2lkZTogcmVxdWlyZSgnLi9yYW5nZXMvb3V0c2lkZScpLFxuICBndHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2d0cicpLFxuICBsdHI6IHJlcXVpcmUoJy4vcmFuZ2VzL2x0cicpLFxuICBpbnRlcnNlY3RzOiByZXF1aXJlKCcuL3Jhbmdlcy9pbnRlcnNlY3RzJyksXG4gIHNpbXBsaWZ5UmFuZ2U6IHJlcXVpcmUoJy4vcmFuZ2VzL3NpbXBsaWZ5JyksXG4gIHN1YnNldDogcmVxdWlyZSgnLi9yYW5nZXMvc3Vic2V0JyksXG59XG4iLCIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVUZW1wVXBkYXRlRmlsZSA9IGV4cG9ydHMuRG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbi8qKiBAcHJpdmF0ZSAqKi9cbmNsYXNzIERvd25sb2FkZWRVcGRhdGVIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlRGlyKSB7XG4gICAgICAgIHRoaXMuY2FjaGVEaXIgPSBjYWNoZURpcjtcbiAgICAgICAgdGhpcy5fZmlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VGaWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJzaW9uSW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsZUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9kb3dubG9hZGVkRmlsZUluZm8gPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZG93bmxvYWRlZEZpbGVJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvO1xuICAgIH1cbiAgICBnZXQgZmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGdldCBwYWNrYWdlRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2thZ2VGaWxlO1xuICAgIH1cbiAgICBnZXQgY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXIsIFwicGVuZGluZ1wiKTtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVEb3dubG9hZGVkUGF0aCh1cGRhdGVGaWxlLCB1cGRhdGVJbmZvLCBmaWxlSW5mbywgbG9nZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25JbmZvICE9IG51bGwgJiYgdGhpcy5maWxlID09PSB1cGRhdGVGaWxlICYmIHRoaXMuZmlsZUluZm8gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIGhhcyBhbHJlYWR5IGJlZW4gZG93bmxvYWRlZCBmcm9tIHRoaXMgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gY2hlY2sgaGVyZSBvbmx5IGV4aXN0ZW5jZSwgbm90IGNoZWNrc3VtXG4gICAgICAgICAgICBpZiAoaXNFcXVhbCh0aGlzLnZlcnNpb25JbmZvLCB1cGRhdGVJbmZvKSAmJiBpc0VxdWFsKHRoaXMuZmlsZUluZm8uaW5mbywgZmlsZUluZm8uaW5mbykgJiYgKGF3YWl0IGZzX2V4dHJhXzEucGF0aEV4aXN0cyh1cGRhdGVGaWxlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGRvd25sb2FkZWQgZnJvbSBzb21lIHByZXZpb3VzIGFwcCBsYXVuY2hcbiAgICAgICAgY29uc3QgY2FjaGVkVXBkYXRlRmlsZSA9IGF3YWl0IHRoaXMuZ2V0VmFsaWRDYWNoZWRVcGRhdGVGaWxlKGZpbGVJbmZvLCBsb2dnZXIpO1xuICAgICAgICBpZiAoY2FjaGVkVXBkYXRlRmlsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYFVwZGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGRvd25sb2FkZWQgdG8gJHt1cGRhdGVGaWxlfSkuYCk7XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBjYWNoZWRVcGRhdGVGaWxlO1xuICAgICAgICByZXR1cm4gY2FjaGVkVXBkYXRlRmlsZTtcbiAgICB9XG4gICAgYXN5bmMgc2V0RG93bmxvYWRlZEZpbGUoZG93bmxvYWRlZEZpbGUsIHBhY2thZ2VGaWxlLCB2ZXJzaW9uSW5mbywgZmlsZUluZm8sIHVwZGF0ZUZpbGVOYW1lLCBpc1NhdmVDYWNoZSkge1xuICAgICAgICB0aGlzLl9maWxlID0gZG93bmxvYWRlZEZpbGU7XG4gICAgICAgIHRoaXMuX3BhY2thZ2VGaWxlID0gcGFja2FnZUZpbGU7XG4gICAgICAgIHRoaXMudmVyc2lvbkluZm8gPSB2ZXJzaW9uSW5mbztcbiAgICAgICAgdGhpcy5maWxlSW5mbyA9IGZpbGVJbmZvO1xuICAgICAgICB0aGlzLl9kb3dubG9hZGVkRmlsZUluZm8gPSB7XG4gICAgICAgICAgICBmaWxlTmFtZTogdXBkYXRlRmlsZU5hbWUsXG4gICAgICAgICAgICBzaGE1MTI6IGZpbGVJbmZvLmluZm8uc2hhNTEyLFxuICAgICAgICAgICAgaXNBZG1pblJpZ2h0c1JlcXVpcmVkOiBmaWxlSW5mby5pbmZvLmlzQWRtaW5SaWdodHNSZXF1aXJlZCA9PT0gdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzU2F2ZUNhY2hlKSB7XG4gICAgICAgICAgICBhd2FpdCBmc19leHRyYV8xLm91dHB1dEpzb24odGhpcy5nZXRVcGRhdGVJbmZvRmlsZSgpLCB0aGlzLl9kb3dubG9hZGVkRmlsZUluZm8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9maWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFja2FnZUZpbGUgPSBudWxsO1xuICAgICAgICB0aGlzLnZlcnNpb25JbmZvID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxlSW5mbyA9IG51bGw7XG4gICAgICAgIGF3YWl0IHRoaXMuY2xlYW5DYWNoZURpckZvclBlbmRpbmdVcGRhdGUoKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYW5DYWNoZURpckZvclBlbmRpbmdVcGRhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgc3RhbGUgZGF0YVxuICAgICAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5lbXB0eURpcih0aGlzLmNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBcInVwZGF0ZS1pbmZvLmpzb25cIiB3aGljaCBpcyBjcmVhdGVkIGluIHRoZSB1cGRhdGUgY2FjaGUgZGlyZWN0b3J5J3MgXCJwZW5kaW5nXCIgc3ViZm9sZGVyIGFmdGVyIHRoZSBmaXJzdCB1cGRhdGUgaXMgZG93bmxvYWRlZC4gIElmIHRoZSB1cGRhdGUgZmlsZSBkb2VzIG5vdCBleGlzdCB0aGVuIHRoZSBjYWNoZSBpcyBjbGVhcmVkIGFuZCByZWNyZWF0ZWQuICBJZiB0aGUgdXBkYXRlIGZpbGUgZXhpc3RzIHRoZW4gaXRzIHByb3BlcnRpZXMgYXJlIHZhbGlkYXRlZC5cbiAgICAgKiBAcGFyYW0gZmlsZUluZm9cbiAgICAgKiBAcGFyYW0gbG9nZ2VyXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VmFsaWRDYWNoZWRVcGRhdGVGaWxlKGZpbGVJbmZvLCBsb2dnZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cGRhdGVJbmZvRmlsZVBhdGggPSB0aGlzLmdldFVwZGF0ZUluZm9GaWxlKCk7XG4gICAgICAgIGNvbnN0IGRvZXNVcGRhdGVJbmZvRmlsZUV4aXN0ID0gYXdhaXQgZnNfZXh0cmFfMS5wYXRoRXhpc3RzKHVwZGF0ZUluZm9GaWxlUGF0aCk7XG4gICAgICAgIGlmICghZG9lc1VwZGF0ZUluZm9GaWxlRXhpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWNoZWRJbmZvO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FjaGVkSW5mbyA9IGF3YWl0IGZzX2V4dHJhXzEucmVhZEpzb24odXBkYXRlSW5mb0ZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gYE5vIGNhY2hlZCB1cGRhdGUgaW5mbyBhdmFpbGFibGVgO1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgIChlcnJvciBvbiByZWFkOiAke2Vycm9yLm1lc3NhZ2V9KWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ2FjaGVkSW5mb0ZpbGVOYW1lVmFsaWQgPSAoX2EgPSAoY2FjaGVkSW5mbyA9PT0gbnVsbCB8fCBjYWNoZWRJbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWNoZWRJbmZvLmZpbGVOYW1lKSAhPT0gbnVsbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGlmICghaXNDYWNoZWRJbmZvRmlsZU5hbWVWYWxpZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENhY2hlZCB1cGRhdGUgaW5mbyBpcyBjb3JydXB0ZWQ6IG5vIGZpbGVOYW1lLCBkaXJlY3RvcnkgZm9yIGNhY2hlZCB1cGRhdGUgd2lsbCBiZSBjbGVhbmVkYCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsZWFuQ2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZUluZm8uaW5mby5zaGE1MTIgIT09IGNhY2hlZEluZm8uc2hhNTEyKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgQ2FjaGVkIHVwZGF0ZSBzaGE1MTIgY2hlY2tzdW0gZG9lc24ndCBtYXRjaCB0aGUgbGF0ZXN0IGF2YWlsYWJsZSB1cGRhdGUuIE5ldyB1cGRhdGUgbXVzdCBiZSBkb3dubG9hZGVkLiBDYWNoZWQ6ICR7Y2FjaGVkSW5mby5zaGE1MTJ9LCBleHBlY3RlZDogJHtmaWxlSW5mby5pbmZvLnNoYTUxMn0uIERpcmVjdG9yeSBmb3IgY2FjaGVkIHVwZGF0ZSB3aWxsIGJlIGNsZWFuZWRgKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xlYW5DYWNoZURpckZvclBlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZpbGUgPSBwYXRoLmpvaW4odGhpcy5jYWNoZURpckZvclBlbmRpbmdVcGRhdGUsIGNhY2hlZEluZm8uZmlsZU5hbWUpO1xuICAgICAgICBpZiAoIShhd2FpdCBmc19leHRyYV8xLnBhdGhFeGlzdHModXBkYXRlRmlsZSkpKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhcIkNhY2hlZCB1cGRhdGUgZmlsZSBkb2Vzbid0IGV4aXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hhNTEyID0gYXdhaXQgaGFzaEZpbGUodXBkYXRlRmlsZSk7XG4gICAgICAgIGlmIChmaWxlSW5mby5pbmZvLnNoYTUxMiAhPT0gc2hhNTEyKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgU2hhNTEyIGNoZWNrc3VtIGRvZXNuJ3QgbWF0Y2ggdGhlIGxhdGVzdCBhdmFpbGFibGUgdXBkYXRlLiBOZXcgdXBkYXRlIG11c3QgYmUgZG93bmxvYWRlZC4gQ2FjaGVkOiAke3NoYTUxMn0sIGV4cGVjdGVkOiAke2ZpbGVJbmZvLmluZm8uc2hhNTEyfWApO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhbkNhY2hlRGlyRm9yUGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZG93bmxvYWRlZEZpbGVJbmZvID0gY2FjaGVkSW5mbztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZpbGU7XG4gICAgfVxuICAgIGdldFVwZGF0ZUluZm9GaWxlKCkge1xuICAgICAgICByZXR1cm4gcGF0aC5qb2luKHRoaXMuY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlLCBcInVwZGF0ZS1pbmZvLmpzb25cIik7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3dubG9hZGVkVXBkYXRlSGVscGVyID0gRG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcbmZ1bmN0aW9uIGhhc2hGaWxlKGZpbGUsIGFsZ29yaXRobSA9IFwic2hhNTEyXCIsIGVuY29kaW5nID0gXCJiYXNlNjRcIiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9fMS5jcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgICAgIGhhc2gub24oXCJlcnJvclwiLCByZWplY3QpLnNldEVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKGZpbGUsIHsgLi4ub3B0aW9ucywgaGlnaFdhdGVyTWFyazogMTAyNCAqIDEwMjQgLyogYmV0dGVyIHRvIHVzZSBtb3JlIG1lbW9yeSBidXQgaGFzaCBmYXN0ZXIgKi8gfSlcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIHJlamVjdClcbiAgICAgICAgICAgIC5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBoYXNoLmVuZCgpO1xuICAgICAgICAgICAgcmVzb2x2ZShoYXNoLnJlYWQoKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZShoYXNoLCB7IGVuZDogZmFsc2UgfSk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVUZW1wVXBkYXRlRmlsZShuYW1lLCBjYWNoZURpciwgbG9nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvcHVsbC8yNDc0I2lzc3VlY29tbWVudC0zNjY0ODE5MTJcbiAgICBsZXQgbmFtZUNvdW50ZXIgPSAwO1xuICAgIGxldCByZXN1bHQgPSBwYXRoLmpvaW4oY2FjaGVEaXIsIG5hbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmc19leHRyYV8xLnVubGluayhyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2cud2FybihgRXJyb3Igb24gcmVtb3ZlIHRlbXAgdXBkYXRlIGZpbGU6ICR7ZX1gKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhdGguam9pbihjYWNoZURpciwgYCR7bmFtZUNvdW50ZXIrK30tJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNyZWF0ZVRlbXBVcGRhdGVGaWxlID0gY3JlYXRlVGVtcFVwZGF0ZUZpbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Eb3dubG9hZGVkVXBkYXRlSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBcHBDYWNoZURpciA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IG9zXzEgPSByZXF1aXJlKFwib3NcIik7XG5mdW5jdGlvbiBnZXRBcHBDYWNoZURpcigpIHtcbiAgICBjb25zdCBob21lZGlyID0gb3NfMS5ob21lZGlyKCk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8xNDA0I2lzc3VlY29tbWVudC0xOTQzOTEyNDdcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gcHJvY2Vzcy5lbnZbXCJMT0NBTEFQUERBVEFcIl0gfHwgcGF0aC5qb2luKGhvbWVkaXIsIFwiQXBwRGF0YVwiLCBcIkxvY2FsXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImRhcndpblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdGguam9pbihob21lZGlyLCBcIkxpYnJhcnlcIiwgXCJBcHBsaWNhdGlvbiBTdXBwb3J0XCIsIFwiQ2FjaGVzXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcHJvY2Vzcy5lbnZbXCJYREdfQ0FDSEVfSE9NRVwiXSB8fCBwYXRoLmpvaW4oaG9tZWRpciwgXCIuY2FjaGVcIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmdldEFwcENhY2hlRGlyID0gZ2V0QXBwQ2FjaGVEaXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHBBZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbGVjdHJvbkFwcEFkYXB0ZXIgPSB2b2lkIDA7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBBcHBBZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBBZGFwdGVyXCIpO1xuY2xhc3MgRWxlY3Ryb25BcHBBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAgPSByZXF1aXJlKFwiZWxlY3Ryb25cIikuYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgIH1cbiAgICB3aGVuUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC53aGVuUmVhZHkoKTtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcC5nZXRWZXJzaW9uKCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuZ2V0TmFtZSgpO1xuICAgIH1cbiAgICBnZXQgaXNQYWNrYWdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwLmlzUGFja2FnZWQgPT09IHRydWU7XG4gICAgfVxuICAgIGdldCBhcHBVcGRhdGVDb25maWdQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1BhY2thZ2VkID8gcGF0aC5qb2luKHByb2Nlc3MucmVzb3VyY2VzUGF0aCwgXCJhcHAtdXBkYXRlLnltbFwiKSA6IHBhdGguam9pbih0aGlzLmFwcC5nZXRBcHBQYXRoKCksIFwiZGV2LWFwcC11cGRhdGUueW1sXCIpO1xuICAgIH1cbiAgICBnZXQgdXNlckRhdGFQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHAuZ2V0UGF0aChcInVzZXJEYXRhXCIpO1xuICAgIH1cbiAgICBnZXQgYmFzZUNhY2hlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIEFwcEFkYXB0ZXJfMS5nZXRBcHBDYWNoZURpcigpO1xuICAgIH1cbiAgICBxdWl0KCkge1xuICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgfVxuICAgIG9uUXVpdChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXBwLm9uY2UoXCJxdWl0XCIsIChfLCBleGl0Q29kZSkgPT4gaGFuZGxlcihleGl0Q29kZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuRWxlY3Ryb25BcHBBZGFwdGVyID0gRWxlY3Ryb25BcHBBZGFwdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RWxlY3Ryb25BcHBBZGFwdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbGVjdHJvbkh0dHBFeGVjdXRvciA9IGV4cG9ydHMuZ2V0TmV0U2Vzc2lvbiA9IGV4cG9ydHMuTkVUX1NFU1NJT05fTkFNRSA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5leHBvcnRzLk5FVF9TRVNTSU9OX05BTUUgPSBcImVsZWN0cm9uLXVwZGF0ZXJcIjtcbmZ1bmN0aW9uIGdldE5ldFNlc3Npb24oKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoXCJlbGVjdHJvblwiKS5zZXNzaW9uLmZyb21QYXJ0aXRpb24oZXhwb3J0cy5ORVRfU0VTU0lPTl9OQU1FLCB7XG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0TmV0U2Vzc2lvbiA9IGdldE5ldFNlc3Npb247XG5jbGFzcyBFbGVjdHJvbkh0dHBFeGVjdXRvciBleHRlbmRzIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEV4ZWN1dG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm94eUxvZ2luQ2FsbGJhY2spIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wcm94eUxvZ2luQ2FsbGJhY2sgPSBwcm94eUxvZ2luQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY2FjaGVkU2Vzc2lvbiA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvd25sb2FkKHVybCwgZGVzdGluYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4uY3JlYXRlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJtYW51YWxcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RVcmwodXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9Eb3dubG9hZChyZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25DYW5jZWwsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyOiBudWxsLFxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGZpeCAobm9kZSA3KykgZm9yIG1ha2luZyBlbGVjdHJvbiB1cGRhdGVyIHdvcmsgd2hlbiB1c2luZyBBV1MgcHJpdmF0ZSBidWNrZXRzLCBjaGVjayBpZiBoZWFkZXJzIGNvbnRhaW4gSG9zdCBwcm9wZXJ0eVxuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzICYmIG9wdGlvbnMuaGVhZGVycy5Ib3N0KSB7XG4gICAgICAgICAgICAvLyBzZXQgaG9zdCB2YWx1ZSBmcm9tIGhlYWRlcnMuSG9zdFxuICAgICAgICAgICAgb3B0aW9ucy5ob3N0ID0gb3B0aW9ucy5oZWFkZXJzLkhvc3Q7XG4gICAgICAgICAgICAvLyByZW1vdmUgaGVhZGVyIHByb3BlcnR5ICdIb3N0JywgaWYgbm90IHJlbW92ZWQgY2F1c2VzIG5ldDo6RVJSX0lOVkFMSURfQVJHVU1FTlQgZXhjZXB0aW9uXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5oZWFkZXJzLkhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW50aWFsIGRvd25sb2FkZXIgY2FuIGNhbGwgdGhpcyBtZXRob2QgdmVyeSBvZnRlbiwgc28sIGJldHRlciB0byBjYWNoZSBzZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFNlc3Npb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZWRTZXNzaW9uID0gZ2V0TmV0U2Vzc2lvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1aXJlKFwiZWxlY3Ryb25cIikubmV0LnJlcXVlc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHNlc3Npb246IHRoaXMuY2FjaGVkU2Vzc2lvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Qub24oXCJyZXNwb25zZVwiLCBjYWxsYmFjayk7XG4gICAgICAgIGlmICh0aGlzLnByb3h5TG9naW5DYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKFwibG9naW5cIiwgdGhpcy5wcm94eUxvZ2luQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbiAgICBhZGRSZWRpcmVjdEhhbmRsZXJzKHJlcXVlc3QsIG9wdGlvbnMsIHJlamVjdCwgcmVkaXJlY3RDb3VudCwgaGFuZGxlcikge1xuICAgICAgICByZXF1ZXN0Lm9uKFwicmVkaXJlY3RcIiwgKHN0YXR1c0NvZGUsIG1ldGhvZCwgcmVkaXJlY3RVcmwpID0+IHtcbiAgICAgICAgICAgIC8vIG5vIHdheSB0byBtb2RpZnkgcmVxdWVzdCBvcHRpb25zLCBhYm9ydCBvbGQgYW5kIG1ha2UgYSBuZXcgb25lXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vaXNzdWVzLzExNTA1XG4gICAgICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICBpZiAocmVkaXJlY3RDb3VudCA+IHRoaXMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlTWF4UmVkaXJlY3RFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5IdHRwRXhlY3V0b3IucHJlcGFyZVJlZGlyZWN0VXJsT3B0aW9ucyhyZWRpcmVjdFVybCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkVsZWN0cm9uSHR0cEV4ZWN1dG9yID0gRWxlY3Ryb25IdHRwRXhlY3V0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGVjdHJvbkh0dHBFeGVjdXRvci5qcy5tYXAiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgIHJlSGFzUmVnRXhwQ2hhciA9IFJlZ0V4cChyZVJlZ0V4cENoYXIuc291cmNlKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICovXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgIDogc3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVJlZ0V4cDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibG9ja21hcEZpbGVzID0gZXhwb3J0cy5nZXRDaGFubmVsRmlsZW5hbWUgPSBleHBvcnRzLm5ld1VybEZyb21CYXNlID0gZXhwb3J0cy5uZXdCYXNlVXJsID0gdm9pZCAwO1xuLy8gaWYgYmFzZVVybCBwYXRoIGRvZXNuJ3QgZW5kcyB3aXRoIC8sIHRoaXMgcGF0aCB3aWxsIGJlIG5vdCBwcmVwZW5kZWQgdG8gcGFzc2VkIHBhdGhuYW1lIGZvciBuZXcgVVJMKGlucHV0LCBiYXNlKVxuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgZXNjYXBlUmVnRXhwID0gcmVxdWlyZShcImxvZGFzaC5lc2NhcGVyZWdleHBcIik7XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBuZXdCYXNlVXJsKHVybCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyB1cmxfMS5VUkwodXJsKTtcbiAgICBpZiAoIXJlc3VsdC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgcmVzdWx0LnBhdGhuYW1lICs9IFwiL1wiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5uZXdCYXNlVXJsID0gbmV3QmFzZVVybDtcbi8vIGFkZFJhbmRvbVF1ZXJ5VG9Bdm9pZENhY2hpbmcgaXMgZmFsc2UgYnkgZGVmYXVsdCBiZWNhdXNlIGluIG1vc3QgY2FzZXMgVVJMIGFscmVhZHkgY29udGFpbnMgdmVyc2lvbiBudW1iZXIsXG4vLyBzbywgaXQgbWFrZXMgc2Vuc2Ugb25seSBmb3IgR2VuZXJpYyBQcm92aWRlciBmb3IgY2hhbm5lbCBmaWxlc1xuZnVuY3Rpb24gbmV3VXJsRnJvbUJhc2UocGF0aG5hbWUsIGJhc2VVcmwsIGFkZFJhbmRvbVF1ZXJ5VG9Bdm9pZENhY2hpbmcgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyB1cmxfMS5VUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xuICAgIC8vIHNlYXJjaCBpcyBub3QgcHJvcGFnYXRlZCAoc2VhcmNoIGlzIGFuIGVtcHR5IHN0cmluZyBpZiBub3Qgc3BlY2lmaWVkKVxuICAgIGNvbnN0IHNlYXJjaCA9IGJhc2VVcmwuc2VhcmNoO1xuICAgIGlmIChzZWFyY2ggIT0gbnVsbCAmJiBzZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJlc3VsdC5zZWFyY2ggPSBzZWFyY2g7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZFJhbmRvbVF1ZXJ5VG9Bdm9pZENhY2hpbmcpIHtcbiAgICAgICAgcmVzdWx0LnNlYXJjaCA9IGBub0NhY2hlPSR7RGF0ZS5ub3coKS50b1N0cmluZygzMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubmV3VXJsRnJvbUJhc2UgPSBuZXdVcmxGcm9tQmFzZTtcbmZ1bmN0aW9uIGdldENoYW5uZWxGaWxlbmFtZShjaGFubmVsKSB7XG4gICAgcmV0dXJuIGAke2NoYW5uZWx9LnltbGA7XG59XG5leHBvcnRzLmdldENoYW5uZWxGaWxlbmFtZSA9IGdldENoYW5uZWxGaWxlbmFtZTtcbmZ1bmN0aW9uIGJsb2NrbWFwRmlsZXMoYmFzZVVybCwgb2xkVmVyc2lvbiwgbmV3VmVyc2lvbikge1xuICAgIGNvbnN0IG5ld0Jsb2NrTWFwVXJsID0gbmV3VXJsRnJvbUJhc2UoYCR7YmFzZVVybC5wYXRobmFtZX0uYmxvY2ttYXBgLCBiYXNlVXJsKTtcbiAgICBjb25zdCBvbGRCbG9ja01hcFVybCA9IG5ld1VybEZyb21CYXNlKGAke2Jhc2VVcmwucGF0aG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChuZXdWZXJzaW9uKSwgXCJnXCIpLCBvbGRWZXJzaW9uKX0uYmxvY2ttYXBgLCBiYXNlVXJsKTtcbiAgICByZXR1cm4gW29sZEJsb2NrTWFwVXJsLCBuZXdCbG9ja01hcFVybF07XG59XG5leHBvcnRzLmJsb2NrbWFwRmlsZXMgPSBibG9ja21hcEZpbGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZUZpbGVzID0gZXhwb3J0cy5nZXRGaWxlTGlzdCA9IGV4cG9ydHMucGFyc2VVcGRhdGVJbmZvID0gZXhwb3J0cy5maW5kRmlsZSA9IGV4cG9ydHMuUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QganNfeWFtbF8xID0gcmVxdWlyZShcImpzLXlhbWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihydW50aW1lT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJ1bnRpbWVPcHRpb25zID0gcnVudGltZU9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmV4ZWN1dG9yID0gcnVudGltZU9wdGlvbnMuZXhlY3V0b3I7XG4gICAgfVxuICAgIGdldCBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lT3B0aW9ucy5pc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0ICE9PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbEZpbGVQcmVmaXgoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bnRpbWVPcHRpb25zLnBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyY2ggPSBwcm9jZXNzLmVudltcIlRFU1RfVVBEQVRFUl9BUkNIXCJdIHx8IHByb2Nlc3MuYXJjaDtcbiAgICAgICAgICAgIGNvbnN0IGFyY2hTdWZmaXggPSBhcmNoID09PSBcIng2NFwiID8gXCJcIiA6IGAtJHthcmNofWA7XG4gICAgICAgICAgICByZXR1cm4gXCItbGludXhcIiArIGFyY2hTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW50aW1lT3B0aW9ucy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIiA/IFwiLW1hY1wiIDogXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkdWUgdG8gaGlzdG9yaWNhbCByZWFzb25zIGZvciB3aW5kb3dzIHdlIHVzZSBjaGFubmVsIG5hbWUgd2l0aG91dCBwbGF0Zm9ybSBzcGVjaWZpZXJcbiAgICBnZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1c3RvbUNoYW5uZWxOYW1lKFwibGF0ZXN0XCIpO1xuICAgIH1cbiAgICBnZXRDdXN0b21DaGFubmVsTmFtZShjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBgJHtjaGFubmVsfSR7dGhpcy5nZXRDaGFubmVsRmlsZVByZWZpeCgpfWA7XG4gICAgfVxuICAgIGdldCBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBwZXJmb3JtIEFQSSByZXF1ZXN0IG9ubHkgdG8gcmVzb2x2ZSB1cGRhdGUgaW5mbywgYnV0IG5vdCB0byBkb3dubG9hZCB1cGRhdGUuXG4gICAgICovXG4gICAgaHR0cFJlcXVlc3QodXJsLCBoZWFkZXJzLCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRvci5yZXF1ZXN0KHRoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnModXJsLCBoZWFkZXJzKSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBjcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaGVhZGVycyA9IGhlYWRlcnMgPT0gbnVsbCA/IHRoaXMucmVxdWVzdEhlYWRlcnMgOiB7IC4uLnRoaXMucmVxdWVzdEhlYWRlcnMsIC4uLmhlYWRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RVcmwodXJsLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdmlkZXIgPSBQcm92aWRlcjtcbmZ1bmN0aW9uIGZpbmRGaWxlKGZpbGVzLCBleHRlbnNpb24sIG5vdCkge1xuICAgIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcIk5vIGZpbGVzIHByb3ZpZGVkXCIsIFwiRVJSX1VQREFURVJfTk9fRklMRVNfUFJPVklERURcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVzLmZpbmQoaXQgPT4gaXQudXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYC4ke2V4dGVuc2lvbn1gKSk7XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmaWxlc1swXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlcy5maW5kKGZpbGVJbmZvID0+ICFub3Quc29tZShleHQgPT4gZmlsZUluZm8udXJsLnBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoYC4ke2V4dH1gKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZmluZEZpbGUgPSBmaW5kRmlsZTtcbmZ1bmN0aW9uIHBhcnNlVXBkYXRlSW5mbyhyYXdEYXRhLCBjaGFubmVsRmlsZSwgY2hhbm5lbEZpbGVVcmwpIHtcbiAgICBpZiAocmF3RGF0YSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBwYXJzZSB1cGRhdGUgaW5mbyBmcm9tICR7Y2hhbm5lbEZpbGV9IGluIHRoZSBsYXRlc3QgcmVsZWFzZSBhcnRpZmFjdHMgKCR7Y2hhbm5lbEZpbGVVcmx9KTogcmF3RGF0YTogbnVsbGAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9VUERBVEVfSU5GT1wiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBqc195YW1sXzEubG9hZChyYXdEYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IHBhcnNlIHVwZGF0ZSBpbmZvIGZyb20gJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfSwgcmF3RGF0YTogJHtyYXdEYXRhfWAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9VUERBVEVfSU5GT1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2VVcGRhdGVJbmZvID0gcGFyc2VVcGRhdGVJbmZvO1xuZnVuY3Rpb24gZ2V0RmlsZUxpc3QodXBkYXRlSW5mbykge1xuICAgIGNvbnN0IGZpbGVzID0gdXBkYXRlSW5mby5maWxlcztcbiAgICBpZiAoZmlsZXMgIT0gbnVsbCAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTRGVwcmVjYXRlZFN5bWJvbHNcbiAgICBpZiAodXBkYXRlSW5mby5wYXRoICE9IG51bGwpIHtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTRGVwcmVjYXRlZFN5bWJvbHNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IHVwZGF0ZUluZm8ucGF0aCxcbiAgICAgICAgICAgICAgICBzaGEyOiB1cGRhdGVJbmZvLnNoYTIsXG4gICAgICAgICAgICAgICAgc2hhNTEyOiB1cGRhdGVJbmZvLnNoYTUxMixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBObyBmaWxlcyBwcm92aWRlZDogJHtidWlsZGVyX3V0aWxfcnVudGltZV8xLnNhZmVTdHJpbmdpZnlKc29uKHVwZGF0ZUluZm8pfWAsIFwiRVJSX1VQREFURVJfTk9fRklMRVNfUFJPVklERURcIik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGaWxlTGlzdCA9IGdldEZpbGVMaXN0O1xuZnVuY3Rpb24gcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIGJhc2VVcmwsIHBhdGhUcmFuc2Zvcm1lciA9IChwKSA9PiBwKSB7XG4gICAgY29uc3QgZmlsZXMgPSBnZXRGaWxlTGlzdCh1cGRhdGVJbmZvKTtcbiAgICBjb25zdCByZXN1bHQgPSBmaWxlcy5tYXAoZmlsZUluZm8gPT4ge1xuICAgICAgICBpZiAoZmlsZUluZm8uc2hhMiA9PSBudWxsICYmIGZpbGVJbmZvLnNoYTUxMiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBVcGRhdGUgaW5mbyBkb2Vzbid0IGNvbnRhaW4gbm9yIHNoYTI1NiBuZWl0aGVyIHNoYTUxMiBjaGVja3N1bTogJHtidWlsZGVyX3V0aWxfcnVudGltZV8xLnNhZmVTdHJpbmdpZnlKc29uKGZpbGVJbmZvKX1gLCBcIkVSUl9VUERBVEVSX05PX0NIRUNLU1VNXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHV0aWxfMS5uZXdVcmxGcm9tQmFzZShwYXRoVHJhbnNmb3JtZXIoZmlsZUluZm8udXJsKSwgYmFzZVVybCksXG4gICAgICAgICAgICBpbmZvOiBmaWxlSW5mbyxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwYWNrYWdlcyA9IHVwZGF0ZUluZm8ucGFja2FnZXM7XG4gICAgY29uc3QgcGFja2FnZUluZm8gPSBwYWNrYWdlcyA9PSBudWxsID8gbnVsbCA6IHBhY2thZ2VzW3Byb2Nlc3MuYXJjaF0gfHwgcGFja2FnZXMuaWEzMjtcbiAgICBpZiAocGFja2FnZUluZm8gIT0gbnVsbCkge1xuICAgICAgICA7XG4gICAgICAgIHJlc3VsdFswXS5wYWNrYWdlSW5mbyA9IHtcbiAgICAgICAgICAgIC4uLnBhY2thZ2VJbmZvLFxuICAgICAgICAgICAgcGF0aDogdXRpbF8xLm5ld1VybEZyb21CYXNlKHBhdGhUcmFuc2Zvcm1lcihwYWNrYWdlSW5mby5wYXRoKSwgYmFzZVVybCkuaHJlZixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVzb2x2ZUZpbGVzID0gcmVzb2x2ZUZpbGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdlbmVyaWNQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9Qcm92aWRlclwiKTtcbmNsYXNzIEdlbmVyaWNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyXzEuUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb24sIHVwZGF0ZXIsIHJ1bnRpbWVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gdXRpbF8xLm5ld0Jhc2VVcmwodGhpcy5jb25maWd1cmF0aW9uLnVybCk7XG4gICAgfVxuICAgIGdldCBjaGFubmVsKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVwZGF0ZXIuY2hhbm5lbCB8fCB0aGlzLmNvbmZpZ3VyYXRpb24uY2hhbm5lbDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PSBudWxsID8gdGhpcy5nZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSA6IHRoaXMuZ2V0Q3VzdG9tQ2hhbm5lbE5hbWUocmVzdWx0KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSB1dGlsXzEuZ2V0Q2hhbm5lbEZpbGVuYW1lKHRoaXMuY2hhbm5lbCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxVcmwgPSB1dGlsXzEubmV3VXJsRnJvbUJhc2UoY2hhbm5lbEZpbGUsIHRoaXMuYmFzZVVybCwgdGhpcy51cGRhdGVyLmlzQWRkTm9DYWNoZVF1ZXJ5KTtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdE51bWJlciA9IDA7OyBhdHRlbXB0TnVtYmVyKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucGFyc2VVcGRhdGVJbmZvKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbFVybCksIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBidWlsZGVyX3V0aWxfcnVudGltZV8xLkh0dHBFcnJvciAmJiBlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDYW5ub3QgZmluZCBjaGFubmVsIFwiJHtjaGFubmVsRmlsZX1cIiB1cGRhdGUgaW5mbzogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0NIQU5ORUxfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdE51bWJlciA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAgKiBhdHRlbXB0TnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlRmlsZXModXBkYXRlSW5mbykge1xuICAgICAgICByZXR1cm4gUHJvdmlkZXJfMS5yZXNvbHZlRmlsZXModXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsKTtcbiAgICB9XG59XG5leHBvcnRzLkdlbmVyaWNQcm92aWRlciA9IEdlbmVyaWNQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlbmVyaWNQcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmludHJheUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGh0dHBFeGVjdXRvcl8xID0gcmVxdWlyZShcIi4vaHR0cEV4ZWN1dG9yXCIpO1xuY2xhc3MgQmludHJheUNsaWVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgaHR0cEV4ZWN1dG9yLCBjYW5jZWxsYXRpb25Ub2tlbiwgYXBpS2V5KSB7XG4gICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gaHR0cEV4ZWN1dG9yO1xuICAgICAgICB0aGlzLmNhbmNlbGxhdGlvblRva2VuID0gY2FuY2VsbGF0aW9uVG9rZW47XG4gICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5vd25lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvd25lciBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBhY2thZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2FnZSBpcyBub3Qgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwbyA9IG9wdGlvbnMucmVwbyB8fCBcImdlbmVyaWNcIjtcbiAgICAgICAgdGhpcy5wYWNrYWdlTmFtZSA9IG9wdGlvbnMucGFja2FnZTtcbiAgICAgICAgdGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG4gICAgICAgIHRoaXMudXNlciA9IG9wdGlvbnMudXNlciB8fCBvcHRpb25zLm93bmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG9wdGlvbnMuY29tcG9uZW50IHx8IG51bGw7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uID0gb3B0aW9ucy5kaXN0cmlidXRpb24gfHwgXCJzdGFibGVcIjtcbiAgICAgICAgdGhpcy5hdXRoID0gYXBpS2V5ID09IG51bGwgPyBudWxsIDogYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7dGhpcy51c2VyfToke2FwaUtleX1gKS50b1N0cmluZyhcImJhc2U2NFwiKX1gO1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYC9wYWNrYWdlcy8ke3RoaXMub3duZXJ9LyR7dGhpcy5yZXBvfS8ke3RoaXMucGFja2FnZU5hbWV9YDtcbiAgICB9XG4gICAgc2V0UmVxdWVzdEhlYWRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SGVhZGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBiaW50cmF5UmVxdWVzdChwYXRoLCBhdXRoLCBkYXRhID0gbnVsbCwgY2FuY2VsbGF0aW9uVG9rZW4sIG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaHR0cEV4ZWN1dG9yXzEucGFyc2VKc29uKHRoaXMuaHR0cEV4ZWN1dG9yLnJlcXVlc3QoaHR0cEV4ZWN1dG9yXzEuY29uZmlndXJlUmVxdWVzdE9wdGlvbnMoeyBob3N0bmFtZTogXCJhcGkuYmludHJheS5jb21cIiwgcGF0aCwgaGVhZGVyczogdGhpcy5yZXF1ZXN0SGVhZGVycyB8fCB1bmRlZmluZWQgfSwgYXV0aCwgbWV0aG9kKSwgY2FuY2VsbGF0aW9uVG9rZW4sIGRhdGEpKTtcbiAgICB9XG4gICAgZ2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zLyR7dmVyc2lvbn1gLCB0aGlzLmF1dGgsIG51bGwsIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBnZXRWZXJzaW9uRmlsZXModmVyc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW50cmF5UmVxdWVzdChgJHt0aGlzLmJhc2VQYXRofS92ZXJzaW9ucy8ke3ZlcnNpb259L2ZpbGVzYCwgdGhpcy5hdXRoLCBudWxsLCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgY3JlYXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zYCwgdGhpcy5hdXRoLCB7XG4gICAgICAgICAgICBuYW1lOiB2ZXJzaW9uLFxuICAgICAgICB9LCB0aGlzLmNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZGVsZXRlVmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbnRyYXlSZXF1ZXN0KGAke3RoaXMuYmFzZVBhdGh9L3ZlcnNpb25zLyR7dmVyc2lvbn1gLCB0aGlzLmF1dGgsIG51bGwsIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4sIFwiREVMRVRFXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmludHJheUNsaWVudCA9IEJpbnRyYXlDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW50cmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CaW50cmF5UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgYmludHJheV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lL291dC9iaW50cmF5XCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG5jbGFzcyBCaW50cmF5UHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcl8xLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcihydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gbmV3IGJpbnRyYXlfMS5CaW50cmF5Q2xpZW50KGNvbmZpZ3VyYXRpb24sIHJ1bnRpbWVPcHRpb25zLmV4ZWN1dG9yLCBuZXcgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25Ub2tlbigpKTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gdXRpbF8xLm5ld0Jhc2VVcmwoYGh0dHBzOi8vZGwuYmludHJheS5jb20vJHt0aGlzLmNsaWVudC5vd25lcn0vJHt0aGlzLmNsaWVudC5yZXBvfWApO1xuICAgIH1cbiAgICBzZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXRSZXF1ZXN0SGVhZGVycyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2xpZW50LnNldFJlcXVlc3RIZWFkZXJzKHZhbHVlKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNsaWVudC5nZXRWZXJzaW9uKFwiX2xhdGVzdFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlbmFtZSA9IHV0aWxfMS5nZXRDaGFubmVsRmlsZW5hbWUodGhpcy5nZXREZWZhdWx0Q2hhbm5lbE5hbWUoKSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMuY2xpZW50LmdldFZlcnNpb25GaWxlcyhkYXRhLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGUgPSBmaWxlcy5maW5kKGl0ID0+IGl0Lm5hbWUuZW5kc1dpdGgoYF8ke2NoYW5uZWxGaWxlbmFtZX1gKSB8fCBpdC5uYW1lLmVuZHNXaXRoKGAtJHtjaGFubmVsRmlsZW5hbWV9YCkpO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWxGaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IGZpbmQgY2hhbm5lbCBmaWxlIFwiJHtjaGFubmVsRmlsZW5hbWV9XCIsIGV4aXN0aW5nIGZpbGVzOlxcbiR7ZmlsZXMubWFwKGl0ID0+IEpTT04uc3RyaW5naWZ5KGl0LCBudWxsLCAyKSkuam9pbihcIixcXG5cIil9YCwgXCJFUlJfVVBEQVRFUl9DSEFOTkVMX0ZJTEVfTk9UX0ZPVU5EXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVVcmwgPSBuZXcgdXJsXzEuVVJMKGBodHRwczovL2RsLmJpbnRyYXkuY29tLyR7dGhpcy5jbGllbnQub3duZXJ9LyR7dGhpcy5jbGllbnQucmVwb30vJHtjaGFubmVsRmlsZS5uYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucGFyc2VVcGRhdGVJbmZvKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QoY2hhbm5lbEZpbGVVcmwpLCBjaGFubmVsRmlsZW5hbWUsIGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKFwic3RhdHVzQ29kZVwiIGluIGUgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBObyBsYXRlc3QgdmVyc2lvbiwgcGxlYXNlIGVuc3VyZSB0aGF0IHVzZXIsIHBhY2thZ2UgYW5kIHJlcG9zaXRvcnkgY29ycmVjdGx5IGNvbmZpZ3VyZWQuIE9yIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHB1Ymxpc2hlZC4gJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucmVzb2x2ZUZpbGVzKHVwZGF0ZUluZm8sIHRoaXMuYmFzZVVybCk7XG4gICAgfVxufVxuZXhwb3J0cy5CaW50cmF5UHJvdmlkZXIgPSBCaW50cmF5UHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaW50cmF5UHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXB1dGVSZWxlYXNlTm90ZXMgPSBleHBvcnRzLkdpdEh1YlByb3ZpZGVyID0gZXhwb3J0cy5CYXNlR2l0SHViUHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY29uc3QgaHJlZlJlZ0V4cCA9IC9cXC90YWdcXC8oW14vXSspJC87XG5jbGFzcyBCYXNlR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcl8xLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBkZWZhdWx0SG9zdCwgcnVudGltZU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICAvKiBiZWNhdXNlIEdpdEhpYiB1c2VzIFMzICovXG4gICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IHV0aWxfMS5uZXdCYXNlVXJsKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2l0aHViVXJsKG9wdGlvbnMsIGRlZmF1bHRIb3N0KSk7XG4gICAgICAgIGNvbnN0IGFwaUhvc3QgPSBkZWZhdWx0SG9zdCA9PT0gXCJnaXRodWIuY29tXCIgPyBcImFwaS5naXRodWIuY29tXCIgOiBkZWZhdWx0SG9zdDtcbiAgICAgICAgdGhpcy5iYXNlQXBpVXJsID0gdXRpbF8xLm5ld0Jhc2VVcmwoYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5naXRodWJVcmwob3B0aW9ucywgYXBpSG9zdCkpO1xuICAgIH1cbiAgICBjb21wdXRlR2l0aHViQmFzZVBhdGgocmVzdWx0KSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xOTAzI2lzc3VlY29tbWVudC0zMjA4ODEyMTFcbiAgICAgICAgY29uc3QgaG9zdCA9IHRoaXMub3B0aW9ucy5ob3N0O1xuICAgICAgICByZXR1cm4gaG9zdCAhPSBudWxsICYmIGhvc3QgIT09IFwiZ2l0aHViLmNvbVwiICYmIGhvc3QgIT09IFwiYXBpLmdpdGh1Yi5jb21cIiA/IGAvYXBpL3YzJHtyZXN1bHR9YCA6IHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VHaXRIdWJQcm92aWRlciA9IEJhc2VHaXRIdWJQcm92aWRlcjtcbmNsYXNzIEdpdEh1YlByb3ZpZGVyIGV4dGVuZHMgQmFzZUdpdEh1YlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBcImdpdGh1Yi5jb21cIiwgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgIGNvbnN0IGZlZWRYbWwgPSAoYXdhaXQgdGhpcy5odHRwUmVxdWVzdCh1dGlsXzEubmV3VXJsRnJvbUJhc2UoYCR7dGhpcy5iYXNlUGF0aH0uYXRvbWAsIHRoaXMuYmFzZVVybCksIHtcbiAgICAgICAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi94bWwsIGFwcGxpY2F0aW9uL2F0b20reG1sLCB0ZXh0L3htbCwgKi8qXCIsXG4gICAgICAgIH0sIGNhbmNlbGxhdGlvblRva2VuKSk7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBidWlsZGVyX3V0aWxfcnVudGltZV8xLnBhcnNlWG1sKGZlZWRYbWwpO1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICBsZXQgbGF0ZXN0UmVsZWFzZSA9IGZlZWQuZWxlbWVudChcImVudHJ5XCIsIGZhbHNlLCBgTm8gcHVibGlzaGVkIHZlcnNpb25zIG9uIEdpdEh1YmApO1xuICAgICAgICBsZXQgdGFnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICAgICAgICAgIHRhZyA9IGhyZWZSZWdFeHAuZXhlYyhsYXRlc3RSZWxlYXNlLmVsZW1lbnQoXCJsaW5rXCIpLmF0dHJpYnV0ZShcImhyZWZcIikpWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFnID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RUYWdOYW1lKGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZmVlZC5nZXRFbGVtZW50cyhcImVudHJ5XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0VmFsaWRhdGVKU1R5cGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChocmVmUmVnRXhwLmV4ZWMoZWxlbWVudC5lbGVtZW50KFwibGlua1wiKS5hdHRyaWJ1dGUoXCJocmVmXCIpKVsxXSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRlc3RSZWxlYXNlID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDYW5ub3QgcGFyc2UgcmVsZWFzZXMgZmVlZDogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX0sXFxuWE1MOlxcbiR7ZmVlZFhtbH1gLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfUkVMRUFTRV9GRUVEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgTm8gcHVibGlzaGVkIHZlcnNpb25zIG9uIEdpdEh1YmAsIFwiRVJSX1VQREFURVJfTk9fUFVCTElTSEVEX1ZFUlNJT05TXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSh0aGlzLmdldERlZmF1bHRDaGFubmVsTmFtZSgpKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbEZpbGVVcmwgPSB1dGlsXzEubmV3VXJsRnJvbUJhc2UodGhpcy5nZXRCYXNlRG93bmxvYWRQYXRoKHRhZywgY2hhbm5lbEZpbGUpLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoY2hhbm5lbEZpbGVVcmwpO1xuICAgICAgICBsZXQgcmF3RGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJhd0RhdGEgPSAoYXdhaXQgdGhpcy5leGVjdXRvci5yZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBjYW5jZWxsYXRpb25Ub2tlbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlci5hbGxvd1ByZXJlbGVhc2UgJiYgZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuSHR0cEVycm9yICYmIGUuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIGxhdGVzdCByZWxlYXNlIGFydGlmYWN0cyAoJHtjaGFubmVsRmlsZVVybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUHJvdmlkZXJfMS5wYXJzZVVwZGF0ZUluZm8ocmF3RGF0YSwgY2hhbm5lbEZpbGUsIGNoYW5uZWxGaWxlVXJsKTtcbiAgICAgICAgaWYgKHJlc3VsdC5yZWxlYXNlTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsZWFzZU5hbWUgPSBsYXRlc3RSZWxlYXNlLmVsZW1lbnRWYWx1ZU9yRW1wdHkoXCJ0aXRsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnJlbGVhc2VOb3RlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsZWFzZU5vdGVzID0gY29tcHV0ZVJlbGVhc2VOb3Rlcyh0aGlzLnVwZGF0ZXIuY3VycmVudFZlcnNpb24sIHRoaXMudXBkYXRlci5mdWxsQ2hhbmdlbG9nLCBmZWVkLCBsYXRlc3RSZWxlYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGdldExhdGVzdFRhZ05hbWUoY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLy8gZG8gbm90IHVzZSBBUEkgZm9yIEdpdEh1YiB0byBhdm9pZCBsaW1pdCwgb25seSBmb3IgY3VzdG9tIGhvc3Qgb3IgR2l0SHViIEVudGVycHJpc2VcbiAgICAgICAgY29uc3QgdXJsID0gb3B0aW9ucy5ob3N0ID09IG51bGwgfHwgb3B0aW9ucy5ob3N0ID09PSBcImdpdGh1Yi5jb21cIlxuICAgICAgICAgICAgPyB1dGlsXzEubmV3VXJsRnJvbUJhc2UoYCR7dGhpcy5iYXNlUGF0aH0vbGF0ZXN0YCwgdGhpcy5iYXNlVXJsKVxuICAgICAgICAgICAgOiBuZXcgdXJsXzEuVVJMKGAke3RoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvcmVwb3MvJHtvcHRpb25zLm93bmVyfS8ke29wdGlvbnMucmVwb30vcmVsZWFzZXNgKX0vbGF0ZXN0YCwgdGhpcy5iYXNlQXBpVXJsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCB0aGlzLmh0dHBSZXF1ZXN0KHVybCwgeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgICAgIGlmIChyYXdEYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VJbmZvID0gSlNPTi5wYXJzZShyYXdEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiByZWxlYXNlSW5mby50YWdfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgVW5hYmxlIHRvIGZpbmQgbGF0ZXN0IHZlcnNpb24gb24gR2l0SHViICgke3VybH0pLCBwbGVhc2UgZW5zdXJlIGEgcHJvZHVjdGlvbiByZWxlYXNlIGV4aXN0czogJHtlLnN0YWNrIHx8IGUubWVzc2FnZX1gLCBcIkVSUl9VUERBVEVSX0xBVEVTVF9WRVJTSU9OX05PVF9GT1VORFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmFzZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgLyR7dGhpcy5vcHRpb25zLm93bmVyfS8ke3RoaXMub3B0aW9ucy5yZXBvfS9yZWxlYXNlc2A7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIC8vIHN0aWxsIHJlcGxhY2Ugc3BhY2UgdG8gLSBkdWUgdG8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICByZXR1cm4gUHJvdmlkZXJfMS5yZXNvbHZlRmlsZXModXBkYXRlSW5mbywgdGhpcy5iYXNlVXJsLCBwID0+IHRoaXMuZ2V0QmFzZURvd25sb2FkUGF0aCh1cGRhdGVJbmZvLnRhZywgcC5yZXBsYWNlKC8gL2csIFwiLVwiKSkpO1xuICAgIH1cbiAgICBnZXRCYXNlRG93bmxvYWRQYXRoKHRhZywgZmlsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZVBhdGh9L2Rvd25sb2FkLyR7dGFnfS8ke2ZpbGVOYW1lfWA7XG4gICAgfVxufVxuZXhwb3J0cy5HaXRIdWJQcm92aWRlciA9IEdpdEh1YlByb3ZpZGVyO1xuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlKHBhcmVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudC5lbGVtZW50VmFsdWVPckVtcHR5KFwiY29udGVudFwiKTtcbiAgICAvLyBHaXRIdWIgcmVwb3J0cyBlbXB0eSBub3RlcyBhcyA8Y29udGVudD5ObyBjb250ZW50LjwvY29udGVudD5cbiAgICByZXR1cm4gcmVzdWx0ID09PSBcIk5vIGNvbnRlbnQuXCIgPyBcIlwiIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlbGVhc2VOb3RlcyhjdXJyZW50VmVyc2lvbiwgaXNGdWxsQ2hhbmdlbG9nLCBmZWVkLCBsYXRlc3RSZWxlYXNlKSB7XG4gICAgaWYgKCFpc0Z1bGxDaGFuZ2Vsb2cpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vdGVWYWx1ZShsYXRlc3RSZWxlYXNlKTtcbiAgICB9XG4gICAgY29uc3QgcmVsZWFzZU5vdGVzID0gW107XG4gICAgZm9yIChjb25zdCByZWxlYXNlIG9mIGZlZWQuZ2V0RWxlbWVudHMoXCJlbnRyeVwiKSkge1xuICAgICAgICAvLyBub2luc3BlY3Rpb24gVHlwZVNjcmlwdFZhbGlkYXRlSlNUeXBlc1xuICAgICAgICBjb25zdCB2ZXJzaW9uUmVsZWFzZSA9IC9cXC90YWdcXC92PyhbXi9dKykkLy5leGVjKHJlbGVhc2UuZWxlbWVudChcImxpbmtcIikuYXR0cmlidXRlKFwiaHJlZlwiKSlbMV07XG4gICAgICAgIGlmIChzZW12ZXIubHQoY3VycmVudFZlcnNpb24sIHZlcnNpb25SZWxlYXNlKSkge1xuICAgICAgICAgICAgcmVsZWFzZU5vdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25SZWxlYXNlLFxuICAgICAgICAgICAgICAgIG5vdGU6IGdldE5vdGVWYWx1ZShyZWxlYXNlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWxlYXNlTm90ZXMuc29ydCgoYSwgYikgPT4gc2VtdmVyLnJjb21wYXJlKGEudmVyc2lvbiwgYi52ZXJzaW9uKSk7XG59XG5leHBvcnRzLmNvbXB1dGVSZWxlYXNlTm90ZXMgPSBjb21wdXRlUmVsZWFzZU5vdGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2l0SHViUHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLktleWdlblByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL1Byb3ZpZGVyXCIpO1xuY2xhc3MgS2V5Z2VuUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlcl8xLlByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucykge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAuLi5ydW50aW1lT3B0aW9ucyxcbiAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlcjtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gdXRpbF8xLm5ld0Jhc2VVcmwoYGh0dHBzOi8vYXBpLmtleWdlbi5zaC92MS9hY2NvdW50cy8ke3RoaXMuY29uZmlndXJhdGlvbi5hY2NvdW50fS9hcnRpZmFjdHNgKTtcbiAgICB9XG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuY2hhbm5lbCB8fCB0aGlzLmNvbmZpZ3VyYXRpb24uY2hhbm5lbCB8fCBcInN0YWJsZVwiO1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSh0aGlzLmdldEN1c3RvbUNoYW5uZWxOYW1lKHRoaXMuY2hhbm5lbCkpO1xuICAgICAgICBjb25zdCBjaGFubmVsVXJsID0gdXRpbF8xLm5ld1VybEZyb21CYXNlKGNoYW5uZWxGaWxlLCB0aGlzLmJhc2VVcmwsIHRoaXMudXBkYXRlci5pc0FkZE5vQ2FjaGVRdWVyeSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVJbmZvID0gYXdhaXQgdGhpcy5odHRwUmVxdWVzdChjaGFubmVsVXJsLCB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5hcGkranNvblwiLFxuICAgICAgICAgICAgfSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIFByb3ZpZGVyXzEucGFyc2VVcGRhdGVJbmZvKHVwZGF0ZUluZm8sIGNoYW5uZWxGaWxlLCBjaGFubmVsVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgVW5hYmxlIHRvIGZpbmQgbGF0ZXN0IHZlcnNpb24gb24gJHt0aGlzLnRvU3RyaW5nKCl9LCBwbGVhc2UgZW5zdXJlIHJlbGVhc2UgZXhpc3RzOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBQcm92aWRlcl8xLnJlc29sdmVGaWxlcyh1cGRhdGVJbmZvLCB0aGlzLmJhc2VVcmwpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgeyBhY2NvdW50LCBwcm9kdWN0LCBwbGF0Zm9ybSB9ID0gdGhpcy5jb25maWd1cmF0aW9uO1xuICAgICAgICByZXR1cm4gYEtleWdlbiAoYWNjb3VudDogJHthY2NvdW50fSwgcHJvZHVjdDogJHtwcm9kdWN0fSwgcGxhdGZvcm06ICR7cGxhdGZvcm19LCBjaGFubmVsOiAke3RoaXMuY2hhbm5lbH0pYDtcbiAgICB9XG59XG5leHBvcnRzLktleWdlblByb3ZpZGVyID0gS2V5Z2VuUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlnZW5Qcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpdmF0ZUdpdEh1YlByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGpzX3lhbWxfMSA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBHaXRIdWJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vR2l0SHViUHJvdmlkZXJcIik7XG5jb25zdCBQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vUHJvdmlkZXJcIik7XG5jbGFzcyBQcml2YXRlR2l0SHViUHJvdmlkZXIgZXh0ZW5kcyBHaXRIdWJQcm92aWRlcl8xLkJhc2VHaXRIdWJQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgdXBkYXRlciwgdG9rZW4sIHJ1bnRpbWVPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIFwiYXBpLmdpdGh1Yi5jb21cIiwgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKHVybCwgaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5jcmVhdGVSZXF1ZXN0T3B0aW9ucyh1cmwsIGhlYWRlcnMpO1xuICAgICAgICByZXN1bHQucmVkaXJlY3QgPSBcIm1hbnVhbFwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZXRMYXRlc3RWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxGaWxlID0gdXRpbF8xLmdldENoYW5uZWxGaWxlbmFtZSh0aGlzLmdldERlZmF1bHRDaGFubmVsTmFtZSgpKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUluZm8gPSBhd2FpdCB0aGlzLmdldExhdGVzdFZlcnNpb25JbmZvKGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgY29uc3QgYXNzZXQgPSByZWxlYXNlSW5mby5hc3NldHMuZmluZChpdCA9PiBpdC5uYW1lID09PSBjaGFubmVsRmlsZSk7XG4gICAgICAgIGlmIChhc3NldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBodG1sX3VybCBtdXN0IGJlIGFsd2F5cywgYnV0IGp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgQ2Fubm90IGZpbmQgJHtjaGFubmVsRmlsZX0gaW4gdGhlIHJlbGVhc2UgJHtyZWxlYXNlSW5mby5odG1sX3VybCB8fCByZWxlYXNlSW5mby5uYW1lfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgdXJsXzEuVVJMKGFzc2V0LnVybCk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBqc195YW1sXzEubG9hZCgoYXdhaXQgdGhpcy5odHRwUmVxdWVzdCh1cmwsIHRoaXMuY29uZmlndXJlSGVhZGVycyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSwgY2FuY2VsbGF0aW9uVG9rZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5IdHRwRXJyb3IgJiYgZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDYW5ub3QgZmluZCAke2NoYW5uZWxGaWxlfSBpbiB0aGUgbGF0ZXN0IHJlbGVhc2UgYXJ0aWZhY3RzICgke3VybH0pOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfQ0hBTk5FTF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICByZXN1bHQuYXNzZXRzID0gcmVsZWFzZUluZm8uYXNzZXRzO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVIZWFkZXJzKFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG4gICAgY29uZmlndXJlSGVhZGVycyhhY2NlcHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2VwdCxcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGB0b2tlbiAke3RoaXMudG9rZW59YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGF0ZXN0VmVyc2lvbkluZm8oY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWxsb3dQcmVyZWxlYXNlID0gdGhpcy51cGRhdGVyLmFsbG93UHJlcmVsZWFzZTtcbiAgICAgICAgbGV0IGJhc2VQYXRoID0gdGhpcy5iYXNlUGF0aDtcbiAgICAgICAgaWYgKCFhbGxvd1ByZXJlbGVhc2UpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYCR7YmFzZVBhdGh9L2xhdGVzdGA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gdXRpbF8xLm5ld1VybEZyb21CYXNlKGJhc2VQYXRoLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IEpTT04ucGFyc2UoKGF3YWl0IHRoaXMuaHR0cFJlcXVlc3QodXJsLCB0aGlzLmNvbmZpZ3VyZUhlYWRlcnMoXCJhcHBsaWNhdGlvbi92bmQuZ2l0aHViLnYzK2pzb25cIiksIGNhbmNlbGxhdGlvblRva2VuKSkpO1xuICAgICAgICAgICAgaWYgKGFsbG93UHJlcmVsZWFzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uLmZpbmQoaXQgPT4gaXQucHJlcmVsZWFzZSkgfHwgdmVyc2lvblswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBVbmFibGUgdG8gZmluZCBsYXRlc3QgdmVyc2lvbiBvbiBHaXRIdWIgKCR7dXJsfSksIHBsZWFzZSBlbnN1cmUgYSBwcm9kdWN0aW9uIHJlbGVhc2UgZXhpc3RzOiAke2Uuc3RhY2sgfHwgZS5tZXNzYWdlfWAsIFwiRVJSX1VQREFURVJfTEFURVNUX1ZFUlNJT05fTk9UX0ZPVU5EXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiYXNlUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUdpdGh1YkJhc2VQYXRoKGAvcmVwb3MvJHt0aGlzLm9wdGlvbnMub3duZXJ9LyR7dGhpcy5vcHRpb25zLnJlcG99L3JlbGVhc2VzYCk7XG4gICAgfVxuICAgIHJlc29sdmVGaWxlcyh1cGRhdGVJbmZvKSB7XG4gICAgICAgIHJldHVybiBQcm92aWRlcl8xLmdldEZpbGVMaXN0KHVwZGF0ZUluZm8pLm1hcChpdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGF0aC5wb3NpeC5iYXNlbmFtZShpdC51cmwpLnJlcGxhY2UoLyAvZywgXCItXCIpO1xuICAgICAgICAgICAgY29uc3QgYXNzZXQgPSB1cGRhdGVJbmZvLmFzc2V0cy5maW5kKGl0ID0+IGl0ICE9IG51bGwgJiYgaXQubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoYXNzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYENhbm5vdCBmaW5kIGFzc2V0IFwiJHtuYW1lfVwiIGluOiAke0pTT04uc3RyaW5naWZ5KHVwZGF0ZUluZm8uYXNzZXRzLCBudWxsLCAyKX1gLCBcIkVSUl9VUERBVEVSX0FTU0VUX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiBuZXcgdXJsXzEuVVJMKGFzc2V0LnVybCksXG4gICAgICAgICAgICAgICAgaW5mbzogaXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlByaXZhdGVHaXRIdWJQcm92aWRlciA9IFByaXZhdGVHaXRIdWJQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVByaXZhdGVHaXRIdWJQcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQ2xpZW50ID0gZXhwb3J0cy5pc1VybFByb2JhYmx5U3VwcG9ydE11bHRpUmFuZ2VSZXF1ZXN0cyA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBCaW50cmF5UHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9CaW50cmF5UHJvdmlkZXJcIik7XG5jb25zdCBHZW5lcmljUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9HZW5lcmljUHJvdmlkZXJcIik7XG5jb25zdCBHaXRIdWJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL0dpdEh1YlByb3ZpZGVyXCIpO1xuY29uc3QgS2V5Z2VuUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9LZXlnZW5Qcm92aWRlclwiKTtcbmNvbnN0IFByaXZhdGVHaXRIdWJQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL1ByaXZhdGVHaXRIdWJQcm92aWRlclwiKTtcbmZ1bmN0aW9uIGlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKHVybCkge1xuICAgIHJldHVybiAhdXJsLmluY2x1ZGVzKFwiczMuYW1hem9uYXdzLmNvbVwiKTtcbn1cbmV4cG9ydHMuaXNVcmxQcm9iYWJseVN1cHBvcnRNdWx0aVJhbmdlUmVxdWVzdHMgPSBpc1VybFByb2JhYmx5U3VwcG9ydE11bHRpUmFuZ2VSZXF1ZXN0cztcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChkYXRhLCB1cGRhdGVyLCBydW50aW1lT3B0aW9ucykge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcIlBsZWFzZSBwYXNzIFB1Ymxpc2hDb25maWd1cmF0aW9uIG9iamVjdFwiLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfUFJPVklERVJfQ09ORklHVVJBVElPTlwiKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyO1xuICAgIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICAgICAgY2FzZSBcImdpdGh1YlwiOiB7XG4gICAgICAgICAgICBjb25zdCBnaXRodWJPcHRpb25zID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gKGdpdGh1Yk9wdGlvbnMucHJpdmF0ZSA/IHByb2Nlc3MuZW52W1wiR0hfVE9LRU5cIl0gfHwgcHJvY2Vzcy5lbnZbXCJHSVRIVUJfVE9LRU5cIl0gOiBudWxsKSB8fCBnaXRodWJPcHRpb25zLnRva2VuO1xuICAgICAgICAgICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdpdEh1YlByb3ZpZGVyXzEuR2l0SHViUHJvdmlkZXIoZ2l0aHViT3B0aW9ucywgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcml2YXRlR2l0SHViUHJvdmlkZXJfMS5Qcml2YXRlR2l0SHViUHJvdmlkZXIoZ2l0aHViT3B0aW9ucywgdXBkYXRlciwgdG9rZW4sIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWdlblByb3ZpZGVyXzEuS2V5Z2VuUHJvdmlkZXIoZGF0YSwgdXBkYXRlciwgcnVudGltZU9wdGlvbnMpO1xuICAgICAgICBjYXNlIFwiczNcIjpcbiAgICAgICAgY2FzZSBcInNwYWNlc1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljUHJvdmlkZXJfMS5HZW5lcmljUHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBcImdlbmVyaWNcIixcbiAgICAgICAgICAgICAgICB1cmw6IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuZ2V0UzNMaWtlUHJvdmlkZXJCYXNlVXJsKGRhdGEpLFxuICAgICAgICAgICAgICAgIGNoYW5uZWw6IGRhdGEuY2hhbm5lbCB8fCBudWxsLFxuICAgICAgICAgICAgfSwgdXBkYXRlciwge1xuICAgICAgICAgICAgICAgIC4uLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pby9taW5pby9pc3N1ZXMvNTI4NSNpc3N1ZWNvbW1lbnQtMzUwNDI4OTU1XG4gICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBcImdlbmVyaWNcIjoge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNQcm92aWRlcl8xLkdlbmVyaWNQcm92aWRlcihvcHRpb25zLCB1cGRhdGVyLCB7XG4gICAgICAgICAgICAgICAgLi4ucnVudGltZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogb3B0aW9ucy51c2VNdWx0aXBsZVJhbmdlUmVxdWVzdCAhPT0gZmFsc2UgJiYgaXNVcmxQcm9iYWJseVN1cHBvcnRNdWx0aVJhbmdlUmVxdWVzdHMob3B0aW9ucy51cmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbnRyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmludHJheVByb3ZpZGVyXzEuQmludHJheVByb3ZpZGVyKGRhdGEsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgY2FzZSBcImN1c3RvbVwiOiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gb3B0aW9ucy51cGRhdGVQcm92aWRlcjtcbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKFwiQ3VzdG9tIHByb3ZpZGVyIG5vdCBzcGVjaWZpZWRcIiwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1BST1ZJREVSX0NPTkZJR1VSQVRJT05cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yKG9wdGlvbnMsIHVwZGF0ZXIsIHJ1bnRpbWVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihgVW5zdXBwb3J0ZWQgcHJvdmlkZXI6ICR7cHJvdmlkZXJ9YCwgXCJFUlJfVVBEQVRFUl9VTlNVUFBPUlRFRF9QUk9WSURFUlwiKTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUNsaWVudCA9IGNyZWF0ZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyRmFjdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9PcExvZ2dlciA9IGV4cG9ydHMuQXBwVXBkYXRlciA9IHZvaWQgMDtcbmNvbnN0IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEgPSByZXF1aXJlKFwiYnVpbGRlci11dGlsLXJ1bnRpbWVcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBmc19leHRyYV8xID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3QgcHJvbWlzZXNfMSA9IHJlcXVpcmUoXCJmcy9wcm9taXNlc1wiKTtcbmNvbnN0IGpzX3lhbWxfMSA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuY29uc3QgbGF6eV92YWxfMSA9IHJlcXVpcmUoXCJsYXp5LXZhbFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHNlbXZlcl8xID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IERvd25sb2FkZWRVcGRhdGVIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL0Rvd25sb2FkZWRVcGRhdGVIZWxwZXJcIik7XG5jb25zdCBFbGVjdHJvbkFwcEFkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL0VsZWN0cm9uQXBwQWRhcHRlclwiKTtcbmNvbnN0IGVsZWN0cm9uSHR0cEV4ZWN1dG9yXzEgPSByZXF1aXJlKFwiLi9lbGVjdHJvbkh0dHBFeGVjdXRvclwiKTtcbmNvbnN0IEdlbmVyaWNQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJzL0dlbmVyaWNQcm92aWRlclwiKTtcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuL21haW5cIik7XG5jb25zdCBwcm92aWRlckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyRmFjdG9yeVwiKTtcbmNsYXNzIEFwcFVwZGF0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGRvd25sb2FkIGFuIHVwZGF0ZSB3aGVuIGl0IGlzIGZvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvRG93bmxvYWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhdXRvbWF0aWNhbGx5IGluc3RhbGwgYSBkb3dubG9hZGVkIHVwZGF0ZSBvbiBhcHAgcXVpdCAoaWYgYHF1aXRBbmRJbnN0YWxsYCB3YXMgbm90IGNhbGxlZCBiZWZvcmUpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdXRvSW5zdGFsbE9uQXBwUXVpdCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqR2l0SHViIHByb3ZpZGVyIG9ubHkuKiBXaGV0aGVyIHRvIGFsbG93IHVwZGF0ZSB0byBwcmUtcmVsZWFzZSB2ZXJzaW9ucy4gRGVmYXVsdHMgdG8gYHRydWVgIGlmIGFwcGxpY2F0aW9uIHZlcnNpb24gY29udGFpbnMgcHJlcmVsZWFzZSBjb21wb25lbnRzIChlLmcuIGAwLjEyLjEtYWxwaGEuMWAsIGhlcmUgYGFscGhhYCBpcyBhIHByZXJlbGVhc2UgY29tcG9uZW50KSwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGB0cnVlYCwgZG93bmdyYWRlIHdpbGwgYmUgYWxsb3dlZCAoYGFsbG93RG93bmdyYWRlYCB3aWxsIGJlIHNldCB0byBgdHJ1ZWApLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxvd1ByZXJlbGVhc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICpHaXRIdWIgcHJvdmlkZXIgb25seS4qIEdldCBhbGwgcmVsZWFzZSBub3RlcyAoZnJvbSBjdXJyZW50IHZlcnNpb24gdG8gbGF0ZXN0KSwgbm90IGp1c3QgdGhlIGxhdGVzdC5cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnVsbENoYW5nZWxvZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBhbGxvdyB2ZXJzaW9uIGRvd25ncmFkZSAod2hlbiBhIHVzZXIgZnJvbSB0aGUgYmV0YSBjaGFubmVsIHdhbnRzIHRvIGdvIGJhY2sgdG8gdGhlIHN0YWJsZSBjaGFubmVsKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGFrZW4gaW4gYWNjb3VudCBvbmx5IGlmIGNoYW5uZWwgZGlmZmVycyAocHJlLXJlbGVhc2UgdmVyc2lvbiBjb21wb25lbnQgaW4gdGVybXMgb2Ygc2VtYW50aWMgdmVyc2lvbmluZykuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbG93RG93bmdyYWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogIFRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gY29uc29sZTtcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIHR5cGUgc2FmZXR5IHlvdSBjYW4gdXNlIHNpZ25hbHMsIGUuZy4gYGF1dG9VcGRhdGVyLnNpZ25hbHMudXBkYXRlRG93bmxvYWRlZCgoKSA9PiB7fSlgIGluc3RlYWQgb2YgYGF1dG9VcGRhdGVyLm9uKCd1cGRhdGUtYXZhaWxhYmxlJywgKCkgPT4ge30pYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaWduYWxzID0gbmV3IG1haW5fMS5VcGRhdGVyU2lnbmFsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFnaW5nVXNlcklkUHJvbWlzZSA9IG5ldyBsYXp5X3ZhbF8xLkxhenkoKCkgPT4gdGhpcy5nZXRPckNyZWF0ZVN0YWdpbmdVc2VySWQoKSk7XG4gICAgICAgIC8vIHB1YmxpYywgYWxsb3cgdG8gcmVhZCBvbGQgY29uZmlnIGZvciBhbnlvbmVcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNvbmZpZ09uRGlzayA9IG5ldyBsYXp5X3ZhbF8xLkxhenkoKCkgPT4gdGhpcy5sb2FkVXBkYXRlQ29uZmlnKCkpO1xuICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm9BbmRQcm92aWRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Rlc3RPbmx5T3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgRXJyb3I6ICR7ZXJyb3Iuc3RhY2sgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChhcHAgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSBuZXcgRWxlY3Ryb25BcHBBZGFwdGVyXzEuRWxlY3Ryb25BcHBBZGFwdGVyKCk7XG4gICAgICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IG5ldyBlbGVjdHJvbkh0dHBFeGVjdXRvcl8xLkVsZWN0cm9uSHR0cEV4ZWN1dG9yKChhdXRoSW5mbywgY2FsbGJhY2spID0+IHRoaXMuZW1pdChcImxvZ2luXCIsIGF1dGhJbmZvLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgICAgICB0aGlzLmh0dHBFeGVjdXRvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb25TdHJpbmcgPSB0aGlzLmFwcC52ZXJzaW9uO1xuICAgICAgICBjb25zdCBjdXJyZW50VmVyc2lvbiA9IHNlbXZlcl8xLnBhcnNlKGN1cnJlbnRWZXJzaW9uU3RyaW5nKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYEFwcCB2ZXJzaW9uIGlzIG5vdCBhIHZhbGlkIHNlbXZlciB2ZXJzaW9uOiBcIiR7Y3VycmVudFZlcnNpb25TdHJpbmd9XCJgLCBcIkVSUl9VUERBVEVSX0lOVkFMSURfVkVSU0lPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRWZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgICAgIHRoaXMuYWxsb3dQcmVyZWxlYXNlID0gaGFzUHJlcmVsZWFzZUNvbXBvbmVudHMoY3VycmVudFZlcnNpb24pO1xuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZlZWRVUkwob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5yZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSBvcHRpb25zLnJlcXVlc3RIZWFkZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdXBkYXRlIGNoYW5uZWwuIE5vdCBhcHBsaWNhYmxlIGZvciBHaXRIdWIuIERvZXNuJ3QgcmV0dXJuIGBjaGFubmVsYCBmcm9tIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbiwgb25seSBpZiB3YXMgcHJldmlvdXNseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHVwZGF0ZSBjaGFubmVsLiBOb3QgYXBwbGljYWJsZSBmb3IgR2l0SHViLiBPdmVycmlkZXMgYGNoYW5uZWxgIGluIHRoZSB1cGRhdGUgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIGBhbGxvd0Rvd25ncmFkZWAgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBgdHJ1ZWAuIElmIHRoaXMgYmVoYXZpb3IgaXMgbm90IHN1aXRhYmxlIGZvciB5b3UsIHNpbXBsZSBzZXQgYGFsbG93RG93bmdyYWRlYCBleHBsaWNpdGx5IGFmdGVyLlxuICAgICAqL1xuICAgIHNldCBjaGFubmVsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGFubmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vaW5zcGVjdGlvbiBTdXNwaWNpb3VzVHlwZU9mR3VhcmRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDaGFubmVsIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3Q6ICR7dmFsdWV9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX0NIQU5ORUxcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBDaGFubmVsIG11c3QgYmUgbm90IGFuIGVtcHR5IHN0cmluZ2AsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9DSEFOTkVMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5uZWwgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5hbGxvd0Rvd25ncmFkZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTaG9ydGN1dCBmb3IgZXhwbGljaXRseSBhZGRpbmcgYXV0aCB0b2tlbnMgdG8gcmVxdWVzdCBoZWFkZXJzXG4gICAgICovXG4gICAgYWRkQXV0aEhlYWRlcih0b2tlbikge1xuICAgICAgICB0aGlzLnJlcXVlc3RIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXF1ZXN0SGVhZGVycywge1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogdG9rZW4sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNNZXRob2RDYW5CZVN0YXRpYyxKU1VudXNlZEdsb2JhbFN5bWJvbHNcbiAgICBnZXQgbmV0U2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIGVsZWN0cm9uSHR0cEV4ZWN1dG9yXzEuZ2V0TmV0U2Vzc2lvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbG9nZ2VyLiBZb3UgY2FuIHBhc3MgW2VsZWN0cm9uLWxvZ10oaHR0cHM6Ly9naXRodWIuY29tL21lZ2FoZXJ0ei9lbGVjdHJvbi1sb2cpLCBbd2luc3Rvbl0oaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uKSBvciBhbm90aGVyIGxvZ2dlciB3aXRoIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlOiBgeyBpbmZvKCksIHdhcm4oKSwgZXJyb3IoKSB9YC5cbiAgICAgKiBTZXQgaXQgdG8gYG51bGxgIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRpc2FibGUgYSBsb2dnaW5nIGZlYXR1cmUuXG4gICAgICovXG4gICAgZ2V0IGxvZ2dlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcbiAgICB9XG4gICAgc2V0IGxvZ2dlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9sb2dnZXIgPSB2YWx1ZSA9PSBudWxsID8gbmV3IE5vT3BMb2dnZXIoKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgLyoqXG4gICAgICogdGVzdCBvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXQgdXBkYXRlQ29uZmlnUGF0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnT25EaXNrID0gbmV3IGxhenlfdmFsXzEuTGF6eSgoKSA9PiB0aGlzLmxvYWRVcGRhdGVDb25maWcoKSk7XG4gICAgfVxuICAgIC8vbm9pbnNwZWN0aW9uIEpTTWV0aG9kQ2FuQmVTdGF0aWMsSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgZ2V0RmVlZFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIFwiRGVwcmVjYXRlZC4gRG8gbm90IHVzZSBpdC5cIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHVwZGF0ZSBwcm92aWRlci4gSWYgdmFsdWUgaXMgYHN0cmluZ2AsIFtHZW5lcmljU2VydmVyT3B0aW9uc10oL2NvbmZpZ3VyYXRpb24vcHVibGlzaCNnZW5lcmljc2VydmVyb3B0aW9ucykgd2lsbCBiZSBzZXQgd2l0aCB2YWx1ZSBhcyBgdXJsYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJZiB5b3Ugd2FudCB0byBvdmVycmlkZSBjb25maWd1cmF0aW9uIGluIHRoZSBgYXBwLXVwZGF0ZS55bWxgLlxuICAgICAqL1xuICAgIHNldEZlZWRVUkwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW50aW1lT3B0aW9ucyA9IHRoaXMuY3JlYXRlUHJvdmlkZXJSdW50aW1lT3B0aW9ucygpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMTEwNVxuICAgICAgICBsZXQgcHJvdmlkZXI7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgR2VuZXJpY1Byb3ZpZGVyXzEuR2VuZXJpY1Byb3ZpZGVyKHsgcHJvdmlkZXI6IFwiZ2VuZXJpY1wiLCB1cmw6IG9wdGlvbnMgfSwgdGhpcywge1xuICAgICAgICAgICAgICAgIC4uLnJ1bnRpbWVPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHByb3ZpZGVyRmFjdG9yeV8xLmlzVXJsUHJvYmFibHlTdXBwb3J0TXVsdGlSYW5nZVJlcXVlc3RzKG9wdGlvbnMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm92aWRlciA9IHByb3ZpZGVyRmFjdG9yeV8xLmNyZWF0ZUNsaWVudChvcHRpb25zLCB0aGlzLCBydW50aW1lT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHByb3ZpZGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNrcyB0aGUgc2VydmVyIHdoZXRoZXIgdGhlcmUgaXMgYW4gdXBkYXRlLlxuICAgICAqL1xuICAgIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgICAgbGV0IGNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2U7XG4gICAgICAgIGlmIChjaGVja0ZvclVwZGF0ZXNQcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiQ2hlY2tpbmcgZm9yIHVwZGF0ZSAoYWxyZWFkeSBpbiBwcm9ncmVzcylcIik7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudWxsaXplUHJvbWlzZSA9ICgpID0+ICh0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBudWxsKTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJDaGVja2luZyBmb3IgdXBkYXRlXCIpO1xuICAgICAgICBjaGVja0ZvclVwZGF0ZXNQcm9taXNlID0gdGhpcy5kb0NoZWNrRm9yVXBkYXRlcygpXG4gICAgICAgICAgICAudGhlbihpdCA9PiB7XG4gICAgICAgICAgICBudWxsaXplUHJvbWlzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgbnVsbGl6ZVByb21pc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGUsIGBDYW5ub3QgY2hlY2sgZm9yIHVwZGF0ZXM6ICR7KGUuc3RhY2sgfHwgZSkudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoZWNrRm9yVXBkYXRlc1Byb21pc2UgPSBjaGVja0ZvclVwZGF0ZXNQcm9taXNlO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JVcGRhdGVzUHJvbWlzZTtcbiAgICB9XG4gICAgaXNVcGRhdGVyQWN0aXZlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYXBwLmlzUGFja2FnZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiU2tpcCBjaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkgYmVjYXVzZSBhcHBsaWNhdGlvbiBpcyBub3QgcGFja2VkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG4gICAgY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KGRvd25sb2FkTm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1VwZGF0ZXJBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0ZvclVwZGF0ZXMoKS50aGVuKGl0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvd25sb2FkUHJvbWlzZSA9IGl0LmRvd25sb2FkUHJvbWlzZTtcbiAgICAgICAgICAgIGlmIChkb3dubG9hZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoXCJjaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkgY2FsbGVkLCBkb3dubG9hZFByb21pc2UgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBkb3dubG9hZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uQ29udGVudCA9IEFwcFVwZGF0ZXIuZm9ybWF0RG93bmxvYWROb3RpZmljYXRpb24oaXQudXBkYXRlSW5mby52ZXJzaW9uLCB0aGlzLmFwcC5uYW1lLCBkb3dubG9hZE5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgbmV3IChyZXF1aXJlKFwiZWxlY3Ryb25cIikuTm90aWZpY2F0aW9uKShub3RpZmljYXRpb25Db250ZW50KS5zaG93KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JtYXREb3dubG9hZE5vdGlmaWNhdGlvbih2ZXJzaW9uLCBhcHBOYW1lLCBkb3dubG9hZE5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAoZG93bmxvYWROb3RpZmljYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgZG93bmxvYWROb3RpZmljYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQSBuZXcgdXBkYXRlIGlzIHJlYWR5IHRvIGluc3RhbGxcIixcbiAgICAgICAgICAgICAgICBib2R5OiBge2FwcE5hbWV9IHZlcnNpb24ge3ZlcnNpb259IGhhcyBiZWVuIGRvd25sb2FkZWQgYW5kIHdpbGwgYmUgYXV0b21hdGljYWxseSBpbnN0YWxsZWQgb24gZXhpdGAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGRvd25sb2FkTm90aWZpY2F0aW9uID0ge1xuICAgICAgICAgICAgdGl0bGU6IGRvd25sb2FkTm90aWZpY2F0aW9uLnRpdGxlLnJlcGxhY2UoXCJ7YXBwTmFtZX1cIiwgYXBwTmFtZSkucmVwbGFjZShcInt2ZXJzaW9ufVwiLCB2ZXJzaW9uKSxcbiAgICAgICAgICAgIGJvZHk6IGRvd25sb2FkTm90aWZpY2F0aW9uLmJvZHkucmVwbGFjZShcInthcHBOYW1lfVwiLCBhcHBOYW1lKS5yZXBsYWNlKFwie3ZlcnNpb259XCIsIHZlcnNpb24pLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZG93bmxvYWROb3RpZmljYXRpb247XG4gICAgfVxuICAgIGFzeW5jIGlzU3RhZ2luZ01hdGNoKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgY29uc3QgcmF3U3RhZ2luZ1BlcmNlbnRhZ2UgPSB1cGRhdGVJbmZvLnN0YWdpbmdQZXJjZW50YWdlO1xuICAgICAgICBsZXQgc3RhZ2luZ1BlcmNlbnRhZ2UgPSByYXdTdGFnaW5nUGVyY2VudGFnZTtcbiAgICAgICAgaWYgKHN0YWdpbmdQZXJjZW50YWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YWdpbmdQZXJjZW50YWdlID0gcGFyc2VJbnQoc3RhZ2luZ1BlcmNlbnRhZ2UsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKHN0YWdpbmdQZXJjZW50YWdlKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFN0YWdpbmcgcGVyY2VudGFnZSBpcyBOYU46ICR7cmF3U3RhZ2luZ1BlcmNlbnRhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IGZyb20gdXNlciAwLTEwMCB0byBpbnRlcm5hbCAwLTFcbiAgICAgICAgc3RhZ2luZ1BlcmNlbnRhZ2UgPSBzdGFnaW5nUGVyY2VudGFnZSAvIDEwMDtcbiAgICAgICAgY29uc3Qgc3RhZ2luZ1VzZXJJZCA9IGF3YWl0IHRoaXMuc3RhZ2luZ1VzZXJJZFByb21pc2UudmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbCA9IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC5wYXJzZShzdGFnaW5nVXNlcklkKS5yZWFkVUludDMyQkUoMTIpO1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gdmFsIC8gMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYFN0YWdpbmcgcGVyY2VudGFnZTogJHtzdGFnaW5nUGVyY2VudGFnZX0sIHBlcmNlbnRhZ2U6ICR7cGVyY2VudGFnZX0sIHVzZXIgaWQ6ICR7c3RhZ2luZ1VzZXJJZH1gKTtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPCBzdGFnaW5nUGVyY2VudGFnZTtcbiAgICB9XG4gICAgY29tcHV0ZUZpbmFsSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaGVhZGVycywgdGhpcy5yZXF1ZXN0SGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIGFzeW5jIGlzVXBkYXRlQXZhaWxhYmxlKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IHNlbXZlcl8xLnBhcnNlKHVwZGF0ZUluZm8udmVyc2lvbik7XG4gICAgICAgIGlmIChsYXRlc3RWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYFRoaXMgZmlsZSBjb3VsZCBub3QgYmUgZG93bmxvYWRlZCwgb3IgdGhlIGxhdGVzdCB2ZXJzaW9uIChmcm9tIHVwZGF0ZSBzZXJ2ZXIpIGRvZXMgbm90IGhhdmUgYSB2YWxpZCBzZW12ZXIgdmVyc2lvbjogXCIke3VwZGF0ZUluZm8udmVyc2lvbn1cImAsIFwiRVJSX1VQREFURVJfSU5WQUxJRF9WRVJTSU9OXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWZXJzaW9uID0gdGhpcy5jdXJyZW50VmVyc2lvbjtcbiAgICAgICAgaWYgKHNlbXZlcl8xLmVxKGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3RhZ2luZ01hdGNoID0gYXdhaXQgdGhpcy5pc1N0YWdpbmdNYXRjaCh1cGRhdGVJbmZvKTtcbiAgICAgICAgaWYgKCFpc1N0YWdpbmdNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvMzExMSNpc3N1ZWNvbW1lbnQtNDA1MDMzMjI3XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL3B1bGwvMzExMSNpc3N1ZWNvbW1lbnQtNDA1MDMwNzk3XG4gICAgICAgIGNvbnN0IGlzTGF0ZXN0VmVyc2lvbk5ld2VyID0gc2VtdmVyXzEuZ3QobGF0ZXN0VmVyc2lvbiwgY3VycmVudFZlcnNpb24pO1xuICAgICAgICBjb25zdCBpc0xhdGVzdFZlcnNpb25PbGRlciA9IHNlbXZlcl8xLmx0KGxhdGVzdFZlcnNpb24sIGN1cnJlbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKGlzTGF0ZXN0VmVyc2lvbk5ld2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxvd0Rvd25ncmFkZSAmJiBpc0xhdGVzdFZlcnNpb25PbGRlcjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXBkYXRlSW5mb0FuZFByb3ZpZGVyKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmFwcC53aGVuUmVhZHkoKTtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50UHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudFByb21pc2UgPSB0aGlzLmNvbmZpZ09uRGlzay52YWx1ZS50aGVuKGl0ID0+IHByb3ZpZGVyRmFjdG9yeV8xLmNyZWF0ZUNsaWVudChpdCwgdGhpcywgdGhpcy5jcmVhdGVQcm92aWRlclJ1bnRpbWVPcHRpb25zKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCB0aGlzLmNsaWVudFByb21pc2U7XG4gICAgICAgIGNvbnN0IHN0YWdpbmdVc2VySWQgPSBhd2FpdCB0aGlzLnN0YWdpbmdVc2VySWRQcm9taXNlLnZhbHVlO1xuICAgICAgICBjbGllbnQuc2V0UmVxdWVzdEhlYWRlcnModGhpcy5jb21wdXRlRmluYWxIZWFkZXJzKHsgXCJ4LXVzZXItc3RhZ2luZy1pZFwiOiBzdGFnaW5nVXNlcklkIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZm86IGF3YWl0IGNsaWVudC5nZXRMYXRlc3RWZXJzaW9uKCksXG4gICAgICAgICAgICBwcm92aWRlcjogY2xpZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG4gICAgY3JlYXRlUHJvdmlkZXJSdW50aW1lT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IHRydWUsXG4gICAgICAgICAgICBwbGF0Zm9ybTogdGhpcy5fdGVzdE9ubHlPcHRpb25zID09IG51bGwgPyBwcm9jZXNzLnBsYXRmb3JtIDogdGhpcy5fdGVzdE9ubHlPcHRpb25zLnBsYXRmb3JtLFxuICAgICAgICAgICAgZXhlY3V0b3I6IHRoaXMuaHR0cEV4ZWN1dG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBkb0NoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2hlY2tpbmctZm9yLXVwZGF0ZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRVcGRhdGVJbmZvQW5kUHJvdmlkZXIoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlSW5mbyA9IHJlc3VsdC5pbmZvO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLmlzVXBkYXRlQXZhaWxhYmxlKHVwZGF0ZUluZm8pKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYFVwZGF0ZSBmb3IgdmVyc2lvbiAke3RoaXMuY3VycmVudFZlcnNpb259IGlzIG5vdCBhdmFpbGFibGUgKGxhdGVzdCB2ZXJzaW9uOiAke3VwZGF0ZUluZm8udmVyc2lvbn0sIGRvd25ncmFkZSBpcyAke3RoaXMuYWxsb3dEb3duZ3JhZGUgPyBcImFsbG93ZWRcIiA6IFwiZGlzYWxsb3dlZFwifSkuYCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGUtbm90LWF2YWlsYWJsZVwiLCB1cGRhdGVJbmZvKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbkluZm86IHVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgdXBkYXRlSW5mbyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbmZvQW5kUHJvdmlkZXIgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMub25VcGRhdGVBdmFpbGFibGUodXBkYXRlSW5mbyk7XG4gICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uVG9rZW4oKTtcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gRVM2TWlzc2luZ0F3YWl0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uSW5mbzogdXBkYXRlSW5mbyxcbiAgICAgICAgICAgIHVwZGF0ZUluZm8sXG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgIGRvd25sb2FkUHJvbWlzZTogdGhpcy5hdXRvRG93bmxvYWQgPyB0aGlzLmRvd25sb2FkVXBkYXRlKGNhbmNlbGxhdGlvblRva2VuKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uVXBkYXRlQXZhaWxhYmxlKHVwZGF0ZUluZm8pIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEZvdW5kIHZlcnNpb24gJHt1cGRhdGVJbmZvLnZlcnNpb259ICh1cmw6ICR7YnVpbGRlcl91dGlsX3J1bnRpbWVfMS5hc0FycmF5KHVwZGF0ZUluZm8uZmlsZXMpXG4gICAgICAgICAgICAubWFwKGl0ID0+IGl0LnVybClcbiAgICAgICAgICAgIC5qb2luKFwiLCBcIil9KWApO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1cGRhdGUtYXZhaWxhYmxlXCIsIHVwZGF0ZUluZm8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBkb3dubG9hZGluZyB1cGRhdGUgbWFudWFsbHkuIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIGlmIGBhdXRvRG93bmxvYWRgIG9wdGlvbiBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQYXRoIHRvIGRvd25sb2FkZWQgZmlsZS5cbiAgICAgKi9cbiAgICBkb3dubG9hZFVwZGF0ZShjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuKCkpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlSW5mb0FuZFByb3ZpZGVyID0gdGhpcy51cGRhdGVJbmZvQW5kUHJvdmlkZXI7XG4gICAgICAgIGlmICh1cGRhdGVJbmZvQW5kUHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJQbGVhc2UgY2hlY2sgdXBkYXRlIGZpcnN0XCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYERvd25sb2FkaW5nIHVwZGF0ZSBmcm9tICR7YnVpbGRlcl91dGlsX3J1bnRpbWVfMS5hc0FycmF5KHVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvLmZpbGVzKVxuICAgICAgICAgICAgLm1hcChpdCA9PiBpdC51cmwpXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfWApO1xuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzExNTAjaXNzdWVjb21tZW50LTQzNjg5MTE1OVxuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ2FuY2VsbGF0aW9uRXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAobmVzdGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYENhbm5vdCBkaXNwYXRjaCBlcnJvciBldmVudDogJHtuZXN0ZWRFcnJvci5zdGFjayB8fCBuZXN0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRG93bmxvYWRVcGRhdGUoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZUluZm9BbmRQcm92aWRlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyczogdGhpcy5jb21wdXRlUmVxdWVzdEhlYWRlcnModXBkYXRlSW5mb0FuZFByb3ZpZGVyLnByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JIYW5kbGVyKGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwYXRjaEVycm9yKGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZSwgKGUuc3RhY2sgfHwgZSkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCkge1xuICAgICAgICB0aGlzLmVtaXQobWFpbl8xLlVQREFURV9ET1dOTE9BREVELCBldmVudCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRVcGRhdGVDb25maWcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hcHBVcGRhdGVDb25maWdQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGggPSB0aGlzLmFwcC5hcHBVcGRhdGVDb25maWdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc195YW1sXzEubG9hZChhd2FpdCBwcm9taXNlc18xLnJlYWRGaWxlKHRoaXMuX2FwcFVwZGF0ZUNvbmZpZ1BhdGgsIFwidXRmLThcIikpO1xuICAgIH1cbiAgICBjb21wdXRlUmVxdWVzdEhlYWRlcnMocHJvdmlkZXIpIHtcbiAgICAgICAgY29uc3QgZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzID0gcHJvdmlkZXIuZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzO1xuICAgICAgICBpZiAoZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gdGhpcy5yZXF1ZXN0SGVhZGVycztcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0SGVhZGVycyA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBmaWxlRXh0cmFEb3dubG9hZEhlYWRlcnNcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZmlsZUV4dHJhRG93bmxvYWRIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGaW5hbEhlYWRlcnMoeyBhY2NlcHQ6IFwiKi8qXCIgfSk7XG4gICAgfVxuICAgIGFzeW5jIGdldE9yQ3JlYXRlU3RhZ2luZ1VzZXJJZCgpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHBhdGguam9pbih0aGlzLmFwcC51c2VyRGF0YVBhdGgsIFwiLnVwZGF0ZXJJZFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gYXdhaXQgcHJvbWlzZXNfMS5yZWFkRmlsZShmaWxlLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgaWYgKGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC5jaGVjayhpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgU3RhZ2luZyB1c2VyIGlkIGZpbGUgZXhpc3RzLCBidXQgY29udGVudCB3YXMgaW52YWxpZDogJHtpZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBDb3VsZG4ndCByZWFkIHN0YWdpbmcgdXNlciBJRCwgY3JlYXRpbmcgYSBibGFuayBvbmU6ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuVVVJRC52NShjcnlwdG9fMS5yYW5kb21CeXRlcyg0MDk2KSwgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5VVUlELk9JRCk7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBHZW5lcmF0ZWQgbmV3IHN0YWdpbmcgdXNlciBJRDogJHtpZH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGZzX2V4dHJhXzEub3V0cHV0RmlsZShmaWxlLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBDb3VsZG4ndCB3cml0ZSBvdXQgc3RhZ2luZyB1c2VyIElEOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGlzQWRkTm9DYWNoZVF1ZXJ5KCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXF1ZXN0SGVhZGVycztcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvaXNzdWVzLzMwMjFcbiAgICAgICAgaWYgKGhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHMgPT09IFwiYXV0aG9yaXphdGlvblwiIHx8IHMgPT09IFwicHJpdmF0ZS10b2tlblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZURvd25sb2FkSGVscGVyKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpck5hbWUgPSAoYXdhaXQgdGhpcy5jb25maWdPbkRpc2sudmFsdWUpLnVwZGF0ZXJDYWNoZURpck5hbWU7XG4gICAgICAgICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gICAgICAgICAgICBpZiAoZGlyTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwidXBkYXRlckNhY2hlRGlyTmFtZSBpcyBub3Qgc3BlY2lmaWVkIGluIGFwcC11cGRhdGUueW1sIFdhcyBhcHAgYnVpbGQgdXNpbmcgYXQgbGVhc3QgZWxlY3Ryb24tYnVpbGRlciAyMC4zNC4wP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRGlyID0gcGF0aC5qb2luKHRoaXMuYXBwLmJhc2VDYWNoZVBhdGgsIGRpck5hbWUgfHwgdGhpcy5hcHAubmFtZSk7XG4gICAgICAgICAgICBpZiAobG9nZ2VyLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYHVwZGF0ZXIgY2FjaGUgZGlyOiAke2NhY2hlRGlyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IERvd25sb2FkZWRVcGRhdGVIZWxwZXJfMS5Eb3dubG9hZGVkVXBkYXRlSGVscGVyKGNhY2hlRGlyKTtcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlRG93bmxvYWQodGFza09wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmlsZUluZm8gPSB0YXNrT3B0aW9ucy5maWxlSW5mbztcbiAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgaGVhZGVyczogdGFza09wdGlvbnMuZG93bmxvYWRVcGRhdGVPcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IHRhc2tPcHRpb25zLmRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgIHNoYTI6IGZpbGVJbmZvLmluZm8uc2hhMixcbiAgICAgICAgICAgIHNoYTUxMjogZmlsZUluZm8uaW5mby5zaGE1MTIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVyQ291bnQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTKSA+IDApIHtcbiAgICAgICAgICAgIGRvd25sb2FkT3B0aW9ucy5vblByb2dyZXNzID0gaXQgPT4gdGhpcy5lbWl0KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUywgaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwZGF0ZUluZm8gPSB0YXNrT3B0aW9ucy5kb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm87XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB1cGRhdGVJbmZvLnZlcnNpb247XG4gICAgICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gZmlsZUluZm8ucGFja2FnZUluZm87XG4gICAgICAgIGZ1bmN0aW9uIGdldENhY2hlVXBkYXRlRmlsZU5hbWUoKSB7XG4gICAgICAgICAgICAvLyBOb2RlSlMgVVJMIGRvZXNuJ3QgZGVjb2RlIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgIGNvbnN0IHVybFBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGFza09wdGlvbnMuZmlsZUluZm8udXJsLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGlmICh1cmxQYXRoLmVuZHNXaXRoKGAuJHt0YXNrT3B0aW9ucy5maWxlRXh0ZW5zaW9ufWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgucG9zaXguYmFzZW5hbWUodXJsUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB1cmwgbGlrZSAvbGF0ZXN0LCBnZW5lcmF0ZSBuYW1lXG4gICAgICAgICAgICAgICAgcmV0dXJuIGB1cGRhdGUuJHt0YXNrT3B0aW9ucy5maWxlRXh0ZW5zaW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVEb3dubG9hZEhlbHBlcigpO1xuICAgICAgICBjb25zdCBjYWNoZURpciA9IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIuY2FjaGVEaXJGb3JQZW5kaW5nVXBkYXRlO1xuICAgICAgICBhd2FpdCBwcm9taXNlc18xLm1rZGlyKGNhY2hlRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgdXBkYXRlRmlsZU5hbWUgPSBnZXRDYWNoZVVwZGF0ZUZpbGVOYW1lKCk7XG4gICAgICAgIGxldCB1cGRhdGVGaWxlID0gcGF0aC5qb2luKGNhY2hlRGlyLCB1cGRhdGVGaWxlTmFtZSk7XG4gICAgICAgIGNvbnN0IHBhY2thZ2VGaWxlID0gcGFja2FnZUluZm8gPT0gbnVsbCA/IG51bGwgOiBwYXRoLmpvaW4oY2FjaGVEaXIsIGBwYWNrYWdlLSR7dmVyc2lvbn0ke3BhdGguZXh0bmFtZShwYWNrYWdlSW5mby5wYXRoKSB8fCBcIi43elwifWApO1xuICAgICAgICBjb25zdCBkb25lID0gYXN5bmMgKGlzU2F2ZUNhY2hlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBkb3dubG9hZGVkVXBkYXRlSGVscGVyLnNldERvd25sb2FkZWRGaWxlKHVwZGF0ZUZpbGUsIHBhY2thZ2VGaWxlLCB1cGRhdGVJbmZvLCBmaWxlSW5mbywgdXBkYXRlRmlsZU5hbWUsIGlzU2F2ZUNhY2hlKTtcbiAgICAgICAgICAgIGF3YWl0IHRhc2tPcHRpb25zLmRvbmUoe1xuICAgICAgICAgICAgICAgIC4uLnVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgZG93bmxvYWRlZEZpbGU6IHVwZGF0ZUZpbGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRmlsZSA9PSBudWxsID8gW3VwZGF0ZUZpbGVdIDogW3VwZGF0ZUZpbGUsIHBhY2thZ2VGaWxlXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbG9nID0gdGhpcy5fbG9nZ2VyO1xuICAgICAgICBjb25zdCBjYWNoZWRVcGRhdGVGaWxlID0gYXdhaXQgZG93bmxvYWRlZFVwZGF0ZUhlbHBlci52YWxpZGF0ZURvd25sb2FkZWRQYXRoKHVwZGF0ZUZpbGUsIHVwZGF0ZUluZm8sIGZpbGVJbmZvLCBsb2cpO1xuICAgICAgICBpZiAoY2FjaGVkVXBkYXRlRmlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVGaWxlID0gY2FjaGVkVXBkYXRlRmlsZTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkb25lKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmVGaWxlSWZBbnkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBkb3dubG9hZGVkVXBkYXRlSGVscGVyLmNsZWFyKCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZXNfMS51bmxpbmsodXBkYXRlRmlsZSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRlbXBVcGRhdGVGaWxlID0gYXdhaXQgRG93bmxvYWRlZFVwZGF0ZUhlbHBlcl8xLmNyZWF0ZVRlbXBVcGRhdGVGaWxlKGB0ZW1wLSR7dXBkYXRlRmlsZU5hbWV9YCwgY2FjaGVEaXIsIGxvZyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0YXNrT3B0aW9ucy50YXNrKHRlbXBVcGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMsIHBhY2thZ2VGaWxlLCByZW1vdmVGaWxlSWZBbnkpO1xuICAgICAgICAgICAgYXdhaXQgcHJvbWlzZXNfMS5yZW5hbWUodGVtcFVwZGF0ZUZpbGUsIHVwZGF0ZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVGaWxlSWZBbnkoKTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5DYW5jZWxsYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZGF0ZS1jYW5jZWxsZWRcIiwgdXBkYXRlSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5pbmZvKGBOZXcgdmVyc2lvbiAke3ZlcnNpb259IGhhcyBiZWVuIGRvd25sb2FkZWQgdG8gJHt1cGRhdGVGaWxlfWApO1xuICAgICAgICByZXR1cm4gYXdhaXQgZG9uZSh0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLkFwcFVwZGF0ZXIgPSBBcHBVcGRhdGVyO1xuZnVuY3Rpb24gaGFzUHJlcmVsZWFzZUNvbXBvbmVudHModmVyc2lvbikge1xuICAgIGNvbnN0IHZlcnNpb25QcmVyZWxlYXNlQ29tcG9uZW50ID0gc2VtdmVyXzEucHJlcmVsZWFzZSh2ZXJzaW9uKTtcbiAgICByZXR1cm4gdmVyc2lvblByZXJlbGVhc2VDb21wb25lbnQgIT0gbnVsbCAmJiB2ZXJzaW9uUHJlcmVsZWFzZUNvbXBvbmVudC5sZW5ndGggPiAwO1xufVxuLyoqIEBwcml2YXRlICovXG5jbGFzcyBOb09wTG9nZ2VyIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgaW5mbyhtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgd2FybihtZXNzYWdlKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZXJyb3IobWVzc2FnZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICB9XG59XG5leHBvcnRzLk5vT3BMb2dnZXIgPSBOb09wTG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVVwZGF0ZXIgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IEFwcFVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG5jbGFzcyBCYXNlVXBkYXRlciBleHRlbmRzIEFwcFVwZGF0ZXJfMS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcXVpdEFuZEluc3RhbGwoaXNTaWxlbnQgPSBmYWxzZSwgaXNGb3JjZVJ1bkFmdGVyID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYEluc3RhbGwgb24gZXhwbGljaXQgcXVpdEFuZEluc3RhbGxgKTtcbiAgICAgICAgY29uc3QgaXNJbnN0YWxsZWQgPSB0aGlzLmluc3RhbGwoaXNTaWxlbnQsIGlzU2lsZW50ID8gaXNGb3JjZVJ1bkFmdGVyIDogdHJ1ZSk7XG4gICAgICAgIGlmIChpc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC5xdWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlRG93bmxvYWQodGFza09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICAuLi50YXNrT3B0aW9ucyxcbiAgICAgICAgICAgIGRvbmU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoVXBkYXRlRG93bmxvYWRlZChldmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRRdWl0SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBtdXN0IGJlIHN5bmMgKGJlY2F1c2UgcXVpdCBldmVuIGhhbmRsZXIgaXMgbm90IGFzeW5jKVxuICAgIGluc3RhbGwoaXNTaWxlbnQsIGlzRm9yY2VSdW5BZnRlcikge1xuICAgICAgICBpZiAodGhpcy5xdWl0QW5kSW5zdGFsbENhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oXCJpbnN0YWxsIGNhbGwgaWdub3JlZDogcXVpdEFuZEluc3RhbGxDYWxsZWQgaXMgc2V0IHRvIHRydWVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlcjtcbiAgICAgICAgY29uc3QgaW5zdGFsbGVyUGF0aCA9IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPT0gbnVsbCA/IG51bGwgOiBkb3dubG9hZGVkVXBkYXRlSGVscGVyLmZpbGU7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlSW5mbyA9IGRvd25sb2FkZWRVcGRhdGVIZWxwZXIgPT0gbnVsbCA/IG51bGwgOiBkb3dubG9hZGVkVXBkYXRlSGVscGVyLmRvd25sb2FkZWRGaWxlSW5mbztcbiAgICAgICAgaWYgKGluc3RhbGxlclBhdGggPT0gbnVsbCB8fCBkb3dubG9hZGVkRmlsZUluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKG5ldyBFcnJvcihcIk5vIHZhbGlkIHVwZGF0ZSBhdmFpbGFibGUsIGNhbid0IHF1aXQgYW5kIGluc3RhbGxcIikpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgY2FsbGluZyBzZXZlcmFsIHRpbWVzXG4gICAgICAgIHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGluc3RhbGxQYXRoUmVxdWlyZXNFbGV2YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NUZXN0UGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUocHJvY2Vzcy5leGVjUGF0aCksIGBhY2Nlc3MtJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDApfS50bXBgKTtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhhY2Nlc3NUZXN0UGF0aCwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICBmcy5ybVN5bmMoYWNjZXNzVGVzdFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmUgYWRtaW4gcmlnaHRzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICBpbnN0YWxsUGF0aFJlcXVpcmVzRWxldmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgSW5zdGFsbDogaXNTaWxlbnQ6ICR7aXNTaWxlbnR9LCBpc0ZvcmNlUnVuQWZ0ZXI6ICR7aXNGb3JjZVJ1bkFmdGVyfSwgaW5zdGFsbFBhdGhSZXF1aXJlc0VsZXZhdGlvbjogJHtpbnN0YWxsUGF0aFJlcXVpcmVzRWxldmF0aW9ufWApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9JbnN0YWxsKHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZXJQYXRoLFxuICAgICAgICAgICAgICAgIGlzU2lsZW50LFxuICAgICAgICAgICAgICAgIGlzRm9yY2VSdW5BZnRlcixcbiAgICAgICAgICAgICAgICBpc0FkbWluUmlnaHRzUmVxdWlyZWQ6IGluc3RhbGxQYXRoUmVxdWlyZXNFbGV2YXRpb24gfHwgZG93bmxvYWRlZEZpbGVJbmZvLmlzQWRtaW5SaWdodHNSZXF1aXJlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkUXVpdEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1aXRIYW5kbGVyQWRkZWQgfHwgIXRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1aXRIYW5kbGVyQWRkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmFwcC5vblF1aXQoZXhpdENvZGUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVpdEFuZEluc3RhbGxDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlVwZGF0ZSBpbnN0YWxsZXIgaGFzIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQuIFF1aXR0aW5nIGFwcGxpY2F0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXV0b0luc3RhbGxPbkFwcFF1aXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcIlVwZGF0ZSB3aWxsIG5vdCBiZSBpbnN0YWxsZWQgb24gcXVpdCBiZWNhdXNlIGF1dG9JbnN0YWxsT25BcHBRdWl0IGlzIHNldCB0byBmYWxzZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4aXRDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oYFVwZGF0ZSB3aWxsIGJlIG5vdCBpbnN0YWxsZWQgb24gcXVpdCBiZWNhdXNlIGFwcGxpY2F0aW9uIGlzIHF1aXR0aW5nIHdpdGggZXhpdCBjb2RlICR7ZXhpdENvZGV9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmluZm8oXCJBdXRvIGluc3RhbGwgdXBkYXRlIG9uIHF1aXRcIik7XG4gICAgICAgICAgICB0aGlzLmluc3RhbGwodHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VVcGRhdGVyID0gQmFzZVVwZGF0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlVXBkYXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZU9wZXJhdGlvbnMgPSBleHBvcnRzLk9wZXJhdGlvbktpbmQgPSB2b2lkIDA7XG52YXIgT3BlcmF0aW9uS2luZDtcbihmdW5jdGlvbiAoT3BlcmF0aW9uS2luZCkge1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkNPUFlcIl0gPSAwXSA9IFwiQ09QWVwiO1xuICAgIE9wZXJhdGlvbktpbmRbT3BlcmF0aW9uS2luZFtcIkRPV05MT0FEXCJdID0gMV0gPSBcIkRPV05MT0FEXCI7XG59KShPcGVyYXRpb25LaW5kID0gZXhwb3J0cy5PcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLk9wZXJhdGlvbktpbmQgPSB7fSkpO1xuZnVuY3Rpb24gY29tcHV0ZU9wZXJhdGlvbnMob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwLCBsb2dnZXIpIHtcbiAgICBjb25zdCBuYW1lVG9PbGRCbG9ja3MgPSBidWlsZEJsb2NrRmlsZU1hcChvbGRCbG9ja01hcC5maWxlcyk7XG4gICAgY29uc3QgbmFtZVRvTmV3QmxvY2tzID0gYnVpbGRCbG9ja0ZpbGVNYXAobmV3QmxvY2tNYXAuZmlsZXMpO1xuICAgIGxldCBsYXN0T3BlcmF0aW9uID0gbnVsbDtcbiAgICAvLyBmb3Igbm93IG9ubHkgb25lIGZpbGUgaXMgc3VwcG9ydGVkIGluIGJsb2NrIG1hcFxuICAgIGNvbnN0IGJsb2NrTWFwRmlsZSA9IG5ld0Jsb2NrTWFwLmZpbGVzWzBdO1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBuYW1lID0gYmxvY2tNYXBGaWxlLm5hbWU7XG4gICAgY29uc3Qgb2xkRW50cnkgPSBuYW1lVG9PbGRCbG9ja3MuZ2V0KG5hbWUpO1xuICAgIGlmIChvbGRFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldyBmaWxlICh1bnJlYWxpc3RpYyBjYXNlIGZvciBub3csIGJlY2F1c2UgaW4gYW55IGNhc2UgYm90aCBibG9ja21hcCBjb250YWluIHRoZSBvbmx5IGZpbGUgbmFtZWQgYXMgXCJmaWxlXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gZmlsZSAke25hbWV9IGluIG9sZCBibG9ja21hcGApO1xuICAgIH1cbiAgICBjb25zdCBuZXdGaWxlID0gbmFtZVRvTmV3QmxvY2tzLmdldChuYW1lKTtcbiAgICBsZXQgY2hhbmdlZEJsb2NrQ291bnQgPSAwO1xuICAgIGNvbnN0IHsgY2hlY2tzdW1Ub09mZnNldDogY2hlY2tzdW1Ub09sZE9mZnNldCwgY2hlY2tzdW1Ub09sZFNpemUgfSA9IGJ1aWxkQ2hlY2tzdW1NYXAobmFtZVRvT2xkQmxvY2tzLmdldChuYW1lKSwgb2xkRW50cnkub2Zmc2V0LCBsb2dnZXIpO1xuICAgIGxldCBuZXdPZmZzZXQgPSBibG9ja01hcEZpbGUub2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RmlsZS5jaGVja3N1bXMubGVuZ3RoOyBuZXdPZmZzZXQgKz0gbmV3RmlsZS5zaXplc1tpXSwgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrU2l6ZSA9IG5ld0ZpbGUuc2l6ZXNbaV07XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3RmlsZS5jaGVja3N1bXNbaV07XG4gICAgICAgIGxldCBvbGRPZmZzZXQgPSBjaGVja3N1bVRvT2xkT2Zmc2V0LmdldChjaGVja3N1bSk7XG4gICAgICAgIGlmIChvbGRPZmZzZXQgIT0gbnVsbCAmJiBjaGVja3N1bVRvT2xkU2l6ZS5nZXQoY2hlY2tzdW0pICE9PSBibG9ja1NpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBDaGVja3N1bSAoXCIke2NoZWNrc3VtfVwiKSBtYXRjaGVzLCBidXQgc2l6ZSBkaWZmZXJzIChvbGQ6ICR7Y2hlY2tzdW1Ub09sZFNpemUuZ2V0KGNoZWNrc3VtKX0sIG5ldzogJHtibG9ja1NpemV9KWApO1xuICAgICAgICAgICAgb2xkT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG93bmxvYWQgZGF0YSBmcm9tIG5ldyBmaWxlXG4gICAgICAgICAgICBjaGFuZ2VkQmxvY2tDb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxhc3RPcGVyYXRpb24gIT0gbnVsbCAmJiBsYXN0T3BlcmF0aW9uLmtpbmQgPT09IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQgJiYgbGFzdE9wZXJhdGlvbi5lbmQgPT09IG5ld09mZnNldCkge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBuZXdPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbmV3T2Zmc2V0ICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAvLyBvbGRCbG9ja3M6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUFuZEFkZChsYXN0T3BlcmF0aW9uLCBvcGVyYXRpb25zLCBjaGVja3N1bSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXVzZSBkYXRhIGZyb20gb2xkIGZpbGVcbiAgICAgICAgICAgIGlmIChsYXN0T3BlcmF0aW9uICE9IG51bGwgJiYgbGFzdE9wZXJhdGlvbi5raW5kID09PSBPcGVyYXRpb25LaW5kLkNPUFkgJiYgbGFzdE9wZXJhdGlvbi5lbmQgPT09IG9sZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxhc3RPcGVyYXRpb24uZW5kICs9IGJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBsYXN0T3BlcmF0aW9uLm9sZEJsb2NrcyEhLnB1c2goY2hlY2tzdW0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0T3BlcmF0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBraW5kOiBPcGVyYXRpb25LaW5kLkNPUFksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBvbGRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogb2xkT2Zmc2V0ICsgYmxvY2tTaXplLFxuICAgICAgICAgICAgICAgICAgICAvLyBvbGRCbG9ja3M6IFtjaGVja3N1bV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlQW5kQWRkKGxhc3RPcGVyYXRpb24sIG9wZXJhdGlvbnMsIGNoZWNrc3VtLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hhbmdlZEJsb2NrQ291bnQgPiAwKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBGaWxlJHtibG9ja01hcEZpbGUubmFtZSA9PT0gXCJmaWxlXCIgPyBcIlwiIDogXCIgXCIgKyBibG9ja01hcEZpbGUubmFtZX0gaGFzICR7Y2hhbmdlZEJsb2NrQ291bnR9IGNoYW5nZWQgYmxvY2tzYCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25zO1xufVxuZXhwb3J0cy5jb21wdXRlT3BlcmF0aW9ucyA9IGNvbXB1dGVPcGVyYXRpb25zO1xuY29uc3QgaXNWYWxpZGF0ZU9wZXJhdGlvblJhbmdlID0gcHJvY2Vzcy5lbnZbXCJESUZGRVJFTlRJQUxfRE9XTkxPQURfUExBTl9CVUlMREVSX1ZBTElEQVRFX1JBTkdFU1wiXSA9PT0gXCJ0cnVlXCI7XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZEFkZChvcGVyYXRpb24sIG9wZXJhdGlvbnMsIGNoZWNrc3VtLCBpbmRleCkge1xuICAgIGlmIChpc1ZhbGlkYXRlT3BlcmF0aW9uUmFuZ2UgJiYgb3BlcmF0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFzdE9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbb3BlcmF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RPcGVyYXRpb24ua2luZCA9PT0gb3BlcmF0aW9uLmtpbmQgJiYgb3BlcmF0aW9uLnN0YXJ0IDwgbGFzdE9wZXJhdGlvbi5lbmQgJiYgb3BlcmF0aW9uLnN0YXJ0ID4gbGFzdE9wZXJhdGlvbi5zdGFydCkge1xuICAgICAgICAgICAgY29uc3QgbWluID0gW2xhc3RPcGVyYXRpb24uc3RhcnQsIGxhc3RPcGVyYXRpb24uZW5kLCBvcGVyYXRpb24uc3RhcnQsIG9wZXJhdGlvbi5lbmRdLnJlZHVjZSgocCwgdikgPT4gKHAgPCB2ID8gcCA6IHYpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3BlcmF0aW9uIChibG9jayBpbmRleDogJHtpbmRleH0sIGNoZWNrc3VtOiAke2NoZWNrc3VtfSwga2luZDogJHtPcGVyYXRpb25LaW5kW29wZXJhdGlvbi5raW5kXX0pIG92ZXJsYXBzIHByZXZpb3VzIG9wZXJhdGlvbiAoY2hlY2tzdW06ICR7Y2hlY2tzdW19KTpcXG5gICtcbiAgICAgICAgICAgICAgICBgYWJzOiAke2xhc3RPcGVyYXRpb24uc3RhcnR9IHVudGlsICR7bGFzdE9wZXJhdGlvbi5lbmR9IGFuZCAke29wZXJhdGlvbi5zdGFydH0gdW50aWwgJHtvcGVyYXRpb24uZW5kfVxcbmAgK1xuICAgICAgICAgICAgICAgIGByZWw6ICR7bGFzdE9wZXJhdGlvbi5zdGFydCAtIG1pbn0gdW50aWwgJHtsYXN0T3BlcmF0aW9uLmVuZCAtIG1pbn0gYW5kICR7b3BlcmF0aW9uLnN0YXJ0IC0gbWlufSB1bnRpbCAke29wZXJhdGlvbi5lbmQgLSBtaW59YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlXG5mdW5jdGlvbiBidWlsZENoZWNrc3VtTWFwKGZpbGUsIGZpbGVPZmZzZXQsIGxvZ2dlcikge1xuICAgIGNvbnN0IGNoZWNrc3VtVG9PZmZzZXQgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgY2hlY2tzdW1Ub1NpemUgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG9mZnNldCA9IGZpbGVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlLmNoZWNrc3Vtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZpbGUuY2hlY2tzdW1zW2ldO1xuICAgICAgICBjb25zdCBzaXplID0gZmlsZS5zaXplc1tpXTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBjaGVja3N1bVRvU2l6ZS5nZXQoY2hlY2tzdW0pO1xuICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hlY2tzdW1Ub09mZnNldC5zZXQoY2hlY2tzdW0sIG9mZnNldCk7XG4gICAgICAgICAgICBjaGVja3N1bVRvU2l6ZS5zZXQoY2hlY2tzdW0sIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvZ2dlci5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplRXhwbGFuYXRpb24gPSBleGlzdGluZyA9PT0gc2l6ZSA/IFwiKHNhbWUgc2l6ZSlcIiA6IGAoc2l6ZTogJHtleGlzdGluZ30sIHRoaXMgc2l6ZTogJHtzaXplfSlgO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NoZWNrc3VtfSBkdXBsaWNhdGVkIGluIGJsb2NrbWFwICR7c2l6ZUV4cGxhbmF0aW9ufSwgaXQgZG9lc24ndCBsZWFkIHRvIGJyb2tlbiBkaWZmZXJlbnRpYWwgZG93bmxvYWRlciwganVzdCBjb3JyZXNwb25kaW5nIGJsb2NrIHdpbGwgYmUgc2tpcHBlZClgKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hlY2tzdW1Ub09mZnNldCwgY2hlY2tzdW1Ub09sZFNpemU6IGNoZWNrc3VtVG9TaXplIH07XG59XG5mdW5jdGlvbiBidWlsZEJsb2NrRmlsZU1hcChsaXN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaXRlbS5uYW1lLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvd25sb2FkUGxhbkJ1aWxkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRhdGFTcGxpdHRlciA9IGV4cG9ydHMuY29weURhdGEgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5jb25zdCBET1VCTEVfQ1JMRiA9IEJ1ZmZlci5mcm9tKFwiXFxyXFxuXFxyXFxuXCIpO1xudmFyIFJlYWRTdGF0ZTtcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJIRUFERVJcIl0gPSAxXSA9IFwiSEVBREVSXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIkJPRFlcIl0gPSAyXSA9IFwiQk9EWVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuZnVuY3Rpb24gY29weURhdGEodGFzaywgb3V0LCBvbGRGaWxlRmQsIHJlamVjdCwgcmVzb2x2ZSkge1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBmc18xLmNyZWF0ZVJlYWRTdHJlYW0oXCJcIiwge1xuICAgICAgICBmZDogb2xkRmlsZUZkLFxuICAgICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgICAgICBzdGFydDogdGFzay5zdGFydCxcbiAgICAgICAgLy8gZW5kIGlzIGluY2x1c2l2ZVxuICAgICAgICBlbmQ6IHRhc2suZW5kIC0gMSxcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICByZWFkU3RyZWFtLm9uY2UoXCJlbmRcIiwgcmVzb2x2ZSk7XG4gICAgcmVhZFN0cmVhbS5waXBlKG91dCwge1xuICAgICAgICBlbmQ6IGZhbHNlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5jb3B5RGF0YSA9IGNvcHlEYXRhO1xuY2xhc3MgRGF0YVNwbGl0dGVyIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKG91dCwgb3B0aW9ucywgcGFydEluZGV4VG9UYXNrSW5kZXgsIGJvdW5kYXJ5LCBwYXJ0SW5kZXhUb0xlbmd0aCwgZmluaXNoSGFuZGxlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm91dCA9IG91dDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleCA9IHBhcnRJbmRleFRvVGFza0luZGV4O1xuICAgICAgICB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoID0gcGFydEluZGV4VG9MZW5ndGg7XG4gICAgICAgIHRoaXMuZmluaXNoSGFuZGxlciA9IGZpbmlzaEhhbmRsZXI7XG4gICAgICAgIHRoaXMucGFydEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgIHRoaXMuaWdub3JlQnl0ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5hY3R1YWxQYXJ0TGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5ib3VuZGFyeUxlbmd0aCA9IGJvdW5kYXJ5Lmxlbmd0aCArIDQ7IC8qIHNpemUgb2YgXFxyXFxuLS0gKi9cbiAgICAgICAgLy8gZmlyc3QgY2h1bmsgZG9lc24ndCBzdGFydCB3aXRoIFxcclxcblxuICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IHRoaXMuYm91bmRhcnlMZW5ndGggLSAyO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFydEluZGV4ID09PSB0aGlzLnBhcnRJbmRleFRvTGVuZ3RoLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuICAgIF93cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVHJhaWxpbmcgaWdub3JlZCBkYXRhOiAke2RhdGEubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlRGF0YShkYXRhKS50aGVuKGNhbGxiYWNrKS5jYXRjaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZURhdGEoY2h1bmspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQnl0ZUNvdW50ICE9PSAwICYmIHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcIkludGVybmFsIGVycm9yXCIsIFwiRVJSX0RBVEFfU1BMSVRURVJfQllURV9DT1VOVF9NSVNNQVRDSFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ25vcmVCeXRlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0b0lnbm9yZSA9IE1hdGgubWluKHRoaXMuaWdub3JlQnl0ZUNvdW50LCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVCeXRlQ291bnQgLT0gdG9JZ25vcmU7XG4gICAgICAgICAgICBzdGFydCA9IHRvSWdub3JlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvUmVhZCA9IE1hdGgubWluKHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCwgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucmVtYWluaW5nUGFydERhdGFDb3VudCAtPSB0b1JlYWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NQYXJ0RGF0YShjaHVuaywgMCwgdG9SZWFkKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gdG9SZWFkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVhZFN0YXRlID09PSBSZWFkU3RhdGUuSEVBREVSKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJMaXN0RW5kID0gdGhpcy5zZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyTGlzdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IGhlYWRlckxpc3RFbmQ7XG4gICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5CT0RZO1xuICAgICAgICAgICAgLy8gaGVhZGVyIGxpc3QgaXMgaWdub3JlZCwgd2UgZG9uJ3QgbmVlZCBpdFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJMaXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZFN0YXRlID09PSBSZWFkU3RhdGUuQk9EWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLklOSVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgIGxldCB0YXNrSW5kZXggPSB0aGlzLnBhcnRJbmRleFRvVGFza0luZGV4LmdldCh0aGlzLnBhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tJbmRleCA9IHRoaXMub3B0aW9ucy5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKFwidGFza0luZGV4IGlzIG51bGxcIiwgXCJFUlJfREFUQV9TUExJVFRFUl9UQVNLX0lOREVYX0lTX05VTExcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRhc2tJbmRleCA9IHRoaXMucGFydEluZGV4ID09PSAwID8gdGhpcy5vcHRpb25zLnN0YXJ0IDogdGhpcy5wYXJ0SW5kZXhUb1Rhc2tJbmRleC5nZXQodGhpcy5wYXJ0SW5kZXggLSAxKSArIDE7IC8qIHByZXYgcGFydCBpcyBkb3dubG9hZCwgbmV4dCBtYXliZSBjb3B5ICovXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUYXNrSW5kZXggPCB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb3B5RXhpc3RpbmdEYXRhKHByZXZUYXNrSW5kZXgsIHRhc2tJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZUYXNrSW5kZXggPiB0YXNrSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcInByZXZUYXNrSW5kZXggbXVzdCBiZSA8IHRhc2tJbmRleFwiLCBcIkVSUl9EQVRBX1NQTElUVEVSX1RBU0tfSU5ERVhfQVNTRVJUX0ZBSUxFRFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFydEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuc2VhcmNoSGVhZGVyTGlzdEVuZChjaHVuaywgc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuSEVBREVSO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFydExlbmd0aCA9IHRoaXMucGFydEluZGV4VG9MZW5ndGhbdGhpcy5wYXJ0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBwYXJ0TGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZWZmZWN0aXZlRW5kID0gTWF0aC5taW4oZW5kLCBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUGFydFN0YXJ0ZWQoY2h1bmssIHN0YXJ0LCBlZmZlY3RpdmVFbmQpO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID0gcGFydExlbmd0aCAtIChlZmZlY3RpdmVFbmQgLSBzdGFydCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW1haW5pbmdQYXJ0RGF0YUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kICsgdGhpcy5ib3VuZGFyeUxlbmd0aDtcbiAgICAgICAgICAgIGlmIChzdGFydCA+PSBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlnbm9yZUJ5dGVDb3VudCA9IHRoaXMuYm91bmRhcnlMZW5ndGggLSAoY2h1bmsubGVuZ3RoIC0gZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29weUV4aXN0aW5nRGF0YShpbmRleCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gdGhpcy5vcHRpb25zLnRhc2tzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGFzay5raW5kICE9PSBkb3dubG9hZFBsYW5CdWlsZGVyXzEuT3BlcmF0aW9uS2luZC5DT1BZKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUYXNrIGtpbmQgbXVzdCBiZSBDT1BZXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3B5RGF0YSh0YXNrLCB0aGlzLm91dCwgdGhpcy5vcHRpb25zLm9sZEZpbGVGZCwgcmVqZWN0LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIHcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWFyY2hIZWFkZXJMaXN0RW5kKGNodW5rLCByZWFkT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlckxpc3RFbmQgPSBjaHVuay5pbmRleE9mKERPVUJMRV9DUkxGLCByZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKGhlYWRlckxpc3RFbmQgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyTGlzdEVuZCArIERPVUJMRV9DUkxGLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3QgYWxsIGhlYWRlcnMgZGF0YSB3ZXJlIHJlY2VpdmVkLCBzYXZlIHRvIGJ1ZmZlclxuICAgICAgICBjb25zdCBwYXJ0aWFsQ2h1bmsgPSByZWFkT2Zmc2V0ID09PSAwID8gY2h1bmsgOiBjaHVuay5zbGljZShyZWFkT2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyTGlzdEJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBwYXJ0aWFsQ2h1bms7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlckxpc3RCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlckxpc3RCdWZmZXIsIHBhcnRpYWxDaHVua10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgb25QYXJ0RW5kKCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZExlbmd0aCA9IHRoaXMucGFydEluZGV4VG9MZW5ndGhbdGhpcy5wYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuYWN0dWFsUGFydExlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoYEV4cGVjdGVkIGxlbmd0aDogJHtleHBlY3RlZExlbmd0aH0gZGlmZmVycyBmcm9tIGFjdHVhbDogJHt0aGlzLmFjdHVhbFBhcnRMZW5ndGh9YCwgXCJFUlJfREFUQV9TUExJVFRFUl9MRU5HVEhfTUlTTUFUQ0hcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3R1YWxQYXJ0TGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcHJvY2Vzc1BhcnRTdGFydGVkKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFydEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm9uUGFydEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NQYXJ0RGF0YShkYXRhLCBzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BhcnREYXRhKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5hY3R1YWxQYXJ0TGVuZ3RoICs9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLm91dDtcbiAgICAgICAgaWYgKG91dC53cml0ZShzdGFydCA9PT0gMCAmJiBkYXRhLmxlbmd0aCA9PT0gZW5kID8gZGF0YSA6IGRhdGEuc2xpY2Uoc3RhcnQsIGVuZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIG91dC5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgb3V0Lm9uY2UoXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhU3BsaXR0ZXIgPSBEYXRhU3BsaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU3BsaXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQgPSBleHBvcnRzLmV4ZWN1dGVUYXNrc1VzaW5nTXVsdGlwbGVSYW5nZVJlcXVlc3RzID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IERhdGFTcGxpdHRlcl8xID0gcmVxdWlyZShcIi4vRGF0YVNwbGl0dGVyXCIpO1xuY29uc3QgZG93bmxvYWRQbGFuQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vZG93bmxvYWRQbGFuQnVpbGRlclwiKTtcbmZ1bmN0aW9uIGV4ZWN1dGVUYXNrc1VzaW5nTXVsdGlwbGVSYW5nZVJlcXVlc3RzKGRpZmZlcmVudGlhbERvd25sb2FkZXIsIHRhc2tzLCBvdXQsIG9sZEZpbGVGZCwgcmVqZWN0KSB7XG4gICAgY29uc3QgdyA9ICh0YXNrT2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmICh0YXNrT2Zmc2V0ID49IHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGRpZmZlcmVudGlhbERvd25sb2FkZXIuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvdXQud3JpdGUoZGlmZmVyZW50aWFsRG93bmxvYWRlci5maWxlTWV0YWRhdGFCdWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0LmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSB0YXNrT2Zmc2V0ICsgMTAwMDtcbiAgICAgICAgZG9FeGVjdXRlVGFza3MoZGlmZmVyZW50aWFsRG93bmxvYWRlciwge1xuICAgICAgICAgICAgdGFza3MsXG4gICAgICAgICAgICBzdGFydDogdGFza09mZnNldCxcbiAgICAgICAgICAgIGVuZDogTWF0aC5taW4odGFza3MubGVuZ3RoLCBuZXh0T2Zmc2V0KSxcbiAgICAgICAgICAgIG9sZEZpbGVGZCxcbiAgICAgICAgfSwgb3V0LCAoKSA9PiB3KG5leHRPZmZzZXQpLCByZWplY3QpO1xuICAgIH07XG4gICAgcmV0dXJuIHc7XG59XG5leHBvcnRzLmV4ZWN1dGVUYXNrc1VzaW5nTXVsdGlwbGVSYW5nZVJlcXVlc3RzID0gZXhlY3V0ZVRhc2tzVXNpbmdNdWx0aXBsZVJhbmdlUmVxdWVzdHM7XG5mdW5jdGlvbiBkb0V4ZWN1dGVUYXNrcyhkaWZmZXJlbnRpYWxEb3dubG9hZGVyLCBvcHRpb25zLCBvdXQsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCByYW5nZXMgPSBcImJ5dGVzPVwiO1xuICAgIGxldCBwYXJ0Q291bnQgPSAwO1xuICAgIGNvbnN0IHBhcnRJbmRleFRvVGFza0luZGV4ID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcnRJbmRleFRvTGVuZ3RoID0gW107XG4gICAgZm9yIChsZXQgaSA9IG9wdGlvbnMuc3RhcnQ7IGkgPCBvcHRpb25zLmVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBvcHRpb25zLnRhc2tzW2ldO1xuICAgICAgICBpZiAodGFzay5raW5kID09PSBkb3dubG9hZFBsYW5CdWlsZGVyXzEuT3BlcmF0aW9uS2luZC5ET1dOTE9BRCkge1xuICAgICAgICAgICAgcmFuZ2VzICs9IGAke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfSwgYDtcbiAgICAgICAgICAgIHBhcnRJbmRleFRvVGFza0luZGV4LnNldChwYXJ0Q291bnQsIGkpO1xuICAgICAgICAgICAgcGFydENvdW50Kys7XG4gICAgICAgICAgICBwYXJ0SW5kZXhUb0xlbmd0aC5wdXNoKHRhc2suZW5kIC0gdGFzay5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRDb3VudCA8PSAxKSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IHJlbW90ZSByYW5nZSAtIGNvcHlcbiAgICAgICAgY29uc3QgdyA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBvcHRpb25zLnRhc2tzW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKHRhc2sua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgICAgIERhdGFTcGxpdHRlcl8xLmNvcHlEYXRhKHRhc2ssIG91dCwgb3B0aW9ucy5vbGRGaWxlRmQsIHJlamVjdCwgKCkgPT4gdyhpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3Rhc2suc3RhcnR9LSR7dGFzay5lbmQgLSAxfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGRpZmZlcmVudGlhbERvd25sb2FkZXIuaHR0cEV4ZWN1dG9yLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lzUmFuZ2VzU3VwcG9ydGVkKHJlc3BvbnNlLCByZWplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGlwZShvdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5vbmNlKFwiZW5kXCIsICgpID0+IHcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHcob3B0aW9ucy5zdGFydCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmNyZWF0ZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5SYW5nZSA9IHJhbmdlcy5zdWJzdHJpbmcoMCwgcmFuZ2VzLmxlbmd0aCAtIDIpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBkaWZmZXJlbnRpYWxEb3dubG9hZGVyLmh0dHBFeGVjdXRvci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXNwb25zZSA9PiB7XG4gICAgICAgIGlmICghY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlR2V0SGVhZGVyKHJlc3BvbnNlLCBcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgY29uc3QgbSA9IC9ebXVsdGlwYXJ0XFwvLis/KD86OyBib3VuZGFyeT0oPzooPzpcIiguKylcIil8KD86KFteXFxzXSspKSkpJC9pLmV4ZWMoY29udGVudFR5cGUpO1xuICAgICAgICBpZiAobSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBDb250ZW50LVR5cGUgXCJtdWx0aXBhcnQvYnl0ZXJhbmdlc1wiIGlzIGV4cGVjdGVkLCBidXQgZ290IFwiJHtjb250ZW50VHlwZX1cImApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWNlciA9IG5ldyBEYXRhU3BsaXR0ZXJfMS5EYXRhU3BsaXR0ZXIob3V0LCBvcHRpb25zLCBwYXJ0SW5kZXhUb1Rhc2tJbmRleCwgbVsxXSB8fCBtWzJdLCBwYXJ0SW5kZXhUb0xlbmd0aCwgcmVzb2x2ZSk7XG4gICAgICAgIGRpY2VyLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgcmVzcG9uc2UucGlwZShkaWNlcik7XG4gICAgICAgIHJlc3BvbnNlLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVzcG9uc2UgZW5kcyB3aXRob3V0IGNhbGxpbmcgYW55IGhhbmRsZXJzXCIpKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGlmZmVyZW50aWFsRG93bmxvYWRlci5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICByZXF1ZXN0LmVuZCgpO1xufVxuZnVuY3Rpb24gY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSB7XG4gICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgcmVqZWN0KGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuY3JlYXRlSHR0cEVycm9yKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwNikge1xuICAgICAgICBjb25zdCBhY2NlcHRSYW5nZXMgPSBidWlsZGVyX3V0aWxfcnVudGltZV8xLnNhZmVHZXRIZWFkZXIocmVzcG9uc2UsIFwiYWNjZXB0LXJhbmdlc1wiKTtcbiAgICAgICAgaWYgKGFjY2VwdFJhbmdlcyA9PSBudWxsIHx8IGFjY2VwdFJhbmdlcyA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFNlcnZlciBkb2Vzbid0IHN1cHBvcnQgQWNjZXB0LVJhbmdlcyAocmVzcG9uc2UgY29kZSAke3Jlc3BvbnNlLnN0YXR1c0NvZGV9KWApKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZCA9IGNoZWNrSXNSYW5nZXNTdXBwb3J0ZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aXBsZVJhbmdlRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZENhbGxiYWNrVHJhbnNmb3JtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xudmFyIE9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKE9wZXJhdGlvbktpbmQpIHtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJDT1BZXCJdID0gMF0gPSBcIkNPUFlcIjtcbiAgICBPcGVyYXRpb25LaW5kW09wZXJhdGlvbktpbmRbXCJET1dOTE9BRFwiXSA9IDFdID0gXCJET1dOTE9BRFwiO1xufSkoT3BlcmF0aW9uS2luZCB8fCAoT3BlcmF0aW9uS2luZCA9IHt9KSk7XG5jbGFzcyBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0gZXh0ZW5kcyBzdHJlYW1fMS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKHByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLCBjYW5jZWxsYXRpb25Ub2tlbiwgb25Qcm9ncmVzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvID0gcHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm87XG4gICAgICAgIHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbjtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcbiAgICAgICAgdGhpcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgPSAwO1xuICAgICAgICB0aGlzLmRlbHRhID0gMDtcbiAgICAgICAgdGhpcy5leHBlY3RlZEJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvbktpbmQuQ09QWTtcbiAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gdGhpcy5zdGFydCArIDEwMDA7XG4gICAgfVxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcImNhbmNlbGxlZFwiKSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3Qgc2VuZCBwcm9ncmVzcyB1cGRhdGUgd2hlbiBjb3B5aW5nIGZyb20gZGlza1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRpb25UeXBlID09IE9wZXJhdGlvbktpbmQuQ09QWSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY2h1bmspO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmZXJyZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmRlbHRhICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyA+PSB0aGlzLm5leHRVcGRhdGUgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMuZXhwZWN0ZWRCeXRlcyAvKiB3aWxsIGJlIGVtaXR0ZWQgYnkgZW5kUmFuZ2VEb3dubG9hZCgpICovICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVycmVkICE9PSB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmdyYW5kVG90YWwgLyogd2lsbCBiZSBlbWl0dGVkIG9uIF9mbHVzaCAqLykge1xuICAgICAgICAgICAgdGhpcy5uZXh0VXBkYXRlID0gbm93ICsgMTAwMDtcbiAgICAgICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgdG90YWw6IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCxcbiAgICAgICAgICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgICAgICBwZXJjZW50OiAodGhpcy50cmFuc2ZlcnJlZCAvIHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCkgKiAxMDAsXG4gICAgICAgICAgICAgICAgYnl0ZXNQZXJTZWNvbmQ6IE1hdGgucm91bmQodGhpcy50cmFuc2ZlcnJlZCAvICgobm93IC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNodW5rKTtcbiAgICB9XG4gICAgYmVnaW5GaWxlQ29weSgpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gT3BlcmF0aW9uS2luZC5DT1BZO1xuICAgIH1cbiAgICBiZWdpblJhbmdlRG93bmxvYWQoKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IE9wZXJhdGlvbktpbmQuRE9XTkxPQUQ7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRCeXRlcyArPSB0aGlzLnByb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRJbmZvLmV4cGVjdGVkQnl0ZUNvdW50c1t0aGlzLmluZGV4KytdO1xuICAgIH1cbiAgICBlbmRSYW5nZURvd25sb2FkKCkge1xuICAgICAgICAvLyBfZmx1c2goKSB3aWxsIGRvb3VyIGZpbmFsIDEwMCVcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmZXJyZWQgIT09IHRoaXMucHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8uZ3JhbmRUb3RhbCkge1xuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICB0b3RhbDogdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsLFxuICAgICAgICAgICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVycmVkOiB0aGlzLnRyYW5zZmVycmVkLFxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6ICh0aGlzLnRyYW5zZmVycmVkIC8gdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsKSAqIDEwMCxcbiAgICAgICAgICAgICAgICBieXRlc1BlclNlY29uZDogTWF0aC5yb3VuZCh0aGlzLnRyYW5zZmVycmVkIC8gKChEYXRlLm5vdygpIC0gdGhpcy5zdGFydCkgLyAxMDAwKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsZWQgd2hlbiB3ZSBhcmUgMTAwJSBkb25lIHdpdGggdGhlIGNvbm5lY3Rpb24vZG93bmxvYWRcbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJjYW5jZWxsZWRcIikpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICB0b3RhbDogdGhpcy5wcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mby5ncmFuZFRvdGFsLFxuICAgICAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZDogdGhpcy50cmFuc2ZlcnJlZCxcbiAgICAgICAgICAgIHBlcmNlbnQ6IDEwMCxcbiAgICAgICAgICAgIGJ5dGVzUGVyU2Vjb25kOiBNYXRoLnJvdW5kKHRoaXMudHJhbnNmZXJyZWQgLyAoKERhdGUubm93KCkgLSB0aGlzLnN0YXJ0KSAvIDEwMDApKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkID0gMDtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0gPSBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpZmZlcmVudGlhbERvd25sb2FkZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBEYXRhU3BsaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0RhdGFTcGxpdHRlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGRvd25sb2FkUGxhbkJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2Rvd25sb2FkUGxhbkJ1aWxkZXJcIik7XG5jb25zdCBtdWx0aXBsZVJhbmdlRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vbXVsdGlwbGVSYW5nZURvd25sb2FkZXJcIik7XG5jb25zdCBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyZXNzRGlmZmVyZW50aWFsRG93bmxvYWRDYWxsYmFja1RyYW5zZm9ybVwiKTtcbmNsYXNzIERpZmZlcmVudGlhbERvd25sb2FkZXIge1xuICAgIC8vIG5vaW5zcGVjdGlvbiBUeXBlU2NyaXB0QWJzdHJhY3RDbGFzc0NvbnN0cnVjdG9yQ2FuQmVNYWRlUHJvdGVjdGVkXG4gICAgY29uc3RydWN0b3IoYmxvY2tBd2FyZUZpbGVJbmZvLCBodHRwRXhlY3V0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ibG9ja0F3YXJlRmlsZUluZm8gPSBibG9ja0F3YXJlRmlsZUluZm87XG4gICAgICAgIHRoaXMuaHR0cEV4ZWN1dG9yID0gaHR0cEV4ZWN1dG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3RPcHRpb25zKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGFjY2VwdDogXCIqLypcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuY29uZmlndXJlUmVxdWVzdFVybCh0aGlzLm9wdGlvbnMubmV3VXJsLCByZXN1bHQpO1xuICAgICAgICAvLyB1c2VyLWFnZW50LCBjYWNoZS1jb250cm9sIGFuZCBvdGhlciBjb21tb24gb3B0aW9uc1xuICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RPcHRpb25zKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRvRG93bmxvYWQob2xkQmxvY2tNYXAsIG5ld0Jsb2NrTWFwKSB7XG4gICAgICAgIC8vIHdlIGRvbid0IGNoZWNrIG90aGVyIG1ldGFkYXRhIGxpa2UgY29tcHJlc3Npb25NZXRob2QgLSBnZW5lcmljIGNoZWNrIHRoYXQgaXQgaXMgbWFrZSBzZW5zZSB0byBkaWZmZXJlbnRpYWxseSB1cGRhdGUgaXMgc3VpdGFibGUgZm9yIGl0XG4gICAgICAgIGlmIChvbGRCbG9ja01hcC52ZXJzaW9uICE9PSBuZXdCbG9ja01hcC52ZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZlcnNpb24gaXMgZGlmZmVyZW50ICgke29sZEJsb2NrTWFwLnZlcnNpb259IC0gJHtuZXdCbG9ja01hcC52ZXJzaW9ufSksIGZ1bGwgZG93bmxvYWQgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2dnZXIgPSB0aGlzLmxvZ2dlcjtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5jb21wdXRlT3BlcmF0aW9ucyhvbGRCbG9ja01hcCwgbmV3QmxvY2tNYXAsIGxvZ2dlcik7XG4gICAgICAgIGlmIChsb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKEpTT04uc3RyaW5naWZ5KG9wZXJhdGlvbnMsIG51bGwsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZG93bmxvYWRTaXplID0gMDtcbiAgICAgICAgbGV0IGNvcHlTaXplID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gb3BlcmF0aW9uLmVuZCAtIG9wZXJhdGlvbi5zdGFydDtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ua2luZCA9PT0gZG93bmxvYWRQbGFuQnVpbGRlcl8xLk9wZXJhdGlvbktpbmQuRE9XTkxPQUQpIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZFNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVNpemUgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLmJsb2NrQXdhcmVGaWxlSW5mby5zaXplO1xuICAgICAgICBpZiAoZG93bmxvYWRTaXplICsgY29weVNpemUgKyAodGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPT0gbnVsbCA/IDAgOiB0aGlzLmZpbGVNZXRhZGF0YUJ1ZmZlci5sZW5ndGgpICE9PSBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIGVycm9yLCBzaXplIG1pc21hdGNoOiBkb3dubG9hZFNpemU6ICR7ZG93bmxvYWRTaXplfSwgY29weVNpemU6ICR7Y29weVNpemV9LCBuZXdTaXplOiAke25ld1NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYEZ1bGw6ICR7Zm9ybWF0Qnl0ZXMobmV3U2l6ZSl9LCBUbyBkb3dubG9hZDogJHtmb3JtYXRCeXRlcyhkb3dubG9hZFNpemUpfSAoJHtNYXRoLnJvdW5kKGRvd25sb2FkU2l6ZSAvIChuZXdTaXplIC8gMTAwKSl9JSlgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRGaWxlKG9wZXJhdGlvbnMpO1xuICAgIH1cbiAgICBkb3dubG9hZEZpbGUodGFza3MpIHtcbiAgICAgICAgY29uc3QgZmRMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IGNsb3NlRmlsZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZmRMaXN0Lm1hcChvcGVuZWRGaWxlID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnNfZXh0cmFfMS5jbG9zZShvcGVuZWRGaWxlLmRlc2NyaXB0b3IpLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihgY2Fubm90IGNsb3NlIGZpbGUgXCIke29wZW5lZEZpbGUucGF0aH1cIjogJHtlfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5kb0Rvd25sb2FkRmlsZSh0YXNrcywgZmRMaXN0KVxuICAgICAgICAgICAgLnRoZW4oY2xvc2VGaWxlcylcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIC8vIHRoZW4gbXVzdCBiZSBhZnRlciBjYXRjaCBoZXJlIChzaW5jZSB0aGVuIGFsd2F5cyB0aHJvd3MgZXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VGaWxlcygpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGNsb3NlRmlsZXNFcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY2xvc2VGaWxlcyBuZXZlciB0aHJvdyBlcnJvciwgYnV0IGp1c3QgdG8gYmUgc3VyZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGBjYW5ub3QgY2xvc2UgZmlsZXM6ICR7Y2xvc2VGaWxlc0Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3JPbkxvZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvck9uTG9nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2ssIGdpdmUgdXAgYW5kIGlnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb0Rvd25sb2FkRmlsZSh0YXNrcywgZmRMaXN0KSB7XG4gICAgICAgIGNvbnN0IG9sZEZpbGVGZCA9IGF3YWl0IGZzX2V4dHJhXzEub3Blbih0aGlzLm9wdGlvbnMub2xkRmlsZSwgXCJyXCIpO1xuICAgICAgICBmZExpc3QucHVzaCh7IGRlc2NyaXB0b3I6IG9sZEZpbGVGZCwgcGF0aDogdGhpcy5vcHRpb25zLm9sZEZpbGUgfSk7XG4gICAgICAgIGNvbnN0IG5ld0ZpbGVGZCA9IGF3YWl0IGZzX2V4dHJhXzEub3Blbih0aGlzLm9wdGlvbnMubmV3RmlsZSwgXCJ3XCIpO1xuICAgICAgICBmZExpc3QucHVzaCh7IGRlc2NyaXB0b3I6IG5ld0ZpbGVGZCwgcGF0aDogdGhpcy5vcHRpb25zLm5ld0ZpbGUgfSk7XG4gICAgICAgIGNvbnN0IGZpbGVPdXQgPSBmc18xLmNyZWF0ZVdyaXRlU3RyZWFtKHRoaXMub3B0aW9ucy5uZXdGaWxlLCB7IGZkOiBuZXdGaWxlRmQgfSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbXMgPSBbXTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBvdXIgZG93bmxvYWQgaW5mbyB0cmFuc2Zvcm1lciBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICAgICAgbGV0IGRvd25sb2FkSW5mb1RyYW5zZm9ybSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QgJiYgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBEb2VzIG5vdCBzdXBwb3J0IG11bHRpcGxlIHJhbmdlcyAoc29tZW9uZSBmZWVsIGZyZWUgdG8gUFIgdGhpcyEpXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRCeXRlQ291bnRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGdyYW5kVG90YWxCeXRlcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkRPV05MT0FEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZEJ5dGVDb3VudHMucHVzaCh0YXNrLmVuZCAtIHRhc2suc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRUb3RhbEJ5dGVzICs9IHRhc2suZW5kIC0gdGFzay5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkSW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRCeXRlQ291bnRzOiBleHBlY3RlZEJ5dGVDb3VudHMsXG4gICAgICAgICAgICAgICAgICAgIGdyYW5kVG90YWw6IGdyYW5kVG90YWxCeXRlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybSA9IG5ldyBQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1fMS5Qcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm0ocHJvZ3Jlc3NEaWZmZXJlbnRpYWxEb3dubG9hZEluZm8sIHRoaXMub3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbiwgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHN0cmVhbXMucHVzaChkb3dubG9hZEluZm9UcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlnZXN0VHJhbnNmb3JtID0gbmV3IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuRGlnZXN0VHJhbnNmb3JtKHRoaXMuYmxvY2tBd2FyZUZpbGVJbmZvLnNoYTUxMik7XG4gICAgICAgICAgICAvLyB0byBzaW1wbHkgZGVidWcsIGRvIG1hbnVhbCB2YWxpZGF0aW9uIHRvIGFsbG93IGZpbGUgdG8gYmUgZnVsbHkgd3JpdHRlblxuICAgICAgICAgICAgZGlnZXN0VHJhbnNmb3JtLmlzVmFsaWRhdGVPbkVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKGRpZ2VzdFRyYW5zZm9ybSk7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNBcnJvd0Z1bmN0aW9uQ2FuQmVSZXBsYWNlZFdpdGhTaG9ydGhhbmRcbiAgICAgICAgICAgIGZpbGVPdXQub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBmaWxlT3V0LmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGZyb20gZmQgbGlzdCBiZWNhdXNlIGNsb3NlZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgICAgICAgICAgZmRMaXN0LnNwbGljZSgxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2VzdFRyYW5zZm9ybS52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW1zLnB1c2goZmlsZU91dCk7XG4gICAgICAgICAgICBsZXQgbGFzdFN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbSBvZiBzdHJlYW1zKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFN0cmVhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYXN0U3RyZWFtID0gbGFzdFN0cmVhbS5waXBlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RTdHJlYW0gPSBzdHJlYW1zWzBdO1xuICAgICAgICAgICAgbGV0IHc7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzVXNlTXVsdGlwbGVSYW5nZVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB3ID0gbXVsdGlwbGVSYW5nZURvd25sb2FkZXJfMS5leGVjdXRlVGFza3NVc2luZ011bHRpcGxlUmFuZ2VSZXF1ZXN0cyh0aGlzLCB0YXNrcywgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB3KDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkb3dubG9hZE9wZXJhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBhY3R1YWxVcmwgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgRGlmZmVyZW50aWFsIGRvd25sb2FkOiAke3RoaXMub3B0aW9ucy5uZXdVcmx9YCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnJlZGlyZWN0ID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgIHcgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0U3RyZWFtLndyaXRlKHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdFN0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB0YXNrc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLmtpbmQgPT09IGRvd25sb2FkUGxhbkJ1aWxkZXJfMS5PcGVyYXRpb25LaW5kLkNPUFkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGNvcHlpbmcsIGxldCdzIG5vdCBzZW5kIHN0YXR1cyB1cGRhdGVzIHRvIHRoZSBVSVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRJbmZvVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZEluZm9UcmFuc2Zvcm0uYmVnaW5GaWxlQ29weSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIERhdGFTcGxpdHRlcl8xLmNvcHlEYXRhKG9wZXJhdGlvbiwgZmlyc3RTdHJlYW0sIG9sZEZpbGVGZCwgcmVqZWN0LCAoKSA9PiB3KGluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBgYnl0ZXM9JHtvcGVyYXRpb24uc3RhcnR9LSR7b3BlcmF0aW9uLmVuZCAtIDF9YDtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5sb2dnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWJ1ZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGBkb3dubG9hZCByYW5nZTogJHtyYW5nZX1gKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RhcnRpbmcgdG8gZG93bmxvYWRcbiAgICAgICAgICAgICAgICBpZiAoZG93bmxvYWRJbmZvVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybS5iZWdpblJhbmdlRG93bmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuaHR0cEV4ZWN1dG9yLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxlY3Ryb24gbmV0IGhhbmRsZXMgcmVkaXJlY3RzIGF1dG9tYXRpY2FsbHksIG91ciBOb2RlSlMgdGVzdCBzZXJ2ZXIgZG9lc24ndCB1c2UgcmVkaXJlY3RzIC0gc28sIHdlIGRvbid0IGNoZWNrIDN4eCBjb2Rlcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5jcmVhdGVIdHRwRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5waXBlKGZpcnN0U3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uub25jZShcImVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIG9uIHRoYXQgd2UgYXJlIGRvd25sb2FkaW5nIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvd25sb2FkSW5mb1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkSW5mb1RyYW5zZm9ybS5lbmRSYW5nZURvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytkb3dubG9hZE9wZXJhdGlvbkNvdW50ID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZE9wZXJhdGlvbkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHcoaW5kZXgpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uKFwicmVkaXJlY3RcIiwgKHN0YXR1c0NvZGUsIG1ldGhvZCwgcmVkaXJlY3RVcmwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbyhgUmVkaXJlY3QgdG8gJHtyZW1vdmVRdWVyeShyZWRpcmVjdFVybCl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbFVybCA9IHJlZGlyZWN0VXJsO1xuICAgICAgICAgICAgICAgICAgICBidWlsZGVyX3V0aWxfcnVudGltZV8xLmNvbmZpZ3VyZVJlcXVlc3RVcmwobmV3IHVybF8xLlVSTChhY3R1YWxVcmwpLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZm9sbG93UmVkaXJlY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmh0dHBFeGVjdXRvci5hZGRFcnJvckFuZFRpbWVvdXRIYW5kbGVycyhyZXF1ZXN0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdygwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSZW1vdGVCeXRlcyhzdGFydCwgZW5kSW5jbHVzaXZlKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmRJbmNsdXNpdmUgKyAxIC0gc3RhcnQpO1xuICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuY3JlYXRlUmVxdWVzdE9wdGlvbnMoKTtcbiAgICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZEluY2x1c2l2ZX1gO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAwO1xuICAgICAgICBhd2FpdCB0aGlzLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIGNodW5rID0+IHtcbiAgICAgICAgICAgIGNodW5rLmNvcHkoYnVmZmVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocG9zaXRpb24gIT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgZGF0YSBsZW5ndGggJHtwb3NpdGlvbn0gaXMgbm90IGVxdWFsIHRvIGV4cGVjdGVkICR7YnVmZmVyLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICByZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBkYXRhSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuaHR0cEV4ZWN1dG9yLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW11bHRpcGxlUmFuZ2VEb3dubG9hZGVyXzEuY2hlY2tJc1Jhbmdlc1N1cHBvcnRlZChyZXNwb25zZSwgcmVqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKFwiZGF0YVwiLCBkYXRhSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oXCJlbmRcIiwgKCkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5odHRwRXhlY3V0b3IuYWRkRXJyb3JBbmRUaW1lb3V0SGFuZGxlcnMocmVxdWVzdCwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IERpZmZlcmVudGlhbERvd25sb2FkZXI7XG5mdW5jdGlvbiBmb3JtYXRCeXRlcyh2YWx1ZSwgc3ltYm9sID0gXCIgS0JcIikge1xuICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlblwiKS5mb3JtYXQoKHZhbHVlIC8gMTAyNCkudG9GaXhlZCgyKSkgKyBzeW1ib2w7XG59XG4vLyBzYWZldHlcbmZ1bmN0aW9uIHJlbW92ZVF1ZXJ5KHVybCkge1xuICAgIGNvbnN0IGluZGV4ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICAgIHJldHVybiBpbmRleCA8IDAgPyB1cmwgOiB1cmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpZmZlcmVudGlhbERvd25sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgPSB2b2lkIDA7XG5jb25zdCBmc19leHRyYV8xID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3QgRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY2xhc3MgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlciBleHRlbmRzIERpZmZlcmVudGlhbERvd25sb2FkZXJfMS5EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICBhc3luYyBkb3dubG9hZCgpIHtcbiAgICAgICAgY29uc3QgcGFja2FnZUluZm8gPSB0aGlzLmJsb2NrQXdhcmVGaWxlSW5mbztcbiAgICAgICAgY29uc3QgZmlsZVNpemUgPSBwYWNrYWdlSW5mby5zaXplO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBmaWxlU2l6ZSAtIChwYWNrYWdlSW5mby5ibG9ja01hcFNpemUgKyA0KTtcbiAgICAgICAgdGhpcy5maWxlTWV0YWRhdGFCdWZmZXIgPSBhd2FpdCB0aGlzLnJlYWRSZW1vdGVCeXRlcyhvZmZzZXQsIGZpbGVTaXplIC0gMSk7XG4gICAgICAgIGNvbnN0IG5ld0Jsb2NrTWFwID0gcmVhZEJsb2NrTWFwKHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyLnNsaWNlKDAsIHRoaXMuZmlsZU1ldGFkYXRhQnVmZmVyLmxlbmd0aCAtIDQpKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kb0Rvd25sb2FkKGF3YWl0IHJlYWRFbWJlZGRlZEJsb2NrTWFwRGF0YSh0aGlzLm9wdGlvbnMub2xkRmlsZSksIG5ld0Jsb2NrTWFwKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIgPSBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyO1xuZnVuY3Rpb24gcmVhZEJsb2NrTWFwKGRhdGEpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh6bGliXzEuaW5mbGF0ZVJhd1N5bmMoZGF0YSkudG9TdHJpbmcoKSk7XG59XG5hc3luYyBmdW5jdGlvbiByZWFkRW1iZWRkZWRCbG9ja01hcERhdGEoZmlsZSkge1xuICAgIGNvbnN0IGZkID0gYXdhaXQgZnNfZXh0cmFfMS5vcGVuKGZpbGUsIFwiclwiKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBmaWxlU2l6ZSA9IChhd2FpdCBmc19leHRyYV8xLmZzdGF0KGZkKSkuc2l6ZTtcbiAgICAgICAgY29uc3Qgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KTtcbiAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5yZWFkKGZkLCBzaXplQnVmZmVyLCAwLCBzaXplQnVmZmVyLmxlbmd0aCwgZmlsZVNpemUgLSBzaXplQnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZUJ1ZmZlci5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICBhd2FpdCBmc19leHRyYV8xLnJlYWQoZmQsIGRhdGFCdWZmZXIsIDAsIGRhdGFCdWZmZXIubGVuZ3RoLCBmaWxlU2l6ZSAtIHNpemVCdWZmZXIubGVuZ3RoIC0gZGF0YUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBhd2FpdCBmc19leHRyYV8xLmNsb3NlKGZkKTtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9ja01hcChkYXRhQnVmZmVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgYXdhaXQgZnNfZXh0cmFfMS5jbG9zZShmZCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwSW1hZ2VVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY29uc3QgZnNfZXh0cmFfMSA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBCYXNlVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQmFzZVVwZGF0ZXJcIik7XG5jb25zdCBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEgPSByZXF1aXJlKFwiLi9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCBtYWluXzEgPSByZXF1aXJlKFwiLi9tYWluXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbmNsYXNzIEFwcEltYWdlVXBkYXRlciBleHRlbmRzIEJhc2VVcGRhdGVyXzEuQmFzZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFwcCkge1xuICAgICAgICBzdXBlcihvcHRpb25zLCBhcHApO1xuICAgIH1cbiAgICBpc1VwZGF0ZXJBY3RpdmUoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudltcIkFQUElNQUdFXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudltcIlNOQVBcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKFwiQVBQSU1BR0UgZW52IGlzIG5vdCBkZWZpbmVkLCBjdXJyZW50IGFwcGxpY2F0aW9uIGlzIG5vdCBhbiBBcHBJbWFnZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKFwiU05BUCBlbnYgaXMgZGVmaW5lZCwgdXBkYXRlciBpcyBkaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuaXNVcGRhdGVyQWN0aXZlKCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gUHJvdmlkZXJfMS5maW5kRmlsZShwcm92aWRlci5yZXNvbHZlRmlsZXMoZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvKSwgXCJBcHBJbWFnZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZURvd25sb2FkKHtcbiAgICAgICAgICAgIGZpbGVFeHRlbnNpb246IFwiQXBwSW1hZ2VcIixcbiAgICAgICAgICAgIGZpbGVJbmZvLFxuICAgICAgICAgICAgZG93bmxvYWRVcGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgdGFzazogYXN5bmMgKHVwZGF0ZUZpbGUsIGRvd25sb2FkT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEZpbGUgPSBwcm9jZXNzLmVudltcIkFQUElNQUdFXCJdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRGaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5uZXdFcnJvcihcIkFQUElNQUdFIGVudiBpcyBub3QgZGVmaW5lZFwiLCBcIkVSUl9VUERBVEVSX09MRF9GSUxFX05PVF9GT1VORFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlzRG93bmxvYWRGdWxsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VXJsOiBmaWxlSW5mby51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlOiB1cGRhdGVGaWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogcHJvdmlkZXIuaXNVc2VNdWx0aXBsZVJhbmdlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZE9wdGlvbnMub25Qcm9ncmVzcyA9IGl0ID0+IHRoaXMuZW1pdChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MsIGl0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgRmlsZVdpdGhFbWJlZGRlZEJsb2NrTWFwRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xLkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXIoZmlsZUluZm8uaW5mbywgdGhpcy5odHRwRXhlY3V0b3IsIGRvd25sb2FkT3B0aW9ucykuZG93bmxvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjKSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlzRG93bmxvYWRGdWxsID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJsaW51eFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEb3dubG9hZEZ1bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLCB1cGRhdGVGaWxlLCBkb3dubG9hZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBmc19leHRyYV8xLmNobW9kKHVwZGF0ZUZpbGUsIDBvNzU1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkb0luc3RhbGwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcHBJbWFnZUZpbGUgPSBwcm9jZXNzLmVudltcIkFQUElNQUdFXCJdO1xuICAgICAgICBpZiAoYXBwSW1hZ2VGaWxlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEubmV3RXJyb3IoXCJBUFBJTUFHRSBlbnYgaXMgbm90IGRlZmluZWRcIiwgXCJFUlJfVVBEQVRFUl9PTERfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE3MTIwNTEvMTkxMDE5MVxuICAgICAgICBmc18xLnVubGlua1N5bmMoYXBwSW1hZ2VGaWxlKTtcbiAgICAgICAgbGV0IGRlc3RpbmF0aW9uO1xuICAgICAgICBjb25zdCBleGlzdGluZ0Jhc2VOYW1lID0gcGF0aC5iYXNlbmFtZShhcHBJbWFnZUZpbGUpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMjk2NFxuICAgICAgICAvLyBpZiBubyB2ZXJzaW9uIGluIGV4aXN0aW5nIGZpbGUgbmFtZSwgaXQgbWVhbnMgdGhhdCB1c2VyIHdhbnRzIHRvIHByZXNlcnZlIGN1cnJlbnQgY3VzdG9tIG5hbWVcbiAgICAgICAgaWYgKHBhdGguYmFzZW5hbWUob3B0aW9ucy5pbnN0YWxsZXJQYXRoKSA9PT0gZXhpc3RpbmdCYXNlTmFtZSB8fCAhL1xcZCtcXC5cXGQrXFwuXFxkKy8udGVzdChleGlzdGluZ0Jhc2VOYW1lKSkge1xuICAgICAgICAgICAgLy8gbm8gdmVyc2lvbiBpbiB0aGUgZmlsZSBuYW1lLCBvdmVyd3JpdGUgZXhpc3RpbmdcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uID0gYXBwSW1hZ2VGaWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24gPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKGFwcEltYWdlRmlsZSksIHBhdGguYmFzZW5hbWUob3B0aW9ucy5pbnN0YWxsZXJQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYyhcIm12XCIsIFtcIi1mXCIsIG9wdGlvbnMuaW5zdGFsbGVyUGF0aCwgZGVzdGluYXRpb25dKTtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICE9PSBhcHBJbWFnZUZpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImFwcGltYWdlLWZpbGVuYW1lLXVwZGF0ZWRcIiwgZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgICAgQVBQSU1BR0VfU0lMRU5UX0lOU1RBTEw6IFwidHJ1ZVwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5pc0ZvcmNlUnVuQWZ0ZXIpIHtcbiAgICAgICAgICAgIGNoaWxkX3Byb2Nlc3NfMS5zcGF3bihkZXN0aW5hdGlvbiwgW10sIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzdGRpbzogXCJpZ25vcmVcIixcbiAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICB9KS51bnJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW52LkFQUElNQUdFX0VYSVRfQUZURVJfSU5TVEFMTCA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYyhkZXN0aW5hdGlvbiwgW10sIHsgZW52IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwSW1hZ2VVcGRhdGVyID0gQXBwSW1hZ2VVcGRhdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwSW1hZ2VVcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWNVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBBcHBVcGRhdGVyXzEgPSByZXF1aXJlKFwiLi9BcHBVcGRhdGVyXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbmNvbnN0IGNoaWxkX3Byb2Nlc3NfMSA9IHJlcXVpcmUoXCJjaGlsZF9wcm9jZXNzXCIpO1xuY2xhc3MgTWFjVXBkYXRlciBleHRlbmRzIEFwcFVwZGF0ZXJfMS5BcHBVcGRhdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcHApIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucywgYXBwKTtcbiAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyID0gcmVxdWlyZShcImVsZWN0cm9uXCIpLmF1dG9VcGRhdGVyO1xuICAgICAgICB0aGlzLnNxdWlycmVsRG93bmxvYWRlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJlcnJvclwiLCBpdCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihpdCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBpdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNxdWlycmVsRG93bmxvYWRlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWJ1ZyhtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXIuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRvRG93bmxvYWRVcGRhdGUoZG93bmxvYWRVcGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGxldCBmaWxlcyA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXIucmVzb2x2ZUZpbGVzKGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mbyk7XG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgLy8gZGV0ZWN0IGlmIHdlIGFyZSBydW5uaW5nIGluc2lkZSBSb3NldHRhIGVtdWxhdGlvblxuICAgICAgICBjb25zdCBzeXNjdGxSb3NldHRhSW5mb0tleSA9IFwic3lzY3RsLnByb2NfdHJhbnNsYXRlZFwiO1xuICAgICAgICBsZXQgaXNSb3NldHRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkNoZWNraW5nIGZvciBtYWNPUyBSb3NldHRhIGVudmlyb25tZW50XCIpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGRfcHJvY2Vzc18xLmV4ZWNGaWxlU3luYyhcInN5c2N0bFwiLCBbc3lzY3RsUm9zZXR0YUluZm9LZXldLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KTtcbiAgICAgICAgICAgIGlzUm9zZXR0YSA9IHJlc3VsdC5pbmNsdWRlcyhgJHtzeXNjdGxSb3NldHRhSW5mb0tleX06IDFgKTtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBDaGVja2VkIGZvciBtYWNPUyBSb3NldHRhIGVudmlyb25tZW50IChpc1Jvc2V0dGE9JHtpc1Jvc2V0dGF9KWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2cud2Fybihgc3lzY3RsIHNoZWxsIGNvbW1hbmQgdG8gY2hlY2sgZm9yIG1hY09TIFJvc2V0dGEgZW52aXJvbm1lbnQgZmFpbGVkOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgYXJtNjQgbWFjcyB0byBpbnN0YWxsIHVuaXZlcnNhbCBvciByb3NldHRhMih4NjQpIC0gaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXVzZXJsYW5kL2VsZWN0cm9uLWJ1aWxkZXIvcHVsbC81NTI0XG4gICAgICAgIGNvbnN0IGlzQXJtNjQgPSAoZmlsZSkgPT4geyB2YXIgX2E7IHJldHVybiBmaWxlLnVybC5wYXRobmFtZS5pbmNsdWRlcyhcImFybTY0XCIpIHx8ICgoX2EgPSBmaWxlLmluZm8udXJsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoXCJhcm02NFwiKSk7IH07XG4gICAgICAgIGlmIChmaWxlcy5zb21lKGlzQXJtNjQpKSB7XG4gICAgICAgICAgICBmaWxlcyA9IGZpbGVzLmZpbHRlcihmaWxlID0+IChwcm9jZXNzLmFyY2ggPT09IFwiYXJtNjRcIiB8fCBpc1Jvc2V0dGEpID09PSBpc0FybTY0KGZpbGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6aXBGaWxlSW5mbyA9IFByb3ZpZGVyXzEuZmluZEZpbGUoZmlsZXMsIFwiemlwXCIsIFtcInBrZ1wiLCBcImRtZ1wiXSk7XG4gICAgICAgIGlmICh6aXBGaWxlSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBaSVAgZmlsZSBub3QgcHJvdmlkZWQ6ICR7YnVpbGRlcl91dGlsX3J1bnRpbWVfMS5zYWZlU3RyaW5naWZ5SnNvbihmaWxlcyl9YCwgXCJFUlJfVVBEQVRFUl9aSVBfRklMRV9OT1RfRk9VTkRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZURvd25sb2FkKHtcbiAgICAgICAgICAgIGZpbGVFeHRlbnNpb246IFwiemlwXCIsXG4gICAgICAgICAgICBmaWxlSW5mbzogemlwRmlsZUluZm8sXG4gICAgICAgICAgICBkb3dubG9hZFVwZGF0ZU9wdGlvbnMsXG4gICAgICAgICAgICB0YXNrOiAoZGVzdGluYXRpb25GaWxlLCBkb3dubG9hZE9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoemlwRmlsZUluZm8udXJsLCBkZXN0aW5hdGlvbkZpbGUsIGRvd25sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9uZTogZXZlbnQgPT4gdGhpcy51cGRhdGVEb3dubG9hZGVkKHppcEZpbGVJbmZvLCBldmVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVEb3dubG9hZGVkKHppcEZpbGVJbmZvLCBldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZXZlbnQuZG93bmxvYWRlZEZpbGU7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZpbGVTaXplID0gKF9hID0gemlwRmlsZUluZm8uaW5mby5zaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoYXdhaXQgZnNfZXh0cmFfMS5zdGF0KGRvd25sb2FkZWRGaWxlKSkuc2l6ZTtcbiAgICAgICAgY29uc3QgbG9nID0gdGhpcy5fbG9nZ2VyO1xuICAgICAgICBjb25zdCBsb2dDb250ZXh0ID0gYGZpbGVUb1Byb3h5PSR7emlwRmlsZUluZm8udXJsLmhyZWZ9YDtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQ3JlYXRpbmcgcHJveHkgc2VydmVyIGZvciBuYXRpdmUgU3F1aXJyZWwuTWFjICgke2xvZ0NvbnRleHR9KWApO1xuICAgICAgICBjb25zdCBzZXJ2ZXIgPSBodHRwXzEuY3JlYXRlU2VydmVyKCk7XG4gICAgICAgIHRoaXMuZGVidWcoYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBjcmVhdGVkICgke2xvZ0NvbnRleHR9KWApO1xuICAgICAgICBzZXJ2ZXIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2cuaW5mbyhgUHJveHkgc2VydmVyIGZvciBuYXRpdmUgU3F1aXJyZWwuTWFjIGlzIGNsb3NlZCAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG11c3QgYmUgY2FsbGVkIGFmdGVyIHNlcnZlciBpcyBsaXN0ZW5pbmcsIG90aGVyd2lzZSBhZGRyZXNzIGlzIG51bGxcbiAgICAgICAgZnVuY3Rpb24gZ2V0U2VydmVyVXJsKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gYGh0dHA6Ly8xMjcuMC4wLjE6JHthZGRyZXNzLnBvcnR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gaW5zZWN1cmUgcmFuZG9tIGlzIG9rXG4gICAgICAgICAgICBjb25zdCBmaWxlVXJsID0gYC8ke0RhdGUubm93KCkudG9TdHJpbmcoMTYpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OTkpLnRvU3RyaW5nKDE2KX0uemlwYDtcbiAgICAgICAgICAgIHNlcnZlci5vbihcInJlcXVlc3RcIiwgKHJlcXVlc3QsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFVybCA9IHJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKGAke3JlcXVlc3RVcmx9IHJlcXVlc3RlZGApO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsID09PSBcIi9cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20oYHsgXCJ1cmxcIjogXCIke2dldFNlcnZlclVybCgpfSR7ZmlsZVVybH1cIiB9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCgyMDAsIHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsIFwiQ29udGVudC1MZW5ndGhcIjogZGF0YS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmVuZChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3RVcmwuc3RhcnRzV2l0aChmaWxlVXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgJHtyZXF1ZXN0VXJsfSByZXF1ZXN0ZWQsIGJ1dCBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhgJHtmaWxlVXJsfSByZXF1ZXN0ZWQgYnkgU3F1aXJyZWwuTWFjLCBwaXBlICR7ZG93bmxvYWRlZEZpbGV9YCk7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yT2NjdXJyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbihcImZpbmlzaFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gc2VydmVyLmNsb3NlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvck9jY3VycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBmc18xLmNyZWF0ZVJlYWRTdHJlYW0oZG93bmxvYWRlZEZpbGUpO1xuICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYGNhbm5vdCBlbmQgcmVzcG9uc2U6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvck9jY3VycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IHBpcGUgXCIke2Rvd25sb2FkZWRGaWxlfVwiOiAke2Vycm9yfWApKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS53cml0ZUhlYWQoMjAwLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vemlwXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogdXBkYXRlRmlsZVNpemUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5waXBlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgUHJveHkgc2VydmVyIGZvciBuYXRpdmUgU3F1aXJyZWwuTWFjIGlzIHN0YXJ0aW5nIHRvIGxpc3RlbiAoJHtsb2dDb250ZXh0fSlgKTtcbiAgICAgICAgICAgIHNlcnZlci5saXN0ZW4oMCwgXCIxMjcuMC4wLjFcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYFByb3h5IHNlcnZlciBmb3IgbmF0aXZlIFNxdWlycmVsLk1hYyBpcyBsaXN0ZW5pbmcgKGFkZHJlc3M9JHtnZXRTZXJ2ZXJVcmwoKX0sICR7bG9nQ29udGV4dH0pYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnNldEZlZWRVUkwoe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGdldFNlcnZlclVybCgpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ2FjaGUtQ29udHJvbFwiOiBcIm5vLWNhY2hlXCIgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXBkYXRlIGhhcyBiZWVuIGRvd25sb2FkZWQgYW5kIGlzIHJlYWR5IHRvIGJlIHNlcnZlZCB0byBTcXVpcnJlbFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hVcGRhdGVEb3dubG9hZGVkKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvSW5zdGFsbE9uQXBwUXVpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub25jZShcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGZldGNoaW5nIGFuZCBpbnN0YWxsaW5nIHRoZSBmaWxlIG9uIFNxdWlycmVsIHNpZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLmNoZWNrRm9yVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWl0QW5kSW5zdGFsbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3F1aXJyZWxEb3dubG9hZGVkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYWxyZWFkeSBmZXRjaGVkIGJ5IFNxdWlycmVsLCBpdCdzIHJlYWR5IHRvIGluc3RhbGxcbiAgICAgICAgICAgIHRoaXMubmF0aXZlVXBkYXRlci5xdWl0QW5kSW5zdGFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcXVpdCBhbmQgaW5zdGFsbCBhcyBzb29uIGFzIFNxdWlycmVsIGdldCB0aGUgdXBkYXRlXG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVVwZGF0ZXIub24oXCJ1cGRhdGUtZG93bmxvYWRlZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVVcGRhdGVyLnF1aXRBbmRJbnN0YWxsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTWFjVXBkYXRlciA9IE1hY1VwZGF0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYWNVcGRhdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciA9IHZvaWQgMDtcbmNvbnN0IERpZmZlcmVudGlhbERvd25sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL0RpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jbGFzcyBHZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlciBleHRlbmRzIERpZmZlcmVudGlhbERvd25sb2FkZXJfMS5EaWZmZXJlbnRpYWxEb3dubG9hZGVyIHtcbiAgICBkb3dubG9hZChvbGRCbG9ja01hcCwgbmV3QmxvY2tNYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9Eb3dubG9hZChvbGRCbG9ja01hcCwgbmV3QmxvY2tNYXApO1xuICAgIH1cbn1cbmV4cG9ydHMuR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXIgPSBHZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdlbmVyaWNEaWZmZXJlbnRpYWxEb3dubG9hZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52ZXJpZnlTaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbi8vICRjZXJ0aWZpY2F0ZUluZm8gPSAoR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAneHh4XFx5eXkuZXhlJ1xuLy8gfCB3aGVyZSB7JF8uU3RhdHVzLkVxdWFscyhbU3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5TaWduYXR1cmVTdGF0dXNdOjpWYWxpZCkgLWFuZCAkXy5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0LkNvbnRhaW5zKFwiQ049c2llbWVucy5jb21cIil9KVxuLy8gfCBPdXQtU3RyaW5nIDsgaWYgKCRjZXJ0aWZpY2F0ZUluZm8pIHsgZXhpdCAwIH0gZWxzZSB7IGV4aXQgMSB9XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocHVibGlzaGVyTmFtZXMsIHVuZXNjYXBlZFRlbXBVcGRhdGVGaWxlLCBsb2dnZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIC8vIEVzY2FwZSBxdW90ZXMgYW5kIGJhY2t0aWNrcyBpbiBmaWxlbmFtZXMgdG8gcHJldmVudCB1c2VyIGZyb20gYnJlYWtpbmcgdGhlXG4gICAgICAgIC8vIGFyZ3VtZW50cyBhbmQgcGVyZm9ybSBhIHJlbW90ZSBjb21tYW5kIGluamVjdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQ29uc2lkZXIgZXhhbXBsZSBwb3dlcnNoZWxsIGNvbW1hbmQ6XG4gICAgICAgIC8vIGBgYHBvd2Vyc2hlbGxcbiAgICAgICAgLy8gR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAnQzpcXFxccGF0aFxcXFxteS1iYWQtJztjYWxjOydmaWxlbmFtZS5leGUnXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBUaGUgYWJvdmUgd291bGQgd29yayBleHBlY3RlZCBhbmQgZmluZCB0aGUgZmlsZSBuYW1lLCBob3dldmVyLCBpdCB3aWxsIGFsc28gZXhlY3V0ZSBgO2NhbGM7YFxuICAgICAgICAvLyBjb21tYW5kIGFuZCBzdGFydCB0aGUgY2FsY3VsYXRvciBhcHAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZyb20gUG93ZXJzaGVsbCBxdW90aW5nIHJ1bGVzOlxuICAgICAgICAvLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wb3dlcnNoZWxsL21vZHVsZS9taWNyb3NvZnQucG93ZXJzaGVsbC5jb3JlL2Fib3V0L2Fib3V0X3F1b3RpbmdfcnVsZXM/dmlldz1wb3dlcnNoZWxsLTdcbiAgICAgICAgLy8gKiBEb3VibGUgcXVvdGVzIGBcImAgYXJlIHRyZWF0ZWQgbGl0ZXJhbGx5IHdpdGhpbiBzaW5nbGUtcXVvdGVkIHN0cmluZ3M7XG4gICAgICAgIC8vICogU2luZ2xlIHF1b3RlcyBjYW4gYmUgZXNjYXBlZCBieSBkb3VibGluZyB0aGVtOiAnZG9uJyd0JyAtPiBkb24ndDtcbiAgICAgICAgLy8gKiBCYWNrdGlja3MgY2FuIGJlIGVzY2FwZWQgYnkgZG91YmxpbmcgdGhlbTogJ0EgYmFja3RpY2sgKGBgKSBjaGFyYWN0ZXInO1xuICAgICAgICAvL1xuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhdCB0aGlzIHBvaW50IHRoZSBmaWxlIGhhcyBhbHJlYWR5IGJlZW4gd3JpdHRlbiB0byB0aGUgZGlzaywgdGh1cyB3ZSBhcmVcbiAgICAgICAgLy8gZ3VhcmFudGVlZCB0aGF0IHRoZSBwYXRoIHdpbGwgbm90IGNvbnRhaW4gYW55IGlsbGVnYWwgY2hhcmFjdGVycyBsaWtlIDw+OlwiL1xcfD8qXG4gICAgICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3Mvd2luMzIvZmlsZWlvL25hbWluZy1hLWZpbGVcbiAgICAgICAgY29uc3QgdGVtcFVwZGF0ZUZpbGUgPSB1bmVzY2FwZWRUZW1wVXBkYXRlRmlsZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvYC9nLCBcImBgXCIpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMjQyMVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24tdXNlcmxhbmQvZWxlY3Ryb24tYnVpbGRlci9pc3N1ZXMvMjUzNVxuICAgICAgICBjaGlsZF9wcm9jZXNzXzEuZXhlY0ZpbGUoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbXG4gICAgICAgICAgICBcIi1Ob1Byb2ZpbGVcIixcbiAgICAgICAgICAgIFwiLU5vbkludGVyYWN0aXZlXCIsXG4gICAgICAgICAgICBcIi1JbnB1dEZvcm1hdFwiLFxuICAgICAgICAgICAgXCJOb25lXCIsXG4gICAgICAgICAgICBcIi1Db21tYW5kXCIsXG4gICAgICAgICAgICBgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZSAnJHt0ZW1wVXBkYXRlRmlsZX0nIHwgQ29udmVydFRvLUpzb24gLUNvbXByZXNzIHwgRm9yRWFjaC1PYmplY3QgeyBbQ29udmVydF06OlRvQmFzZTY0U3RyaW5nKFtTeXN0ZW0uVGV4dC5FbmNvZGluZ106OlVURjguR2V0Qnl0ZXMoJF8pKSB9YCxcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgdGltZW91dDogMjAgKiAxMDAwLFxuICAgICAgICB9LCAoZXJyb3IsIHN0ZG91dCwgc3RkZXJyKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsIHx8IHN0ZGVycikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihsb2dnZXIsIGVycm9yLCBzdGRlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXJzZU91dChCdWZmZXIuZnJvbShzdGRvdXQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmLThcIikpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLlN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYnVpbGRlcl91dGlsX3J1bnRpbWVfMS5wYXJzZURuKGRhdGEuU2lnbmVyQ2VydGlmaWNhdGUuU3ViamVjdCkuZ2V0KFwiQ05cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdWJsaXNoZXJOYW1lcy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBgcHVibGlzaGVyTmFtZXM6ICR7cHVibGlzaGVyTmFtZXMuam9pbihcIiB8IFwiKX0sIHJhdyBpbmZvOiBgICsgSlNPTi5zdHJpbmdpZnkoZGF0YSwgKG5hbWUsIHZhbHVlKSA9PiAobmFtZSA9PT0gXCJSYXdEYXRhXCIgPyB1bmRlZmluZWQgOiB2YWx1ZSksIDIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBTaWduIHZlcmlmaWNhdGlvbiBmYWlsZWQsIGluc3RhbGxlciBzaWduZWQgd2l0aCBpbmNvcnJlY3QgY2VydGlmaWNhdGU6ICR7cmVzdWx0fWApO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYENhbm5vdCBleGVjdXRlIEdldC1BdXRoZW50aWNvZGVTaWduYXR1cmU6ICR7ZXJyb3J9LiBJZ25vcmluZyBzaWduYXR1cmUgdmFsaWRhdGlvbiBkdWUgdG8gdW5rbm93biBlcnJvci5gKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZTtcbmZ1bmN0aW9uIHBhcnNlT3V0KG91dCkge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG91dCk7XG4gICAgZGVsZXRlIGRhdGEuUHJpdmF0ZUtleTtcbiAgICBkZWxldGUgZGF0YS5Jc09TQmluYXJ5O1xuICAgIGRlbGV0ZSBkYXRhLlNpZ25hdHVyZVR5cGU7XG4gICAgY29uc3Qgc2lnbmVyQ2VydGlmaWNhdGUgPSBkYXRhLlNpZ25lckNlcnRpZmljYXRlO1xuICAgIGlmIChzaWduZXJDZXJ0aWZpY2F0ZSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5BcmNoaXZlZDtcbiAgICAgICAgZGVsZXRlIHNpZ25lckNlcnRpZmljYXRlLkV4dGVuc2lvbnM7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYW5kbGU7XG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5IYXNQcml2YXRlS2V5O1xuICAgICAgICAvLyBkdXBsaWNhdGVzIGRhdGEuU2lnbmVyQ2VydGlmaWNhdGUgKGNvbnRhaW5zIFJhd0RhdGEpXG4gICAgICAgIGRlbGV0ZSBzaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0TmFtZTtcbiAgICB9XG4gICAgZGVsZXRlIGRhdGEuUGF0aDtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGxvZ2dlciwgZXJyb3IsIHN0ZGVycikge1xuICAgIGlmIChpc09sZFdpbjYoKSkge1xuICAgICAgICBsb2dnZXIud2FybihgQ2Fubm90IGV4ZWN1dGUgR2V0LUF1dGhlbnRpY29kZVNpZ25hdHVyZTogJHtlcnJvciB8fCBzdGRlcnJ9LiBJZ25vcmluZyBzaWduYXR1cmUgdmFsaWRhdGlvbiBkdWUgdG8gdW5zdXBwb3J0ZWQgcG93ZXJzaGVsbCB2ZXJzaW9uLiBQbGVhc2UgdXBncmFkZSB0byBwb3dlcnNoZWxsIDMgb3IgaGlnaGVyLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNoaWxkX3Byb2Nlc3NfMS5leGVjRmlsZVN5bmMoXCJwb3dlcnNoZWxsLmV4ZVwiLCBbXCItTm9Qcm9maWxlXCIsIFwiLU5vbkludGVyYWN0aXZlXCIsIFwiLUNvbW1hbmRcIiwgXCJDb252ZXJ0VG8tSnNvbiB0ZXN0XCJdLCB7IHRpbWVvdXQ6IDEwICogMTAwMCB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKHRlc3RFcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihgQ2Fubm90IGV4ZWN1dGUgQ29udmVydFRvLUpzb246ICR7dGVzdEVycm9yLm1lc3NhZ2V9LiBJZ25vcmluZyBzaWduYXR1cmUgdmFsaWRhdGlvbiBkdWUgdG8gdW5zdXBwb3J0ZWQgcG93ZXJzaGVsbCB2ZXJzaW9uLiBQbGVhc2UgdXBncmFkZSB0byBwb3dlcnNoZWxsIDMgb3IgaGlnaGVyLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBDYW5ub3QgZXhlY3V0ZSBHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlLCBzdGRlcnI6ICR7c3RkZXJyfS4gSWdub3Jpbmcgc2lnbmF0dXJlIHZhbGlkYXRpb24gZHVlIHRvIHVua25vd24gc3RkZXJyLmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPbGRXaW42KCkge1xuICAgIGNvbnN0IHdpblZlcnNpb24gPSBvcy5yZWxlYXNlKCk7XG4gICAgcmV0dXJuIHdpblZlcnNpb24uc3RhcnRzV2l0aChcIjYuXCIpICYmICF3aW5WZXJzaW9uLnN0YXJ0c1dpdGgoXCI2LjNcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTnNpc1VwZGF0ZXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyX3V0aWxfcnVudGltZV8xID0gcmVxdWlyZShcImJ1aWxkZXItdXRpbC1ydW50aW1lXCIpO1xuY29uc3QgY2hpbGRfcHJvY2Vzc18xID0gcmVxdWlyZShcImNoaWxkX3Byb2Nlc3NcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBCYXNlVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vQmFzZVVwZGF0ZXJcIik7XG5jb25zdCBGaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyXzEgPSByZXF1aXJlKFwiLi9kaWZmZXJlbnRpYWxEb3dubG9hZGVyL0ZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJcIik7XG5jb25zdCBHZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcl8xID0gcmVxdWlyZShcIi4vZGlmZmVyZW50aWFsRG93bmxvYWRlci9HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlclwiKTtcbmNvbnN0IG1haW5fMSA9IHJlcXVpcmUoXCIuL21haW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgUHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVycy9Qcm92aWRlclwiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCB3aW5kb3dzRXhlY3V0YWJsZUNvZGVTaWduYXR1cmVWZXJpZmllcl8xID0gcmVxdWlyZShcIi4vd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNsYXNzIE5zaXNVcGRhdGVyIGV4dGVuZHMgQmFzZVVwZGF0ZXJfMS5CYXNlVXBkYXRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgYXBwKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIGFwcCk7XG4gICAgfVxuICAgIC8qKiogQHByaXZhdGUgKi9cbiAgICBkb0Rvd25sb2FkVXBkYXRlKGRvd25sb2FkVXBkYXRlT3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGZpbGVJbmZvID0gUHJvdmlkZXJfMS5maW5kRmlsZShwcm92aWRlci5yZXNvbHZlRmlsZXMoZG93bmxvYWRVcGRhdGVPcHRpb25zLnVwZGF0ZUluZm9BbmRQcm92aWRlci5pbmZvKSwgXCJleGVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVEb3dubG9hZCh7XG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiBcImV4ZVwiLFxuICAgICAgICAgICAgZG93bmxvYWRVcGRhdGVPcHRpb25zLFxuICAgICAgICAgICAgZmlsZUluZm8sXG4gICAgICAgICAgICB0YXNrOiBhc3luYyAoZGVzdGluYXRpb25GaWxlLCBkb3dubG9hZE9wdGlvbnMsIHBhY2thZ2VGaWxlLCByZW1vdmVUZW1wRGlySWZBbnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGZpbGVJbmZvLnBhY2thZ2VJbmZvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzV2ViSW5zdGFsbGVyID0gcGFja2FnZUluZm8gIT0gbnVsbCAmJiBwYWNrYWdlRmlsZSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpc1dlYkluc3RhbGxlciB8fCAoYXdhaXQgdGhpcy5kaWZmZXJlbnRpYWxEb3dubG9hZEluc3RhbGxlcihmaWxlSW5mbywgZG93bmxvYWRVcGRhdGVPcHRpb25zLCBkZXN0aW5hdGlvbkZpbGUsIHByb3ZpZGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWQoZmlsZUluZm8udXJsLCBkZXN0aW5hdGlvbkZpbGUsIGRvd25sb2FkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZVZlcmlmaWNhdGlvblN0YXR1cyA9IGF3YWl0IHRoaXMudmVyaWZ5U2lnbmF0dXJlKGRlc3RpbmF0aW9uRmlsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZVZlcmlmaWNhdGlvblN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZVRlbXBEaXJJZkFueSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gVGhyb3dJbnNpZGVGaW5hbGx5QmxvY2tKU1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBidWlsZGVyX3V0aWxfcnVudGltZV8xLm5ld0Vycm9yKGBOZXcgdmVyc2lvbiAke2Rvd25sb2FkVXBkYXRlT3B0aW9ucy51cGRhdGVJbmZvQW5kUHJvdmlkZXIuaW5mby52ZXJzaW9ufSBpcyBub3Qgc2lnbmVkIGJ5IHRoZSBhcHBsaWNhdGlvbiBvd25lcjogJHtzaWduYXR1cmVWZXJpZmljYXRpb25TdGF0dXN9YCwgXCJFUlJfVVBEQVRFUl9JTlZBTElEX1NJR05BVFVSRVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViSW5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLmRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZShkb3dubG9hZFVwZGF0ZU9wdGlvbnMsIHBhY2thZ2VJbmZvLCBwYWNrYWdlRmlsZSwgcHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaHR0cEV4ZWN1dG9yLmRvd25sb2FkKG5ldyB1cmxfMS5VUkwocGFja2FnZUluZm8ucGF0aCksIHBhY2thZ2VGaWxlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhNTEyOiBwYWNrYWdlSW5mby5zaGE1MTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGZzX2V4dHJhXzEudW5saW5rKHBhY2thZ2VGaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gJGNlcnRpZmljYXRlSW5mbyA9IChHZXQtQXV0aGVudGljb2RlU2lnbmF0dXJlICd4eHhcXHl5eS5leGUnXG4gICAgLy8gfCB3aGVyZSB7JF8uU3RhdHVzLkVxdWFscyhbU3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5TaWduYXR1cmVTdGF0dXNdOjpWYWxpZCkgLWFuZCAkXy5TaWduZXJDZXJ0aWZpY2F0ZS5TdWJqZWN0LkNvbnRhaW5zKFwiQ049c2llbWVucy5jb21cIil9KVxuICAgIC8vIHwgT3V0LVN0cmluZyA7IGlmICgkY2VydGlmaWNhdGVJbmZvKSB7IGV4aXQgMCB9IGVsc2UgeyBleGl0IDEgfVxuICAgIGFzeW5jIHZlcmlmeVNpZ25hdHVyZSh0ZW1wVXBkYXRlRmlsZSkge1xuICAgICAgICBsZXQgcHVibGlzaGVyTmFtZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHB1Ymxpc2hlck5hbWUgPSAoYXdhaXQgdGhpcy5jb25maWdPbkRpc2sudmFsdWUpLnB1Ymxpc2hlck5hbWU7XG4gICAgICAgICAgICBpZiAocHVibGlzaGVyTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBubyBhcHAtdXBkYXRlLnltbFxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgd2luZG93c0V4ZWN1dGFibGVDb2RlU2lnbmF0dXJlVmVyaWZpZXJfMS52ZXJpZnlTaWduYXR1cmUoQXJyYXkuaXNBcnJheShwdWJsaXNoZXJOYW1lKSA/IHB1Ymxpc2hlck5hbWUgOiBbcHVibGlzaGVyTmFtZV0sIHRlbXBVcGRhdGVGaWxlLCB0aGlzLl9sb2dnZXIpO1xuICAgIH1cbiAgICBkb0luc3RhbGwob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcmdzID0gW1wiLS11cGRhdGVkXCJdO1xuICAgICAgICBpZiAob3B0aW9ucy5pc1NpbGVudCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKFwiL1NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaXNGb3JjZVJ1bkFmdGVyKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCItLWZvcmNlLXJ1blwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlciA9PSBudWxsID8gbnVsbCA6IHRoaXMuZG93bmxvYWRlZFVwZGF0ZUhlbHBlci5wYWNrYWdlRmlsZTtcbiAgICAgICAgaWYgKHBhY2thZ2VQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgPSBmb3JtIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgYXJncy5wdXNoKGAtLXBhY2thZ2UtZmlsZT0ke3BhY2thZ2VQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxVc2luZ0VsZXZhdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgIF9zcGF3bihwYXRoLmpvaW4ocHJvY2Vzcy5yZXNvdXJjZXNQYXRoLCBcImVsZXZhdGUuZXhlXCIpLCBbb3B0aW9ucy5pbnN0YWxsZXJQYXRoXS5jb25jYXQoYXJncykpLmNhdGNoKGUgPT4gdGhpcy5kaXNwYXRjaEVycm9yKGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNBZG1pblJpZ2h0c1JlcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhcImlzQWRtaW5SaWdodHNSZXF1aXJlZCBpcyBzZXQgdG8gdHJ1ZSwgcnVuIGluc3RhbGxlciB1c2luZyBlbGV2YXRlLmV4ZVwiKTtcbiAgICAgICAgICAgIGNhbGxVc2luZ0VsZXZhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3NwYXduKG9wdGlvbnMuaW5zdGFsbGVyUGF0aCwgYXJncykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi11c2VybGFuZC9lbGVjdHJvbi1idWlsZGVyL2lzc3Vlcy8xMTI5XG4gICAgICAgICAgICAvLyBOb2RlIDggc2VuZHMgZXJyb3JzOiBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjgueC9kb2NzL2FwaS9lcnJvcnMuaHRtbCNlcnJvcnNfY29tbW9uX3N5c3RlbV9lcnJvcnNcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGBDYW5ub3QgcnVuIGluc3RhbGxlcjogZXJyb3IgY29kZTogJHtlcnJvckNvZGV9LCBlcnJvciBtZXNzYWdlOiBcIiR7ZS5tZXNzYWdlfVwiLCB3aWxsIGJlIGV4ZWN1dGVkIGFnYWluIHVzaW5nIGVsZXZhdGUgaWYgRUFDQ0VTXCJgKTtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFwiVU5LTk9XTlwiIHx8IGVycm9yQ29kZSA9PT0gXCJFQUNDRVNcIikge1xuICAgICAgICAgICAgICAgIGNhbGxVc2luZ0VsZXZhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGRpZmZlcmVudGlhbERvd25sb2FkSW5zdGFsbGVyKGZpbGVJbmZvLCBkb3dubG9hZFVwZGF0ZU9wdGlvbnMsIGluc3RhbGxlclBhdGgsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGVzdE9ubHlPcHRpb25zICE9IG51bGwgJiYgIXRoaXMuX3Rlc3RPbmx5T3B0aW9ucy5pc1VzZURpZmZlcmVudGlhbERvd25sb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja21hcEZpbGVVcmxzID0gdXRpbF8xLmJsb2NrbWFwRmlsZXMoZmlsZUluZm8udXJsLCB0aGlzLmFwcC52ZXJzaW9uLCBkb3dubG9hZFVwZGF0ZU9wdGlvbnMudXBkYXRlSW5mb0FuZFByb3ZpZGVyLmluZm8udmVyc2lvbik7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgRG93bmxvYWQgYmxvY2sgbWFwcyAob2xkOiBcIiR7YmxvY2ttYXBGaWxlVXJsc1swXX1cIiwgbmV3OiAke2Jsb2NrbWFwRmlsZVVybHNbMV19KWApO1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRCbG9ja01hcCA9IGFzeW5jICh1cmwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5odHRwRXhlY3V0b3IuZG93bmxvYWRUb0J1ZmZlcih1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZG93bmxvYWRVcGRhdGVPcHRpb25zLnJlcXVlc3RIZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogZG93bmxvYWRVcGRhdGVPcHRpb25zLmNhbmNlbGxhdGlvblRva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9ja21hcCBcIiR7dXJsLmhyZWZ9XCIgaXMgZW1wdHlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoemxpYl8xLmd1bnppcFN5bmMoZGF0YSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIGJsb2NrbWFwIFwiJHt1cmwuaHJlZn1cIiwgZXJyb3I6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG5ld1VybDogZmlsZUluZm8udXJsLFxuICAgICAgICAgICAgICAgIG9sZEZpbGU6IHBhdGguam9pbih0aGlzLmRvd25sb2FkZWRVcGRhdGVIZWxwZXIuY2FjaGVEaXIsIGJ1aWxkZXJfdXRpbF9ydW50aW1lXzEuQ1VSUkVOVF9BUFBfSU5TVEFMTEVSX0ZJTEVfTkFNRSksXG4gICAgICAgICAgICAgICAgbG9nZ2VyOiB0aGlzLl9sb2dnZXIsXG4gICAgICAgICAgICAgICAgbmV3RmlsZTogaW5zdGFsbGVyUGF0aCxcbiAgICAgICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlci5pc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMucmVxdWVzdEhlYWRlcnMsXG4gICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW46IGRvd25sb2FkVXBkYXRlT3B0aW9ucy5jYW5jZWxsYXRpb25Ub2tlbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUykgPiAwKSB7XG4gICAgICAgICAgICAgICAgZG93bmxvYWRPcHRpb25zLm9uUHJvZ3Jlc3MgPSBpdCA9PiB0aGlzLmVtaXQobWFpbl8xLkRPV05MT0FEX1BST0dSRVNTLCBpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja01hcERhdGFMaXN0ID0gYXdhaXQgUHJvbWlzZS5hbGwoYmxvY2ttYXBGaWxlVXJscy5tYXAodSA9PiBkb3dubG9hZEJsb2NrTWFwKHUpKSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJfMS5HZW5lcmljRGlmZmVyZW50aWFsRG93bmxvYWRlcihmaWxlSW5mby5pbmZvLCB0aGlzLmh0dHBFeGVjdXRvciwgZG93bmxvYWRPcHRpb25zKS5kb3dubG9hZChibG9ja01hcERhdGFMaXN0WzBdLCBibG9ja01hcERhdGFMaXN0WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGBDYW5ub3QgZG93bmxvYWQgZGlmZmVyZW50aWFsbHksIGZhbGxiYWNrIHRvIGZ1bGwgZG93bmxvYWQ6ICR7ZS5zdGFjayB8fCBlfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Rlc3RPbmx5T3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBtb2RlXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRpZmZlcmVudGlhbERvd25sb2FkV2ViUGFja2FnZShkb3dubG9hZFVwZGF0ZU9wdGlvbnMsIHBhY2thZ2VJbmZvLCBwYWNrYWdlUGF0aCwgcHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKHBhY2thZ2VJbmZvLmJsb2NrTWFwU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZG93bmxvYWRPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG5ld1VybDogbmV3IHVybF8xLlVSTChwYWNrYWdlSW5mby5wYXRoKSxcbiAgICAgICAgICAgICAgICBvbGRGaWxlOiBwYXRoLmpvaW4odGhpcy5kb3dubG9hZGVkVXBkYXRlSGVscGVyLmNhY2hlRGlyLCBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNVUlJFTlRfQVBQX1BBQ0tBR0VfRklMRV9OQU1FKSxcbiAgICAgICAgICAgICAgICBsb2dnZXI6IHRoaXMuX2xvZ2dlcixcbiAgICAgICAgICAgICAgICBuZXdGaWxlOiBwYWNrYWdlUGF0aCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVyczogdGhpcy5yZXF1ZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICBpc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0OiBwcm92aWRlci5pc1VzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuOiBkb3dubG9hZFVwZGF0ZU9wdGlvbnMuY2FuY2VsbGF0aW9uVG9rZW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJDb3VudChtYWluXzEuRE9XTkxPQURfUFJPR1JFU1MpID4gMCkge1xuICAgICAgICAgICAgICAgIGRvd25sb2FkT3B0aW9ucy5vblByb2dyZXNzID0gaXQgPT4gdGhpcy5lbWl0KG1haW5fMS5ET1dOTE9BRF9QUk9HUkVTUywgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgbmV3IEZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJfMS5GaWxlV2l0aEVtYmVkZGVkQmxvY2tNYXBEaWZmZXJlbnRpYWxEb3dubG9hZGVyKHBhY2thZ2VJbmZvLCB0aGlzLmh0dHBFeGVjdXRvciwgZG93bmxvYWRPcHRpb25zKS5kb3dubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYENhbm5vdCBkb3dubG9hZCBkaWZmZXJlbnRpYWxseSwgZmFsbGJhY2sgdG8gZnVsbCBkb3dubG9hZDogJHtlLnN0YWNrIHx8IGV9YCk7XG4gICAgICAgICAgICAvLyBkdXJpbmcgdGVzdCAoZGV2ZWxvcGVyIG1hY2hpbmUgbWFjIG9yIGxpbnV4KSB3ZSBtdXN0IHRocm93IGVycm9yXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk5zaXNVcGRhdGVyID0gTnNpc1VwZGF0ZXI7XG4vKipcbiAqIFRoaXMgaGFuZGxlcyBib3RoIG5vZGUgOCBhbmQgbm9kZSAxMCB3YXkgb2YgZW1pdHRpbmcgZXJyb3Igd2hlbiBzcGF3bmluZyBhIHByb2Nlc3NcbiAqICAgLSBub2RlIDg6IFRocm93cyB0aGUgZXJyb3JcbiAqICAgLSBub2RlIDEwOiBFbWl0IHRoZSBlcnJvcihOZWVkIHRvIGxpc3RlbiB3aXRoIG9uKVxuICovXG5hc3luYyBmdW5jdGlvbiBfc3Bhd24oZXhlLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3MgPSBjaGlsZF9wcm9jZXNzXzEuc3Bhd24oZXhlLCBhcmdzLCB7XG4gICAgICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RkaW86IFwiaWdub3JlXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3Mub24oXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvY2Vzcy51bnJlZigpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MucGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnNpc1VwZGF0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVwZGF0ZXJTaWduYWwgPSBleHBvcnRzLlVQREFURV9ET1dOTE9BREVEID0gZXhwb3J0cy5ET1dOTE9BRF9QUk9HUkVTUyA9IGV4cG9ydHMuTnNpc1VwZGF0ZXIgPSBleHBvcnRzLk1hY1VwZGF0ZXIgPSBleHBvcnRzLkFwcEltYWdlVXBkYXRlciA9IGV4cG9ydHMuUHJvdmlkZXIgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5Ob09wTG9nZ2VyID0gZXhwb3J0cy5BcHBVcGRhdGVyID0gdm9pZCAwO1xuY29uc3QgYnVpbGRlcl91dGlsX3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJidWlsZGVyLXV0aWwtcnVudGltZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBidWlsZGVyX3V0aWxfcnVudGltZV8xLkNhbmNlbGxhdGlvblRva2VuOyB9IH0pO1xudmFyIEFwcFVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0FwcFVwZGF0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcHBVcGRhdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBBcHBVcGRhdGVyXzEuQXBwVXBkYXRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vT3BMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFwcFVwZGF0ZXJfMS5Ob09wTG9nZ2VyOyB9IH0pO1xudmFyIFByb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9wcm92aWRlcnMvUHJvdmlkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm92aWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvdmlkZXJfMS5Qcm92aWRlcjsgfSB9KTtcbnZhciBBcHBJbWFnZVVwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL0FwcEltYWdlVXBkYXRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFwcEltYWdlVXBkYXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQXBwSW1hZ2VVcGRhdGVyXzEuQXBwSW1hZ2VVcGRhdGVyOyB9IH0pO1xudmFyIE1hY1VwZGF0ZXJfMSA9IHJlcXVpcmUoXCIuL01hY1VwZGF0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNYWNVcGRhdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWNVcGRhdGVyXzEuTWFjVXBkYXRlcjsgfSB9KTtcbnZhciBOc2lzVXBkYXRlcl8xID0gcmVxdWlyZShcIi4vTnNpc1VwZGF0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOc2lzVXBkYXRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTnNpc1VwZGF0ZXJfMS5Oc2lzVXBkYXRlcjsgfSB9KTtcbi8vIGF1dG9VcGRhdGVyIHRvIG1pbWljIGVsZWN0cm9uIGJ1bmRsZWQgYXV0b1VwZGF0ZXJcbmxldCBfYXV0b1VwZGF0ZXI7XG5mdW5jdGlvbiBkb0xvYWRBdXRvVXBkYXRlcigpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZTpwcmVmZXItY29uZGl0aW9uYWwtZXhwcmVzc2lvblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICAgICAgX2F1dG9VcGRhdGVyID0gbmV3IChyZXF1aXJlKFwiLi9Oc2lzVXBkYXRlclwiKS5Oc2lzVXBkYXRlcikoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuICAgICAgICBfYXV0b1VwZGF0ZXIgPSBuZXcgKHJlcXVpcmUoXCIuL01hY1VwZGF0ZXJcIikuTWFjVXBkYXRlcikoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9hdXRvVXBkYXRlciA9IG5ldyAocmVxdWlyZShcIi4vQXBwSW1hZ2VVcGRhdGVyXCIpLkFwcEltYWdlVXBkYXRlcikoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9hdXRvVXBkYXRlcjtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImF1dG9VcGRhdGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gX2F1dG9VcGRhdGVyIHx8IGRvTG9hZEF1dG9VcGRhdGVyKCk7XG4gICAgfSxcbn0pO1xuZXhwb3J0cy5ET1dOTE9BRF9QUk9HUkVTUyA9IFwiZG93bmxvYWQtcHJvZ3Jlc3NcIjtcbmV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQgPSBcInVwZGF0ZS1kb3dubG9hZGVkXCI7XG5jbGFzcyBVcGRhdGVyU2lnbmFsIHtcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhbiBhdXRoZW50aWNhdGluZyBwcm94eSBpcyBbYXNraW5nIGZvciB1c2VyIGNyZWRlbnRpYWxzXShodHRwczovL2dpdGh1Yi5jb20vZWxlY3Ryb24vZWxlY3Ryb24vYmxvYi9tYXN0ZXIvZG9jcy9hcGkvY2xpZW50LXJlcXVlc3QubWQjZXZlbnQtbG9naW4pLlxuICAgICAqL1xuICAgIGxvZ2luKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIFwibG9naW5cIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIHByb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIGV4cG9ydHMuRE9XTkxPQURfUFJPR1JFU1MsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB1cGRhdGVEb3dubG9hZGVkKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkSGFuZGxlcih0aGlzLmVtaXR0ZXIsIGV4cG9ydHMuVVBEQVRFX0RPV05MT0FERUQsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB1cGRhdGVDYW5jZWxsZWQoaGFuZGxlcikge1xuICAgICAgICBhZGRIYW5kbGVyKHRoaXMuZW1pdHRlciwgXCJ1cGRhdGUtY2FuY2VsbGVkXCIsIGhhbmRsZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVXBkYXRlclNpZ25hbCA9IFVwZGF0ZXJTaWduYWw7XG5jb25zdCBpc0xvZ0V2ZW50ID0gZmFsc2U7XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVtaXR0ZXIsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKGlzTG9nRXZlbnQpIHtcbiAgICAgICAgZW1pdHRlci5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiJXMgJXNcIiwgZXZlbnQsIGFyZ3MpO1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNPYmogPSByZXF1aXJlKCdpcy1vYmonKTtcblxuY29uc3QgZGlzYWxsb3dlZEtleXMgPSBuZXcgU2V0KFtcblx0J19fcHJvdG9fXycsXG5cdCdwcm90b3R5cGUnLFxuXHQnY29uc3RydWN0b3InXG5dKTtcblxuY29uc3QgaXNWYWxpZFBhdGggPSBwYXRoU2VnbWVudHMgPT4gIXBhdGhTZWdtZW50cy5zb21lKHNlZ21lbnQgPT4gZGlzYWxsb3dlZEtleXMuaGFzKHNlZ21lbnQpKTtcblxuZnVuY3Rpb24gZ2V0UGF0aFNlZ21lbnRzKHBhdGgpIHtcblx0Y29uc3QgcGF0aEFycmF5ID0gcGF0aC5zcGxpdCgnLicpO1xuXHRjb25zdCBwYXJ0cyA9IFtdO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0bGV0IHAgPSBwYXRoQXJyYXlbaV07XG5cblx0XHR3aGlsZSAocFtwLmxlbmd0aCAtIDFdID09PSAnXFxcXCcgJiYgcGF0aEFycmF5W2kgKyAxXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwID0gcC5zbGljZSgwLCAtMSkgKyAnLic7XG5cdFx0XHRwICs9IHBhdGhBcnJheVsrK2ldO1xuXHRcdH1cblxuXHRcdHBhcnRzLnB1c2gocCk7XG5cdH1cblxuXHRpZiAoIWlzVmFsaWRQYXRoKHBhcnRzKSkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHJldHVybiBwYXJ0cztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBvYmplY3QgOiB2YWx1ZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0b2JqZWN0ID0gb2JqZWN0W3BhdGhBcnJheVtpXV07XG5cblx0XHRcdGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwpIHtcblx0XHRcdFx0Ly8gYG9iamVjdGAgaXMgZWl0aGVyIGB1bmRlZmluZWRgIG9yIGBudWxsYCBzbyB3ZSB3YW50IHRvIHN0b3AgdGhlIGxvb3AsIGFuZFxuXHRcdFx0XHQvLyBpZiB0aGlzIGlzIG5vdCB0aGUgbGFzdCBiaXQgb2YgdGhlIHBhdGgsIGFuZFxuXHRcdFx0XHQvLyBpZiBpdCBkaWQndCByZXR1cm4gYHVuZGVmaW5lZGBcblx0XHRcdFx0Ly8gaXQgd291bGQgcmV0dXJuIGBudWxsYCBpZiBgb2JqZWN0YCBpcyBgbnVsbGBcblx0XHRcdFx0Ly8gYnV0IHdlIHdhbnQgYGdldCh7Zm9vOiBudWxsfSwgJ2Zvby5iYXInKWAgdG8gZXF1YWwgYHVuZGVmaW5lZGAsIG9yIHRoZSBzdXBwbGllZCB2YWx1ZSwgbm90IGBudWxsYFxuXHRcdFx0XHRpZiAoaSAhPT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqZWN0ID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IG9iamVjdDtcblx0fSxcblxuXHRzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm9vdCA9IG9iamVjdDtcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgcCA9IHBhdGhBcnJheVtpXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3RbcF0pKSB7XG5cdFx0XHRcdG9iamVjdFtwXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0b2JqZWN0W3BdID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcm9vdDtcblx0fSxcblxuXHRkZWxldGUob2JqZWN0LCBwYXRoKSB7XG5cdFx0aWYgKCFpc09iaihvYmplY3QpIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGNvbnN0IHBhdGhBcnJheSA9IGdldFBhdGhTZWdtZW50cyhwYXRoKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwID0gcGF0aEFycmF5W2ldO1xuXG5cdFx0XHRpZiAoaSA9PT0gcGF0aEFycmF5Lmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0ZGVsZXRlIG9iamVjdFtwXTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdFtwXTtcblxuXHRcdFx0aWYgKCFpc09iaihvYmplY3QpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aGFzKG9iamVjdCwgcGF0aCkge1xuXHRcdGlmICghaXNPYmoob2JqZWN0KSB8fCB0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRjb25zdCBwYXRoQXJyYXkgPSBnZXRQYXRoU2VnbWVudHMocGF0aCk7XG5cdFx0aWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby1mb3ItbG9vcFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aEFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaXNPYmoob2JqZWN0KSkge1xuXHRcdFx0XHRpZiAoIShwYXRoQXJyYXlbaV0gaW4gb2JqZWN0KSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iamVjdCA9IG9iamVjdFtwYXRoQXJyYXlbaV1dO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZwID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRmcy5hY2Nlc3MoZnAsIGVyciA9PiB7XG5cdFx0cmVzb2x2ZSghZXJyKTtcblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IGZwID0+IHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKGZwKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwVHJ5ID0gKGZuLCAuLi5hcmd1bWVudHNfKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0cmVzb2x2ZShmbiguLi5hcmd1bWVudHNfKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwVHJ5O1xuLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBUcnk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwVHJ5ID0gcmVxdWlyZSgncC10cnknKTtcblxuY29uc3QgcExpbWl0ID0gY29uY3VycmVuY3kgPT4ge1xuXHRpZiAoISgoTnVtYmVyLmlzSW50ZWdlcihjb25jdXJyZW5jeSkgfHwgY29uY3VycmVuY3kgPT09IEluZmluaXR5KSAmJiBjb25jdXJyZW5jeSA+IDApKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBjb25jdXJyZW5jeWAgdG8gYmUgYSBudW1iZXIgZnJvbSAxIGFuZCB1cCcpKTtcblx0fVxuXG5cdGNvbnN0IHF1ZXVlID0gW107XG5cdGxldCBhY3RpdmVDb3VudCA9IDA7XG5cblx0Y29uc3QgbmV4dCA9ICgpID0+IHtcblx0XHRhY3RpdmVDb3VudC0tO1xuXG5cdFx0aWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdHF1ZXVlLnNoaWZ0KCkoKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgcnVuID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0YWN0aXZlQ291bnQrKztcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHBUcnkoZm4sIC4uLmFyZ3MpO1xuXG5cdFx0cmVzb2x2ZShyZXN1bHQpO1xuXG5cdFx0cmVzdWx0LnRoZW4obmV4dCwgbmV4dCk7XG5cdH07XG5cblx0Y29uc3QgZW5xdWV1ZSA9IChmbiwgcmVzb2x2ZSwgLi4uYXJncykgPT4ge1xuXHRcdGlmIChhY3RpdmVDb3VudCA8IGNvbmN1cnJlbmN5KSB7XG5cdFx0XHRydW4oZm4sIHJlc29sdmUsIC4uLmFyZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRxdWV1ZS5wdXNoKHJ1bi5iaW5kKG51bGwsIGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGdlbmVyYXRvciA9IChmbiwgLi4uYXJncykgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBlbnF1ZXVlKGZuLCByZXNvbHZlLCAuLi5hcmdzKSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdlbmVyYXRvciwge1xuXHRcdGFjdGl2ZUNvdW50OiB7XG5cdFx0XHRnZXQ6ICgpID0+IGFjdGl2ZUNvdW50XG5cdFx0fSxcblx0XHRwZW5kaW5nQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gcXVldWUubGVuZ3RoXG5cdFx0fSxcblx0XHRjbGVhclF1ZXVlOiB7XG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRxdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGdlbmVyYXRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcExpbWl0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBMaW1pdDtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBMaW1pdCA9IHJlcXVpcmUoJ3AtbGltaXQnKTtcblxuY2xhc3MgRW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHZhbHVlKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdH1cbn1cblxuLy8gVGhlIGlucHV0IGNhbiBhbHNvIGJlIGEgcHJvbWlzZSwgc28gd2UgYFByb21pc2UucmVzb2x2ZSgpYCBpdFxuY29uc3QgdGVzdEVsZW1lbnQgPSAoZWwsIHRlc3RlcikgPT4gUHJvbWlzZS5yZXNvbHZlKGVsKS50aGVuKHRlc3Rlcik7XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLmFsbCgpYCB0aGVtIGJvdGhcbmNvbnN0IGZpbmRlciA9IGVsID0+IFByb21pc2UuYWxsKGVsKS50aGVuKHZhbCA9PiB2YWxbMV0gPT09IHRydWUgJiYgUHJvbWlzZS5yZWplY3QobmV3IEVuZEVycm9yKHZhbFswXSkpKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaXRlcmFibGUsIHRlc3Rlciwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y29uY3VycmVuY3k6IEluZmluaXR5LFxuXHRcdHByZXNlcnZlT3JkZXI6IHRydWVcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgbGltaXQgPSBwTGltaXQob3B0cy5jb25jdXJyZW5jeSk7XG5cblx0Ly8gU3RhcnQgYWxsIHRoZSBwcm9taXNlcyBjb25jdXJyZW50bHkgd2l0aCBvcHRpb25hbCBsaW1pdFxuXHRjb25zdCBpdGVtcyA9IFsuLi5pdGVyYWJsZV0ubWFwKGVsID0+IFtlbCwgbGltaXQodGVzdEVsZW1lbnQsIGVsLCB0ZXN0ZXIpXSk7XG5cblx0Ly8gQ2hlY2sgdGhlIHByb21pc2VzIGVpdGhlciBzZXJpYWxseSBvciBjb25jdXJyZW50bHlcblx0Y29uc3QgY2hlY2tMaW1pdCA9IHBMaW1pdChvcHRzLnByZXNlcnZlT3JkZXIgPyAxIDogSW5maW5pdHkpO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5tYXAoZWwgPT4gY2hlY2tMaW1pdChmaW5kZXIsIGVsKSkpXG5cdFx0LnRoZW4oKCkgPT4ge30pXG5cdFx0LmNhdGNoKGVyciA9PiBlcnIgaW5zdGFuY2VvZiBFbmRFcnJvciA/IGVyci52YWx1ZSA6IFByb21pc2UucmVqZWN0KGVycikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBwYXRoRXhpc3RzID0gcmVxdWlyZSgncGF0aC1leGlzdHMnKTtcbmNvbnN0IHBMb2NhdGUgPSByZXF1aXJlKCdwLWxvY2F0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChpdGVyYWJsZSwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpXG5cdH0sIG9wdGlvbnMpO1xuXG5cdHJldHVybiBwTG9jYXRlKGl0ZXJhYmxlLCBlbCA9PiBwYXRoRXhpc3RzKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgZWwpKSwgb3B0aW9ucyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGl0ZXJhYmxlLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRjd2Q6IHByb2Nlc3MuY3dkKClcblx0fSwgb3B0aW9ucyk7XG5cblx0Zm9yIChjb25zdCBlbCBvZiBpdGVyYWJsZSkge1xuXHRcdGlmIChwYXRoRXhpc3RzLnN5bmMocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBlbCkpKSB7XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fVxuXHR9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGxvY2F0ZVBhdGggPSByZXF1aXJlKCdsb2NhdGUtcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGNvbnN0IHN0YXJ0RGlyID0gcGF0aC5yZXNvbHZlKG9wdHMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShzdGFydERpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHRyZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG5cdFx0KGZ1bmN0aW9uIGZpbmQoZGlyKSB7XG5cdFx0XHRsb2NhdGVQYXRoKGZpbGVuYW1lcywge2N3ZDogZGlyfSkudGhlbihmaWxlID0+IHtcblx0XHRcdFx0aWYgKGZpbGUpIHtcblx0XHRcdFx0XHRyZXNvbHZlKHBhdGguam9pbihkaXIsIGZpbGUpKTtcblx0XHRcdFx0fSBlbHNlIGlmIChkaXIgPT09IHJvb3QpIHtcblx0XHRcdFx0XHRyZXNvbHZlKG51bGwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZpbmQocGF0aC5kaXJuYW1lKGRpcikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KShzdGFydERpcik7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChmaWxlbmFtZSwgb3B0cyA9IHt9KSA9PiB7XG5cdGxldCBkaXIgPSBwYXRoLnJlc29sdmUob3B0cy5jd2QgfHwgJycpO1xuXHRjb25zdCB7cm9vdH0gPSBwYXRoLnBhcnNlKGRpcik7XG5cblx0Y29uc3QgZmlsZW5hbWVzID0gW10uY29uY2F0KGZpbGVuYW1lKTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Y29uc3QgZmlsZSA9IGxvY2F0ZVBhdGguc3luYyhmaWxlbmFtZXMsIHtjd2Q6IGRpcn0pO1xuXG5cdFx0aWYgKGZpbGUpIHtcblx0XHRcdHJldHVybiBwYXRoLmpvaW4oZGlyLCBmaWxlKTtcblx0XHR9XG5cblx0XHRpZiAoZGlyID09PSByb290KSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRkaXIgPSBwYXRoLmRpcm5hbWUoZGlyKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IGZpbmRVcCA9IHJlcXVpcmUoJ2ZpbmQtdXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3luYyAoe2N3ZH0gPSB7fSkgPT4gZmluZFVwKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKHtjd2R9ID0ge30pID0+IGZpbmRVcC5zeW5jKCdwYWNrYWdlLmpzb24nLCB7Y3dkfSk7XG4iLCIndXNlIHN0cmljdCc7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuXG5jb25zdCBob21lZGlyID0gb3MuaG9tZWRpcigpO1xuY29uc3QgdG1wZGlyID0gb3MudG1wZGlyKCk7XG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmNvbnN0IG1hY29zID0gbmFtZSA9PiB7XG5cdGNvbnN0IGxpYnJhcnkgPSBwYXRoLmpvaW4oaG9tZWRpciwgJ0xpYnJhcnknKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHBhdGguam9pbihsaWJyYXJ5LCAnQXBwbGljYXRpb24gU3VwcG9ydCcsIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGxpYnJhcnksICdQcmVmZXJlbmNlcycsIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obGlicmFyeSwgJ0NhY2hlcycsIG5hbWUpLFxuXHRcdGxvZzogcGF0aC5qb2luKGxpYnJhcnksICdMb2dzJywgbmFtZSksXG5cdFx0dGVtcDogcGF0aC5qb2luKHRtcGRpciwgbmFtZSlcblx0fTtcbn07XG5cbmNvbnN0IHdpbmRvd3MgPSBuYW1lID0+IHtcblx0Y29uc3QgYXBwRGF0YSA9IGVudi5BUFBEQVRBIHx8IHBhdGguam9pbihob21lZGlyLCAnQXBwRGF0YScsICdSb2FtaW5nJyk7XG5cdGNvbnN0IGxvY2FsQXBwRGF0YSA9IGVudi5MT0NBTEFQUERBVEEgfHwgcGF0aC5qb2luKGhvbWVkaXIsICdBcHBEYXRhJywgJ0xvY2FsJyk7XG5cblx0cmV0dXJuIHtcblx0XHQvLyBEYXRhL2NvbmZpZy9jYWNoZS9sb2cgYXJlIGludmVudGVkIGJ5IG1lIGFzIFdpbmRvd3MgaXNuJ3Qgb3BpbmlvbmF0ZWQgYWJvdXQgdGhpc1xuXHRcdGRhdGE6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdEYXRhJyksXG5cdFx0Y29uZmlnOiBwYXRoLmpvaW4oYXBwRGF0YSwgbmFtZSwgJ0NvbmZpZycpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4obG9jYWxBcHBEYXRhLCBuYW1lLCAnQ2FjaGUnKSxcblx0XHRsb2c6IHBhdGguam9pbihsb2NhbEFwcERhdGEsIG5hbWUsICdMb2cnKSxcblx0XHR0ZW1wOiBwYXRoLmpvaW4odG1wZGlyLCBuYW1lKVxuXHR9O1xufTtcblxuLy8gaHR0cHM6Ly9zcGVjaWZpY2F0aW9ucy5mcmVlZGVza3RvcC5vcmcvYmFzZWRpci1zcGVjL2Jhc2VkaXItc3BlYy1sYXRlc3QuaHRtbFxuY29uc3QgbGludXggPSBuYW1lID0+IHtcblx0Y29uc3QgdXNlcm5hbWUgPSBwYXRoLmJhc2VuYW1lKGhvbWVkaXIpO1xuXG5cdHJldHVybiB7XG5cdFx0ZGF0YTogcGF0aC5qb2luKGVudi5YREdfREFUQV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3NoYXJlJyksIG5hbWUpLFxuXHRcdGNvbmZpZzogcGF0aC5qb2luKGVudi5YREdfQ09ORklHX0hPTUUgfHwgcGF0aC5qb2luKGhvbWVkaXIsICcuY29uZmlnJyksIG5hbWUpLFxuXHRcdGNhY2hlOiBwYXRoLmpvaW4oZW52LlhER19DQUNIRV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmNhY2hlJyksIG5hbWUpLFxuXHRcdC8vIGh0dHBzOi8vd2lraS5kZWJpYW4ub3JnL1hER0Jhc2VEaXJlY3RvcnlTcGVjaWZpY2F0aW9uI3N0YXRlXG5cdFx0bG9nOiBwYXRoLmpvaW4oZW52LlhER19TVEFURV9IT01FIHx8IHBhdGguam9pbihob21lZGlyLCAnLmxvY2FsJywgJ3N0YXRlJyksIG5hbWUpLFxuXHRcdHRlbXA6IHBhdGguam9pbih0bXBkaXIsIHVzZXJuYW1lLCBuYW1lKVxuXHR9O1xufTtcblxuY29uc3QgZW52UGF0aHMgPSAobmFtZSwgb3B0aW9ucykgPT4ge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgbmFtZX1gKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtzdWZmaXg6ICdub2RlanMnfSwgb3B0aW9ucyk7XG5cblx0aWYgKG9wdGlvbnMuc3VmZml4KSB7XG5cdFx0Ly8gQWRkIHN1ZmZpeCB0byBwcmV2ZW50IHBvc3NpYmxlIGNvbmZsaWN0IHdpdGggbmF0aXZlIGFwcHNcblx0XHRuYW1lICs9IGAtJHtvcHRpb25zLnN1ZmZpeH1gO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG5cdFx0cmV0dXJuIG1hY29zKG5hbWUpO1xuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcblx0XHRyZXR1cm4gd2luZG93cyhuYW1lKTtcblx0fVxuXG5cdHJldHVybiBsaW51eChuYW1lKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW52UGF0aHM7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVudlBhdGhzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBDT05TVFMgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTk9PUCA9IGV4cG9ydHMuTElNSVRfRklMRVNfREVTQ1JJUFRPUlMgPSBleHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IGV4cG9ydHMuSVNfVVNFUl9ST09UID0gZXhwb3J0cy5JU19QT1NJWCA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBleHBvcnRzLkRFRkFVTFRfVElNRU9VVF9BU1lOQyA9IGV4cG9ydHMuREVGQVVMVF9XUklURV9PUFRJT05TID0gZXhwb3J0cy5ERUZBVUxUX1JFQURfT1BUSU9OUyA9IGV4cG9ydHMuREVGQVVMVF9GT0xERVJfTU9ERSA9IGV4cG9ydHMuREVGQVVMVF9GSUxFX01PREUgPSBleHBvcnRzLkRFRkFVTFRfRU5DT0RJTkcgPSB2b2lkIDA7XG5jb25zdCBERUZBVUxUX0VOQ09ESU5HID0gJ3V0ZjgnO1xuZXhwb3J0cy5ERUZBVUxUX0VOQ09ESU5HID0gREVGQVVMVF9FTkNPRElORztcbmNvbnN0IERFRkFVTFRfRklMRV9NT0RFID0gMG82NjY7XG5leHBvcnRzLkRFRkFVTFRfRklMRV9NT0RFID0gREVGQVVMVF9GSUxFX01PREU7XG5jb25zdCBERUZBVUxUX0ZPTERFUl9NT0RFID0gMG83Nzc7XG5leHBvcnRzLkRFRkFVTFRfRk9MREVSX01PREUgPSBERUZBVUxUX0ZPTERFUl9NT0RFO1xuY29uc3QgREVGQVVMVF9SRUFEX09QVElPTlMgPSB7fTtcbmV4cG9ydHMuREVGQVVMVF9SRUFEX09QVElPTlMgPSBERUZBVUxUX1JFQURfT1BUSU9OUztcbmNvbnN0IERFRkFVTFRfV1JJVEVfT1BUSU9OUyA9IHt9O1xuZXhwb3J0cy5ERUZBVUxUX1dSSVRFX09QVElPTlMgPSBERUZBVUxUX1dSSVRFX09QVElPTlM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSA1MDAwO1xuZXhwb3J0cy5ERUZBVUxUX1RJTUVPVVRfQVNZTkMgPSBERUZBVUxUX1RJTUVPVVRfQVNZTkM7XG5jb25zdCBERUZBVUxUX1RJTUVPVVRfU1lOQyA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9USU1FT1VUX1NZTkMgPSBERUZBVUxUX1RJTUVPVVRfU1lOQztcbmNvbnN0IElTX1BPU0lYID0gISFwcm9jZXNzLmdldHVpZDtcbmV4cG9ydHMuSVNfUE9TSVggPSBJU19QT1NJWDtcbmNvbnN0IElTX1VTRVJfUk9PVCA9IHByb2Nlc3MuZ2V0dWlkID8gIXByb2Nlc3MuZ2V0dWlkKCkgOiBmYWxzZTtcbmV4cG9ydHMuSVNfVVNFUl9ST09UID0gSVNfVVNFUl9ST09UO1xuY29uc3QgTElNSVRfQkFTRU5BTUVfTEVOR1RIID0gMTI4OyAvL1RPRE86IGZldGNoIHRoZSByZWFsIGxpbWl0IGZyb20gdGhlIGZpbGVzeXN0ZW0gLy9UT0RPOiBmZXRjaCB0aGUgd2hvbGUtcGF0aCBsZW5ndGggbGltaXQgdG9vXG5leHBvcnRzLkxJTUlUX0JBU0VOQU1FX0xFTkdUSCA9IExJTUlUX0JBU0VOQU1FX0xFTkdUSDtcbmNvbnN0IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTID0gMTAwMDA7IC8vVE9ETzogZmV0Y2ggdGhlIHJlYWwgbGltaXQgZnJvbSB0aGUgZmlsZXN5c3RlbVxuZXhwb3J0cy5MSU1JVF9GSUxFU19ERVNDUklQVE9SUyA9IExJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTO1xuY29uc3QgTk9PUCA9ICgpID0+IHsgfTtcbmV4cG9ydHMuTk9PUCA9IE5PT1A7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hdHRlbXB0aWZ5U3luYyA9IGV4cG9ydHMuYXR0ZW1wdGlmeUFzeW5jID0gdm9pZCAwO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogQVRURU1QVElGWSAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2Vcbi8vRklYTUU6IFRoZSB0eXBlIGNhc3RpbmdzIGhlcmUgYXJlbid0IGV4YWN0bHkgY29ycmVjdFxuY29uc3QgYXR0ZW1wdGlmeUFzeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykuY2F0Y2gob25FcnJvcik7XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlBc3luYyA9IGF0dGVtcHRpZnlBc3luYztcbmNvbnN0IGF0dGVtcHRpZnlTeW5jID0gKGZuLCBvbkVycm9yID0gY29uc3RzXzEuTk9PUCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnRzLmF0dGVtcHRpZnlTeW5jID0gYXR0ZW1wdGlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuLyogRlMgSEFORExFUlMgKi9cbmNvbnN0IEhhbmRsZXJzID0ge1xuICAgIGlzQ2hhbmdlRXJyb3JPazogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PU1lTJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWNvbnN0c18xLklTX1VTRVJfUk9PVCAmJiAoY29kZSA9PT0gJ0VJTlZBTCcgfHwgY29kZSA9PT0gJ0VQRVJNJykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaXNSZXRyaWFibGVFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29kZSB9ID0gZXJyb3I7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU1GSUxFJyB8fCBjb2RlID09PSAnRU5GSUxFJyB8fCBjb2RlID09PSAnRUFHQUlOJyB8fCBjb2RlID09PSAnRUJVU1knIHx8IGNvZGUgPT09ICdFQUNDRVNTJyB8fCBjb2RlID09PSAnRUFDQ1MnIHx8IGNvZGUgPT09ICdFUEVSTScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25DaGFuZ2VFcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChIYW5kbGVycy5pc0NoYW5nZUVycm9yT2soZXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBIYW5kbGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG4vKiBSRVRSWUlGWSBRVUVVRSAqL1xuY29uc3QgUmV0cnlmeVF1ZXVlID0ge1xuICAgIGludGVydmFsOiAyNSxcbiAgICBpbnRlcnZhbElkOiB1bmRlZmluZWQsXG4gICAgbGltaXQ6IGNvbnN0c18xLkxJTUlUX0ZJTEVTX0RFU0NSSVBUT1JTLFxuICAgIHF1ZXVlQWN0aXZlOiBuZXcgU2V0KCksXG4gICAgcXVldWVXYWl0aW5nOiBuZXcgU2V0KCksXG4gICAgaW5pdDogKCkgPT4ge1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLmludGVydmFsSWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoUmV0cnlmeVF1ZXVlLnRpY2ssIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbCk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgICBpZiAoIVJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjbGVhckludGVydmFsKFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkKTtcbiAgICAgICAgZGVsZXRlIFJldHJ5ZnlRdWV1ZS5pbnRlcnZhbElkO1xuICAgIH0sXG4gICAgYWRkOiAoZm4pID0+IHtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5hZGQoZm4pO1xuICAgICAgICBpZiAoUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLnNpemUgPCAoUmV0cnlmeVF1ZXVlLmxpbWl0IC8gMikpIHsgLy8gQWN0aXZlIHF1ZXVlIG5vdCB1bmRlciBwcmVhc3N1cmUsIGV4ZWN1dGluZyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgUmV0cnlmeVF1ZXVlLnRpY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJldHJ5ZnlRdWV1ZS5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogKGZuKSA9PiB7XG4gICAgICAgIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcuZGVsZXRlKGZuKTtcbiAgICAgICAgUmV0cnlmeVF1ZXVlLnF1ZXVlQWN0aXZlLmRlbGV0ZShmbik7XG4gICAgfSxcbiAgICBzY2hlZHVsZTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4gUmV0cnlmeVF1ZXVlLnJlbW92ZShyZXNvbHZlcik7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9ICgpID0+IHJlc29sdmUoY2xlYW51cCk7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUuYWRkKHJlc29sdmVyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB0aWNrOiAoKSA9PiB7XG4gICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghUmV0cnlmeVF1ZXVlLnF1ZXVlV2FpdGluZy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIFJldHJ5ZnlRdWV1ZS5yZXNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIFJldHJ5ZnlRdWV1ZS5xdWV1ZVdhaXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuc2l6ZSA+PSBSZXRyeWZ5UXVldWUubGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVXYWl0aW5nLmRlbGV0ZShmbik7XG4gICAgICAgICAgICBSZXRyeWZ5UXVldWUucXVldWVBY3RpdmUuYWRkKGZuKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBSZXRyeWZ5UXVldWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSBleHBvcnRzLnJldHJ5aWZ5QXN5bmMgPSB2b2lkIDA7XG5jb25zdCByZXRyeWlmeV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlfcXVldWVcIik7XG4vKiBSRVRSWUlGWSAqL1xuY29uc3QgcmV0cnlpZnlBc3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5aWZ5X3F1ZXVlXzEuZGVmYXVsdC5zY2hlZHVsZSgpLnRoZW4oY2xlYW51cCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPj0gdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSBNYXRoLnJvdW5kKDEwMCArICg0MDAgKiBNYXRoLnJhbmRvbSgpKSksIGRlbGF5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5UHJvbWlzZS50aGVuKCgpID0+IGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeUFzeW5jID0gcmV0cnlpZnlBc3luYztcbmNvbnN0IHJldHJ5aWZ5U3luYyA9IChmbiwgaXNSZXRyaWFibGVFcnJvcikgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhdHRlbXB0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPiB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldHJpYWJsZUVycm9yKGVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG59O1xuZXhwb3J0cy5yZXRyeWlmeVN5bmMgPSByZXRyeWlmeVN5bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGF0dGVtcHRpZnlfMSA9IHJlcXVpcmUoXCIuL2F0dGVtcHRpZnlcIik7XG5jb25zdCBmc19oYW5kbGVyc18xID0gcmVxdWlyZShcIi4vZnNfaGFuZGxlcnNcIik7XG5jb25zdCByZXRyeWlmeV8xID0gcmVxdWlyZShcIi4vcmV0cnlpZnlcIik7XG4vKiBGUyAqL1xuY29uc3QgRlMgPSB7XG4gICAgY2htb2RBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2htb2QpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2hvd25BdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2hvd24pLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpKSxcbiAgICBmc3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5mc3luYykpLFxuICAgIG1rZGlyQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLm1rZGlyKSksXG4gICAgcmVhbHBhdGhBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMucmVhbHBhdGgpKSxcbiAgICBzdGF0QXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnN0YXQpKSxcbiAgICB1bmxpbmtBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMudW5saW5rKSksXG4gICAgY2xvc2VSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuY2xvc2UpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgZnN5bmNSZXRyeTogcmV0cnlpZnlfMS5yZXRyeWlmeUFzeW5jKHV0aWxfMS5wcm9taXNpZnkoZnMuZnN5bmMpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgb3BlblJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5vcGVuKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLnJlYWRGaWxlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlbmFtZVJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5yZW5hbWUpLCBmc19oYW5kbGVyc18xLmRlZmF1bHQuaXNSZXRyaWFibGVFcnJvciksXG4gICAgc3RhdFJldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5QXN5bmModXRpbF8xLnByb21pc2lmeShmcy5zdGF0KSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlBc3luYyh1dGlsXzEucHJvbWlzaWZ5KGZzLndyaXRlKSwgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGNobW9kU3luY0F0dGVtcHQ6IGF0dGVtcHRpZnlfMS5hdHRlbXB0aWZ5U3luYyhmcy5jaG1vZFN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5vbkNoYW5nZUVycm9yKSxcbiAgICBjaG93blN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuY2hvd25TeW5jLCBmc19oYW5kbGVyc18xLmRlZmF1bHQub25DaGFuZ2VFcnJvciksXG4gICAgY2xvc2VTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLmNsb3NlU3luYyksXG4gICAgbWtkaXJTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLm1rZGlyU3luYyksXG4gICAgcmVhbHBhdGhTeW5jQXR0ZW1wdDogYXR0ZW1wdGlmeV8xLmF0dGVtcHRpZnlTeW5jKGZzLnJlYWxwYXRoU3luYyksXG4gICAgc3RhdFN5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMuc3RhdFN5bmMpLFxuICAgIHVubGlua1N5bmNBdHRlbXB0OiBhdHRlbXB0aWZ5XzEuYXR0ZW1wdGlmeVN5bmMoZnMudW5saW5rU3luYyksXG4gICAgY2xvc2VTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLmNsb3NlU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIGZzeW5jU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5mc3luY1N5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBvcGVuU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5vcGVuU3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHJlYWRGaWxlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5yZWFkRmlsZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICByZW5hbWVTeW5jUmV0cnk6IHJldHJ5aWZ5XzEucmV0cnlpZnlTeW5jKGZzLnJlbmFtZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKSxcbiAgICBzdGF0U3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy5zdGF0U3luYywgZnNfaGFuZGxlcnNfMS5kZWZhdWx0LmlzUmV0cmlhYmxlRXJyb3IpLFxuICAgIHdyaXRlU3luY1JldHJ5OiByZXRyeWlmeV8xLnJldHJ5aWZ5U3luYyhmcy53cml0ZVN5bmMsIGZzX2hhbmRsZXJzXzEuZGVmYXVsdC5pc1JldHJpYWJsZUVycm9yKVxufTtcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gRlM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIExBTkcgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExhbmcgPSB7XG4gICAgaXNGdW5jdGlvbjogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuICAgIH0sXG4gICAgaXNTdHJpbmc6ICh4KSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBpc1VuZGVmaW5lZDogKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJztcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBMYW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBJTVBPUlQgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIFZBUklBQkxFUyAqL1xuY29uc3QgUXVldWVzID0ge307XG4vKiBTQ0hFRFVMRVIgKi9cbi8vVE9ETzogTWF5YmUgcHVibGlzaCB0aGlzIGFzIGEgc3RhbmRhbG9uZSBwYWNrYWdlXG5jb25zdCBTY2hlZHVsZXIgPSB7XG4gICAgbmV4dDogKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgaWYgKCFxdWV1ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29uc3Qgam9iID0gcXVldWVbMF07XG4gICAgICAgIGlmIChqb2IpIHtcbiAgICAgICAgICAgIGpvYigoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIFF1ZXVlc1tpZF07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNjaGVkdWxlOiAoaWQpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgbGV0IHF1ZXVlID0gUXVldWVzW2lkXTtcbiAgICAgICAgICAgIGlmICghcXVldWUpXG4gICAgICAgICAgICAgICAgcXVldWUgPSBRdWV1ZXNbaWRdID0gW107XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiBTY2hlZHVsZXIubmV4dChpZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyogRVhQT1JUICovXG5leHBvcnRzLmRlZmF1bHQgPSBTY2hlZHVsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIElNUE9SVCAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL2ZzXCIpO1xuLyogVEVNUCAqL1xuLy9UT0RPOiBNYXliZSBwdWJsaXNoIHRoaXMgYXMgYSBzdGFuZGFsb25lIHBhY2thZ2VcbmNvbnN0IFRlbXAgPSB7XG4gICAgc3RvcmU6IHt9LFxuICAgIGNyZWF0ZTogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBgMDAwMDAwJHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTYpLCAvLyA2IHJhbmRvbS1lbm91Z2ggaGV4IGNoYXJhY3RlcnNcbiAgICAgICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygpLnNsaWNlKC0xMCksIC8vIDEwIHByZWNpc2UgdGltZXN0YW1wIGRpZ2l0c1xuICAgICAgICBwcmVmaXggPSAndG1wLScsIHN1ZmZpeCA9IGAuJHtwcmVmaXh9JHt0aW1lc3RhbXB9JHtyYW5kb21uZXNzfWAsIHRlbXBQYXRoID0gYCR7ZmlsZVBhdGh9JHtzdWZmaXh9YDtcbiAgICAgICAgcmV0dXJuIHRlbXBQYXRoO1xuICAgIH0sXG4gICAgZ2V0OiAoZmlsZVBhdGgsIGNyZWF0b3IsIHB1cmdlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0ZW1wUGF0aCA9IFRlbXAudHJ1bmNhdGUoY3JlYXRvcihmaWxlUGF0aCkpO1xuICAgICAgICBpZiAodGVtcFBhdGggaW4gVGVtcC5zdG9yZSlcbiAgICAgICAgICAgIHJldHVybiBUZW1wLmdldChmaWxlUGF0aCwgY3JlYXRvciwgcHVyZ2UpOyAvLyBDb2xsaXNpb24gZm91bmQsIHRyeSBhZ2FpblxuICAgICAgICBUZW1wLnN0b3JlW3RlbXBQYXRoXSA9IHB1cmdlO1xuICAgICAgICBjb25zdCBkaXNwb3NlciA9ICgpID0+IGRlbGV0ZSBUZW1wLnN0b3JlW3RlbXBQYXRoXTtcbiAgICAgICAgcmV0dXJuIFt0ZW1wUGF0aCwgZGlzcG9zZXJdO1xuICAgIH0sXG4gICAgcHVyZ2U6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBpZiAoIVRlbXAuc3RvcmVbZmlsZVBhdGhdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWxldGUgVGVtcC5zdG9yZVtmaWxlUGF0aF07XG4gICAgICAgIGZzXzEuZGVmYXVsdC51bmxpbmtBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luYzogKGZpbGVQYXRoKSA9PiB7XG4gICAgICAgIGlmICghVGVtcC5zdG9yZVtmaWxlUGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBUZW1wLnN0b3JlW2ZpbGVQYXRoXTtcbiAgICAgICAgZnNfMS5kZWZhdWx0LnVubGlua1N5bmNBdHRlbXB0KGZpbGVQYXRoKTtcbiAgICB9LFxuICAgIHB1cmdlU3luY0FsbDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIGluIFRlbXAuc3RvcmUpIHtcbiAgICAgICAgICAgIFRlbXAucHVyZ2VTeW5jKGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJ1bmNhdGU6IChmaWxlUGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBpZiAoYmFzZW5hbWUubGVuZ3RoIDw9IGNvbnN0c18xLkxJTUlUX0JBU0VOQU1FX0xFTkdUSClcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogUm91Z2ggYW5kIHF1aWNrIGF0dGVtcHQgYXQgZGV0ZWN0aW5nIG9rIGxlbmd0aHNcbiAgICAgICAgY29uc3QgdHJ1bmNhYmxlID0gL14oXFwuPykoLio/KSgoPzpcXC5bXi5dKyk/KD86XFwudG1wLVxcZHsxMH1bYS1mMC05XXs2fSk/KSQvLmV4ZWMoYmFzZW5hbWUpO1xuICAgICAgICBpZiAoIXRydW5jYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmaWxlUGF0aDsgLy9GSVhNRTogTm8gdHJ1bmNhYmxlIHBhcnQgZGV0ZWN0ZWQsIGNhbid0IHJlYWxseSBkbyBtdWNoIHdpdGhvdXQgYWxzbyBjaGFuZ2luZyB0aGUgcGFyZW50IHBhdGgsIHdoaWNoIGlzIHVuc2FmZSwgaG9waW5nIGZvciB0aGUgYmVzdCBoZXJlXG4gICAgICAgIGNvbnN0IHRydW5jYXRpb25MZW5ndGggPSBiYXNlbmFtZS5sZW5ndGggLSBjb25zdHNfMS5MSU1JVF9CQVNFTkFNRV9MRU5HVEg7XG4gICAgICAgIHJldHVybiBgJHtmaWxlUGF0aC5zbGljZSgwLCAtYmFzZW5hbWUubGVuZ3RoKX0ke3RydW5jYWJsZVsxXX0ke3RydW5jYWJsZVsyXS5zbGljZSgwLCAtdHJ1bmNhdGlvbkxlbmd0aCl9JHt0cnVuY2FibGVbM119YDsgLy9GSVhNRTogVGhlIHRydW5jYWJsZSBwYXJ0IG1pZ2h0IGJlIHNob3J0ZXIgdGhhbiBuZWVkZWQgaGVyZVxuICAgIH1cbn07XG4vKiBJTklUICovXG5wcm9jZXNzLm9uKCdleGl0JywgVGVtcC5wdXJnZVN5bmNBbGwpOyAvLyBFbnN1cmluZyBwdXJnZWFibGUgdGVtcCBmaWxlcyBhcmUgcHVyZ2VkIG9uIGV4aXRcbi8qIEVYUE9SVCAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gVGVtcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogSU1QT1JUICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSBleHBvcnRzLndyaXRlRmlsZSA9IGV4cG9ydHMucmVhZEZpbGVTeW5jID0gZXhwb3J0cy5yZWFkRmlsZSA9IHZvaWQgMDtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0c18xID0gcmVxdWlyZShcIi4vY29uc3RzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2ZzXCIpO1xuY29uc3QgbGFuZ18xID0gcmVxdWlyZShcIi4vdXRpbHMvbGFuZ1wiKTtcbmNvbnN0IHNjaGVkdWxlcl8xID0gcmVxdWlyZShcIi4vdXRpbHMvc2NoZWR1bGVyXCIpO1xuY29uc3QgdGVtcF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdGVtcFwiKTtcbmZ1bmN0aW9uIHJlYWRGaWxlKGZpbGVQYXRoLCBvcHRpb25zID0gY29uc3RzXzEuREVGQVVMVF9SRUFEX09QVElPTlMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gcmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfQVNZTkMpO1xuICAgIHJldHVybiBmc18xLmRlZmF1bHQucmVhZEZpbGVSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlID0gcmVhZEZpbGU7XG47XG5mdW5jdGlvbiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIG9wdGlvbnMgPSBjb25zdHNfMS5ERUZBVUxUX1JFQURfT1BUSU9OUykge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMgfSk7XG4gICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAoKF9hID0gb3B0aW9ucy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdHNfMS5ERUZBVUxUX1RJTUVPVVRfU1lOQyk7XG4gICAgcmV0dXJuIGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmNSZXRyeSh0aW1lb3V0KShmaWxlUGF0aCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLnJlYWRGaWxlU3luYyA9IHJlYWRGaWxlU3luYztcbjtcbmNvbnN0IHdyaXRlRmlsZSA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNGdW5jdGlvbihvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIHdyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgY29uc3RzXzEuREVGQVVMVF9XUklURV9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlID0gd3JpdGVGaWxlQXN5bmMoZmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgcHJvbWlzZS50aGVuKGNhbGxiYWNrLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuZXhwb3J0cy53cml0ZUZpbGUgPSB3cml0ZUZpbGU7XG5jb25zdCB3cml0ZUZpbGVBc3luYyA9IGFzeW5jIChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVBc3luYyhmaWxlUGF0aCwgZGF0YSwgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICBjb25zdCB0aW1lb3V0ID0gRGF0ZS5ub3coKSArICgoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0c18xLkRFRkFVTFRfVElNRU9VVF9BU1lOQyk7XG4gICAgbGV0IHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gbnVsbCwgc2NoZWR1bGVyRGlzcG9zZXIgPSBudWxsLCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlZHVsZSlcbiAgICAgICAgICAgIHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyID0gYXdhaXQgb3B0aW9ucy5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIHNjaGVkdWxlckRpc3Bvc2VyID0gYXdhaXQgc2NoZWR1bGVyXzEuZGVmYXVsdC5zY2hlZHVsZShmaWxlUGF0aCk7XG4gICAgICAgIGZpbGVQYXRoID0gYXdhaXQgZnNfMS5kZWZhdWx0LnJlYWxwYXRoQXR0ZW1wdChmaWxlUGF0aCkgfHwgZmlsZVBhdGg7XG4gICAgICAgIFt0ZW1wUGF0aCwgdGVtcERpc3Bvc2VyXSA9IHRlbXBfMS5kZWZhdWx0LmdldChmaWxlUGF0aCwgb3B0aW9ucy50bXBDcmVhdGUgfHwgdGVtcF8xLmRlZmF1bHQuY3JlYXRlLCAhKG9wdGlvbnMudG1wUHVyZ2UgPT09IGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHVzZVN0YXRDaG93biA9IGNvbnN0c18xLklTX1BPU0lYICYmIGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMuY2hvd24pLCB1c2VTdGF0TW9kZSA9IGxhbmdfMS5kZWZhdWx0LmlzVW5kZWZpbmVkKG9wdGlvbnMubW9kZSk7XG4gICAgICAgIGlmICh1c2VTdGF0Q2hvd24gfHwgdXNlU3RhdE1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmc18xLmRlZmF1bHQuc3RhdEF0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQubWtkaXJBdHRlbXB0KHBhcmVudFBhdGgsIHtcbiAgICAgICAgICAgIG1vZGU6IGNvbnN0c18xLkRFRkFVTFRfRk9MREVSX01PREUsXG4gICAgICAgICAgICByZWN1cnNpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGZkID0gYXdhaXQgZnNfMS5kZWZhdWx0Lm9wZW5SZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgJ3cnLCBvcHRpb25zLm1vZGUgfHwgY29uc3RzXzEuREVGQVVMVF9GSUxFX01PREUpO1xuICAgICAgICBpZiAob3B0aW9ucy50bXBDcmVhdGVkKVxuICAgICAgICAgICAgb3B0aW9ucy50bXBDcmVhdGVkKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKGxhbmdfMS5kZWZhdWx0LmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQud3JpdGVSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC53cml0ZVJldHJ5KHRpbWVvdXQpKGZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mc3luY1dhaXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmZzeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmZzeW5jQXR0ZW1wdChmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNob3duQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5jaG93bi51aWQsIG9wdGlvbnMuY2hvd24uZ2lkKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kZSlcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5jaG1vZEF0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMubW9kZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmc18xLmRlZmF1bHQucmVuYW1lUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGF3YWl0IGZzXzEuZGVmYXVsdC5yZW5hbWVSZXRyeSh0aW1lb3V0KSh0ZW1wUGF0aCwgdGVtcF8xLmRlZmF1bHQudHJ1bmNhdGUoZmlsZVBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW1wRGlzcG9zZXIoKTtcbiAgICAgICAgdGVtcFBhdGggPSBudWxsO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGZkKVxuICAgICAgICAgICAgYXdhaXQgZnNfMS5kZWZhdWx0LmNsb3NlQXR0ZW1wdChmZCk7XG4gICAgICAgIGlmICh0ZW1wUGF0aClcbiAgICAgICAgICAgIHRlbXBfMS5kZWZhdWx0LnB1cmdlKHRlbXBQYXRoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckN1c3RvbURpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyQ3VzdG9tRGlzcG9zZXIoKTtcbiAgICAgICAgaWYgKHNjaGVkdWxlckRpc3Bvc2VyKVxuICAgICAgICAgICAgc2NoZWR1bGVyRGlzcG9zZXIoKTtcbiAgICB9XG59O1xuY29uc3Qgd3JpdGVGaWxlU3luYyA9IChmaWxlUGF0aCwgZGF0YSwgb3B0aW9ucyA9IGNvbnN0c18xLkRFRkFVTFRfV1JJVEVfT1BUSU9OUykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcob3B0aW9ucykpXG4gICAgICAgIHJldHVybiB3cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBkYXRhLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBEYXRlLm5vdygpICsgKChfYSA9IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RzXzEuREVGQVVMVF9USU1FT1VUX1NZTkMpO1xuICAgIGxldCB0ZW1wRGlzcG9zZXIgPSBudWxsLCB0ZW1wUGF0aCA9IG51bGwsIGZkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmaWxlUGF0aCA9IGZzXzEuZGVmYXVsdC5yZWFscGF0aFN5bmNBdHRlbXB0KGZpbGVQYXRoKSB8fCBmaWxlUGF0aDtcbiAgICAgICAgW3RlbXBQYXRoLCB0ZW1wRGlzcG9zZXJdID0gdGVtcF8xLmRlZmF1bHQuZ2V0KGZpbGVQYXRoLCBvcHRpb25zLnRtcENyZWF0ZSB8fCB0ZW1wXzEuZGVmYXVsdC5jcmVhdGUsICEob3B0aW9ucy50bXBQdXJnZSA9PT0gZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdXNlU3RhdENob3duID0gY29uc3RzXzEuSVNfUE9TSVggJiYgbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5jaG93biksIHVzZVN0YXRNb2RlID0gbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQob3B0aW9ucy5tb2RlKTtcbiAgICAgICAgaWYgKHVzZVN0YXRDaG93biB8fCB1c2VTdGF0TW9kZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdCA9IGZzXzEuZGVmYXVsdC5zdGF0U3luY0F0dGVtcHQoZmlsZVBhdGgpO1xuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgaWYgKHVzZVN0YXRDaG93bilcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jaG93biA9IHsgdWlkOiBzdGF0LnVpZCwgZ2lkOiBzdGF0LmdpZCB9O1xuICAgICAgICAgICAgICAgIGlmICh1c2VTdGF0TW9kZSlcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xuICAgICAgICBmc18xLmRlZmF1bHQubWtkaXJTeW5jQXR0ZW1wdChwYXJlbnRQYXRoLCB7XG4gICAgICAgICAgICBtb2RlOiBjb25zdHNfMS5ERUZBVUxUX0ZPTERFUl9NT0RFLFxuICAgICAgICAgICAgcmVjdXJzaXZlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBmZCA9IGZzXzEuZGVmYXVsdC5vcGVuU3luY1JldHJ5KHRpbWVvdXQpKHRlbXBQYXRoLCAndycsIG9wdGlvbnMubW9kZSB8fCBjb25zdHNfMS5ERUZBVUxUX0ZJTEVfTU9ERSk7XG4gICAgICAgIGlmIChvcHRpb25zLnRtcENyZWF0ZWQpXG4gICAgICAgICAgICBvcHRpb25zLnRtcENyZWF0ZWQodGVtcFBhdGgpO1xuICAgICAgICBpZiAobGFuZ18xLmRlZmF1bHQuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgb3B0aW9ucy5lbmNvZGluZyB8fCBjb25zdHNfMS5ERUZBVUxUX0VOQ09ESU5HKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFuZ18xLmRlZmF1bHQuaXNVbmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC53cml0ZVN5bmNSZXRyeSh0aW1lb3V0KShmZCwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmZzeW5jICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZnN5bmNXYWl0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5mc3luY1N5bmNSZXRyeSh0aW1lb3V0KShmZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmc18xLmRlZmF1bHQuZnN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmc18xLmRlZmF1bHQuY2xvc2VTeW5jUmV0cnkodGltZW91dCkoZmQpO1xuICAgICAgICBmZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmNob3duKVxuICAgICAgICAgICAgZnNfMS5kZWZhdWx0LmNob3duU3luY0F0dGVtcHQodGVtcFBhdGgsIG9wdGlvbnMuY2hvd24udWlkLCBvcHRpb25zLmNob3duLmdpZCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1vZGUpXG4gICAgICAgICAgICBmc18xLmRlZmF1bHQuY2htb2RTeW5jQXR0ZW1wdCh0ZW1wUGF0aCwgb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIGZpbGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSAnRU5BTUVUT09MT05HJylcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5yZW5hbWVTeW5jUmV0cnkodGltZW91dCkodGVtcFBhdGgsIHRlbXBfMS5kZWZhdWx0LnRydW5jYXRlKGZpbGVQYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcERpc3Bvc2VyKCk7XG4gICAgICAgIHRlbXBQYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChmZClcbiAgICAgICAgICAgIGZzXzEuZGVmYXVsdC5jbG9zZVN5bmNBdHRlbXB0KGZkKTtcbiAgICAgICAgaWYgKHRlbXBQYXRoKVxuICAgICAgICAgICAgdGVtcF8xLmRlZmF1bHQucHVyZ2UodGVtcFBhdGgpO1xuICAgIH1cbn07XG5leHBvcnRzLndyaXRlRmlsZVN5bmMgPSB3cml0ZUZpbGVTeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2V4cENvZGUgPSBleHBvcnRzLmdldFByb3BlcnR5ID0gZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ckNvbmNhdCA9IGV4cG9ydHMuYWRkQ29kZUFyZyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLl9Db2RlID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5JREVOVElGSUVSID0gZXhwb3J0cy5fQ29kZU9yTmFtZSA9IHZvaWQgMDtcbmNsYXNzIF9Db2RlT3JOYW1lIHtcbn1cbmV4cG9ydHMuX0NvZGVPck5hbWUgPSBfQ29kZU9yTmFtZTtcbmV4cG9ydHMuSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuY2xhc3MgTmFtZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghZXhwb3J0cy5JREVOVElGSUVSLnRlc3QocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBuYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXCIpO1xuICAgICAgICB0aGlzLnN0ciA9IHM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHI7XG4gICAgfVxuICAgIGVtcHR5U3RyKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHsgW3RoaXMuc3RyXTogMSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTmFtZSA9IE5hbWU7XG5jbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBbY29kZV0gOiBjb2RlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyO1xuICAgIH1cbiAgICBlbXB0eVN0cigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1swXTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInO1xuICAgIH1cbiAgICBnZXQgc3RyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fc3RyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fc3RyID0gdGhpcy5faXRlbXMucmVkdWNlKChzLCBjKSA9PiBgJHtzfSR7Y31gLCBcIlwiKSkpO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLl9uYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX25hbWVzID0gdGhpcy5faXRlbXMucmVkdWNlKChuYW1lcywgYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICAgICAgICAgIG5hbWVzW2Muc3RyXSA9IChuYW1lc1tjLnN0cl0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgICAgICB9LCB7fSkpKTtcbiAgICB9XG59XG5leHBvcnRzLl9Db2RlID0gX0NvZGU7XG5leHBvcnRzLm5pbCA9IG5ldyBfQ29kZShcIlwiKTtcbmZ1bmN0aW9uIF8oc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGNvZGUgPSBbc3Ryc1swXV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKTtcbiAgICAgICAgY29kZS5wdXNoKHN0cnNbKytpXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSk7XG59XG5leHBvcnRzLl8gPSBfO1xuY29uc3QgcGx1cyA9IG5ldyBfQ29kZShcIitcIik7XG5mdW5jdGlvbiBzdHIoc3RycywgLi4uYXJncykge1xuICAgIGNvbnN0IGV4cHIgPSBbc2FmZVN0cmluZ2lmeShzdHJzWzBdKV07XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgZXhwci5wdXNoKHBsdXMpO1xuICAgICAgICBhZGRDb2RlQXJnKGV4cHIsIGFyZ3NbaV0pO1xuICAgICAgICBleHByLnB1c2gocGx1cywgc2FmZVN0cmluZ2lmeShzdHJzWysraV0pKTtcbiAgICB9XG4gICAgb3B0aW1pemUoZXhwcik7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShleHByKTtcbn1cbmV4cG9ydHMuc3RyID0gc3RyO1xuZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlLCBhcmcpIHtcbiAgICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpXG4gICAgICAgIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKTtcbiAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKVxuICAgICAgICBjb2RlLnB1c2goYXJnKTtcbiAgICBlbHNlXG4gICAgICAgIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKTtcbn1cbmV4cG9ydHMuYWRkQ29kZUFyZyA9IGFkZENvZGVBcmc7XG5mdW5jdGlvbiBvcHRpbWl6ZShleHByKSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIHdoaWxlIChpIDwgZXhwci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pO1xuICAgICAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByW2krK10gPSBcIitcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VFeHBySXRlbXMoYSwgYikge1xuICAgIGlmIChiID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBhO1xuICAgIGlmIChhID09PSAnXCJcIicpXG4gICAgICAgIHJldHVybiBiO1xuICAgIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChiIGluc3RhbmNlb2YgTmFtZSB8fCBhW2EubGVuZ3RoIC0gMV0gIT09ICdcIicpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImA7XG4gICAgICAgIGlmIChiWzBdID09PSAnXCInKVxuICAgICAgICAgICAgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiBiWzBdID09PSAnXCInICYmICEoYSBpbnN0YW5jZW9mIE5hbWUpKVxuICAgICAgICByZXR1cm4gYFwiJHthfSR7Yi5zbGljZSgxKX1gO1xuICAgIHJldHVybjtcbn1cbmZ1bmN0aW9uIHN0ckNvbmNhdChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzIuZW1wdHlTdHIoKSA/IGMxIDogYzEuZW1wdHlTdHIoKSA/IGMyIDogc3RyIGAke2MxfSR7YzJ9YDtcbn1cbmV4cG9ydHMuc3RyQ29uY2F0ID0gc3RyQ29uY2F0O1xuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgICAgID8geFxuICAgICAgICA6IHNhZmVTdHJpbmdpZnkoQXJyYXkuaXNBcnJheSh4KSA/IHguam9pbihcIixcIikgOiB4KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShzYWZlU3RyaW5naWZ5KHgpKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh4KSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xufVxuZXhwb3J0cy5zYWZlU3RyaW5naWZ5ID0gc2FmZVN0cmluZ2lmeTtcbmZ1bmN0aW9uIGdldFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgZXhwb3J0cy5JREVOVElGSUVSLnRlc3Qoa2V5KSA/IG5ldyBfQ29kZShgLiR7a2V5fWApIDogXyBgWyR7a2V5fV1gO1xufVxuZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGdldFByb3BlcnR5O1xuZnVuY3Rpb24gcmVnZXhwQ29kZShyeCkge1xuICAgIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSk7XG59XG5leHBvcnRzLnJlZ2V4cENvZGUgPSByZWdleHBDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVTY29wZSA9IGV4cG9ydHMuVmFsdWVTY29wZU5hbWUgPSBleHBvcnRzLlNjb3BlID0gZXhwb3J0cy52YXJLaW5kcyA9IGV4cG9ydHMuVXNlZFZhbHVlU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlXCIpO1xuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZTtcbiAgICB9XG59XG52YXIgVXNlZFZhbHVlU3RhdGU7XG4oZnVuY3Rpb24gKFVzZWRWYWx1ZVN0YXRlKSB7XG4gICAgVXNlZFZhbHVlU3RhdGVbVXNlZFZhbHVlU3RhdGVbXCJTdGFydGVkXCJdID0gMF0gPSBcIlN0YXJ0ZWRcIjtcbiAgICBVc2VkVmFsdWVTdGF0ZVtVc2VkVmFsdWVTdGF0ZVtcIkNvbXBsZXRlZFwiXSA9IDFdID0gXCJDb21wbGV0ZWRcIjtcbn0pKFVzZWRWYWx1ZVN0YXRlID0gZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSB8fCAoZXhwb3J0cy5Vc2VkVmFsdWVTdGF0ZSA9IHt9KSk7XG5leHBvcnRzLnZhcktpbmRzID0ge1xuICAgIGNvbnN0OiBuZXcgY29kZV8xLk5hbWUoXCJjb25zdFwiKSxcbiAgICBsZXQ6IG5ldyBjb2RlXzEuTmFtZShcImxldFwiKSxcbiAgICB2YXI6IG5ldyBjb2RlXzEuTmFtZShcInZhclwiKSxcbn07XG5jbGFzcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoeyBwcmVmaXhlcywgcGFyZW50IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IHt9O1xuICAgICAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHRvTmFtZShuYW1lT3JQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeCk7XG4gICAgfVxuICAgIG5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgY29kZV8xLk5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKTtcbiAgICB9XG4gICAgX25ld05hbWUocHJlZml4KSB7XG4gICAgICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YDtcbiAgICB9XG4gICAgX25hbWVHcm91cChwcmVmaXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLl9wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcHJlZml4ZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oYXMocHJlZml4KSkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHsgcHJlZml4LCBpbmRleDogMCB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNjb3BlID0gU2NvcGU7XG5jbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIGNvZGVfMS5OYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXgsIG5hbWVTdHIpIHtcbiAgICAgICAgc3VwZXIobmFtZVN0cik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgeyBwcm9wZXJ0eSwgaXRlbUluZGV4IH0pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlUGF0aCA9IGNvZGVfMS5fIGAuJHtuZXcgY29kZV8xLk5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYDtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gVmFsdWVTY29wZU5hbWU7XG5jb25zdCBsaW5lID0gY29kZV8xLl8gYFxcbmA7XG5jbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuICAgICAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGU7XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogY29kZV8xLm5pbCB9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY29wZTtcbiAgICB9XG4gICAgbmFtZShwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSk7XG4gICAgfVxuICAgIHZhbHVlKG5hbWVPclByZWZpeCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIik7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBjb25zdCB7IHByZWZpeCB9ID0gbmFtZTtcbiAgICAgICAgY29uc3QgdmFsdWVLZXkgPSAoX2EgPSB2YWx1ZS5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlLnJlZjtcbiAgICAgICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF07XG4gICAgICAgIGlmICh2cykge1xuICAgICAgICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpO1xuICAgICAgICAgICAgaWYgKF9uYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiBfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKTtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSk7XG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoO1xuICAgICAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWY7XG4gICAgICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHsgcHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4IH0pO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdO1xuICAgICAgICBpZiAoIXZzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKTtcbiAgICB9XG4gICAgc2NvcGVSZWZzKHNjb3BlTmFtZSwgdmFsdWVzID0gdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApO1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVfMS5fIGAke3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY29wZUNvZGUodmFsdWVzID0gdGhpcy5fdmFsdWVzLCB1c2VkVmFsdWVzLCBnZXRDb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYCk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlO1xuICAgICAgICB9LCB1c2VkVmFsdWVzLCBnZXRDb2RlKTtcbiAgICB9XG4gICAgX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIHZhbHVlQ29kZSwgdXNlZFZhbHVlcyA9IHt9LCBnZXRDb2RlKSB7XG4gICAgICAgIGxldCBjb2RlID0gY29kZV8xLm5pbDtcbiAgICAgICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdO1xuICAgICAgICAgICAgaWYgKCF2cylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSk7XG4gICAgICAgICAgICB2cy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZCk7XG4gICAgICAgICAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IGV4cG9ydHMudmFyS2luZHMudmFyIDogZXhwb3J0cy52YXJLaW5kcy5jb25zdDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGVfMS5fIGAke2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChjID0gZ2V0Q29kZSA9PT0gbnVsbCB8fCBnZXRDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDb2RlKG5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZV8xLl8gYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZVNjb3BlID0gVmFsdWVTY29wZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vciA9IGV4cG9ydHMuYW5kID0gZXhwb3J0cy5ub3QgPSBleHBvcnRzLkNvZGVHZW4gPSBleHBvcnRzLm9wZXJhdG9ycyA9IGV4cG9ydHMudmFyS2luZHMgPSBleHBvcnRzLlZhbHVlU2NvcGVOYW1lID0gZXhwb3J0cy5WYWx1ZVNjb3BlID0gZXhwb3J0cy5TY29wZSA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMucmVnZXhwQ29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZXhwb3J0cy5nZXRQcm9wZXJ0eSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJDb25jYXQgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvZGVcIik7XG5jb25zdCBzY29wZV8xID0gcmVxdWlyZShcIi4vc2NvcGVcIik7XG52YXIgY29kZV8yID0gcmVxdWlyZShcIi4vY29kZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5fOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RyQ29uY2F0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIuc3RyQ29uY2F0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmlsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlXzIubmlsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UHJvcGVydHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5nZXRQcm9wZXJ0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2V4cENvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVfMi5yZWdleHBDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZV8yLk5hbWU7IH0gfSk7XG52YXIgc2NvcGVfMiA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NvcGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlXzIuU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLlZhbHVlU2NvcGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWYWx1ZVNjb3BlTmFtZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NvcGVfMi5WYWx1ZVNjb3BlTmFtZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhcktpbmRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzY29wZV8yLnZhcktpbmRzOyB9IH0pO1xuZXhwb3J0cy5vcGVyYXRvcnMgPSB7XG4gICAgR1Q6IG5ldyBjb2RlXzEuX0NvZGUoXCI+XCIpLFxuICAgIEdURTogbmV3IGNvZGVfMS5fQ29kZShcIj49XCIpLFxuICAgIExUOiBuZXcgY29kZV8xLl9Db2RlKFwiPFwiKSxcbiAgICBMVEU6IG5ldyBjb2RlXzEuX0NvZGUoXCI8PVwiKSxcbiAgICBFUTogbmV3IGNvZGVfMS5fQ29kZShcIj09PVwiKSxcbiAgICBORVE6IG5ldyBjb2RlXzEuX0NvZGUoXCIhPT1cIiksXG4gICAgTk9UOiBuZXcgY29kZV8xLl9Db2RlKFwiIVwiKSxcbiAgICBPUjogbmV3IGNvZGVfMS5fQ29kZShcInx8XCIpLFxuICAgIEFORDogbmV3IGNvZGVfMS5fQ29kZShcIiYmXCIpLFxuICAgIEFERDogbmV3IGNvZGVfMS5fQ29kZShcIitcIiksXG59O1xuY2xhc3MgTm9kZSB7XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMoX25hbWVzLCBfY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHZhcktpbmQsIG5hbWUsIHJocykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJocyA9IHJocztcbiAgICB9XG4gICAgcmVuZGVyKHsgZXM1LCBfbiB9KSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyBzY29wZV8xLnZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZDtcbiAgICAgICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gO1xuICAgICAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLnJocylcbiAgICAgICAgICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fTtcbiAgICB9XG59XG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihsaHMsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnNpZGVFZmZlY3RzID0gc2lkZUVmZmVjdHM7XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfbjtcbiAgICB9XG4gICAgb3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBjb2RlXzEuTmFtZSA/IHt9IDogeyAuLi50aGlzLmxocy5uYW1lcyB9O1xuICAgICAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocyk7XG4gICAgfVxufVxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKGxocywgb3AsIHJocywgc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB0aGlzLm5hbWVzID0ge307XG4gICAgfVxuICAgIHJlbmRlcih7IF9uIH0pIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfbjtcbiAgICB9XG59XG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGxhYmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IHt9O1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uO1xuICAgIH1cbn1cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIoeyBfbiB9KSB7XG4gICAgICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX247XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXM7XG4gICAgfVxufVxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgcmVuZGVyKHsgX24gfSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX247XG4gICAgfVxuICAgIG9wdGltaXplTm9kZXMoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9O1xuICAgIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlcyA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG4pXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0gPSBuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykge1xuICAgICAgICBjb25zdCB7IG5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcyk7XG4gICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX247XG4gICAgfVxufVxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge1xufVxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG59XG5FbHNlLmtpbmQgPSBcImVsc2VcIjtcbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIG5vZGVzKSB7XG4gICAgICAgIHN1cGVyKG5vZGVzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cyk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5vZGVzKCkge1xuICAgICAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvbjtcbiAgICAgICAgaWYgKGNvbmQgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlczsgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICAgICAgbGV0IGUgPSB0aGlzLmVsc2U7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGlmIChjb25kID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsc2UgPSAoX2EgPSB0aGlzLmVsc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lcztcbiAgICAgICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVsc2UpXG4gICAgICAgICAgICBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cbn1cbklmLmtpbmQgPSBcImlmXCI7XG5jbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xufVxuRm9yLmtpbmQgPSBcImZvclwiO1xuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gICAgY29uc3RydWN0b3IoaXRlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uID0gaXRlcmF0aW9uO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJLaW5kLCBuYW1lLCBmcm9tLCB0bykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcktpbmQgPSB2YXJLaW5kO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZyb20sIHRvIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cyk7XG4gICAgfVxuICAgIGdldCBuYW1lcygpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSk7XG4gICAgICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pO1xuICAgIH1cbn1cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxvb3AsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9vcCA9IGxvb3A7XG4gICAgICAgIHRoaXMudmFyS2luZCA9IHZhcktpbmQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG5hbWVzKCkge1xuICAgICAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpO1xuICAgIH1cbn1cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFyZ3MsIGFzeW5jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXN5bmMgPSBhc3luYztcbiAgICB9XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5GdW5jLmtpbmQgPSBcImZ1bmNcIjtcbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5SZXR1cm4ua2luZCA9IFwicmV0dXJuXCI7XG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICAgIHJlbmRlcihvcHRzKSB7XG4gICAgICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuY2F0Y2gpXG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpO1xuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG4gICAgb3B0aW1pemVOb2RlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2EgPSB0aGlzLmNhdGNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemVOb2RlcygpO1xuICAgICAgICAoX2IgPSB0aGlzLmZpbmFsbHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpbWl6ZU5vZGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKTtcbiAgICAgICAgKF9hID0gdGhpcy5jYXRjaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIChfYiA9IHRoaXMuZmluYWxseSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXM7XG4gICAgICAgIGlmICh0aGlzLmNhdGNoKVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbGx5KVxuICAgICAgICAgICAgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcyk7XG4gICAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG59XG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZW5kZXIob3B0cykge1xuICAgICAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKTtcbiAgICB9XG59XG5DYXRjaC5raW5kID0gXCJjYXRjaFwiO1xuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gICAgcmVuZGVyKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpO1xuICAgIH1cbn1cbkZpbmFsbHkua2luZCA9IFwiZmluYWxseVwiO1xuY2xhc3MgQ29kZUdlbiB7XG4gICAgY29uc3RydWN0b3IoZXh0U2NvcGUsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fYmxvY2tTdGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0ge307XG4gICAgICAgIHRoaXMub3B0cyA9IHsgLi4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIiB9O1xuICAgICAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlO1xuICAgICAgICB0aGlzLl9zY29wZSA9IG5ldyBzY29wZV8xLlNjb3BlKHsgcGFyZW50OiBleHRTY29wZSB9KTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKTtcbiAgICB9XG4gICAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgICBuYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpO1xuICAgIH1cbiAgICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgICBzY29wZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeCk7XG4gICAgfVxuICAgIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICAgIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgIHZzLmFkZChuYW1lKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFNjb3BlVmFsdWUocHJlZml4LCBrZXlPclJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZik7XG4gICAgfVxuICAgIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgICBzY29wZVJlZnMoc2NvcGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpO1xuICAgIH1cbiAgICBzY29wZUNvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKTtcbiAgICB9XG4gICAgX2RlZih2YXJLaW5kLCBuYW1lT3JQcmVmaXgsIHJocywgY29uc3RhbnQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpO1xuICAgICAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpXG4gICAgICAgICAgICB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzO1xuICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gICAgY29uc3QobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICAgIGxldChuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYoc2NvcGVfMS52YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpO1xuICAgIH1cbiAgICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgICB2YXIobmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmKHNjb3BlXzEudmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KTtcbiAgICB9XG4gICAgLy8gYXNzaWdubWVudCBjb2RlXG4gICAgYXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKTtcbiAgICB9XG4gICAgLy8gYCs9YCBjb2RlXG4gICAgYWRkKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBleHBvcnRzLm9wZXJhdG9ycy5BREQsIHJocykpO1xuICAgIH1cbiAgICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gICAgY29kZShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBjKCk7XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IGNvZGVfMS5uaWwpXG4gICAgICAgICAgICB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gICAgb2JqZWN0KC4uLmtleVZhbHVlcykge1xuICAgICAgICBjb25zdCBjb2RlID0gW1wie1wiXTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoY29kZS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgIGNvZGUucHVzaChcIixcIik7XG4gICAgICAgICAgICBjb2RlLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5hZGRDb2RlQXJnKGNvZGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2RlLnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShjb2RlKTtcbiAgICB9XG4gICAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbkJvZHksIGVsc2VCb2R5KSB7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSk7XG4gICAgICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICAgIGVsc2VJZihjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKTtcbiAgICB9XG4gICAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICAgIGVsc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gICAgZW5kSWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpO1xuICAgIH1cbiAgICBfZm9yKG5vZGUsIGZvckJvZHkpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICBpZiAoZm9yQm9keSlcbiAgICAgICAgICAgIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICAgIGZvcihpdGVyYXRpb24sIGZvckJvZHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KTtcbiAgICB9XG4gICAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICAgIGZvclJhbmdlKG5hbWVPclByZWZpeCwgZnJvbSwgdG8sIGZvckJvZHksIHZhcktpbmQgPSB0aGlzLm9wdHMuZXM1ID8gc2NvcGVfMS52YXJLaW5kcy52YXIgOiBzY29wZV8xLnZhcktpbmRzLmxldCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSk7XG4gICAgfVxuICAgIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICAgIGZvck9mKG5hbWVPclByZWZpeCwgaXRlcmFibGUsIGZvckJvZHksIHZhcktpbmQgPSBzY29wZV8xLnZhcktpbmRzLmNvbnN0KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsIGNvZGVfMS5fIGAke2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcihuYW1lLCBjb2RlXzEuXyBgJHthcnJ9WyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgZm9yQm9keShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpO1xuICAgIH1cbiAgICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gICAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICAgIGZvckluKG5hbWVPclByZWZpeCwgb2JqLCBmb3JCb2R5LCB2YXJLaW5kID0gdGhpcy5vcHRzLmVzNSA/IHNjb3BlXzEudmFyS2luZHMudmFyIDogc2NvcGVfMS52YXJLaW5kcy5jb25zdCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgY29kZV8xLl8gYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKTtcbiAgICB9XG4gICAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgICBlbmRGb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKTtcbiAgICB9XG4gICAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgICBsYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSk7XG4gICAgfVxuICAgIC8vIGBicmVha2Agc3RhdGVtZW50XG4gICAgYnJlYWsobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpO1xuICAgIH1cbiAgICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgICByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKTtcbiAgICAgICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpO1xuICAgICAgICB0aGlzLmNvZGUodmFsdWUpO1xuICAgICAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pO1xuICAgIH1cbiAgICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgICB0cnkodHJ5Qm9keSwgY2F0Y2hDb2RlLCBmaW5hbGx5Q29kZSkge1xuICAgICAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJyk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KCk7XG4gICAgICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5jb2RlKHRyeUJvZHkpO1xuICAgICAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIik7XG4gICAgICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpO1xuICAgICAgICAgICAgY2F0Y2hDb2RlKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKTtcbiAgICAgICAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSk7XG4gICAgfVxuICAgIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gICAgdGhyb3coZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpO1xuICAgIH1cbiAgICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICAgIGJsb2NrKGJvZHksIG5vZGVDb3VudCkge1xuICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aCk7XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgICBlbmRCbG9jayhub2RlQ291bnQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKCk7XG4gICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKTtcbiAgICAgICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlbjtcbiAgICAgICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICAgIGZ1bmMobmFtZSwgYXJncyA9IGNvZGVfMS5uaWwsIGFzeW5jLCBmdW5jQm9keSkge1xuICAgICAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKTtcbiAgICAgICAgaWYgKGZ1bmNCb2R5KVxuICAgICAgICAgICAgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgIGVuZEZ1bmMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYyk7XG4gICAgfVxuICAgIG9wdGltaXplKG4gPSAxKSB7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9sZWFmTm9kZShub2RlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBfYmxvY2tOb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgX2VuZEJsb2NrTm9kZShOMSwgTjIpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlO1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApO1xuICAgIH1cbiAgICBfZWxzZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGU7XG4gICAgICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgX3Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXTtcbiAgICB9XG4gICAgZ2V0IF9jdXJyTm9kZSgpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgX2N1cnJOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9ub2RlcztcbiAgICAgICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUdlbiA9IENvZGVHZW47XG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIGZvciAoY29uc3QgbiBpbiBmcm9tKVxuICAgICAgICBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApO1xuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lcywgZnJvbSkge1xuICAgIHJldHVybiBmcm9tIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXM7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwciwgbmFtZXMsIGNvbnN0YW50cykge1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgIHJldHVybiByZXBsYWNlTmFtZShleHByKTtcbiAgICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICByZXR1cm4gbmV3IGNvZGVfMS5fQ29kZShleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zLCBjKSA9PiB7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLk5hbWUpXG4gICAgICAgICAgICBjID0gcmVwbGFjZU5hbWUoYyk7XG4gICAgICAgIGlmIChjIGluc3RhbmNlb2YgY29kZV8xLl9Db2RlKVxuICAgICAgICAgICAgaXRlbXMucHVzaCguLi5jLl9pdGVtcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LCBbXSkpO1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG4pIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl07XG4gICAgICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl07XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlKSB7XG4gICAgICAgIHJldHVybiAoZSBpbnN0YW5jZW9mIGNvZGVfMS5fQ29kZSAmJlxuICAgICAgICAgICAgZS5faXRlbXMuc29tZSgoYykgPT4gYyBpbnN0YW5jZW9mIGNvZGVfMS5OYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBuIGluIGZyb20pXG4gICAgICAgIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMCk7XG59XG5mdW5jdGlvbiBub3QoeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6IGNvZGVfMS5fIGAhJHtwYXIoeCl9YDtcbn1cbmV4cG9ydHMubm90ID0gbm90O1xuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQoZXhwb3J0cy5vcGVyYXRvcnMuQU5EKTtcbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChleHBvcnRzLm9wZXJhdG9ycy5PUik7XG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5mdW5jdGlvbiBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSk7XG59XG5leHBvcnRzLm9yID0gb3I7XG5mdW5jdGlvbiBtYXBwZW5kKG9wKSB7XG4gICAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gY29kZV8xLm5pbCA/IHkgOiB5ID09PSBjb2RlXzEubmlsID8geCA6IGNvZGVfMS5fIGAke3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YCk7XG59XG5mdW5jdGlvbiBwYXIoeCkge1xuICAgIHJldHVybiB4IGluc3RhbmNlb2YgY29kZV8xLk5hbWUgPyB4IDogY29kZV8xLl8gYCgke3h9KWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tTdHJpY3RNb2RlID0gZXhwb3J0cy5nZXRFcnJvclBhdGggPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLnVzZUZ1bmMgPSBleHBvcnRzLnNldEV2YWx1YXRlZCA9IGV4cG9ydHMuZXZhbHVhdGVkUHJvcHNUb05hbWUgPSBleHBvcnRzLm1lcmdlRXZhbHVhdGVkID0gZXhwb3J0cy5lYWNoSXRlbSA9IGV4cG9ydHMudW5lc2NhcGVKc29uUG9pbnRlciA9IGV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBleHBvcnRzLmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy51bmVzY2FwZUZyYWdtZW50ID0gZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IGV4cG9ydHMuc2NoZW1hSGFzUnVsZXNCdXRSZWYgPSBleHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gZXhwb3J0cy5jaGVja1Vua25vd25SdWxlcyA9IGV4cG9ydHMuYWx3YXlzVmFsaWRTY2hlbWEgPSBleHBvcnRzLnRvSGFzaCA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuL2NvZGVcIik7XG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmZ1bmN0aW9uIHRvSGFzaChhcnIpIHtcbiAgICBjb25zdCBoYXNoID0ge307XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgcmV0dXJuIGhhc2g7XG59XG5leHBvcnRzLnRvSGFzaCA9IHRvSGFzaDtcbmZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpO1xuICAgIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbCk7XG59XG5leHBvcnRzLmFsd2F5c1ZhbGlkU2NoZW1hID0gYWx3YXlzVmFsaWRTY2hlbWE7XG5mdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hID0gaXQuc2NoZW1hKSB7XG4gICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXJ1bGVzW2tleV0pXG4gICAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrVW5rbm93blJ1bGVzID0gY2hlY2tVbmtub3duUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIHJ1bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKHJ1bGVzW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzID0gc2NoZW1hSGFzUnVsZXM7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSlcbiAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzQnV0UmVmID0gc2NoZW1hSGFzUnVsZXNCdXRSZWY7XG5mdW5jdGlvbiBzY2hlbWFSZWZPclZhbCh7IHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCB9LCBzY2hlbWEsIGtleXdvcmQsICRkYXRhKSB7XG4gICAgaWYgKCEkZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShrZXl3b3JkKX1gO1xufVxuZXhwb3J0cy5zY2hlbWFSZWZPclZhbCA9IHNjaGVtYVJlZk9yVmFsO1xuZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5leHBvcnRzLnVuZXNjYXBlRnJhZ21lbnQgPSB1bmVzY2FwZUZyYWdtZW50O1xuZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbn1cbmV4cG9ydHMuZXNjYXBlRnJhZ21lbnQgPSBlc2NhcGVGcmFnbWVudDtcbmZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBgJHtzdHJ9YDtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSnNvblBvaW50ZXIgPSBlc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuZXhwb3J0cy51bmVzY2FwZUpzb25Qb2ludGVyID0gdW5lc2NhcGVKc29uUG9pbnRlcjtcbmZ1bmN0aW9uIGVhY2hJdGVtKHhzLCBmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiB4cylcbiAgICAgICAgICAgIGYoeCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmKHhzKTtcbiAgICB9XG59XG5leHBvcnRzLmVhY2hJdGVtID0gZWFjaEl0ZW07XG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQoeyBtZXJnZU5hbWVzLCBtZXJnZVRvTmFtZSwgbWVyZ2VWYWx1ZXMsIHJlc3VsdFRvTmFtZSwgfSkge1xuICAgIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJvbVxuICAgICAgICAgICAgOiB0byBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lXG4gICAgICAgICAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZVxuICAgICAgICAgICAgICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0b05hbWUgPT09IGNvZGVnZW5fMS5OYW1lICYmICEocmVzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlcztcbiAgICB9O1xufVxuZXhwb3J0cy5tZXJnZUV2YWx1YXRlZCA9IHtcbiAgICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICAgICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApLmNvZGUoY29kZWdlbl8xLl8gYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYCkpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke3RvfSB8fCB7fWApO1xuICAgICAgICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsgLi4uZnJvbSwgLi4udG8gfSksXG4gICAgICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gICAgfSksXG4gICAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IGdlbi5hc3NpZ24odG8sIGNvZGVnZW5fMS5fIGAke2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApKSxcbiAgICAgICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4gZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBjb2RlZ2VuXzEuXyBgJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YCkpLFxuICAgICAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgICAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICAgIH0pLFxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgcHMpIHtcbiAgICBpZiAocHMgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSk7XG4gICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgY29kZWdlbl8xLl8gYHt9YCk7XG4gICAgaWYgKHBzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcyk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5ldmFsdWF0ZWRQcm9wc1RvTmFtZSA9IGV2YWx1YXRlZFByb3BzVG9OYW1lO1xuZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKSB7XG4gICAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7cHJvcHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocCl9YCwgdHJ1ZSkpO1xufVxuZXhwb3J0cy5zZXRFdmFsdWF0ZWQgPSBzZXRFdmFsdWF0ZWQ7XG5jb25zdCBzbmlwcGV0cyA9IHt9O1xuZnVuY3Rpb24gdXNlRnVuYyhnZW4sIGYpIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgcmVmOiBmLFxuICAgICAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IGNvZGVfMS5fQ29kZShmLmNvZGUpKSxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlRnVuYyA9IHVzZUZ1bmM7XG52YXIgVHlwZTtcbihmdW5jdGlvbiAoVHlwZSkge1xuICAgIFR5cGVbVHlwZVtcIk51bVwiXSA9IDBdID0gXCJOdW1cIjtcbiAgICBUeXBlW1R5cGVbXCJTdHJcIl0gPSAxXSA9IFwiU3RyXCI7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkYXRhUHJvcFR5cGUsIGpzUHJvcGVydHlTeW50YXgpIHtcbiAgICAvLyBsZXQgcGF0aFxuICAgIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSB7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bTtcbiAgICAgICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgICAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgXCJbJ1wiICsgJHtkYXRhUHJvcH0gKyBcIiddXCJgXG4gICAgICAgICAgICA6IGlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEuXyBgXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgICAgICAgICAgICA6IGNvZGVnZW5fMS5fIGBcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYDsgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgICB9XG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyBjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoZGF0YVByb3ApLnRvU3RyaW5nKCkgOiBcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKGRhdGFQcm9wKTtcbn1cbmV4cG9ydHMuZ2V0RXJyb3JQYXRoID0gZ2V0RXJyb3JQYXRoO1xuZnVuY3Rpb24gY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG1vZGUgPSBpdC5vcHRzLnN0cmljdFNjaGVtYSkge1xuICAgIGlmICghbW9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIG1zZyA9IGBzdHJpY3QgbW9kZTogJHttc2d9YDtcbiAgICBpZiAobW9kZSA9PT0gdHJ1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgaXQuc2VsZi5sb2dnZXIud2Fybihtc2cpO1xufVxuZXhwb3J0cy5jaGVja1N0cmljdE1vZGUgPSBjaGVja1N0cmljdE1vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4vY29kZWdlblwiKTtcbmNvbnN0IG5hbWVzID0ge1xuICAgIC8vIHZhbGlkYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgZGF0YTogbmV3IGNvZGVnZW5fMS5OYW1lKFwiZGF0YVwiKSxcbiAgICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICAgIHZhbEN4dDogbmV3IGNvZGVnZW5fMS5OYW1lKFwidmFsQ3h0XCIpLFxuICAgIGluc3RhbmNlUGF0aDogbmV3IGNvZGVnZW5fMS5OYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICAgIHBhcmVudERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudERhdGFcIiksXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gICAgcm9vdERhdGE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInJvb3REYXRhXCIpLFxuICAgIGR5bmFtaWNBbmNob3JzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSxcbiAgICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gICAgdkVycm9yczogbmV3IGNvZGVnZW5fMS5OYW1lKFwidkVycm9yc1wiKSxcbiAgICBlcnJvcnM6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImVycm9yc1wiKSxcbiAgICB0aGlzOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJ0aGlzXCIpLFxuICAgIC8vIFwiZ2xvYmFsc1wiXG4gICAgc2VsZjogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2VsZlwiKSxcbiAgICBzY29wZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwic2NvcGVcIiksXG4gICAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAgICBqc29uOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJqc29uXCIpLFxuICAgIGpzb25Qb3M6IG5ldyBjb2RlZ2VuXzEuTmFtZShcImpzb25Qb3NcIiksXG4gICAganNvbkxlbjogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvbkxlblwiKSxcbiAgICBqc29uUGFydDogbmV3IGNvZGVnZW5fMS5OYW1lKFwianNvblBhcnRcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmFtZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5kRXJyb3JzID0gZXhwb3J0cy5yZXNldEVycm9yc0NvdW50ID0gZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gZXhwb3J0cy5yZXBvcnRFcnJvciA9IGV4cG9ydHMua2V5d29yZCREYXRhRXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVzXCIpO1xuZXhwb3J0cy5rZXl3b3JkRXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn07XG5leHBvcnRzLmtleXdvcmQkRGF0YUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYVR5cGUgfSkgPT4gc2NoZW1hVHlwZVxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICAgIDogY29kZWdlbl8xLnN0ciBgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufTtcbmZ1bmN0aW9uIHJlcG9ydEVycm9yKGN4dCwgZXJyb3IgPSBleHBvcnRzLmtleXdvcmRFcnJvciwgZXJyb3JQYXRocywgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGlmIChvdmVycmlkZUFsbEVycm9ycyAhPT0gbnVsbCAmJiBvdmVycmlkZUFsbEVycm9ycyAhPT0gdm9pZCAwID8gb3ZlcnJpZGVBbGxFcnJvcnMgOiAoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybkVycm9ycyhpdCwgY29kZWdlbl8xLl8gYFske2Vyck9ian1dYCk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFcnJvciA9IHJlcG9ydEVycm9yO1xuZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihjeHQsIGVycm9yID0gZXhwb3J0cy5rZXl3b3JkRXJyb3IsIGVycm9yUGF0aHMpIHtcbiAgICBjb25zdCB7IGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9ycyB9ID0gaXQ7XG4gICAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpO1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKTtcbiAgICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuRXJyb3JzKGl0LCBuYW1lc18xLmRlZmF1bHQudkVycm9ycyk7XG4gICAgfVxufVxuZXhwb3J0cy5yZXBvcnRFeHRyYUVycm9yID0gcmVwb3J0RXh0cmFFcnJvcjtcbmZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuLCBlcnJzQ291bnQpIHtcbiAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIGVycnNDb3VudCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+IGdlbi5pZihlcnJzQ291bnQsICgpID0+IGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpKSk7XG59XG5leHBvcnRzLnJlc2V0RXJyb3JzQ291bnQgPSByZXNldEVycm9yc0NvdW50O1xuZnVuY3Rpb24gZXh0ZW5kRXJyb3JzKHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWFWYWx1ZSwgZGF0YSwgZXJyc0NvdW50LCBpdCwgfSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpO1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzLCAoaSkgPT4ge1xuICAgICAgICBnZW4uY29uc3QoZXJyLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc31bJHtpfV1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uaW5zdGFuY2VQYXRoYCwgY29kZWdlbl8xLnN0ckNvbmNhdChuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKSk7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFQYXRoYCwgY29kZWdlbl8xLnN0ciBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCk7XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSk7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2Vycn0uZGF0YWAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmV4dGVuZEVycm9ycyA9IGV4dGVuZEVycm9ycztcbmZ1bmN0aW9uIGFkZEVycm9yKGdlbiwgZXJyT2JqKSB7XG4gICAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iaik7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52RXJyb3JzfSA9PT0gbnVsbGAsICgpID0+IGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIGNvZGVnZW5fMS5fIGBbJHtlcnJ9XWApLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30ucHVzaCgke2Vycn0pYCk7XG4gICAgZ2VuLmNvZGUoY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc30rK2ApO1xufVxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0LCBlcnJzKSB7XG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52IH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgICAgICBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvcn0oJHtlcnJzfSlgKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKTtcbiAgICAgICAgZ2VuLnJldHVybihmYWxzZSk7XG4gICAgfVxufVxuY29uc3QgRSA9IHtcbiAgICBrZXl3b3JkOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJrZXl3b3JkXCIpLFxuICAgIHNjaGVtYVBhdGg6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVBhdGhcIiksXG4gICAgcGFyYW1zOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwYXJhbXNcIiksXG4gICAgcHJvcGVydHlOYW1lOiBuZXcgY29kZWdlbl8xLk5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gICAgbWVzc2FnZTogbmV3IGNvZGVnZW5fMS5OYW1lKFwibWVzc2FnZVwiKSxcbiAgICBzY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInNjaGVtYVwiKSxcbiAgICBwYXJlbnRTY2hlbWE6IG5ldyBjb2RlZ2VuXzEuTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn07XG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocykge1xuICAgIGNvbnN0IHsgY3JlYXRlRXJyb3JzIH0gPSBjeHQuaXQ7XG4gICAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBge31gO1xuICAgIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKTtcbn1cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMgPSB7fSkge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IGtleVZhbHVlcyA9IFtcbiAgICAgICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgICAgICBlcnJvclNjaGVtYVBhdGgoY3h0LCBlcnJvclBhdGhzKSxcbiAgICBdO1xuICAgIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpO1xuICAgIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcyk7XG59XG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7IGVycm9yUGF0aCB9LCB7IGluc3RhbmNlUGF0aCB9KSB7XG4gICAgY29uc3QgaW5zdFBhdGggPSBpbnN0YW5jZVBhdGhcbiAgICAgICAgPyBjb2RlZ2VuXzEuc3RyIGAke2Vycm9yUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCB1dGlsXzEuVHlwZS5TdHIpfWBcbiAgICAgICAgOiBlcnJvclBhdGg7XG4gICAgcmV0dXJuIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV07XG59XG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoeyBrZXl3b3JkLCBpdDogeyBlcnJTY2hlbWFQYXRoIH0gfSwgeyBzY2hlbWFQYXRoLCBwYXJlbnRTY2hlbWEgfSkge1xuICAgIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6IGNvZGVnZW5fMS5zdHIgYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWA7XG4gICAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICAgICAgc2NoUGF0aCA9IGNvZGVnZW5fMS5zdHIgYCR7c2NoUGF0aH0ke3V0aWxfMS5nZXRFcnJvclBhdGgoc2NoZW1hUGF0aCwgdXRpbF8xLlR5cGUuU3RyKX1gO1xuICAgIH1cbiAgICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF07XG59XG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoY3h0LCB7IHBhcmFtcywgbWVzc2FnZSB9LCBrZXlWYWx1ZXMpIHtcbiAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgb3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGggfSA9IGl0O1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLmtleXdvcmQsIGtleXdvcmRdLCBbRS5wYXJhbXMsIHR5cGVvZiBwYXJhbXMgPT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGN4dCkgOiBwYXJhbXMgfHwgY29kZWdlbl8xLl8gYHt9YF0pO1xuICAgIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAgICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgICAgICBrZXlWYWx1ZXMucHVzaChbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSwgW0UucGFyZW50U2NoZW1hLCBjb2RlZ2VuXzEuXyBgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLCBbbmFtZXNfMS5kZWZhdWx0LmRhdGEsIGRhdGFdKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSlcbiAgICAgICAga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9vbE9yRW1wdHlTY2hlbWEgPSBleHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uL25hbWVzXCIpO1xuY29uc3QgYm9vbEVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn07XG5mdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgICAgICBnZW4ucmV0dXJuKG5hbWVzXzEuZGVmYXVsdC5kYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKTtcbiAgICAgICAgZ2VuLnJldHVybih0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLnRvcEJvb2xPckVtcHR5U2NoZW1hID0gdG9wQm9vbE9yRW1wdHlTY2hlbWE7XG5mdW5jdGlvbiBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hIH0gPSBpdDtcbiAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBnZW4udmFyKHZhbGlkLCBmYWxzZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgfVxufVxuZXhwb3J0cy5ib29sT3JFbXB0eVNjaGVtYSA9IGJvb2xPckVtcHR5U2NoZW1hO1xuZnVuY3Rpb24gZmFsc2VTY2hlbWFFcnJvcihpdCwgb3ZlcnJpZGVBbGxFcnJvcnMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSB9ID0gaXQ7XG4gICAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgICBjb25zdCBjeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJmYWxzZSBzY2hlbWFcIixcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2NoZW1hOiBmYWxzZSxcbiAgICAgICAgc2NoZW1hQ29kZTogZmFsc2UsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbiAgICBlcnJvcnNfMS5yZXBvcnRFcnJvcihjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sU2NoZW1hLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRSdWxlcyA9IGV4cG9ydHMuaXNKU09OVHlwZSA9IHZvaWQgMDtcbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXTtcbmNvbnN0IGpzb25UeXBlcyA9IG5ldyBTZXQoX2pzb25UeXBlcyk7XG5mdW5jdGlvbiBpc0pTT05UeXBlKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpO1xufVxuZXhwb3J0cy5pc0pTT05UeXBlID0gaXNKU09OVHlwZTtcbmZ1bmN0aW9uIGdldFJ1bGVzKCkge1xuICAgIGNvbnN0IGdyb3VwcyA9IHtcbiAgICAgICAgbnVtYmVyOiB7IHR5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXSB9LFxuICAgICAgICBzdHJpbmc6IHsgdHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFycmF5OiB7IHR5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdIH0sXG4gICAgICAgIG9iamVjdDogeyB0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW10gfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVzOiB7IC4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZSB9LFxuICAgICAgICBydWxlczogW3sgcnVsZXM6IFtdIH0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgICAgIHBvc3Q6IHsgcnVsZXM6IFtdIH0sXG4gICAgICAgIGFsbDoge30sXG4gICAgICAgIGtleXdvcmRzOiB7fSxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRSdWxlcyA9IGdldFJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBleHBvcnRzLnNob3VsZFVzZUdyb3VwID0gZXhwb3J0cy5zY2hlbWFIYXNSdWxlc0ZvclR5cGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoeyBzY2hlbWEsIHNlbGYgfSwgdHlwZSkge1xuICAgIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXTtcbiAgICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCk7XG59XG5leHBvcnRzLnNjaGVtYUhhc1J1bGVzRm9yVHlwZSA9IHNjaGVtYUhhc1J1bGVzRm9yVHlwZTtcbmZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKTtcbn1cbmV4cG9ydHMuc2hvdWxkVXNlR3JvdXAgPSBzaG91bGRVc2VHcm91cDtcbmZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoKF9hID0gcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpKSk7XG59XG5leHBvcnRzLnNob3VsZFVzZVJ1bGUgPSBzaG91bGRVc2VSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbGljYWJpbGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZSA9IGV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZXhwb3J0cy5nZXRTY2hlbWFUeXBlcyA9IGV4cG9ydHMuRGF0YVR5cGUgPSB2b2lkIDA7XG5jb25zdCBydWxlc18xID0gcmVxdWlyZShcIi4uL3J1bGVzXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgRGF0YVR5cGU7XG4oZnVuY3Rpb24gKERhdGFUeXBlKSB7XG4gICAgRGF0YVR5cGVbRGF0YVR5cGVbXCJDb3JyZWN0XCJdID0gMF0gPSBcIkNvcnJlY3RcIjtcbiAgICBEYXRhVHlwZVtEYXRhVHlwZVtcIldyb25nXCJdID0gMV0gPSBcIldyb25nXCI7XG59KShEYXRhVHlwZSA9IGV4cG9ydHMuRGF0YVR5cGUgfHwgKGV4cG9ydHMuRGF0YVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hKSB7XG4gICAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpO1xuICAgIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgaWYgKGhhc051bGwpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBudWxsIGNvbnRyYWRpY3RzIG51bGxhYmxlOiBmYWxzZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghdHlwZXMubGVuZ3RoICYmIHNjaGVtYS5udWxsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibnVsbGFibGVcIiBjYW5ub3QgYmUgdXNlZCB3aXRob3V0IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHR5cGVzLnB1c2goXCJudWxsXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZXM7XG59XG5leHBvcnRzLmdldFNjaGVtYVR5cGVzID0gZ2V0U2NoZW1hVHlwZXM7XG5mdW5jdGlvbiBnZXRKU09OVHlwZXModHMpIHtcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXTtcbiAgICBpZiAodHlwZXMuZXZlcnkocnVsZXNfMS5pc0pTT05UeXBlKSlcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKTtcbn1cbmV4cG9ydHMuZ2V0SlNPTlR5cGVzID0gZ2V0SlNPTlR5cGVzO1xuZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKTtcbiAgICBjb25zdCBjaGVja1R5cGVzID0gdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgYXBwbGljYWJpbGl0eV8xLnNjaGVtYUhhc1J1bGVzRm9yVHlwZShpdCwgdHlwZXNbMF0pKTtcbiAgICBpZiAoY2hlY2tUeXBlcykge1xuICAgICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrVHlwZXM7XG59XG5leHBvcnRzLmNvZXJjZUFuZENoZWNrRGF0YVR5cGUgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlO1xuY29uc3QgQ09FUkNJQkxFID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pO1xuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlcywgY29lcmNlVHlwZXMpIHtcbiAgICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICAgICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICAgICAgOiBbXTtcbn1cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbykge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBvcHRzIH0gPSBpdDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX1gKTtcbiAgICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PiBnZW5cbiAgICAgICAgICAgIC5hc3NpZ24oZGF0YSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bMF1gKVxuICAgICAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSkpO1xuICAgIH1cbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApO1xuICAgIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgICAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgICAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW4uZWxzZSgpO1xuICAgIHJlcG9ydFR5cGVFcnJvcihpdCk7XG4gICAgZ2VuLmVuZElmKCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZCk7XG4gICAgICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0KSB7XG4gICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYClcbiAgICAgICAgICAgICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBjb2RlZ2VuXzEuXyBgKyR7ZGF0YX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAuZWxzZUlmKGNvZGVnZW5fMS5fIGAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgY29kZWdlbl8xLl8gYCske2RhdGF9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5lbHNlSWYoY29kZWdlbl8xLl8gYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYCk7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgICAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGNvZGVnZW5fMS5fIGBbJHtkYXRhfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoeyBnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSB9LCBleHByKSB7XG4gICAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKSk7XG59XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdCkge1xuICAgIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuRVEgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLk5FUTtcbiAgICBsZXQgY29uZDtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJHtFUX0gbnVsbGA7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgY29uZCA9IGNvZGVnZW5fMS5fIGBBcnJheS5pc0FycmF5KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgICAgIGNvbmQgPSBudW1Db25kKGNvZGVnZW5fMS5fIGAhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBjb25kID0gbnVtQ29uZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogY29kZWdlbl8xLm5vdChjb25kKTtcbiAgICBmdW5jdGlvbiBudW1Db25kKF9jb25kID0gY29kZWdlbl8xLm5pbCkge1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLmFuZChjb2RlZ2VuXzEuXyBgdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gY29kZWdlbl8xLl8gYGlzRmluaXRlKCR7ZGF0YX0pYCA6IGNvZGVnZW5fMS5uaWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tEYXRhVHlwZSA9IGNoZWNrRGF0YVR5cGU7XG5mdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpIHtcbiAgICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpO1xuICAgIH1cbiAgICBsZXQgY29uZDtcbiAgICBjb25zdCB0eXBlcyA9IHV0aWxfMS50b0hhc2goZGF0YVR5cGVzKTtcbiAgICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5vdE9iaiA9IGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYDtcbiAgICAgICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiBjb2RlZ2VuXzEuXyBgISR7ZGF0YX0gfHwgJHtub3RPYmp9YDtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm51bGw7XG4gICAgICAgIGRlbGV0ZSB0eXBlcy5hcnJheTtcbiAgICAgICAgZGVsZXRlIHR5cGVzLm9iamVjdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEubmlsO1xuICAgIH1cbiAgICBpZiAodHlwZXMubnVtYmVyKVxuICAgICAgICBkZWxldGUgdHlwZXMuaW50ZWdlcjtcbiAgICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpXG4gICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuYW5kKGNvbmQsIGNoZWNrRGF0YVR5cGUodCwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpO1xuICAgIHJldHVybiBjb25kO1xufVxuZXhwb3J0cy5jaGVja0RhdGFUeXBlcyA9IGNoZWNrRGF0YVR5cGVzO1xuY29uc3QgdHlwZUVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYSB9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hLCBzY2hlbWFWYWx1ZSB9KSA9PiB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyBjb2RlZ2VuXzEuXyBge3R5cGU6ICR7c2NoZW1hfX1gIDogY29kZWdlbl8xLl8gYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufTtcbmZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdCkge1xuICAgIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpO1xuICAgIGVycm9yc18xLnJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKTtcbn1cbmV4cG9ydHMucmVwb3J0VHlwZUVycm9yID0gcmVwb3J0VHlwZUVycm9yO1xuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWEgfSA9IGl0O1xuICAgIGNvbnN0IHNjaGVtYUNvZGUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbixcbiAgICAgICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgICAgIHNjaGVtYUNvZGUsXG4gICAgICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgICAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgaXQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGFUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdCwgdHkpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGl0ZW1zIH0gPSBpdC5zY2hlbWE7XG4gICAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGkpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NpZ25EZWZhdWx0cyA9IGFzc2lnbkRlZmF1bHRzO1xuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgeyBnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkRGF0YSA9IGNvZGVnZW5fMS5fIGAke2RhdGF9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkocHJvcCl9YDtcbiAgICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNvbmRpdGlvbiA9IGNvZGVnZW5fMS5fIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGA7XG4gICAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgICAgICBjb25kaXRpb24gPSBjb2RlZ2VuXzEuXyBgJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgO1xuICAgIH1cbiAgICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gICAgZ2VuLmlmKGNvbmRpdGlvbiwgY29kZWdlbl8xLl8gYCR7Y2hpbGREYXRhfSA9ICR7Y29kZWdlbl8xLnN0cmluZ2lmeShkZWZhdWx0VmFsdWUpfWApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlVW5pb24gPSBleHBvcnRzLnZhbGlkYXRlQXJyYXkgPSBleHBvcnRzLnVzZVBhdHRlcm4gPSBleHBvcnRzLmNhbGxWYWxpZGF0ZUNvZGUgPSBleHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLmFsbFNjaGVtYVByb3BlcnRpZXMgPSBleHBvcnRzLm5vUHJvcGVydHlJbkRhdGEgPSBleHBvcnRzLnByb3BlcnR5SW5EYXRhID0gZXhwb3J0cy5pc093blByb3BlcnR5ID0gZXhwb3J0cy5oYXNQcm9wRnVuYyA9IGV4cG9ydHMucmVwb3J0TWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrTWlzc2luZ1Byb3AgPSBleHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi4vY29tcGlsZS9uYW1lc1wiKTtcbmZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKSB7XG4gICAgY29uc3QgeyBnZW4sIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IGNvZGVnZW5fMS5fIGAke3Byb3B9YCB9LCB0cnVlKTtcbiAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AgPSBjaGVja1JlcG9ydE1pc3NpbmdQcm9wO1xuZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcCh7IGdlbiwgZGF0YSwgaXQ6IHsgb3B0cyB9IH0sIHByb3BlcnRpZXMsIG1pc3NpbmcpIHtcbiAgICByZXR1cm4gY29kZWdlbl8xLm9yKC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PiBjb2RlZ2VuXzEuYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBjb2RlZ2VuXzEuXyBgJHttaXNzaW5nfSA9ICR7cHJvcH1gKSkpO1xufVxuZXhwb3J0cy5jaGVja01pc3NpbmdQcm9wID0gY2hlY2tNaXNzaW5nUHJvcDtcbmZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZykge1xuICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IG1pc3NpbmcgfSwgdHJ1ZSk7XG4gICAgY3h0LmVycm9yKCk7XG59XG5leHBvcnRzLnJlcG9ydE1pc3NpbmdQcm9wID0gcmVwb3J0TWlzc2luZ1Byb3A7XG5mdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW4pIHtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFzUHJvcEZ1bmMgPSBoYXNQcm9wRnVuYztcbmZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWA7XG59XG5leHBvcnRzLmlzT3duUHJvcGVydHkgPSBpc093blByb3BlcnR5O1xuZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wZXJ0eSwgb3duUHJvcGVydGllcykge1xuICAgIGNvbnN0IGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGA7XG4gICAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmQ7XG59XG5leHBvcnRzLnByb3BlcnR5SW5EYXRhID0gcHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcGVydHksIG93blByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBjb25kID0gY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgO1xuICAgIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gY29kZWdlbl8xLm9yKGNvbmQsIGNvZGVnZW5fMS5ub3QoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZDtcbn1cbmV4cG9ydHMubm9Qcm9wZXJ0eUluRGF0YSA9IG5vUHJvcGVydHlJbkRhdGE7XG5mdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkge1xuICAgIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXTtcbn1cbmV4cG9ydHMuYWxsU2NoZW1hUHJvcGVydGllcyA9IGFsbFNjaGVtYVByb3BlcnRpZXM7XG5mdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0LCBzY2hlbWFNYXApIHtcbiAgICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hTWFwW3BdKSk7XG59XG5leHBvcnRzLnNjaGVtYVByb3BlcnRpZXMgPSBzY2hlbWFQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZSh7IHNjaGVtYUNvZGUsIGRhdGEsIGl0OiB7IGdlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGggfSwgaXQgfSwgZnVuYywgY29udGV4dCwgcGFzc1NjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YTtcbiAgICBjb25zdCB2YWxDeHQgPSBbXG4gICAgICAgIFtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuc3RyQ29uY2F0KG5hbWVzXzEuZGVmYXVsdC5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgICAgICBbbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICAgICAgW25hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhXSxcbiAgICBdO1xuICAgIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpXG4gICAgICAgIHZhbEN4dC5wdXNoKFtuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIG5hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc10pO1xuICAgIGNvbnN0IGFyZ3MgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YDtcbiAgICByZXR1cm4gY29udGV4dCAhPT0gY29kZWdlbl8xLm5pbCA/IGNvZGVnZW5fMS5fIGAke2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogY29kZWdlbl8xLl8gYCR7ZnVuY30oJHthcmdzfSlgO1xufVxuZXhwb3J0cy5jYWxsVmFsaWRhdGVDb2RlID0gY2FsbFZhbGlkYXRlQ29kZTtcbmZ1bmN0aW9uIHVzZVBhdHRlcm4oeyBnZW4sIGl0OiB7IG9wdHMgfSB9LCBwYXR0ZXJuKSB7XG4gICAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICAgICAga2V5OiBwYXR0ZXJuLFxuICAgICAgICByZWY6IG5ldyBSZWdFeHAocGF0dGVybiwgdSksXG4gICAgICAgIGNvZGU6IGNvZGVnZW5fMS5fIGBuZXcgUmVnRXhwKCR7cGF0dGVybn0sICR7dX0pYCxcbiAgICB9KTtcbn1cbmV4cG9ydHMudXNlUGF0dGVybiA9IHVzZVBhdHRlcm47XG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dCkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSk7XG4gICAgICAgIHJldHVybiB2YWxpZEFycjtcbiAgICB9XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7XG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQpIHtcbiAgICAgICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksIG5vdFZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUFycmF5ID0gdmFsaWRhdGVBcnJheTtcbmZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaCkgPT4gdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKTtcbiAgICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSk7XG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKTtcbiAgICBnZW4uYmxvY2soKCkgPT4gc2NoZW1hLmZvckVhY2goKF9zY2gsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sIHNjaFZhbGlkKTtcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZWdlbl8xLl8gYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YCk7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpO1xuICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgICBpZiAoIW1lcmdlZClcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KHZhbGlkKSk7XG4gICAgfSkpO1xuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVVuaW9uID0gdmFsaWRhdGVVbmlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gZXhwb3J0cy52YWxpZFNjaGVtYVR5cGUgPSBleHBvcnRzLmZ1bmNLZXl3b3JkQ29kZSA9IGV4cG9ydHMubWFjcm9LZXl3b3JkQ29kZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpIHtcbiAgICBjb25zdCB7IGdlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpO1xuICAgIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSk7XG4gICAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKTtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LCB2YWxpZCk7XG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSk7XG59XG5leHBvcnRzLm1hY3JvS2V5d29yZENvZGUgPSBtYWNyb0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZ2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZik7XG4gICAgY29uc3QgdmFsaWRhdGUgPSAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGU7XG4gICAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpO1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpO1xuICAgIGN4dC5vaygoX2EgPSBkZWYudmFsaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbGlkKTtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKSB7XG4gICAgICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYXNzaWduVmFsaWQoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKTtcbiAgICAgICAgICAgIGlmIChkZWYubW9kaWZ5aW5nKVxuICAgICAgICAgICAgICAgIG1vZGlmeURhdGEoY3h0KTtcbiAgICAgICAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpIHtcbiAgICAgICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbCk7XG4gICAgICAgIGdlbi50cnkoKCkgPT4gYXNzaWduVmFsaWQoY29kZWdlbl8xLl8gYGF3YWl0IGApLCAoZSkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKGNvZGVnZW5fMS5fIGAke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3J9YCwgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgY29kZWdlbl8xLl8gYCR7ZX0uZXJyb3JzYCksICgpID0+IGdlbi50aHJvdyhlKSkpO1xuICAgICAgICByZXR1cm4gcnVsZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJzID0gY29kZWdlbl8xLl8gYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2A7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKTtcbiAgICAgICAgYXNzaWduVmFsaWQoY29kZWdlbl8xLm5pbCk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZUVycnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdCA9IGRlZi5hc3luYyA/IGNvZGVnZW5fMS5fIGBhd2FpdCBgIDogY29kZWdlbl8xLm5pbCkge1xuICAgICAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IG5hbWVzXzEuZGVmYXVsdC50aGlzIDogbmFtZXNfMS5kZWZhdWx0LnNlbGY7XG4gICAgICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSk7XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGNvZGVnZW5fMS5fIGAke19hd2FpdH0ke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsIGRlZi5tb2RpZnlpbmcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9ycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEubm90KChfYSA9IGRlZi52YWxpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmFsaWQpLCBlcnJvcnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZnVuY0tleXdvcmRDb2RlID0gZnVuY0tleXdvcmRDb2RlO1xuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCBjb2RlZ2VuXzEuXyBgJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpO1xufVxuZnVuY3Rpb24gYWRkRXJycyhjeHQsIGVycnMpIHtcbiAgICBjb25zdCB7IGdlbiB9ID0gY3h0O1xuICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgQXJyYXkuaXNBcnJheSgke2VycnN9KWAsICgpID0+IHtcbiAgICAgICAgZ2VuXG4gICAgICAgICAgICAuYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgICAgIC5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgICAgICBlcnJvcnNfMS5leHRlbmRFcnJvcnMoY3h0KTtcbiAgICB9LCAoKSA9PiBjeHQuZXJyb3IoKSk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7IHNjaGVtYUVudiB9LCBkZWYpIHtcbiAgICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpO1xufVxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYCk7XG4gICAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwia2V5d29yZFwiLCB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHsgcmVmOiByZXN1bHQgfSA6IHsgcmVmOiByZXN1bHQsIGNvZGU6IGNvZGVnZW5fMS5zdHJpbmdpZnkocmVzdWx0KSB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShzY2hlbWEsIHNjaGVtYVR5cGUsIGFsbG93VW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICAvLyBUT0RPIGFkZCB0ZXN0c1xuICAgIHJldHVybiAoIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+IHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIikpKTtcbn1cbmV4cG9ydHMudmFsaWRTY2hlbWFUeXBlID0gdmFsaWRTY2hlbWFUeXBlO1xuZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoeyBzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGggfSwgZGVmLCBrZXl3b3JkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKTtcbiAgICB9XG4gICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlS2V5d29yZFVzYWdlID0gdmFsaWRhdGVLZXl3b3JkVXNhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXl3b3JkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFNb2RlID0gZXhwb3J0cy5leHRlbmRTdWJzY2hlbWFEYXRhID0gZXhwb3J0cy5nZXRTdWJzY2hlbWEgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKGl0LCB7IGtleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmIH0pIHtcbiAgICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5fIGAke2l0LnNjaGVtYVBhdGh9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoa2V5d29yZCl9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7dXRpbF8xLmVzY2FwZUZyYWdtZW50KHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgICAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKTtcbn1cbmV4cG9ydHMuZ2V0U3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hO1xuZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIGl0LCB7IGRhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWUgfSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBnZW4gfSA9IGl0O1xuICAgIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHsgZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgY29kZWdlbl8xLl8gYCR7aXQuZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eShkYXRhUHJvcCl9YCwgdHJ1ZSk7XG4gICAgICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpO1xuICAgICAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gY29kZWdlbl8xLnN0ciBgJHtlcnJvclBhdGh9JHt1dGlsXzEuZ2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YDtcbiAgICAgICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9IGNvZGVnZW5fMS5fIGAke2RhdGFQcm9wfWA7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV07XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSk7IC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICAgICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG4gICAgICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gICAgfVxuICAgIGlmIChkYXRhVHlwZXMpXG4gICAgICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXM7XG4gICAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGEpIHtcbiAgICAgICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxO1xuICAgICAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW107XG4gICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdO1xuICAgIH1cbn1cbmV4cG9ydHMuZXh0ZW5kU3Vic2NoZW1hRGF0YSA9IGV4dGVuZFN1YnNjaGVtYURhdGE7XG5mdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgeyBqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnMgfSkge1xuICAgIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnM7XG4gICAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzO1xuICAgIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvcjsgLy8gbm90IGluaGVyaXRlZFxuICAgIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhOyAvLyBub3QgaW5oZXJpdGVkXG59XG5leHBvcnRzLmV4dGVuZFN1YnNjaGVtYU1vZGUgPSBleHRlbmRTdWJzY2hlbWFNb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NoZW1hLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgVVJJLmpzIHY0LjQuMSAoYykgMjAxMSBHYXJ5IENvdXJ0LiBMaWNlbnNlOiBodHRwOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvdXJpLWpzICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuVVJJID0gZ2xvYmFsLlVSSSB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoc2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHNbMF0gPSBzZXRzWzBdLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgdmFyIHhsID0gc2V0cy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciB4ID0gMTsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgIHNldHNbeF0gPSBzZXRzW3hdLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRzW3hsXSA9IHNldHNbeGxdLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4gc2V0cy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdWJleHAoc3RyKSB7XG4gICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbn1cbmZ1bmN0aW9uIHR5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8gPT09IHVuZGVmaW5lZCA/IFwidW5kZWZpbmVkXCIgOiBvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbn1cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBvYmogPSB0YXJnZXQ7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSSkge1xuICAgIHZhciBBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuICAgICAgICBDUiQgPSBcIltcXFxceDBEXVwiLFxuICAgICAgICBESUdJVCQkID0gXCJbMC05XVwiLFxuICAgICAgICBEUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG4gICAgICAgIEhFWERJRyQkID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSxcbiAgICAgICAgLy9jYXNlLWluc2Vuc2l0aXZlXG4gICAgTEYkJCA9IFwiW1xcXFx4MEFdXCIsXG4gICAgICAgIFNQJCQgPSBcIltcXFxceDIwXVwiLFxuICAgICAgICBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSksXG4gICAgICAgIC8vZXhwYW5kZWRcbiAgICBHRU5fREVMSU1TJCQgPSBcIltcXFxcOlxcXFwvXFxcXD9cXFxcI1xcXFxbXFxcXF1cXFxcQF1cIixcbiAgICAgICAgU1VCX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwmXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcPV1cIixcbiAgICAgICAgUkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcbiAgICAgICAgVUNTQ0hBUiQkID0gaXNJUkkgPyBcIltcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsXG4gICAgICAgIC8vc3Vic2V0XG4gICAgVU5SRVNFUlZFRCQkID0gbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXC1cXFxcLlxcXFxfXFxcXH5dXCIsIFVDU0NIQVIkJCksXG4gICAgICAgIFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG4gICAgICAgIFVTRVJJTkZPJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpKSArIFwiKlwiKSxcbiAgICAgICAgREVDX09DVEVUJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIlsxLTldXCIgKyBESUdJVCQkKSArIFwifFwiICsgRElHSVQkJCksXG4gICAgICAgIERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksXG4gICAgICAgIC8vcmVsYXhlZCBwYXJzaW5nIHJ1bGVzXG4gICAgSVBWNEFERFJFU1MkID0gc3ViZXhwKERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCArIFwiXFxcXC5cIiArIERFQ19PQ1RFVF9SRUxBWEVEJCksXG4gICAgICAgIEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuICAgICAgICBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLFxuICAgICAgICBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgIElQVjZBRERSRVNTMyQgPSBzdWJleHAoc3ViZXhwKEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7NH1cIiArIExTMzIkKSxcbiAgICAgICAgLy9bICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzQkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDF9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezN9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzUkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDJ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezJ9XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksXG4gICAgICAgIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIExTMzIkKSxcbiAgICAgICAgLy9bICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLFxuICAgICAgICAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgSVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIpLFxuICAgICAgICAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuICAgICAgICBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCkgKyBcIitcIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQgKyBcInsyfSlcIikgKyBaT05FSUQkKSxcbiAgICAgICAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcbiAgICBJUFZGVVRVUkUkID0gc3ViZXhwKFwiW3ZWXVwiICsgSEVYRElHJCQgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSArIFwiK1wiKSxcbiAgICAgICAgSVBfTElURVJBTCQgPSBzdWJleHAoXCJcXFxcW1wiICsgc3ViZXhwKElQVjZBRERSWl9SRUxBWEVEJCArIFwifFwiICsgSVBWNkFERFJFU1MkICsgXCJ8XCIgKyBJUFZGVVRVUkUkKSArIFwiXFxcXF1cIiksXG4gICAgICAgIC8vUkZDIDY4NzRcbiAgICBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpKSArIFwiKlwiKSxcbiAgICAgICAgSE9TVCQgPSBzdWJleHAoSVBfTElURVJBTCQgKyBcInxcIiArIElQVjRBRERSRVNTJCArIFwiKD8hXCIgKyBSRUdfTkFNRSQgKyBcIilcIiArIFwifFwiICsgUkVHX05BTUUkKSxcbiAgICAgICAgUE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcbiAgICAgICAgQVVUSE9SSVRZJCA9IHN1YmV4cChzdWJleHAoVVNFUklORk8kICsgXCJAXCIpICsgXCI/XCIgKyBIT1NUJCArIHN1YmV4cChcIlxcXFw6XCIgKyBQT1JUJCkgKyBcIj9cIiksXG4gICAgICAgIFBDSEFSJCA9IHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXVwiKSksXG4gICAgICAgIFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcbiAgICAgICAgU0VHTUVOVF9OWiQgPSBzdWJleHAoUENIQVIkICsgXCIrXCIpLFxuICAgICAgICBTRUdNRU5UX05aX05DJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSxcbiAgICAgICAgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuICAgICAgICBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSxcbiAgICAgICAgLy9zaW1wbGlmaWVkXG4gICAgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsXG4gICAgICAgIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcbiAgICAgICAgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksXG4gICAgICAgIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcbiAgICAgICAgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSxcbiAgICAgICAgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLFxuICAgICAgICBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuICAgICAgICBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksXG4gICAgICAgIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcbiAgICAgICAgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLFxuICAgICAgICBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG4gICAgICAgIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTk9UX1NDSEVNRTogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG4gICAgICAgIE5PVF9VU0VSSU5GTzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9QQVRIX05PU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9GUkFHTUVOVDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcbiAgICAgICAgRVNDQVBFOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuICAgICAgICBPVEhFUl9DSEFSUzogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcbiAgICAgICAgUENUX0VOQ09ERUQ6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuICAgIH07XG59XG52YXIgVVJJX1BST1RPQ09MID0gYnVpbGRFeHBzKGZhbHNlKTtcblxudmFyIElSSV9QUk9UT0NPTCA9IGJ1aWxkRXhwcyh0cnVlKTtcblxudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICB9XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0b0NvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnIpO1xuICB9XG59O1xuXG4vKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cbi8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbnZhciBkZWxpbWl0ZXIgPSAnLSc7IC8vICdcXHgyRCdcblxuLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbnZhciByZWdleFB1bnljb2RlID0gL154bi0tLztcbnZhciByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7IC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuLyoqIEVycm9yIG1lc3NhZ2VzICovXG52YXIgZXJyb3JzID0ge1xuXHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcblxuLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xudmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAqIGl0ZW0uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0dmFyIHJlc3VsdCA9IFtdO1xuXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gKiBhZGRyZXNzZXMuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICogY2hhcmFjdGVyLlxuICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAqIG1hdGNoaW5nIFVURi0xNi5cbiAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHQvLyBJdCdzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0dmFyIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuXHRcdFx0XHQvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG52YXIgdWNzMmVuY29kZSA9IGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgdG9Db25zdW1hYmxlQXJyYXkoYXJyYXkpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG4gKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAqL1xudmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0aWYgKGNvZGVQb2ludCAtIDB4MzAgPCAweDBBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4MTY7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NDEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NDE7XG5cdH1cblx0aWYgKGNvZGVQb2ludCAtIDB4NjEgPCAweDFBKSB7XG5cdFx0cmV0dXJuIGNvZGVQb2ludCAtIDB4NjE7XG5cdH1cblx0cmV0dXJuIGJhc2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xudmFyIGFkYXB0ID0gZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdHZhciBrID0gMDtcblx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRmb3IgKDsgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9kZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0fVxuXHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAqIHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqL1xudmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdHZhciBvdXRwdXQgPSBbXTtcblx0dmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXHR2YXIgaSA9IDA7XG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdHZhciBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdGlmIChiYXNpYyA8IDApIHtcblx0XHRiYXNpYyA9IDA7XG5cdH1cblxuXHRmb3IgKHZhciBqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRlcnJvciQxKCdub3QtYmFzaWMnKTtcblx0XHR9XG5cdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdH1cblxuXHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0Zm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOykgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqL3tcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0dmFyIG9sZGkgPSBpO1xuXHRcdGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXG5cdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0ZXJyb3IkMSgnaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHR2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRlcnJvciQxKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cdFx0fVxuXG5cdFx0dmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRpICU9IG91dDtcblxuXHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXQuXG5cdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXHR9XG5cblx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcbiAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqL1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHR2YXIgb3V0cHV0ID0gW107XG5cblx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gYW4gYXJyYXkgb2YgVW5pY29kZSBjb2RlIHBvaW50cy5cblx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHQvLyBDYWNoZSB0aGUgbGVuZ3RoLlxuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG5cdHZhciBuID0gaW5pdGlhbE47XG5cdHZhciBkZWx0YSA9IDA7XG5cdHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50cy5cblx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuXHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcblx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG5cdHRyeSB7XG5cdFx0Zm9yICh2YXIgX2l0ZXJhdG9yID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHR2YXIgX2N1cnJlbnRWYWx1ZTIgPSBfc3RlcC52YWx1ZTtcblxuXHRcdFx0aWYgKF9jdXJyZW50VmFsdWUyIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcblx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0fSBmaW5hbGx5IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0dGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0dmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0dmFyIG0gPSBtYXhJbnQ7XG5cdFx0dmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcblx0XHR2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IyID0gaW5wdXRbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMi5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdGVycm9yJDEoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IHRydWU7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuXHRcdHZhciBfaXRlcmF0b3JFcnJvcjMgPSB1bmRlZmluZWQ7XG5cblx0XHR0cnkge1xuXHRcdFx0Zm9yICh2YXIgX2l0ZXJhdG9yMyA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAzOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG5cdFx0XHRcdHZhciBfY3VycmVudFZhbHVlID0gX3N0ZXAzLnZhbHVlO1xuXG5cdFx0XHRcdGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IkMSgnb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoX2N1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXG5cdFx0XHRcdFx0dmFyIHEgPSBkZWx0YTtcblx0XHRcdFx0XHRmb3IgKHZhciBrID0gYmFzZTs7IC8qIG5vIGNvbmRpdGlvbiAqL2sgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhciBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHR2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuXHRcdFx0X2l0ZXJhdG9yRXJyb3IzID0gZXJyO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zICYmIF9pdGVyYXRvcjMucmV0dXJuKSB7XG5cdFx0XHRcdFx0X2l0ZXJhdG9yMy5yZXR1cm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuXHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yMztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXHR9XG5cdHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cbiAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuICogc3RyaW5nLlxuICovXG52YXIgdG9Vbmljb2RlID0gZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuXHR9KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbnZhciB0b0FTQ0lJID0gZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG5cdH0pO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cbnZhciBwdW55Y29kZSA9IHtcblx0LyoqXG4gICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAqIEB0eXBlIFN0cmluZ1xuICAqL1xuXHQndmVyc2lvbic6ICcyLjEuMCcsXG5cdC8qKlxuICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cbiAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgKiBAdHlwZSBPYmplY3RcbiAgKi9cblx0J3VjczInOiB7XG5cdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0fSxcblx0J2RlY29kZSc6IGRlY29kZSxcblx0J2VuY29kZSc6IGVuY29kZSxcblx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG59O1xuXG4vKipcbiAqIFVSSS5qc1xuICpcbiAqIEBmaWxlb3ZlcnZpZXcgQW4gUkZDIDM5ODYgY29tcGxpYW50LCBzY2hlbWUgZXh0ZW5kYWJsZSBVUkkgcGFyc2luZy92YWxpZGF0aW5nL3Jlc29sdmluZyBsaWJyYXJ5IGZvciBKYXZhU2NyaXB0LlxuICogQGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmdhcnkuY291cnRAZ21haWwuY29tXCI+R2FyeSBDb3VydDwvYT5cbiAqIEBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L3VyaS1qc1xuICovXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cbnZhciBTQ0hFTUVTID0ge307XG5mdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgIHZhciBjID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGUgPSB2b2lkIDA7XG4gICAgaWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoYyA8IDEyOCkgZSA9IFwiJVwiICsgYy50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtlbHNlIGlmIChjIDwgMjA0OCkgZSA9IFwiJVwiICsgKGMgPj4gNiB8IDE5MikudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBcIiVcIiArIChjICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO2Vsc2UgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cikge1xuICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaWwgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+PSAxOTQgJiYgYyA8IDIyNCkge1xuICAgICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYyAmIDMxKSA8PCA2IHwgYzIgJiA2Myk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgICBpZiAoaWwgLSBpID49IDkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIHZhciBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAxNSkgPDwgMTIgfCAoX2MgJiA2MykgPDwgNiB8IGMzICYgNjMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdTdHI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpIHtcbiAgICBmdW5jdGlvbiBkZWNvZGVVbnJlc2VydmVkKHN0cikge1xuICAgICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgICAgcmV0dXJuICFkZWNTdHIubWF0Y2gocHJvdG9jb2wuVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1VTRVJJTkZPLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0hPU1QsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoY29tcG9uZW50cy5zY2hlbWUgPyBwcm90b2NvbC5OT1RfUEFUSCA6IHByb3RvY29sLk5PVF9QQVRIX05PU0NIRU1FLCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShwcm90b2NvbC5OT1RfRlJBR01FTlQsIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXjAqKC4qKS8sIFwiJDFcIikgfHwgXCIwXCI7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplSVB2NChob3N0LCBwcm90b2NvbCkge1xuICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG5cbiAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLFxuICAgICAgICBhZGRyZXNzID0gX21hdGNoZXNbMV07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3QubWF0Y2gocHJvdG9jb2wuSVBWNkFERFJFU1MpIHx8IFtdO1xuXG4gICAgdmFyIF9tYXRjaGVzMiA9IHNsaWNlZFRvQXJyYXkobWF0Y2hlcywgMyksXG4gICAgICAgIGFkZHJlc3MgPSBfbWF0Y2hlczJbMV0sXG4gICAgICAgIHpvbmUgPSBfbWF0Y2hlczJbMl07XG5cbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICB2YXIgX2FkZHJlc3MkdG9Mb3dlckNhc2UkID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnNwbGl0KCc6OicpLnJldmVyc2UoKSxcbiAgICAgICAgICAgIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksXG4gICAgICAgICAgICBsYXN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlswXSxcbiAgICAgICAgICAgIGZpcnN0ID0gX2FkZHJlc3MkdG9Mb3dlckNhc2UkMlsxXTtcblxuICAgICAgICB2YXIgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuICAgICAgICB2YXIgbGFzdEZpZWxkcyA9IGxhc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpO1xuICAgICAgICB2YXIgaXNMYXN0RmllbGRJUHY0QWRkcmVzcyA9IHByb3RvY29sLklQVjRBRERSRVNTLnRlc3QobGFzdEZpZWxkc1tsYXN0RmllbGRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG4gICAgICAgIHZhciBsYXN0RmllbGRzU3RhcnQgPSBsYXN0RmllbGRzLmxlbmd0aCAtIGZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBmaWVsZHMgPSBBcnJheShmaWVsZENvdW50KTtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWVsZENvdW50OyArK3gpIHtcbiAgICAgICAgICAgIGZpZWxkc1t4XSA9IGZpcnN0RmllbGRzW3hdIHx8IGxhc3RGaWVsZHNbbGFzdEZpZWxkc1N0YXJ0ICsgeF0gfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MpIHtcbiAgICAgICAgICAgIGZpZWxkc1tmaWVsZENvdW50IC0gMV0gPSBfbm9ybWFsaXplSVB2NChmaWVsZHNbZmllbGRDb3VudCAtIDFdLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbFplcm9GaWVsZHMgPSBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZpZWxkLCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCBmaWVsZCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdExvbmdlc3QgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjLnB1c2goeyBpbmRleDogaW5kZXgsIGxlbmd0aDogMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHZhciBsb25nZXN0WmVyb0ZpZWxkcyA9IGFsbFplcm9GaWVsZHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICB2YXIgbmV3SG9zdCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGxvbmdlc3RaZXJvRmllbGRzICYmIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgICB2YXIgbmV3TGFzdCA9IGZpZWxkcy5zbGljZShsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCArIGxvbmdlc3RaZXJvRmllbGRzLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdIb3N0ID0gbmV3Rmlyc3Quam9pbihcIjpcIikgKyBcIjo6XCIgKyBuZXdMYXN0LmpvaW4oXCI6XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgICAgbmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0hvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgfVxufVxudmFyIFVSSV9QQVJTRSA9IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OihbXlxcLz8jQF0qKUApPyhcXFtbXlxcLz8jXFxdXStcXF18W15cXC8/IzpdKikoPzpcXDooXFxkKikpPykpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFxcbnxcXHIpKikpPy9pO1xudmFyIE5PX01BVENIX0lTX1VOREVGSU5FRCA9IFwiXCIubWF0Y2goLygpezB9LylbMV0gPT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBjb21wb25lbnRzID0ge307XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIikgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgIHZhciBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKE5PX01BVENIX0lTX1VOREVGSU5FRCkge1xuICAgICAgICAgICAgLy9zdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgICAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IG1hdGNoZXNbN107XG4gICAgICAgICAgICBjb21wb25lbnRzLmZyYWdtZW50ID0gbWF0Y2hlc1s4XTtcbiAgICAgICAgICAgIC8vZml4IHBvcnQgbnVtYmVyXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29tcG9uZW50cy5wb3J0KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IG1hdGNoZXNbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL0lFIEZJWCBmb3IgaW1wcm9wZXIgUmVnRXhwIG1hdGNoaW5nXG4gICAgICAgICAgICAvL3N0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IHVyaVN0cmluZy5pbmRleE9mKFwiQFwiKSAhPT0gLTEgPyBtYXRjaGVzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gdXJpU3RyaW5nLmluZGV4T2YoXCIvL1wiKSAhPT0gLTEgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9maXggcG9ydCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdXJpU3RyaW5nLm1hdGNoKC9cXC9cXC8oPzoufFxcbikqXFw6KD86XFwvfFxcP3xcXCN8JCkvKSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgICAgLy9ub3JtYWxpemUgSVAgaG9zdHNcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9kZXRlcm1pbmUgcmVmZXJlbmNlIHR5cGVcbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwic2FtZS1kb2N1bWVudFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwidXJpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9jaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vZmluZCBzY2hlbWUgaGFuZGxlclxuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvL2NoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgICAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgICAgICAgLy9pZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29udmVydCBJUkkgLT4gVVJJXG4gICAgICAgICAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgVVJJX1BST1RPQ09MKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vbm9ybWFsaXplIGVuY29kaW5nc1xuICAgICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICAvL3BlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiVVJJIGNhbiBub3QgYmUgcGFyc2VkLlwiO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHByb3RvY29sID0gb3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudHMucG9ydCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKFwiXCIpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgUkRTMSA9IC9eXFwuXFwuP1xcLy87XG52YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG52YXIgUkRTMyA9IC9eXFwvXFwuXFwuKFxcL3wkKS87XG52YXIgUkRTNSA9IC9eXFwvPyg/Oi58XFxuKSo/KD89XFwvfCQpLztcbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIHdoaWxlIChpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKFJEUzEpKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMSwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMzLCBcIi9cIik7XG4gICAgICAgICAgICBvdXRwdXQucG9wKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09IFwiLlwiIHx8IGlucHV0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbSA9IGlucHV0Lm1hdGNoKFJEUzUpO1xuICAgICAgICAgICAgaWYgKGltKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBpbVswXTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkb3Qgc2VnbWVudCBjb25kaXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgIHZhciB1cmlUb2tlbnMgPSBbXTtcbiAgICAvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuICAgIC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICBpZiAoY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgIC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG4gICAgICAgIGlmIChwcm90b2NvbC5JUFY2QUREUkVTUy50ZXN0KGNvbXBvbmVudHMuaG9zdCkpIHt9XG4gICAgICAgIC8vVE9ETzogbm9ybWFsaXplIElQdjYgYWRkcmVzcyBhcyBwZXIgUkZDIDU5NTJcblxuICAgICAgICAvL2lmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoY29tcG9uZW50cy5ob3N0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy9ub3JtYWxpemUgZW5jb2RpbmdcbiAgICBfbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcoY29tcG9uZW50cywgcHJvdG9jb2wpO1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICB9XG4gICAgdmFyIGF1dGhvcml0eSA9IF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgICAgdXJpVG9rZW5zLnB1c2goXCIvL1wiKTtcbiAgICAgICAgfVxuICAgICAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICB1cmlUb2tlbnMucHVzaChcIi9cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAvL2Rvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRzLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goXCI/XCIpO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudHMuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIiNcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7IC8vbWVyZ2UgdG9rZW5zIGludG8gYSBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZSwgcmVsYXRpdmUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuXG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICAgICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucyk7IC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpOyAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICAgICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZTtcbiAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm87XG4gICAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgXCJcIik7XG4gICAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuICAgICAgICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICAgfVxuICAgIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50O1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICB2YXIgc2NoZW1lbGVzc09wdGlvbnMgPSBhc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmkgPSBzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB1cmkgPSBwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHVyaUEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZShwYXJzZSh1cmlBLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmlCID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUocGFyc2UodXJpQiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB1cmlBID09PSB1cmlCO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpO1xufVxuXG52YXIgaGFuZGxlciA9IHtcbiAgICBzY2hlbWU6IFwiaHR0cFwiLFxuICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy9yZXBvcnQgbWlzc2luZyBob3N0XG4gICAgICAgIGlmICghY29tcG9uZW50cy5ob3N0KSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucG9ydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICAgICAgICBpZiAoIWNvbXBvbmVudHMucGF0aCkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy9OT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gICAgICAgIC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gICAgICAgIC8vYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQxID0ge1xuICAgIHNjaGVtZTogXCJodHRwc1wiLFxuICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICBzZXJpYWxpemU6IGhhbmRsZXIuc2VyaWFsaXplXG59O1xuXG5mdW5jdGlvbiBpc1NlY3VyZSh3c0NvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdzQ29tcG9uZW50cy5zZWN1cmUgPT09ICdib29sZWFuJyA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbn1cbi8vUkZDIDY0NTVcbnZhciBoYW5kbGVyJDIgPSB7XG4gICAgc2NoZW1lOiBcIndzXCIsXG4gICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgd3NDb21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgLy9pbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSBpc1NlY3VyZSh3c0NvbXBvbmVudHMpO1xuICAgICAgICAvL2NvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50cy5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50cy5xdWVyeSA6ICcnKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplKHdzQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICAvL25vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gICAgICAgIGlmICh3c0NvbXBvbmVudHMucG9ydCA9PT0gKGlzU2VjdXJlKHdzQ29tcG9uZW50cykgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnRzLnBvcnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5zZWN1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgICAgdmFyIF93c0NvbXBvbmVudHMkcmVzb3VyYyA9IHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKSxcbiAgICAgICAgICAgICAgICBfd3NDb21wb25lbnRzJHJlc291cmMyID0gc2xpY2VkVG9BcnJheShfd3NDb21wb25lbnRzJHJlc291cmMsIDIpLFxuICAgICAgICAgICAgICAgIHBhdGggPSBfd3NDb21wb25lbnRzJHJlc291cmMyWzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcblxuICAgICAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSBwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3c0NvbXBvbmVudHMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9mb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gICAgICAgIHdzQ29tcG9uZW50cy5mcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICB9XG59O1xuXG52YXIgaGFuZGxlciQzID0ge1xuICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICBkb21haW5Ib3N0OiBoYW5kbGVyJDIuZG9tYWluSG9zdCxcbiAgICBwYXJzZTogaGFuZGxlciQyLnBhcnNlLFxuICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxufTtcblxudmFyIE8gPSB7fTtcbnZhciBpc0lSSSA9IHRydWU7XG4vL1JGQyAzOTg2XG52YXIgVU5SRVNFUlZFRCQkID0gXCJbQS1aYS16MC05XFxcXC1cXFxcLlxcXFxfXFxcXH5cIiArIChpc0lSSSA/IFwiXFxcXHhBMC1cXFxcdTIwMERcXFxcdTIwMTAtXFxcXHUyMDI5XFxcXHUyMDJGLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXCIgOiBcIlwiKSArIFwiXVwiO1xudmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiOyAvL2Nhc2UtaW5zZW5zaXRpdmVcbnZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7IC8vZXhwYW5kZWRcbi8vUkZDIDUzMjIsIGV4Y2VwdCB0aGVzZSBzeW1ib2xzIGFzIHBlciBSRkMgNjA2ODogQCA6IC8gPyAjIFsgXSAmIDsgPVxuLy9jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFwnXFxcXCpcXFxcK1xcXFwtXFxcXC9cXFxcPVxcXFw/XFxcXF5cXFxcX1xcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RVEVYVCQkID0gXCJbXFxcXHgwMS1cXFxceDA4XFxcXHgwQlxcXFx4MENcXFxceDBFLVxcXFx4MUZcXFxceDdGXVwiOyAgLy8oJWQxLTggLyAlZDExLTEyIC8gJWQxNC0zMSAvICVkMTI3KVxuLy9jb25zdCBRVEVYVCQkID0gbWVyZ2UoXCJbXFxcXHgyMVxcXFx4MjMtXFxcXHg1QlxcXFx4NUQtXFxcXHg3RV1cIiwgT0JTX1FURVhUJCQpOyAgLy8lZDMzIC8gJWQzNS05MSAvICVkOTMtMTI2IC8gb2JzLXF0ZXh0XG4vL2NvbnN0IFZDSEFSJCQgPSBcIltcXFxceDIxLVxcXFx4N0VdXCI7XG4vL2NvbnN0IFdTUCQkID0gXCJbXFxcXHgyMFxcXFx4MDldXCI7XG4vL2NvbnN0IE9CU19RUCQgPSBzdWJleHAoXCJcXFxcXFxcXFwiICsgbWVyZ2UoXCJbXFxcXHgwMFxcXFx4MERcXFxceDBBXVwiLCBPQlNfUVRFWFQkJCkpOyAgLy8lZDAgLyBDUiAvIExGIC8gb2JzLXF0ZXh0XG4vL2NvbnN0IEZXUyQgPSBzdWJleHAoc3ViZXhwKFdTUCQkICsgXCIqXCIgKyBcIlxcXFx4MERcXFxceDBBXCIpICsgXCI/XCIgKyBXU1AkJCArIFwiK1wiKTtcbi8vY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKHN1YmV4cChcIlxcXFxcXFxcXCIgKyBzdWJleHAoVkNIQVIkJCArIFwifFwiICsgV1NQJCQpKSArIFwifFwiICsgT0JTX1FQJCk7XG4vL2NvbnN0IFFVT1RFRF9TVFJJTkckID0gc3ViZXhwKCdcXFxcXCInICsgc3ViZXhwKEZXUyQgKyBcIj9cIiArIFFDT05URU5UJCkgKyBcIipcIiArIEZXUyQgKyBcIj9cIiArICdcXFxcXCInKTtcbnZhciBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbnZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG52YXIgVkNIQVIkJCA9IG1lcmdlKFFURVhUJCQsIFwiW1xcXFxcXFwiXFxcXFxcXFxdXCIpO1xudmFyIFNPTUVfREVMSU1TJCQgPSBcIltcXFxcIVxcXFwkXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXDtcXFxcOlxcXFxAXVwiO1xudmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xudmFyIFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbnZhciBOT1RfTE9DQUxfUEFSVCA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgQVRFWFQkJCwgXCJbXFxcXC5dXCIsICdbXFxcXFwiXScsIFZDSEFSJCQpLCBcImdcIik7XG52YXIgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xudmFyIE5PVF9IRlZBTFVFID0gTk9UX0hGTkFNRTtcbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgdmFyIGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG4gICAgcmV0dXJuICFkZWNTdHIubWF0Y2goVU5SRVNFUlZFRCkgPyBzdHIgOiBkZWNTdHI7XG59XG52YXIgaGFuZGxlciQ0ID0ge1xuICAgIHNjaGVtZTogXCJtYWlsdG9cIixcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UkJDEoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSBtYWlsdG9Db21wb25lbnRzLnBhdGggPyBtYWlsdG9Db21wb25lbnRzLnBhdGguc3BsaXQoXCIsXCIpIDogW107XG4gICAgICAgIG1haWx0b0NvbXBvbmVudHMucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1haWx0b0NvbXBvbmVudHMucXVlcnkpIHtcbiAgICAgICAgICAgIHZhciB1bmtub3duSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBoZmllbGRzID0gbWFpbHRvQ29tcG9uZW50cy5xdWVyeS5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChoZmllbGRbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfeCA9IDAsIF94bCA9IHRvQWRkcnMubGVuZ3RoOyBfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLnB1c2godG9BZGRyc1tfeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdWJqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLnN1YmplY3QgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW3VuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFswXSwgb3B0aW9ucyldID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycykgbWFpbHRvQ29tcG9uZW50cy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKHZhciBfeDIgPSAwLCBfeGwyID0gdG8ubGVuZ3RoOyBfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgICAgdmFyIGFkZHIgPSB0b1tfeDJdLnNwbGl0KFwiQFwiKTtcbiAgICAgICAgICAgIGFkZHJbMF0gPSB1bmVzY2FwZUNvbXBvbmVudChhZGRyWzBdKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyWzFdID0gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChhZGRyWzFdLCBvcHRpb25zKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1tfeDJdID0gYWRkci5qb2luKFwiQFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcbiAgICB9LFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gc2VyaWFsaXplJCQxKG1haWx0b0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRyID0gU3RyaW5nKHRvW3hdKTtcbiAgICAgICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBhcnQgPSB0b0FkZHIuc2xpY2UoMCwgYXRJZHgpLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9MT0NBTF9QQVJULCBwY3RFbmNDaGFyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdG9BZGRyLnNsaWNlKGF0SWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IElETiB2aWEgcHVueWNvZGVcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAhb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b1t4XSA9IGxvY2FsUGFydCArIFwiQFwiICsgZG9tYWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpIGhlYWRlcnNbXCJzdWJqZWN0XCJdID0gbWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0O1xuICAgICAgICBpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzW25hbWVdICE9PSBPW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2gobmFtZS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZOQU1FLCBwY3RFbmNDaGFyKSArIFwiPVwiICsgaGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH1cbn07XG5cbnZhciBVUk5fUEFSU0UgPSAvXihbXlxcOl0rKVxcOiguKikvO1xuLy9SRkMgMjE0MVxudmFyIGhhbmRsZXIkNSA9IHtcbiAgICBzY2hlbWU6IFwidXJuXCIsXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG4gICAgICAgIHZhciB1cm5Db21wb25lbnRzID0gY29tcG9uZW50cztcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBuc3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgdmFyIHVyblNjaGVtZSA9IHNjaGVtZSArIFwiOlwiICsgKG9wdGlvbnMubmlkIHx8IG5pZCk7XG4gICAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMubmlkID0gbmlkO1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSBuc3M7XG4gICAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJuQ29tcG9uZW50cy5lcnJvciA9IHVybkNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUk4gY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHZhciBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcbiAgICAgICAgdXJpQ29tcG9uZW50cy5wYXRoID0gKG5pZCB8fCBvcHRpb25zLm5pZCkgKyBcIjpcIiArIG5zcztcbiAgICAgICAgcmV0dXJuIHVyaUNvbXBvbmVudHM7XG4gICAgfVxufTtcblxudmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4vL1JGQyA0MTIyXG52YXIgaGFuZGxlciQ2ID0ge1xuICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1dWlkQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHM7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLnV1aWQgPSB1dWlkQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudHMudXVpZCB8fCAhdXVpZENvbXBvbmVudHMudXVpZC5tYXRjaChVVUlEKSkpIHtcbiAgICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgfSxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh1dWlkQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IHV1aWRDb21wb25lbnRzO1xuICAgICAgICAvL25vcm1hbGl6ZSBVVUlEXG4gICAgICAgIHVybkNvbXBvbmVudHMubnNzID0gKHV1aWRDb21wb25lbnRzLnV1aWQgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIHVybkNvbXBvbmVudHM7XG4gICAgfVxufTtcblxuU0NIRU1FU1toYW5kbGVyLnNjaGVtZV0gPSBoYW5kbGVyO1xuU0NIRU1FU1toYW5kbGVyJDEuc2NoZW1lXSA9IGhhbmRsZXIkMTtcblNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG5TQ0hFTUVTW2hhbmRsZXIkMy5zY2hlbWVdID0gaGFuZGxlciQzO1xuU0NIRU1FU1toYW5kbGVyJDQuc2NoZW1lXSA9IGhhbmRsZXIkNDtcblNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG5TQ0hFTUVTW2hhbmRsZXIkNi5zY2hlbWVdID0gaGFuZGxlciQ2O1xuXG5leHBvcnRzLlNDSEVNRVMgPSBTQ0hFTUVTO1xuZXhwb3J0cy5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbmV4cG9ydHMucGN0RGVjQ2hhcnMgPSBwY3REZWNDaGFycztcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5yZXNvbHZlQ29tcG9uZW50cyA9IHJlc29sdmVDb21wb25lbnRzO1xuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTtcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuZXhwb3J0cy5lcXVhbCA9IGVxdWFsO1xuZXhwb3J0cy5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG5leHBvcnRzLnVuZXNjYXBlQ29tcG9uZW50ID0gdW5lc2NhcGVDb21wb25lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmkuYWxsLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBleHBvcnRzLnJlc29sdmVVcmwgPSBleHBvcnRzLm5vcm1hbGl6ZUlkID0gZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBleHBvcnRzLmdldEZ1bGxQYXRoID0gZXhwb3J0cy5pbmxpbmVSZWYgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZXF1YWwgPSByZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpO1xuY29uc3QgdHJhdmVyc2UgPSByZXF1aXJlKFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIik7XG5jb25zdCBVUkkgPSByZXF1aXJlKFwidXJpLWpzXCIpO1xuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgICBcInR5cGVcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuXSk7XG5mdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hLCBsaW1pdCA9IHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGxpbWl0ID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gIWhhc1JlZihzY2hlbWEpO1xuICAgIGlmICghbGltaXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXQ7XG59XG5leHBvcnRzLmlubGluZVJlZiA9IGlubGluZVJlZjtcbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICAgIFwiJHJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICAgIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKTtcbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWEpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKVxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB1dGlsXzEuZWFjaEl0ZW0oc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoKGlkID0gXCJcIiwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpXG4gICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIGNvbnN0IHAgPSBVUkkucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG59XG5leHBvcnRzLmdldEZ1bGxQYXRoID0gZ2V0RnVsbFBhdGg7XG5mdW5jdGlvbiBfZ2V0RnVsbFBhdGgocCkge1xuICAgIHJldHVybiBVUkkuc2VyaWFsaXplKHApLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiO1xufVxuZXhwb3J0cy5fZ2V0RnVsbFBhdGggPSBfZ2V0RnVsbFBhdGg7XG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC87XG5mdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xufVxuZXhwb3J0cy5ub3JtYWxpemVJZCA9IG5vcm1hbGl6ZUlkO1xuZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlSWQsIGlkKSB7XG4gICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgcmV0dXJuIFVSSS5yZXNvbHZlKGJhc2VJZCwgaWQpO1xufVxuZXhwb3J0cy5yZXNvbHZlVXJsID0gcmVzb2x2ZVVybDtcbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pO1xuZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyhzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0pO1xuICAgIGNvbnN0IGJhc2VJZHMgPSB7IFwiXCI6IHNjaElkIH07XG4gICAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHNjaElkLCBmYWxzZSk7XG4gICAgY29uc3QgbG9jYWxSZWZzID0ge307XG4gICAgY29uc3Qgc2NoZW1hUmVmcyA9IG5ldyBTZXQoKTtcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHI7XG4gICAgICAgIGxldCBiYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgICAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pO1xuICAgICAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcik7XG4gICAgICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcik7XG4gICAgICAgIGJhc2VJZHNbanNvblB0cl0gPSBiYXNlSWQ7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFJlZihyZWYpIHtcbiAgICAgICAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGJhc2VJZCA/IFVSSS5yZXNvbHZlKGJhc2VJZCwgcmVmKSA6IHJlZik7XG4gICAgICAgICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgICAgICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKTtcbiAgICAgICAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxSZWZzW3JlZl0gPSBzY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IGZ1bGxQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQW5jaG9yKGFuY2hvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYCk7XG4gICAgICAgICAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBsb2NhbFJlZnM7XG4gICAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxLCBzY2gyLCByZWYpIHtcbiAgICAgICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpXG4gICAgICAgICAgICB0aHJvdyBhbWJpZ3VvcyhyZWYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhbWJpZ3VvcyhyZWYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFNjaGVtYVJlZnMgPSBnZXRTY2hlbWFSZWZzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGF0YSA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IGV4cG9ydHMudmFsaWRhdGVGdW5jdGlvbkNvZGUgPSB2b2lkIDA7XG5jb25zdCBib29sU2NoZW1hXzEgPSByZXF1aXJlKFwiLi9ib29sU2NoZW1hXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2RhdGFUeXBlXCIpO1xuY29uc3QgYXBwbGljYWJpbGl0eV8xID0gcmVxdWlyZShcIi4vYXBwbGljYWJpbGl0eVwiKTtcbmNvbnN0IGRhdGFUeXBlXzIgPSByZXF1aXJlKFwiLi9kYXRhVHlwZVwiKTtcbmNvbnN0IGRlZmF1bHRzXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcbmNvbnN0IGtleXdvcmRfMSA9IHJlcXVpcmUoXCIuL2tleXdvcmRcIik7XG5jb25zdCBzdWJzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3N1YnNjaGVtYVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db2RlKGl0KSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgdG9wU2NoZW1hT2JqQ29kZShpdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gYm9vbFNjaGVtYV8xLnRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSk7XG59XG5leHBvcnRzLnZhbGlkYXRlRnVuY3Rpb25Db2RlID0gdmFsaWRhdGVGdW5jdGlvbkNvZGU7XG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKHsgZ2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzIH0sIGJvZHkpIHtcbiAgICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgICAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5kYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YCk7XG4gICAgICAgICAgICBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpO1xuICAgICAgICAgICAgZ2VuLmNvZGUoYm9keSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4gZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzKSB7XG4gICAgcmV0dXJuIGNvZGVnZW5fMS5fIGB7JHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofT1cIlwiLCAke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfSwgJHtuYW1lc18xLmRlZmF1bHQucGFyZW50RGF0YVByb3BlcnR5fSwgJHtuYW1lc18xLmRlZmF1bHQucm9vdERhdGF9PSR7bmFtZXNfMS5kZWZhdWx0LmRhdGF9JHtvcHRzLmR5bmFtaWNSZWYgPyBjb2RlZ2VuXzEuXyBgLCAke25hbWVzXzEuZGVmYXVsdC5keW5hbWljQW5jaG9yc309e31gIDogY29kZWdlbl8xLm5pbH19PXt9YDtcbn1cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cykge1xuICAgIGdlbi5pZihuYW1lc18xLmRlZmF1bHQudmFsQ3h0LCAoKSA9PiB7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0Lmluc3RhbmNlUGF0aCwgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZhbEN4dH0uJHtuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRofWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudmFsQ3h0fS4ke25hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhfWApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhUHJvcGVydHksIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eX1gKTtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQucm9vdERhdGEsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LnJvb3REYXRhfWApO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC52YWxDeHR9LiR7bmFtZXNfMS5kZWZhdWx0LmR5bmFtaWNBbmNob3JzfWApO1xuICAgIH0sICgpID0+IHtcbiAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuaW5zdGFuY2VQYXRoLCBjb2RlZ2VuXzEuXyBgXCJcImApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5wYXJlbnREYXRhLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCk7XG4gICAgICAgIGdlbi52YXIobmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApO1xuICAgICAgICBnZW4udmFyKG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YSwgbmFtZXNfMS5kZWZhdWx0LmRhdGEpO1xuICAgICAgICBpZiAob3B0cy5keW5hbWljUmVmKVxuICAgICAgICAgICAgZ2VuLnZhcihuYW1lc18xLmRlZmF1bHQuZHluYW1pY0FuY2hvcnMsIGNvZGVnZW5fMS5fIGB7fWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdCkge1xuICAgIGNvbnN0IHsgc2NoZW1hLCBvcHRzLCBnZW4gfSA9IGl0O1xuICAgIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICAgICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICAgICAgY29tbWVudEtleXdvcmQoaXQpO1xuICAgICAgICBjaGVja05vRGVmYXVsdChpdCk7XG4gICAgICAgIGdlbi5sZXQobmFtZXNfMS5kZWZhdWx0LnZFcnJvcnMsIG51bGwpO1xuICAgICAgICBnZW4ubGV0KG5hbWVzXzEuZGVmYXVsdC5lcnJvcnMsIDApO1xuICAgICAgICBpZiAob3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJlc2V0RXZhbHVhdGVkKGl0KTtcbiAgICAgICAgdHlwZUFuZEtleXdvcmRzKGl0KTtcbiAgICAgICAgcmV0dXJuUmVzdWx0cyhpdCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xufVxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQpIHtcbiAgICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gICAgY29uc3QgeyBnZW4sIHZhbGlkYXRlTmFtZSB9ID0gaXQ7XG4gICAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIGNvZGVnZW5fMS5fIGAke3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYCk7XG4gICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgY29kZWdlbl8xLl8gYHVuZGVmaW5lZGApKTtcbiAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKGNvZGVnZW5fMS5fIGAke2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBjb2RlZ2VuXzEuXyBgdW5kZWZpbmVkYCkpO1xufVxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpIHtcbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF07XG4gICAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/IGNvZGVnZW5fMS5fIGAvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IGNvZGVnZW5fMS5uaWw7XG59XG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQsIHZhbGlkKSB7XG4gICAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgICAgICBjaGVja0tleXdvcmRzKGl0KTtcbiAgICAgICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJvb2xTY2hlbWFfMS5ib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpO1xufVxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoeyBzY2hlbWEsIHNlbGYgfSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICByZXR1cm4gIXNjaGVtYTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpXG4gICAgICAgIGlmIChzZWxmLlJVTEVTLmFsbFtrZXldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTY2hlbWFPYmooaXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGdlbiwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KVxuICAgICAgICBjb21tZW50S2V5d29yZChpdCk7XG4gICAgdXBkYXRlQ29udGV4dChpdCk7XG4gICAgY2hlY2tBc3luY1NjaGVtYShpdCk7XG4gICAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgbmFtZXNfMS5kZWZhdWx0LmVycm9ycyk7XG4gICAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpO1xuICAgIC8vIFRPRE8gdmFyXG4gICAgZ2VuLnZhcih2YWxpZCwgY29kZWdlbl8xLl8gYCR7ZXJyc0NvdW50fSA9PT0gJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfWApO1xufVxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdCkge1xuICAgIHV0aWxfMS5jaGVja1Vua25vd25SdWxlcyhpdCk7XG4gICAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpO1xufVxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpIHtcbiAgICBpZiAoaXQub3B0cy5qdGQpXG4gICAgICAgIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpO1xuICAgIGNvbnN0IHR5cGVzID0gZGF0YVR5cGVfMS5nZXRTY2hlbWFUeXBlcyhpdC5zY2hlbWEpO1xuICAgIGNvbnN0IGNoZWNrZWRUeXBlcyA9IGRhdGFUeXBlXzEuY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpO1xuICAgIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KSB7XG4gICAgY29uc3QgeyBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiB1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgICAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgb3B0cyB9ID0gaXQ7XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChpdCkge1xuICAgIGNvbnN0IHNjaElkID0gaXQuc2NoZW1hW2l0Lm9wdHMuc2NoZW1hSWRdO1xuICAgIGlmIChzY2hJZClcbiAgICAgICAgaXQuYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoaXQuYmFzZUlkLCBzY2hJZCk7XG59XG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0KSB7XG4gICAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHsgZ2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cyB9KSB7XG4gICAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50O1xuICAgIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBjb2RlZ2VuXzEuc3RyIGAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YDtcbiAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHNjaGVtYUVudi5yb290IH0pO1xuICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0KSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHMgfSA9IGl0O1xuICAgIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gMGAsICgpID0+IGdlbi5yZXR1cm4obmFtZXNfMS5kZWZhdWx0LmRhdGEpLCAoKSA9PiBnZW4udGhyb3coY29kZWdlbl8xLl8gYG5ldyAke1ZhbGlkYXRpb25FcnJvcn0oJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30pYCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzKTtcbiAgICAgICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpXG4gICAgICAgICAgICBhc3NpZ25FdmFsdWF0ZWQoaXQpO1xuICAgICAgICBnZW4ucmV0dXJuKGNvZGVnZW5fMS5fIGAke25hbWVzXzEuZGVmYXVsdC5lcnJvcnN9ID09PSAwYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHsgZ2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtcyB9KSB7XG4gICAgaWYgKHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpXG4gICAgICAgIGdlbi5hc3NpZ24oY29kZWdlbl8xLl8gYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKTtcbiAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSlcbiAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpO1xufVxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCB0eXBlRXJyb3JzLCBlcnJzQ291bnQpIHtcbiAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHNlbGY7XG4gICAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhdXRpbF8xLnNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgICAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCBSVUxFUy5hbGwuJHJlZi5kZWZpbml0aW9uKSk7IC8vIFRPRE8gdHlwZWNhc3RcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9wdHMuanRkKVxuICAgICAgICBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcyk7XG4gICAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcylcbiAgICAgICAgICAgIGdyb3VwS2V5d29yZHMoZ3JvdXApO1xuICAgICAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXApIHtcbiAgICAgICAgaWYgKCFhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICAgICAgICBnZW4uaWYoZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpO1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlXzIucmVwb3J0VHlwZUVycm9yKGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgICAgICBpZiAoIWFsbEVycm9ycylcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQuZXJyb3JzfSA9PT0gJHtlcnJzQ291bnQgfHwgMH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgb3B0czogeyB1c2VEZWZhdWx0cyB9LCB9ID0gaXQ7XG4gICAgaWYgKHVzZURlZmF1bHRzKVxuICAgICAgICBkZWZhdWx0c18xLmFzc2lnbkRlZmF1bHRzKGl0LCBncm91cC50eXBlKTtcbiAgICBnZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgICAgICAgIGlmIChhcHBsaWNhYmlsaXR5XzEuc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpIHtcbiAgICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpXG4gICAgICAgIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpO1xuICAgIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgICAgaXQuZGF0YVR5cGVzID0gdHlwZXM7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGl0LmRhdGFUeXBlcyA9IGl0LmRhdGFUeXBlcy5maWx0ZXIoKHQpID0+IGluY2x1ZGVzVHlwZSh0eXBlcywgdCkpO1xufVxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0cykge1xuICAgIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0tleXdvcmRUeXBlcyhpdCwgdHMpIHtcbiAgICBjb25zdCBydWxlcyA9IGl0LnNlbGYuUlVMRVMuYWxsO1xuICAgIGZvciAoY29uc3Qga2V5d29yZCBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF07XG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiICYmIGFwcGxpY2FiaWxpdHlfMS5zaG91bGRVc2VSdWxlKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUcywga3dkVCkge1xuICAgIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzLCB0KSB7XG4gICAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSk7XG59XG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0LCBtc2cpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGg7XG4gICAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWA7XG4gICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKTtcbn1cbmNsYXNzIEtleXdvcmRDeHQge1xuICAgIGNvbnN0cnVjdG9yKGl0LCBkZWYsIGtleXdvcmQpIHtcbiAgICAgICAga2V5d29yZF8xLnZhbGlkYXRlS2V5d29yZFVzYWdlKGl0LCBkZWYsIGtleXdvcmQpO1xuICAgICAgICB0aGlzLmdlbiA9IGl0LmdlbjtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnM7XG4gICAgICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IGl0LmRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdO1xuICAgICAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGE7XG4gICAgICAgIHRoaXMuc2NoZW1hVmFsdWUgPSB1dGlsXzEuc2NoZW1hUmVmT3JWYWwoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKTtcbiAgICAgICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGU7XG4gICAgICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgICAgICB0aGlzLml0ID0gaXQ7XG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xuICAgICAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlO1xuICAgICAgICAgICAgaWYgKCFrZXl3b3JkXzEudmFsaWRTY2hlbWFUeXBlKHRoaXMuc2NoZW1hLCBkZWYuc2NoZW1hVHlwZSwgZGVmLmFsbG93VW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcImNvZGVcIiBpbiBkZWYgPyBkZWYudHJhY2tFcnJvcnMgOiBkZWYuZXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJzQ291bnQgPSBpdC5nZW4uY29uc3QoXCJfZXJyc1wiLCBuYW1lc18xLmRlZmF1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQoY29uZGl0aW9uLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZmFpbFJlc3VsdChjb2RlZ2VuXzEubm90KGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pO1xuICAgIH1cbiAgICBmYWlsUmVzdWx0KGNvbmRpdGlvbiwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbikge1xuICAgICAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbilcbiAgICAgICAgICAgIGZhaWxBY3Rpb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcigpO1xuICAgICAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgICAgICAgICAgc3VjY2Vzc0FjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmVuZElmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFzcyhjb25kaXRpb24sIGZhaWxBY3Rpb24pIHtcbiAgICAgICAgdGhpcy5mYWlsUmVzdWx0KGNvZGVnZW5fMS5ub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKTtcbiAgICB9XG4gICAgZmFpbChjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuLmlmKGZhbHNlKTsgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbik7XG4gICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uZW5kSWYoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZW4uZWxzZSgpO1xuICAgIH1cbiAgICBmYWlsJGRhdGEoY29uZGl0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFDb2RlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gIT09IHVuZGVmaW5lZCAmJiAoJHtjb2RlZ2VuXzEub3IodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYCk7XG4gICAgfVxuICAgIGVycm9yKGFwcGVuZCwgZXJyb3JQYXJhbXMsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJhbXMoe30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgIF9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpIHtcbiAgICAgICAgO1xuICAgICAgICAoYXBwZW5kID8gZXJyb3JzXzEucmVwb3J0RXh0cmFFcnJvciA6IGVycm9yc18xLnJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocyk7XG4gICAgfVxuICAgICRkYXRhRXJyb3IoKSB7XG4gICAgICAgIGVycm9yc18xLnJlcG9ydEVycm9yKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwgZXJyb3JzXzEua2V5d29yZCREYXRhRXJyb3IpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJyk7XG4gICAgICAgIGVycm9yc18xLnJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KTtcbiAgICB9XG4gICAgb2soY29uZCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKVxuICAgICAgICAgICAgdGhpcy5nZW4uaWYoY29uZCk7XG4gICAgfVxuICAgIHNldFBhcmFtcyhvYmosIGFzc2lnbikge1xuICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBvYmo7XG4gICAgfVxuICAgIGJsb2NrJGRhdGEodmFsaWQsIGNvZGVCbG9jaywgJGRhdGFWYWxpZCA9IGNvZGVnZW5fMS5uaWwpIHtcbiAgICAgICAgdGhpcy5nZW4uYmxvY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGVjayRkYXRhKHZhbGlkLCAkZGF0YVZhbGlkKTtcbiAgICAgICAgICAgIGNvZGVCbG9jaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2skZGF0YSh2YWxpZCA9IGNvZGVnZW5fMS5uaWwsICRkYXRhVmFsaWQgPSBjb2RlZ2VuXzEubmlsKSB7XG4gICAgICAgIGlmICghdGhpcy4kZGF0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiB9ID0gdGhpcztcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpO1xuICAgICAgICBpZiAodmFsaWQgIT09IGNvZGVnZW5fMS5uaWwpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKTtcbiAgICAgICAgICAgIHRoaXMuJGRhdGFFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHZhbGlkICE9PSBjb2RlZ2VuXzEubmlsKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW4uZWxzZSgpO1xuICAgIH1cbiAgICBpbnZhbGlkJGRhdGEoKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29kZWdlbl8xLm9yKHdyb25nJERhdGFUeXBlKCksIGludmFsaWQkRGF0YVNjaGVtYSgpKTtcbiAgICAgICAgZnVuY3Rpb24gd3JvbmckRGF0YVR5cGUoKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYCR7ZGF0YVR5cGVfMi5jaGVja0RhdGFUeXBlcyhzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBkYXRhVHlwZV8yLkRhdGFUeXBlLldyb25nKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHsgcmVmOiBkZWYudmFsaWRhdGVTY2hlbWEgfSk7IC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEubmlsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjaGVtYShhcHBsLCB2YWxpZCkge1xuICAgICAgICBjb25zdCBzdWJzY2hlbWEgPSBzdWJzY2hlbWFfMS5nZXRTdWJzY2hlbWEodGhpcy5pdCwgYXBwbCk7XG4gICAgICAgIHN1YnNjaGVtYV8xLmV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKTtcbiAgICAgICAgc3Vic2NoZW1hXzEuZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpO1xuICAgICAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsgLi4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkIH07XG4gICAgICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKTtcbiAgICAgICAgcmV0dXJuIG5leHRDb250ZXh0O1xuICAgIH1cbiAgICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIHRvTmFtZSkge1xuICAgICAgICBjb25zdCB7IGl0LCBnZW4gfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaGVtYUN4dC5wcm9wcywgaXQucHJvcHMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlICYmIHNjaGVtYUN4dC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdC5pdGVtcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQsIHZhbGlkKSB7XG4gICAgICAgIGNvbnN0IHsgaXQsIGdlbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgY29kZWdlbl8xLk5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5LZXl3b3JkQ3h0ID0gS2V5d29yZEN4dDtcbmZ1bmN0aW9uIGtleXdvcmRDb2RlKGl0LCBrZXl3b3JkLCBkZWYsIHJ1bGVUeXBlKSB7XG4gICAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZCk7XG4gICAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgICAgICBkZWYuY29kZShjeHQsIHJ1bGVUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgICAgICBrZXl3b3JkXzEubWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBrZXl3b3JkXzEuZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKTtcbiAgICB9XG59XG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvO1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC87XG5mdW5jdGlvbiBnZXREYXRhKCRkYXRhLCB7IGRhdGFMZXZlbCwgZGF0YU5hbWVzLCBkYXRhUGF0aEFyciB9KSB7XG4gICAgbGV0IGpzb25Qb2ludGVyO1xuICAgIGxldCBkYXRhO1xuICAgIGlmICgkZGF0YSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKTtcbiAgICAgICAganNvblBvaW50ZXIgPSAkZGF0YTtcbiAgICAgICAgZGF0YSA9IG5hbWVzXzEuZGVmYXVsdC5yb290RGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBSRUxBVElWRV9KU09OX1BPSU5URVIuZXhlYygkZGF0YSk7XG4gICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YCk7XG4gICAgICAgIGNvbnN0IHVwID0gK21hdGNoZXNbMV07XG4gICAgICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXTtcbiAgICAgICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKHVwID49IGRhdGFMZXZlbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJwcm9wZXJ0eS9pbmRleFwiLCB1cCkpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXAgPiBkYXRhTGV2ZWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSk7XG4gICAgICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdO1xuICAgICAgICBpZiAoIWpzb25Qb2ludGVyKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGxldCBleHByID0gZGF0YTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBjb2RlZ2VuXzEuXyBgJHtkYXRhfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KHV0aWxfMS51bmVzY2FwZUpzb25Qb2ludGVyKHNlZ21lbnQpKX1gO1xuICAgICAgICAgICAgZXhwciA9IGNvZGVnZW5fMS5fIGAke2V4cHJ9ICYmICR7ZGF0YX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICAgIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlLCB1cCkge1xuICAgICAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWA7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgICAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb25fZXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZXNvbHZlXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlXCIpO1xuY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJhc2VJZCwgcmVmLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKTtcbiAgICAgICAgdGhpcy5taXNzaW5nUmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCByZWYpO1xuICAgICAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSByZXNvbHZlXzEubm9ybWFsaXplSWQocmVzb2x2ZV8xLmdldEZ1bGxQYXRoKHRoaXMubWlzc2luZ1JlZikpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1pc3NpbmdSZWZFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZl9lcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZVNjaGVtYSA9IGV4cG9ydHMuZ2V0Q29tcGlsaW5nU2NoZW1hID0gZXhwb3J0cy5yZXNvbHZlUmVmID0gZXhwb3J0cy5jb21waWxlU2NoZW1hID0gZXhwb3J0cy5TY2hlbWFFbnYgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb2RlZ2VuXCIpO1xuY29uc3QgdmFsaWRhdGlvbl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKTtcbmNvbnN0IG5hbWVzXzEgPSByZXF1aXJlKFwiLi9uYW1lc1wiKTtcbmNvbnN0IHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpO1xuY29uc3QgVVJJID0gcmVxdWlyZShcInVyaS1qc1wiKTtcbmNsYXNzIFNjaGVtYUVudiB7XG4gICAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5yZWZzID0ge307XG4gICAgICAgIHRoaXMuZHluYW1pY0FuY2hvcnMgPSB7fTtcbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBzY2hlbWEgPSBlbnYuc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWE7XG4gICAgICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWQ7XG4gICAgICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuYmFzZUlkID0gKF9hID0gZW52LmJhc2VJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaGVtYVtlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pO1xuICAgICAgICB0aGlzLnNjaGVtYVBhdGggPSBlbnYuc2NoZW1hUGF0aDtcbiAgICAgICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzO1xuICAgICAgICB0aGlzLm1ldGEgPSBlbnYubWV0YTtcbiAgICAgICAgdGhpcy4kYXN5bmMgPSBzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2hlbWEuJGFzeW5jO1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICB9XG59XG5leHBvcnRzLlNjaGVtYUVudiA9IFNjaGVtYUVudjtcbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5mdW5jdGlvbiBjb21waWxlU2NoZW1hKHNjaCkge1xuICAgIC8vIFRPRE8gcmVmYWN0b3IgLSByZW1vdmUgY29tcGlsYXRpb25zXG4gICAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaCk7XG4gICAgaWYgKF9zY2gpXG4gICAgICAgIHJldHVybiBfc2NoO1xuICAgIGNvbnN0IHJvb3RJZCA9IHJlc29sdmVfMS5nZXRGdWxsUGF0aChzY2gucm9vdC5iYXNlSWQpOyAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgY29uc3QgeyBvd25Qcm9wZXJ0aWVzIH0gPSB0aGlzLm9wdHM7XG4gICAgY29uc3QgZ2VuID0gbmV3IGNvZGVnZW5fMS5Db2RlR2VuKHRoaXMuc2NvcGUsIHsgZXM1LCBsaW5lcywgb3duUHJvcGVydGllcyB9KTtcbiAgICBsZXQgX1ZhbGlkYXRpb25FcnJvcjtcbiAgICBpZiAoc2NoLiRhc3luYykge1xuICAgICAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICAgICAgICByZWY6IHZhbGlkYXRpb25fZXJyb3JfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY29kZTogY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIik7XG4gICAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcbiAgICBjb25zdCBzY2hlbWFDeHQgPSB7XG4gICAgICAgIGdlbixcbiAgICAgICAgYWxsRXJyb3JzOiB0aGlzLm9wdHMuYWxsRXJyb3JzLFxuICAgICAgICBkYXRhOiBuYW1lc18xLmRlZmF1bHQuZGF0YSxcbiAgICAgICAgcGFyZW50RGF0YTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGEsXG4gICAgICAgIHBhcmVudERhdGFQcm9wZXJ0eTogbmFtZXNfMS5kZWZhdWx0LnBhcmVudERhdGFQcm9wZXJ0eSxcbiAgICAgICAgZGF0YU5hbWVzOiBbbmFtZXNfMS5kZWZhdWx0LmRhdGFdLFxuICAgICAgICBkYXRhUGF0aEFycjogW2NvZGVnZW5fMS5uaWxdLFxuICAgICAgICBkYXRhTGV2ZWw6IDAsXG4gICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0KCksXG4gICAgICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXCJzY2hlbWFcIiwgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgICAgICA/IHsgcmVmOiBzY2guc2NoZW1hLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaC5zY2hlbWEpIH1cbiAgICAgICAgICAgIDogeyByZWY6IHNjaC5zY2hlbWEgfSksXG4gICAgICAgIHZhbGlkYXRlTmFtZSxcbiAgICAgICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgICAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgICAgIHNjaGVtYUVudjogc2NoLFxuICAgICAgICByb290SWQsXG4gICAgICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICAgICAgZXJyb3JQYXRoOiBjb2RlZ2VuXzEuXyBgXCJcImAsXG4gICAgICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICAgICAgc2VsZjogdGhpcyxcbiAgICB9O1xuICAgIGxldCBzb3VyY2VDb2RlO1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKTtcbiAgICAgICAgdmFsaWRhdGVfMS52YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpO1xuICAgICAgICBnZW4ub3B0aW1pemUodGhpcy5vcHRzLmNvZGUub3B0aW1pemUpO1xuICAgICAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICAgICAgY29uc3QgdmFsaWRhdGVDb2RlID0gZ2VuLnRvU3RyaW5nKCk7XG4gICAgICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKG5hbWVzXzEuZGVmYXVsdC5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKChjb2RlU2l6ZSArPSBzb3VyY2VDb2RlLmxlbmd0aCksIChub2RlQ291bnQgKz0gZ2VuLm5vZGVDb3VudCkpXG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKVxuICAgICAgICAgICAgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgICAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7bmFtZXNfMS5kZWZhdWx0LnNlbGZ9YCwgYCR7bmFtZXNfMS5kZWZhdWx0LnNjb3BlfWAsIHNvdXJjZUNvZGUpO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKTtcbiAgICAgICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHsgcmVmOiB2YWxpZGF0ZSB9KTtcbiAgICAgICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYTtcbiAgICAgICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoO1xuICAgICAgICBpZiAoc2NoLiRhc3luYylcbiAgICAgICAgICAgIHZhbGlkYXRlLiRhc3luYyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHsgdmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGl0ZW1zIH0gPSBzY2hlbWFDeHQ7XG4gICAgICAgICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgICAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBjb2RlZ2VuXzEuTmFtZSxcbiAgICAgICAgICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgY29kZWdlbl8xLk5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlLnNvdXJjZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gY29kZWdlbl8xLnN0cmluZ2lmeSh2YWxpZGF0ZS5ldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuICAgICAgICByZXR1cm4gc2NoO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlO1xuICAgICAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZTtcbiAgICAgICAgaWYgKHNvdXJjZUNvZGUpXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKTtcbiAgICB9XG59XG5leHBvcnRzLmNvbXBpbGVTY2hlbWEgPSBjb21waWxlU2NoZW1hO1xuZnVuY3Rpb24gcmVzb2x2ZVJlZihyb290LCBiYXNlSWQsIHJlZikge1xuICAgIHZhciBfYTtcbiAgICByZWYgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHJlZik7XG4gICAgY29uc3Qgc2NoT3JGdW5jID0gcm9vdC5yZWZzW3JlZl07XG4gICAgaWYgKHNjaE9yRnVuYylcbiAgICAgICAgcmV0dXJuIHNjaE9yRnVuYztcbiAgICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpO1xuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gKF9hID0gcm9vdC5sb2NhbFJlZnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtyZWZdOyAvLyBUT0RPIG1heWJlIGxvY2FsUmVmcyBzaG91bGQgaG9sZCBTY2hlbWFFbnZcbiAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICBpZiAoc2NoZW1hKVxuICAgICAgICAgICAgX3NjaCA9IG5ldyBTY2hlbWFFbnYoeyBzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWQgfSk7XG4gICAgfVxuICAgIGlmIChfc2NoID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpO1xufVxuZXhwb3J0cy5yZXNvbHZlUmVmID0gcmVzb2x2ZVJlZjtcbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZShzY2gpIHtcbiAgICBpZiAocmVzb2x2ZV8xLmlubGluZVJlZihzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpXG4gICAgICAgIHJldHVybiBzY2guc2NoZW1hO1xuICAgIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKTtcbn1cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYShzY2hFbnYpIHtcbiAgICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICAgICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaDtcbiAgICB9XG59XG5leHBvcnRzLmdldENvbXBpbGluZ1NjaGVtYSA9IGdldENvbXBpbGluZ1NjaGVtYTtcbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczEsIHMyKSB7XG4gICAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWQ7XG59XG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShyb290LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxucmVmIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pIHtcbiAgICBsZXQgc2NoO1xuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZWYgPSBzY2g7XG4gICAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKTtcbn1cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5mdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbnJlZiAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKSB7XG4gICAgY29uc3QgcCA9IFVSSS5wYXJzZShyZWYpO1xuICAgIGNvbnN0IHJlZlBhdGggPSByZXNvbHZlXzEuX2dldEZ1bGxQYXRoKHApO1xuICAgIGxldCBiYXNlSWQgPSByZXNvbHZlXzEuZ2V0RnVsbFBhdGgocm9vdC5iYXNlSWQpO1xuICAgIC8vIFRPRE8gYE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwYCBzaG91bGQgbm90IGJlIG5lZWRlZCAtIGJ1dCByZW1vdmluZyBicmVha3MgMiB0ZXN0c1xuICAgIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgcm9vdCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZlBhdGgpO1xuICAgIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdO1xuICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpO1xuICAgICAgICBpZiAodHlwZW9mIChzY2ggPT09IG51bGwgfHwgc2NoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY2guc2NoZW1hKSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoc2NoT3JSZWYgPT09IG51bGwgfHwgc2NoT3JSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjaE9yUmVmLnNjaGVtYSkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKVxuICAgICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpO1xuICAgIGlmIChpZCA9PT0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKHJlZikpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHNjaE9yUmVmO1xuICAgICAgICBjb25zdCB7IHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXTtcbiAgICAgICAgaWYgKHNjaElkKVxuICAgICAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hJZCk7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZik7XG59XG5leHBvcnRzLnJlc29sdmVTY2hlbWEgPSByZXNvbHZlU2NoZW1hO1xuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG5dKTtcbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKHBhcnNlZFJlZiwgeyBiYXNlSWQsIHNjaGVtYSwgcm9vdCB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICgoKF9hID0gcGFyc2VkUmVmLmZyYWdtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSBcIi9cIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWFbdXRpbF8xLnVuZXNjYXBlRnJhZ21lbnQocGFydCldO1xuICAgICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICAgICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF07XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICAgICAgICBiYXNlSWQgPSByZXNvbHZlXzEucmVzb2x2ZVVybChiYXNlSWQsIHNjaElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZW52O1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICF1dGlsXzEuc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgICAgICBjb25zdCAkcmVmID0gcmVzb2x2ZV8xLnJlc29sdmVVcmwoYmFzZUlkLCBzY2hlbWEuJHJlZik7XG4gICAgICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKTtcbiAgICB9XG4gICAgLy8gZXZlbiB0aG91Z2ggcmVzb2x1dGlvbiBmYWlsZWQgd2UgbmVlZCB0byByZXR1cm4gU2NoZW1hRW52IHRvIHRocm93IGV4Y2VwdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICBlbnYgPSBlbnYgfHwgbmV3IFNjaGVtYUVudih7IHNjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZCB9KTtcbiAgICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKVxuICAgICAgICByZXR1cm4gZW52O1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUdlbiA9IGV4cG9ydHMuTmFtZSA9IGV4cG9ydHMubmlsID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuXyA9IGV4cG9ydHMuS2V5d29yZEN4dCA9IHZvaWQgMDtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG5jb25zdCB2YWxpZGF0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIik7XG5jb25zdCByZWZfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgcnVsZXNfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvcnVsZXNcIik7XG5jb25zdCBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlXCIpO1xuY29uc3QgY29kZWdlbl8yID0gcmVxdWlyZShcIi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgcmVzb2x2ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS9yZXNvbHZlXCIpO1xuY29uc3QgZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCAkZGF0YVJlZlNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvZGF0YS5qc29uXCIpO1xuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdO1xuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwic2VyaWFsaXplXCIsXG4gICAgXCJwYXJzZVwiLFxuICAgIFwid3JhcHBlclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwic2NoZW1hXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRzXCIsXG4gICAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gICAgXCJmdW5jXCIsXG4gICAgXCJvYmpcIixcbiAgICBcIkVycm9yXCIsXG5dKTtcbmNvbnN0IHJlbW92ZWRPcHRpb25zID0ge1xuICAgIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gICAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAgICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gICAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICAgIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICAgIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gICAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gICAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gICAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICAgIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICAgIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn07XG5jb25zdCBkZXByZWNhdGVkT3B0aW9ucyA9IHtcbiAgICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gICAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59O1xuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG8pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3IsIF9zLCBfdCwgX3UsIF92LCBfdywgX3g7XG4gICAgY29uc3QgcyA9IG8uc3RyaWN0O1xuICAgIGNvbnN0IF9vcHR6ID0gKF9hID0gby5jb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3B0aW1pemU7XG4gICAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiAoX2MgPSAoX2IgPSBvLnN0cmljdFNjaGVtYSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZSxcbiAgICAgICAgc3RyaWN0TnVtYmVyczogKF9lID0gKF9kID0gby5zdHJpY3ROdW1iZXJzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlLFxuICAgICAgICBzdHJpY3RUeXBlczogKF9nID0gKF9mID0gby5zdHJpY3RUeXBlcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0VHVwbGVzOiAoX2ogPSAoX2ggPSBvLnN0cmljdFR1cGxlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogcykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogXCJsb2dcIixcbiAgICAgICAgc3RyaWN0UmVxdWlyZWQ6IChfbCA9IChfayA9IG8uc3RyaWN0UmVxdWlyZWQpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHMpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IGZhbHNlLFxuICAgICAgICBjb2RlOiBvLmNvZGUgPyB7IC4uLm8uY29kZSwgb3B0aW1pemUgfSA6IHsgb3B0aW1pemUgfSxcbiAgICAgICAgbG9vcFJlcXVpcmVkOiAoX20gPSBvLmxvb3BSZXF1aXJlZCkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogTUFYX0VYUFJFU1NJT04sXG4gICAgICAgIGxvb3BFbnVtOiAoX28gPSBvLmxvb3BFbnVtKSAhPT0gbnVsbCAmJiBfbyAhPT0gdm9pZCAwID8gX28gOiBNQVhfRVhQUkVTU0lPTixcbiAgICAgICAgbWV0YTogKF9wID0gby5tZXRhKSAhPT0gbnVsbCAmJiBfcCAhPT0gdm9pZCAwID8gX3AgOiB0cnVlLFxuICAgICAgICBtZXNzYWdlczogKF9xID0gby5tZXNzYWdlcykgIT09IG51bGwgJiYgX3EgIT09IHZvaWQgMCA/IF9xIDogdHJ1ZSxcbiAgICAgICAgaW5saW5lUmVmczogKF9yID0gby5pbmxpbmVSZWZzKSAhPT0gbnVsbCAmJiBfciAhPT0gdm9pZCAwID8gX3IgOiB0cnVlLFxuICAgICAgICBzY2hlbWFJZDogKF9zID0gby5zY2hlbWFJZCkgIT09IG51bGwgJiYgX3MgIT09IHZvaWQgMCA/IF9zIDogXCIkaWRcIixcbiAgICAgICAgYWRkVXNlZFNjaGVtYTogKF90ID0gby5hZGRVc2VkU2NoZW1hKSAhPT0gbnVsbCAmJiBfdCAhPT0gdm9pZCAwID8gX3QgOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZVNjaGVtYTogKF91ID0gby52YWxpZGF0ZVNjaGVtYSkgIT09IG51bGwgJiYgX3UgIT09IHZvaWQgMCA/IF91IDogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGVGb3JtYXRzOiAoX3YgPSBvLnZhbGlkYXRlRm9ybWF0cykgIT09IG51bGwgJiYgX3YgIT09IHZvaWQgMCA/IF92IDogdHJ1ZSxcbiAgICAgICAgdW5pY29kZVJlZ0V4cDogKF93ID0gby51bmljb2RlUmVnRXhwKSAhPT0gbnVsbCAmJiBfdyAhPT0gdm9pZCAwID8gX3cgOiB0cnVlLFxuICAgICAgICBpbnQzMnJhbmdlOiAoX3ggPSBvLmludDMycmFuZ2UpICE9PSBudWxsICYmIF94ICE9PSB2b2lkIDAgPyBfeCA6IHRydWUsXG4gICAgfTtcbn1cbmNsYXNzIEFqdiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZnMgPSB7fTtcbiAgICAgICAgdGhpcy5mb3JtYXRzID0ge307XG4gICAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgb3B0cyA9IHRoaXMub3B0cyA9IHsgLi4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpIH07XG4gICAgICAgIGNvbnN0IHsgZXM1LCBsaW5lcyB9ID0gdGhpcy5vcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBuZXcgY29kZWdlbl8yLlZhbHVlU2NvcGUoeyBzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXMgfSk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKTtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHM7XG4gICAgICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuUlVMRVMgPSBydWxlc18xLmdldFJ1bGVzKCk7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIik7XG4gICAgICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpO1xuICAgICAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmZvcm1hdHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKTtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKG9wdHMua2V5d29yZHMpXG4gICAgICAgICAgICBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpO1xuICAgICAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpO1xuICAgICAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdDtcbiAgICB9XG4gICAgX2FkZFZvY2FidWxhcmllcygpIHtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpO1xuICAgIH1cbiAgICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKSB7XG4gICAgICAgIGNvbnN0IHsgJGRhdGEsIG1ldGEsIHNjaGVtYUlkIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIGxldCBfZGF0YVJlZlNjaGVtYSA9ICRkYXRhUmVmU2NoZW1hO1xuICAgICAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7IC4uLiRkYXRhUmVmU2NoZW1hIH07XG4gICAgICAgICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZDtcbiAgICAgICAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEgJiYgJGRhdGEpXG4gICAgICAgICAgICB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0TWV0YSgpIHtcbiAgICAgICAgY29uc3QgeyBtZXRhLCBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgZGF0YSAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgICApIHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5jb21waWxlKHNjaGVtYUtleVJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpO1xuICAgICAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKVxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSB2LmVycm9ycztcbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICBjb21waWxlKHNjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpO1xuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICBjb21waWxlQXN5bmMoc2NoZW1hLCBtZXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsb2FkU2NoZW1hIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoX3NjaGVtYSwgX21ldGEpIHtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKCRyZWYpIHtcbiAgICAgICAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHsgJHJlZiB9LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHNjaCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgcmVmX2Vycm9yXzEuZGVmYXVsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHsgbWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmIH0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSlcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEocmVmKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdO1xuICAgICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gICAgYWRkU2NoZW1hKHNjaGVtYSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXksIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGEsIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChrZXkgfHwgaWQpO1xuICAgICAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpO1xuICAgICAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICAgIGFkZE1ldGFTY2hlbWEoc2NoZW1hLCBrZXksIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICAgICkge1xuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgICB2YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgJHNjaGVtYTtcbiAgICAgICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgICAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpO1xuICAgICAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9XG4gICAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgICBnZXRTY2hlbWEoa2V5UmVmKSB7XG4gICAgICAgIGxldCBzY2g7XG4gICAgICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBrZXlSZWYgPSBzY2g7XG4gICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFJZCB9ID0gdGhpcy5vcHRzO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hOiB7fSwgc2NoZW1hSWQgfSk7XG4gICAgICAgICAgICBzY2ggPSBjb21waWxlXzEucmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZik7XG4gICAgICAgICAgICBpZiAoIXNjaClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gICAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICAgIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWYpIHtcbiAgICAgICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdO1xuICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IHJlc29sdmVfMS5ub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICAgIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpXG4gICAgICAgICAgICB0aGlzLmFkZEtleXdvcmQoZGVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEtleXdvcmQoa3dkT3JEZWYsIGRlZiAvLyBkZXByZWNhdGVkXG4gICAgKSB7XG4gICAgICAgIGxldCBrZXl3b3JkO1xuICAgICAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGtleXdvcmQgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIik7XG4gICAgICAgICAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWYgPSBrd2RPckRlZjtcbiAgICAgICAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpO1xuICAgICAgICBpZiAoIWRlZikge1xuICAgICAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi50eXBlKSxcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZi5zY2hlbWFUeXBlKSxcbiAgICAgICAgfTtcbiAgICAgICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGU7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBrZXl3b3JkXG4gICAgcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgICAgICBjb25zdCB7IFJVTEVTIH0gPSB0aGlzO1xuICAgICAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF07XG4gICAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZCk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQWRkIGZvcm1hdFxuICAgIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXJyb3JzVGV4dChlcnJvcnMgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7IHNlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwiIH0gPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICAgKSB7XG4gICAgICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gXCJObyBlcnJvcnNcIjtcbiAgICAgICAgcmV0dXJuIGVycm9yc1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKTtcbiAgICB9XG4gICAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGw7XG4gICAgICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSk7IC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpXG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZGF0YSB9ID0gcnVsZS5kZWZpbml0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhU2NoZW1hO1xuICAgIH1cbiAgICBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzLCByZWdleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9hZGRTY2hlbWEoc2NoZW1hLCBtZXRhLCBiYXNlSWQsIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLCBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYSkge1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hSWQgfSA9IHRoaXMub3B0cztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5qdGQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBzY2g7XG4gICAgICAgIGNvbnN0IGxvY2FsUmVmcyA9IHJlc29sdmVfMS5nZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hKTtcbiAgICAgICAgYmFzZUlkID0gcmVzb2x2ZV8xLm5vcm1hbGl6ZUlkKGlkIHx8IGJhc2VJZCk7XG4gICAgICAgIHNjaCA9IG5ldyBjb21waWxlXzEuU2NoZW1hRW52KHsgc2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnMgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpO1xuICAgICAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICAgICAgICBpZiAoYmFzZUlkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZCk7XG4gICAgICAgICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzY2g7XG4gICAgfVxuICAgIF9jaGVja1VuaXF1ZShpZCkge1xuICAgICAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29tcGlsZVNjaGVtYUVudihzY2gpIHtcbiAgICAgICAgaWYgKHNjaC5tZXRhKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzY2gudmFsaWRhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIik7XG4gICAgICAgIHJldHVybiBzY2gudmFsaWRhdGU7XG4gICAgfVxuICAgIF9jb21waWxlTWV0YVNjaGVtYShzY2gpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHM7XG4gICAgICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGlsZV8xLmNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBanY7XG5BanYuVmFsaWRhdGlvbkVycm9yID0gdmFsaWRhdGlvbl9lcnJvcl8xLmRlZmF1bHQ7XG5BanYuTWlzc2luZ1JlZkVycm9yID0gcmVmX2Vycm9yXzEuZGVmYXVsdDtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhjaGVja09wdHMsIG9wdGlvbnMsIG1zZywgbG9nID0gXCJlcnJvclwiKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IGtleTtcbiAgICAgICAgaWYgKG9wdCBpbiBvcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNjaEVudihrZXlSZWYpIHtcbiAgICBrZXlSZWYgPSByZXNvbHZlXzEubm9ybWFsaXplSWQoa2V5UmVmKTsgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdO1xufVxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoKSB7XG4gICAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hcztcbiAgICBpZiAoIW9wdHNTY2hlbWFzKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcyk7XG4gICAgZWxzZVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcylcbiAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0sIGtleSk7XG59XG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cygpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV07XG4gICAgICAgIGlmIChmb3JtYXQpXG4gICAgICAgICAgICB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhkZWZzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICAgICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIik7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXTtcbiAgICAgICAgaWYgKCFkZWYua2V5d29yZClcbiAgICAgICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRlZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnMoKSB7XG4gICAgY29uc3QgbWV0YU9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpXG4gICAgICAgIGRlbGV0ZSBtZXRhT3B0c1tvcHRdO1xuICAgIHJldHVybiBtZXRhT3B0cztcbn1cbmNvbnN0IG5vTG9ncyA9IHsgbG9nKCkgeyB9LCB3YXJuKCkgeyB9LCBlcnJvcigpIHsgfSB9O1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcikge1xuICAgIGlmIChsb2dnZXIgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gbm9Mb2dzO1xuICAgIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGU7XG4gICAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIik7XG59XG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pO1xuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKGtleXdvcmQsIGRlZikge1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgdXRpbF8xLmVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICAgICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApO1xuICAgICAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKTtcbiAgICB9KTtcbiAgICBpZiAoIWRlZilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRSdWxlKGtleXdvcmQsIGRlZmluaXRpb24sIGRhdGFUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uID09PSBudWxsIHx8IGRlZmluaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlZmluaXRpb24ucG9zdDtcbiAgICBpZiAoZGF0YVR5cGUgJiYgcG9zdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpO1xuICAgIGNvbnN0IHsgUlVMRVMgfSA9IHRoaXM7XG4gICAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoeyB0eXBlOiB0IH0pID0+IHQgPT09IGRhdGFUeXBlKTtcbiAgICBpZiAoIXJ1bGVHcm91cCkge1xuICAgICAgICBydWxlR3JvdXAgPSB7IHR5cGU6IGRhdGFUeXBlLCBydWxlczogW10gfTtcbiAgICAgICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApO1xuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWU7XG4gICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHR5cGU6IGRhdGFUeXBlXzEuZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICAgICAgICBzY2hlbWFUeXBlOiBkYXRhVHlwZV8xLmdldEpTT05UeXBlcyhkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKGRlZmluaXRpb24uYmVmb3JlKVxuICAgICAgICBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSk7XG4gICAgZWxzZVxuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlO1xuICAgIChfYSA9IGRlZmluaXRpb24uaW1wbGVtZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpO1xufVxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZShydWxlR3JvdXAsIHJ1bGUsIGJlZm9yZSkge1xuICAgIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICB9XG59XG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYShkZWYpIHtcbiAgICBsZXQgeyBtZXRhU2NoZW1hIH0gPSBkZWY7XG4gICAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKVxuICAgICAgICBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpO1xuICAgIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKTtcbn1cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAgICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59O1xuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYSkge1xuICAgIHJldHVybiB7IGFueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl0gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpZFwiLFxuICAgIGNvZGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsUmVmID0gZXhwb3J0cy5nZXRWYWxpZGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHJlZl9lcnJvcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgbmFtZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL25hbWVzXCIpO1xuY29uc3QgY29tcGlsZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiJHJlZlwiLFxuICAgIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYTogJHJlZiwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGYgfSA9IGl0O1xuICAgICAgICBjb25zdCB7IHJvb3QgfSA9IGVudjtcbiAgICAgICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbFJvb3RSZWYoKTtcbiAgICAgICAgY29uc3Qgc2NoT3JFbnYgPSBjb21waWxlXzEucmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZik7XG4gICAgICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHJlZl9lcnJvcl8xLmRlZmF1bHQoYmFzZUlkLCAkcmVmKTtcbiAgICAgICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgY29tcGlsZV8xLlNjaGVtYUVudilcbiAgICAgICAgICAgIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpO1xuICAgICAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KTtcbiAgICAgICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKSB7XG4gICAgICAgICAgICBpZiAoZW52ID09PSByb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwgeyByZWY6IHJvb3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFJlZihjeHQsIGNvZGVnZW5fMS5fIGAke3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpO1xuICAgICAgICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFwic2NoZW1hXCIsIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7IHJlZjogc2NoLCBjb2RlOiBjb2RlZ2VuXzEuc3RyaW5naWZ5KHNjaCkgfSA6IHsgcmVmOiBzY2ggfSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGg6IGNvZGVnZW5fMS5uaWwsXG4gICAgICAgICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgICAgICB9LCB2YWxpZCk7XG4gICAgICAgICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dCwgc2NoKSB7XG4gICAgY29uc3QgeyBnZW4gfSA9IGN4dDtcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7IHJlZjogc2NoLnZhbGlkYXRlIH0pXG4gICAgICAgIDogY29kZWdlbl8xLl8gYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHsgcmVmOiBzY2ggfSl9LnZhbGlkYXRlYDtcbn1cbmV4cG9ydHMuZ2V0VmFsaWRhdGUgPSBnZXRWYWxpZGF0ZTtcbmZ1bmN0aW9uIGNhbGxSZWYoY3h0LCB2LCBzY2gsICRhc3luYykge1xuICAgIGNvbnN0IHsgZ2VuLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHsgYWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0cyB9ID0gaXQ7XG4gICAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBuYW1lc18xLmRlZmF1bHQudGhpcyA6IGNvZGVnZW5fMS5uaWw7XG4gICAgaWYgKCRhc3luYylcbiAgICAgICAgY2FsbEFzeW5jUmVmKCk7XG4gICAgZWxzZVxuICAgICAgICBjYWxsU3luY1JlZigpO1xuICAgIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpIHtcbiAgICAgICAgaWYgKCFlbnYuJGFzeW5jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICBnZW4udHJ5KCgpID0+IHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGBhd2FpdCAke2NvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCl9YCk7XG4gICAgICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpOyAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpO1xuICAgICAgICAgICAgYWRkRXJyb3JzRnJvbShlKTtcbiAgICAgICAgICAgIGlmICghYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCkge1xuICAgICAgICBjeHQucmVzdWx0KGNvZGVfMS5jYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCksICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksICgpID0+IGFkZEVycm9yc0Zyb20odikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlcnJzID0gY29kZWdlbl8xLl8gYCR7c291cmNlfS5lcnJvcnNgO1xuICAgICAgICBnZW4uYXNzaWduKG5hbWVzXzEuZGVmYXVsdC52RXJyb3JzLCBjb2RlZ2VuXzEuXyBgJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtuYW1lc18xLmRlZmF1bHQudkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCk7IC8vIFRPRE8gdGFnZ2VkXG4gICAgICAgIGdlbi5hc3NpZ24obmFtZXNfMS5kZWZhdWx0LmVycm9ycywgY29kZWdlbl8xLl8gYCR7bmFtZXNfMS5kZWZhdWx0LnZFcnJvcnN9Lmxlbmd0aGApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gKF9hID0gc2NoID09PSBudWxsIHx8IHNjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoLnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZhbHVhdGVkO1xuICAgICAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpdC5wcm9wcyA9IHV0aWxfMS5tZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIGNvZGVnZW5fMS5fIGAke3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYCk7XG4gICAgICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIGNvZGVnZW5fMS5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuaXRlbXMgPSB1dGlsXzEubWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCBjb2RlZ2VuXzEuXyBgJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApO1xuICAgICAgICAgICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBjb2RlZ2VuXzEuTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNhbGxSZWYgPSBjYWxsUmVmO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaWRfMSA9IHJlcXVpcmUoXCIuL2lkXCIpO1xuY29uc3QgcmVmXzEgPSByZXF1aXJlKFwiLi9yZWZcIik7XG5jb25zdCBjb3JlID0gW1xuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJGlkXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICB7IGtleXdvcmQ6IFwiJGNvbW1lbnRcIiB9LFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICBpZF8xLmRlZmF1bHQsXG4gICAgcmVmXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3Qgb3BzID0gY29kZWdlbl8xLm9wZXJhdG9ycztcbmNvbnN0IEtXRHMgPSB7XG4gICAgbWF4aW11bTogeyBva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUIH0sXG4gICAgbWluaW11bTogeyBva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUIH0sXG4gICAgZXhjbHVzaXZlTWF4aW11bTogeyBva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEUgfSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB7IG9rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURSB9LFxufTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBiZSAke0tXRHNba2V5d29yZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfSAke0tXRHNba2V5d29yZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXROdW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdCB9ID0gY3h0O1xuICAgICAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb247XG4gICAgICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIik7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGBNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGlwbGVPZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZnVuY3Rpb24gdWNzMmxlbmd0aChzdHIpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCB2YWx1ZTtcbiAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApXG4gICAgICAgICAgICAgICAgcG9zKys7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdWNzMmxlbmd0aDtcbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWNzMmxlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgdWNzMmxlbmd0aF8xID0gcmVxdWlyZShcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2A7XG4gICAgfSxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsga2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gY29kZWdlbl8xLm9wZXJhdG9ycy5HVCA6IGNvZGVnZW5fMS5vcGVyYXRvcnMuTFQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgIDogY29kZWdlbl8xLl8gYCR7dXRpbF8xLnVzZUZ1bmMoY3h0LmdlbiwgdWNzMmxlbmd0aF8xLmRlZmF1bHQpfSgke2RhdGF9KWA7XG4gICAgICAgIGN4dC5mYWlsJGRhdGEoY29kZWdlbl8xLl8gYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW1pdExlbmd0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICAgICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIjtcbiAgICAgICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyBjb2RlZ2VuXzEuXyBgKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IGNvZGVfMS51c2VQYXR0ZXJuKGN4dCwgc2NoZW1hKTtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2UoeyBrZXl3b3JkLCBzY2hlbWFDb2RlIH0pIHtcbiAgICAgICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IGNvZGVnZW5fMS5vcGVyYXRvcnMuR1QgOiBjb2RlZ2VuXzEub3BlcmF0b3JzLkxUO1xuICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5fIGBPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6ICh7IHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHkgfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkO1xuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgYWxsRXJyb3JzTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBleGl0T25FcnJvck1vZGUoKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY29uc3QgeyBkZWZpbmVkUHJvcGVydGllcyB9ID0gY3h0Lml0O1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BzID09PSBudWxsIHx8IHByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9wc1tyZXF1aXJlZEtleV0pID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgO1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCkge1xuICAgICAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgICAgICBjeHQuYmxvY2skZGF0YShjb2RlZ2VuXzEubmlsLCBsb29wQWxsUmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb2RlXzEuY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgICAgICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSk7XG4gICAgICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlXzEuY2hlY2tNaXNzaW5nUHJvcChjeHQsIHNjaGVtYSwgbWlzc2luZykpO1xuICAgICAgICAgICAgICAgIGNvZGVfMS5yZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpO1xuICAgICAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCkge1xuICAgICAgICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBtaXNzaW5nUHJvcGVydHk6IHByb3AgfSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVfMS5ub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkge1xuICAgICAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pc3NpbmdQcm9wZXJ0eTogbWlzc2luZyB9KTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihtaXNzaW5nLCBzY2hlbWFDb2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN4dC5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvZGVnZW5fMS5uaWwpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1aXJlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSB7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIjtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5zdHIgYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgO1xuICAgIH0sXG4gICAgcGFyYW1zOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5fIGB7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGtleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUgfSA9IGN4dDtcbiAgICAgICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBjb2RlZ2VuXzEub3BlcmF0b3JzLkdUIDogY29kZWdlbl8xLm9wZXJhdG9ycy5MVDtcbiAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGltaXRJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5jb25zdCBlcXVhbCA9IHJlcXVpcmUoXCJmYXN0LWRlZXAtZXF1YWxcIik7XG5lcXVhbC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnO1xuZXhwb3J0cy5kZWZhdWx0ID0gZXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcXVhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsgcGFyYW1zOiB7IGksIGogfSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgaSwgaiB9IH0pID0+IGNvZGVnZW5fMS5fIGB7aTogJHtpfSwgajogJHtqfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAgICRkYXRhOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIik7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/IGRhdGFUeXBlXzEuZ2V0U2NoZW1hVHlwZXMocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdO1xuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgY29kZWdlbl8xLl8gYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYCk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ubGVuZ3RoYCk7XG4gICAgICAgICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIik7XG4gICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaSwgaiB9KTtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTihpLCBqKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpO1xuICAgICAgICAgICAgY29uc3Qgd3JvbmdUeXBlID0gZGF0YVR5cGVfMS5jaGVja0RhdGFUeXBlcyhpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgZGF0YVR5cGVfMS5EYXRhVHlwZS5Xcm9uZyk7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCBjb2RlZ2VuXzEuXyBge31gKTtcbiAgICAgICAgICAgIGdlbi5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5sZXQoaXRlbSwgY29kZWdlbl8xLl8gYCR7ZGF0YX1bJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCBjb2RlZ2VuXzEuXyBgY29udGludWVgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsIGNvZGVnZW5fMS5fIGAke2l0ZW19ICs9IFwiX1wiYCk7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBjb2RlZ2VuXzEuXyBgJHtpbmRpY2VzfVske2l0ZW19XWApO1xuICAgICAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNvZGUoY29kZWdlbl8xLl8gYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsb29wTjIoaSwgaikge1xuICAgICAgICAgICAgY29uc3QgZXFsID0gdXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpO1xuICAgICAgICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoY29kZWdlbl8xLl8gYDske2l9LS07YCwgKCkgPT4gZ2VuLmZvcihjb2RlZ2VuXzEuXyBgJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PiBnZW4uaWYoY29kZWdlbl8xLl8gYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlSXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVxdWFsXzEgPSByZXF1aXJlKFwiLi4vLi4vcnVudGltZS9lcXVhbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICAgIHBhcmFtczogKHsgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuXyBge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICAgJGRhdGE6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWEgfSA9IGN4dDtcbiAgICAgICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEuXyBgISR7dXRpbF8xLnVzZUZ1bmMoZ2VuLCBlcXVhbF8xLmRlZmF1bHQpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3h0LmZhaWwoY29kZWdlbl8xLl8gYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXF1YWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ydW50aW1lL2VxdWFsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZW51bVwiLFxuICAgIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXQgfSA9IGN4dDtcbiAgICAgICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpO1xuICAgICAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtO1xuICAgICAgICBjb25zdCBlcWwgPSB1dGlsXzEudXNlRnVuYyhnZW4sIGVxdWFsXzEuZGVmYXVsdCk7XG4gICAgICAgIGxldCB2YWxpZDtcbiAgICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpO1xuICAgICAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSk7XG4gICAgICAgICAgICB2YWxpZCA9IGNvZGVnZW5fMS5vciguLi5zY2hlbWEubWFwKChfeCwgaSkgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3h0LnBhc3ModmFsaWQpO1xuICAgICAgICBmdW5jdGlvbiBsb29wRW51bSgpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSwgKHYpID0+IGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtlcWx9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAke2VxbH0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgICAgICAgICAgOiBjb2RlZ2VuXzEuXyBgJHtkYXRhfSA9PT0gJHtzY2h9YDtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxpbWl0TnVtYmVyXzEgPSByZXF1aXJlKFwiLi9saW1pdE51bWJlclwiKTtcbmNvbnN0IG11bHRpcGxlT2ZfMSA9IHJlcXVpcmUoXCIuL211bHRpcGxlT2ZcIik7XG5jb25zdCBsaW1pdExlbmd0aF8xID0gcmVxdWlyZShcIi4vbGltaXRMZW5ndGhcIik7XG5jb25zdCBwYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9wYXR0ZXJuXCIpO1xuY29uc3QgbGltaXRQcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9saW1pdFByb3BlcnRpZXNcIik7XG5jb25zdCByZXF1aXJlZF8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWRcIik7XG5jb25zdCBsaW1pdEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9saW1pdEl0ZW1zXCIpO1xuY29uc3QgdW5pcXVlSXRlbXNfMSA9IHJlcXVpcmUoXCIuL3VuaXF1ZUl0ZW1zXCIpO1xuY29uc3QgY29uc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnN0XCIpO1xuY29uc3QgZW51bV8xID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbmNvbnN0IHZhbGlkYXRpb24gPSBbXG4gICAgLy8gbnVtYmVyXG4gICAgbGltaXROdW1iZXJfMS5kZWZhdWx0LFxuICAgIG11bHRpcGxlT2ZfMS5kZWZhdWx0LFxuICAgIC8vIHN0cmluZ1xuICAgIGxpbWl0TGVuZ3RoXzEuZGVmYXVsdCxcbiAgICBwYXR0ZXJuXzEuZGVmYXVsdCxcbiAgICAvLyBvYmplY3RcbiAgICBsaW1pdFByb3BlcnRpZXNfMS5kZWZhdWx0LFxuICAgIHJlcXVpcmVkXzEuZGVmYXVsdCxcbiAgICAvLyBhcnJheVxuICAgIGxpbWl0SXRlbXNfMS5kZWZhdWx0LFxuICAgIHVuaXF1ZUl0ZW1zXzEuZGVmYXVsdCxcbiAgICAvLyBhbnlcbiAgICB7IGtleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXSB9LFxuICAgIHsga2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIiB9LFxuICAgIGNvbnN0XzEuZGVmYXVsdCxcbiAgICBlbnVtXzEuZGVmYXVsdCxcbl07XG5leHBvcnRzLmRlZmF1bHQgPSB2YWxpZGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zID0gdm9pZCAwO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBpdGVtcyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKSB7XG4gICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICBpdC5pdGVtcyA9IHRydWU7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoeyBsZW46IGl0ZW1zLmxlbmd0aCB9KTtcbiAgICAgICAgY3h0LnBhc3MoY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgY29kZWdlbl8xLl8gYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKTsgLy8gVE9ETyB2YXJcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQpIHtcbiAgICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0gfSwgdmFsaWQpO1xuICAgICAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMgPSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcztcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxJdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZvaWQgMDtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSk7XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShjeHQsIGV4dHJhSXRlbXMsIHNjaEFyciA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICAgIGl0Lml0ZW1zID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIGNvZGVnZW5fMS5fIGAke2RhdGF9Lmxlbmd0aGApO1xuICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgaWYgKHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2xlbn0gPiAke2l9YCwgKCkgPT4gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LCB2YWxpZCkpO1xuICAgICAgICBjeHQub2sodmFsaWQpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCB9ID0gaXQ7XG4gICAgICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoO1xuICAgICAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUdXBsZSA9IHZhbGlkYXRlVHVwbGU7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVtcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGl0ZW1zXzEgPSByZXF1aXJlKFwiLi9pdGVtc1wiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGNvZGU6IChjeHQpID0+IGl0ZW1zXzEudmFsaWRhdGVUdXBsZShjeHQsIFwiaXRlbXNcIiksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4SXRlbXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgYWRkaXRpb25hbEl0ZW1zXzEgPSByZXF1aXJlKFwiLi9hZGRpdGlvbmFsSXRlbXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbGVuIH0gfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgICBwYXJhbXM6ICh7IHBhcmFtczogeyBsZW4gfSB9KSA9PiBjb2RlZ2VuXzEuXyBge2xpbWl0OiAke2xlbn19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJpdGVtc1wiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4SXRlbXMgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaXQuaXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocHJlZml4SXRlbXMpXG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbXNfMS52YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIHByZWZpeEl0ZW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY3h0Lm9rKGNvZGVfMS52YWxpZGF0ZUFycmF5KGN4dCkpO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlbXMyMDIwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgbWluLCBtYXggfSB9KSA9PiBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGNvZGVnZW5fMS5zdHIgYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgICAgOiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IG1pbiwgbWF4IH0gfSkgPT4gbWF4ID09PSB1bmRlZmluZWQgPyBjb2RlZ2VuXzEuXyBge21pbkNvbnRhaW5zOiAke21pbn19YCA6IGNvZGVnZW5fMS5fIGB7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgdHJhY2tFcnJvcnM6IHRydWUsXG4gICAgZXJyb3IsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdCB9ID0gY3h0O1xuICAgICAgICBsZXQgbWluO1xuICAgICAgICBsZXQgbWF4O1xuICAgICAgICBjb25zdCB7IG1pbkNvbnRhaW5zLCBtYXhDb250YWlucyB9ID0gcGFyZW50U2NoZW1hO1xuICAgICAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICAgICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zO1xuICAgICAgICAgICAgbWF4ID0gbWF4Q29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW4gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBjb2RlZ2VuXzEuXyBgJHtkYXRhfS5sZW5ndGhgKTtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7IG1pbiwgbWF4IH0pO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICAgICAgICB1dGlsXzEuY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGxldCBjb25kID0gY29kZWdlbl8xLl8gYCR7bGVufSA+PSAke21pbn1gO1xuICAgICAgICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbmQgPSBjb2RlZ2VuXzEuXyBgJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YDtcbiAgICAgICAgICAgIGN4dC5wYXNzKGNvbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGl0Lml0ZW1zID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMCk7XG4gICAgICAgICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQsIGJsb2NrKSB7XG4gICAgICAgICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiB1dGlsXzEuVHlwZS5OdW0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSwgX3ZhbGlkKTtcbiAgICAgICAgICAgICAgICBibG9jaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQpIHtcbiAgICAgICAgICAgIGdlbi5jb2RlKGNvZGVnZW5fMS5fIGAke2NvdW50fSsrYCk7XG4gICAgICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGAke2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSAxKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVTY2hlbWFEZXBzID0gZXhwb3J0cy52YWxpZGF0ZVByb3BlcnR5RGVwcyA9IGV4cG9ydHMuZXJyb3IgPSB2b2lkIDA7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuZXhwb3J0cy5lcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgcHJvcGVydHksIGRlcHNDb3VudCwgZGVwcyB9IH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCI7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuXzEuc3RyIGBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YDtcbiAgICB9LFxuICAgIHBhcmFtczogKHsgcGFyYW1zOiB7IHByb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eSB9IH0pID0+IGNvZGVnZW5fMS5fIGB7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICAgIGVycm9yOiBleHBvcnRzLmVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpO1xuICAgICAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKTtcbiAgICAgICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcyk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7IHNjaGVtYSB9KSB7XG4gICAgY29uc3QgcHJvcGVydHlEZXBzID0ge307XG4gICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHM7XG4gICAgICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BlcnR5RGVwcyA9IGN4dC5zY2hlbWEpIHtcbiAgICBjb25zdCB7IGdlbiwgZGF0YSwgaXQgfSA9IGN4dDtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIik7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgICAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdO1xuICAgICAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSBjb2RlXzEucHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZV8xLmNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBkZXBQcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtoYXNQcm9wZXJ0eX0gJiYgKCR7Y29kZV8xLmNoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYCk7XG4gICAgICAgICAgICBjb2RlXzEucmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKTtcbiAgICAgICAgICAgIGdlbi5lbHNlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUHJvcGVydHlEZXBzID0gdmFsaWRhdGVQcm9wZXJ0eURlcHM7XG5mdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hlbWFEZXBzID0gY3h0LnNjaGVtYSkge1xuICAgIGNvbnN0IHsgZ2VuLCBkYXRhLCBrZXl3b3JkLCBpdCB9ID0gY3h0O1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFEZXBzW3Byb3BdKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQsIHNjaGVtYVByb3A6IHByb3AgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZCk7XG4gICAgICAgIH0sICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVNjaGVtYURlcHMgPSB2YWxpZGF0ZVNjaGVtYURlcHM7XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXBlbmRlbmNpZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgdHlwZTogXCJvYmplY3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBwcm9wZXJ0eU5hbWU6IGtleSB9KTtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSwgdmFsaWQpO1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXQuYWxsRXJyb3JzKVxuICAgICAgICAgICAgICAgICAgICBnZW4uYnJlYWsoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3BlcnR5TmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBuYW1lc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICAgIHBhcmFtczogKHsgcGFyYW1zIH0pID0+IGNvZGVnZW5fMS5fIGB7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZXJyc0NvdW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBjb25zdCB7IGFsbEVycm9ycywgb3B0cyB9ID0gaXQ7XG4gICAgICAgIGl0LnByb3BzID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiB1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3BzID0gY29kZV8xLmFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICBjb25zdCBwYXRQcm9wcyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcyk7XG4gICAgICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTtcbiAgICAgICAgY3h0Lm9rKGNvZGVnZW5fMS5fIGAke2VycnNDb3VudH0gPT09ICR7bmFtZXNfMS5kZWZhdWx0LmVycm9yc31gKTtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleSkge1xuICAgICAgICAgICAgbGV0IGRlZmluZWRQcm9wO1xuICAgICAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9IHV0aWxfMS5zY2hlbWFSZWZPclZhbChpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKTtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVfMS5pc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5vciguLi5wcm9wcy5tYXAoKHApID0+IGNvZGVnZW5fMS5fIGAke2tleX0gPT09ICR7cH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVkUHJvcCA9IGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFByb3AgPSBjb2RlZ2VuXzEub3IoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gY29kZWdlbl8xLl8gYCR7Y29kZV8xLnVzZVBhdHRlcm4oY3h0LCBwKX0udGVzdCgke2tleX0pYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5ub3QoZGVmaW5lZFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KSB7XG4gICAgICAgICAgICBnZW4uY29kZShjb2RlZ2VuXzEuXyBgZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgYWRkaXRpb25hbFByb3BlcnR5OiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgY3h0LmVycm9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5icmVhaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIXV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxFcnJvcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLm5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGVycm9ycykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NoZW1hID0ge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogdXRpbF8xLlR5cGUuU3RyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZGl0aW9uYWxQcm9wZXJ0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdmFsaWRhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCIpO1xuY29uc3QgY29kZV8xID0gcmVxdWlyZShcIi4uL2NvZGVcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgYWRkaXRpb25hbFByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdC5jb2RlKG5ldyB2YWxpZGF0ZV8xLktleXdvcmRDeHQoaXQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJvcHMgPSBjb2RlXzEuYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGl0LnByb3BzID0gdXRpbF8xLm1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgdXRpbF8xLnRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhdXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIik7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZW4uaWYoY29kZV8xLnByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgICAgICAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmFsbEVycm9ycylcbiAgICAgICAgICAgICAgICAgICAgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlbi5lbmRJZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVfMSA9IHJlcXVpcmUoXCIuLi9jb2RlXCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCB1dGlsXzIgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS91dGlsXCIpO1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gICAgY29kZShjeHQpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdCB9ID0gY3h0O1xuICAgICAgICBjb25zdCB7IG9wdHMgfSA9IGl0O1xuICAgICAgICBjb25zdCBwYXR0ZXJucyA9IGNvZGVfMS5hbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+IHV0aWxfMS5hbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSk7XG4gICAgICAgIGlmIChwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPSBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIGNvZGVnZW5fMS5OYW1lKSkge1xuICAgICAgICAgICAgaXQucHJvcHMgPSB1dGlsXzIuZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBpdC5wcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gaXQ7XG4gICAgICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSk7IC8vIFRPRE8gdmFyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uaWYodmFsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmNoZWNrU3RyaWN0TW9kZShpdCwgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KSB7XG4gICAgICAgICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGdlbi5pZihjb2RlZ2VuXzEuXyBgJHtjb2RlXzEudXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IHV0aWxfMi5UeXBlLlN0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmFzc2lnbihjb2RlZ2VuXzEuXyBgJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXR0ZXJuUHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJub3RcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGN4dC5mYWlsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sIHZhbGlkKTtcbiAgICAgICAgY3h0LmZhaWxSZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpLCAoKSA9PiBjeHQuZXJyb3IoKSk7XG4gICAgfSxcbiAgICBlcnJvcjogeyBtZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCIgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlXzEgPSByZXF1aXJlKFwiLi4vY29kZVwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFueU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGNvZGU6IGNvZGVfMS52YWxpZGF0ZVVuaW9uLFxuICAgIGVycm9yOiB7IG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwiIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW55T2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGVycm9yID0ge1xuICAgIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgICBwYXJhbXM6ICh7IHBhcmFtcyB9KSA9PiBjb2RlZ2VuXzEuXyBge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQgfSA9IGN4dDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xuICAgICAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hBcnIgPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHsgcGFzc2luZyB9KTtcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpO1xuICAgICAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSwgKCkgPT4gY3h0LmVycm9yKHRydWUpKTtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpIHtcbiAgICAgICAgICAgIHNjaEFyci5mb3JFYWNoKChzY2gsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgc2NoQ3h0O1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBzY2hWYWxpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZihjb2RlZ2VuXzEuXyBgJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsIGNvZGVnZW5fMS5fIGBbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmVsc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoQ3h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uZU9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvdXRpbFwiKTtcbmNvbnN0IGRlZiA9IHtcbiAgICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gICAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBzY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICBzY2hlbWEuZm9yRWFjaCgoc2NoLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoeyBrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGkgfSwgdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm9rKHZhbGlkKTtcbiAgICAgICAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsbE9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLnN0ciBgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXMgfSkgPT4gY29kZWdlbl8xLl8gYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICAgIHRyYWNrRXJyb3JzOiB0cnVlLFxuICAgIGVycm9yLFxuICAgIGNvZGUoY3h0KSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpO1xuICAgICAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpO1xuICAgICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpO1xuICAgICAgICB2YWxpZGF0ZUlmKCk7XG4gICAgICAgIGN4dC5yZXNldCgpO1xuICAgICAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKTtcbiAgICAgICAgICAgIGN4dC5zZXRQYXJhbXMoeyBpZkNsYXVzZSB9KTtcbiAgICAgICAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5ub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpO1xuICAgICAgICB9XG4gICAgICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgICAgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZCwgaWZDbGF1c2UpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQgfSwgc2NoVmFsaWQpO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKTtcbiAgICAgICAgICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWZDbGF1c2UpXG4gICAgICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24oaWZDbGF1c2UsIGNvZGVnZW5fMS5fIGAke2tleXdvcmR9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjeHQuc2V0UGFyYW1zKHsgaWZDbGF1c2U6IGtleXdvcmQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQsIGtleXdvcmQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF07XG4gICAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICF1dGlsXzEuYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL3V0aWxcIik7XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gICAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgICBjb2RlKHsga2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdCB9KSB7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHV0aWxfMS5jaGVja1N0cmljdE1vZGUoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYCk7XG4gICAgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVuRWxzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFkZGl0aW9uYWxJdGVtc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbEl0ZW1zXCIpO1xuY29uc3QgcHJlZml4SXRlbXNfMSA9IHJlcXVpcmUoXCIuL3ByZWZpeEl0ZW1zXCIpO1xuY29uc3QgaXRlbXNfMSA9IHJlcXVpcmUoXCIuL2l0ZW1zXCIpO1xuY29uc3QgaXRlbXMyMDIwXzEgPSByZXF1aXJlKFwiLi9pdGVtczIwMjBcIik7XG5jb25zdCBjb250YWluc18xID0gcmVxdWlyZShcIi4vY29udGFpbnNcIik7XG5jb25zdCBkZXBlbmRlbmNpZXNfMSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llc1wiKTtcbmNvbnN0IHByb3BlcnR5TmFtZXNfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5TmFtZXNcIik7XG5jb25zdCBhZGRpdGlvbmFsUHJvcGVydGllc18xID0gcmVxdWlyZShcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIik7XG5jb25zdCBwcm9wZXJ0aWVzXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpO1xuY29uc3QgcGF0dGVyblByb3BlcnRpZXNfMSA9IHJlcXVpcmUoXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCIpO1xuY29uc3Qgbm90XzEgPSByZXF1aXJlKFwiLi9ub3RcIik7XG5jb25zdCBhbnlPZl8xID0gcmVxdWlyZShcIi4vYW55T2ZcIik7XG5jb25zdCBvbmVPZl8xID0gcmVxdWlyZShcIi4vb25lT2ZcIik7XG5jb25zdCBhbGxPZl8xID0gcmVxdWlyZShcIi4vYWxsT2ZcIik7XG5jb25zdCBpZl8xID0gcmVxdWlyZShcIi4vaWZcIik7XG5jb25zdCB0aGVuRWxzZV8xID0gcmVxdWlyZShcIi4vdGhlbkVsc2VcIik7XG5mdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAgICAgLy8gYW55XG4gICAgICAgIG5vdF8xLmRlZmF1bHQsXG4gICAgICAgIGFueU9mXzEuZGVmYXVsdCxcbiAgICAgICAgb25lT2ZfMS5kZWZhdWx0LFxuICAgICAgICBhbGxPZl8xLmRlZmF1bHQsXG4gICAgICAgIGlmXzEuZGVmYXVsdCxcbiAgICAgICAgdGhlbkVsc2VfMS5kZWZhdWx0LFxuICAgICAgICAvLyBvYmplY3RcbiAgICAgICAgcHJvcGVydHlOYW1lc18xLmRlZmF1bHQsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwZW5kZW5jaWVzXzEuZGVmYXVsdCxcbiAgICAgICAgcHJvcGVydGllc18xLmRlZmF1bHQsXG4gICAgICAgIHBhdHRlcm5Qcm9wZXJ0aWVzXzEuZGVmYXVsdCxcbiAgICBdO1xuICAgIC8vIGFycmF5XG4gICAgaWYgKGRyYWZ0MjAyMClcbiAgICAgICAgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXMyMDIwXzEuZGVmYXVsdCk7XG4gICAgZWxzZVxuICAgICAgICBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zXzEuZGVmYXVsdCwgaXRlbXNfMS5kZWZhdWx0KTtcbiAgICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnNfMS5kZWZhdWx0KTtcbiAgICByZXR1cm4gYXBwbGljYXRvcjtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFwcGxpY2F0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBzY2hlbWFDb2RlIH0pID0+IGNvZGVnZW5fMS5zdHIgYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgICBwYXJhbXM6ICh7IHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn07XG5jb25zdCBkZWYgPSB7XG4gICAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCwgcnVsZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIGNvZGVnZW5fMS5fIGAke2ZtdHN9WyR7c2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIik7XG4gICAgICAgICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICAgICAgICBnZW4uaWYoY29kZWdlbl8xLl8gYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGNvZGVnZW5fMS5fIGAke2ZEZWZ9LnZhbGlkYXRlYCksICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIGNvZGVnZW5fMS5fIGBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZikpO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb2RlZ2VuXzEub3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5uaWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW5fMS5fIGAke3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgICAgICAgICAgICA/IGNvZGVnZW5fMS5fIGAoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgICAgICAgICAgIDogY29kZWdlbl8xLl8gYCR7Zm9ybWF0fSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWREYXRhID0gY29kZWdlbl8xLl8gYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXREZWYgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXTtcbiAgICAgICAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bkZvcm1hdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpO1xuICAgICAgICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKVxuICAgICAgICAgICAgICAgIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWF9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgICAgICAgICAgPyBjb2RlZ2VuXzEucmVnZXhwQ29kZShmbXREZWYpXG4gICAgICAgICAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29kZWdlbl8xLl8gYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtjb2RlZ2VuXzEuZ2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwgeyBrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIGNvZGVnZW5fMS5fIGAke2ZtdH0udmFsaWRhdGVgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZWdlbl8xLl8gYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/IGNvZGVnZW5fMS5fIGAke2ZtdFJlZn0oJHtkYXRhfSlgIDogY29kZWdlbl8xLl8gYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XG5jb25zdCBmb3JtYXQgPSBbZm9ybWF0XzEuZGVmYXVsdF07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBleHBvcnRzLm1ldGFkYXRhVm9jYWJ1bGFyeSA9IHZvaWQgMDtcbmV4cG9ydHMubWV0YWRhdGFWb2NhYnVsYXJ5ID0gW1xuICAgIFwidGl0bGVcIixcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkZXByZWNhdGVkXCIsXG4gICAgXCJyZWFkT25seVwiLFxuICAgIFwid3JpdGVPbmx5XCIsXG4gICAgXCJleGFtcGxlc1wiLFxuXTtcbmV4cG9ydHMuY29udGVudFZvY2FidWxhcnkgPSBbXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uXCIpO1xuY29uc3QgYXBwbGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXBwbGljYXRvclwiKTtcbmNvbnN0IGZvcm1hdF8xID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzID0gW1xuICAgIGNvcmVfMS5kZWZhdWx0LFxuICAgIHZhbGlkYXRpb25fMS5kZWZhdWx0LFxuICAgIGFwcGxpY2F0b3JfMS5kZWZhdWx0KCksXG4gICAgZm9ybWF0XzEuZGVmYXVsdCxcbiAgICBtZXRhZGF0YV8xLm1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgICBtZXRhZGF0YV8xLmNvbnRlbnRWb2NhYnVsYXJ5LFxuXTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRyYWZ0N1ZvY2FidWxhcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRyYWZ0Ny5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGlzY3JFcnJvciA9IHZvaWQgMDtcbnZhciBEaXNjckVycm9yO1xuKGZ1bmN0aW9uIChEaXNjckVycm9yKSB7XG4gICAgRGlzY3JFcnJvcltcIlRhZ1wiXSA9IFwidGFnXCI7XG4gICAgRGlzY3JFcnJvcltcIk1hcHBpbmdcIl0gPSBcIm1hcHBpbmdcIjtcbn0pKERpc2NyRXJyb3IgPSBleHBvcnRzLkRpc2NyRXJyb3IgfHwgKGV4cG9ydHMuRGlzY3JFcnJvciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIik7XG5jb25zdCBlcnJvciA9IHtcbiAgICBtZXNzYWdlOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnTmFtZSB9IH0pID0+IGRpc2NyRXJyb3IgPT09IHR5cGVzXzEuRGlzY3JFcnJvci5UYWdcbiAgICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gICAgcGFyYW1zOiAoeyBwYXJhbXM6IHsgZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lIH0gfSkgPT4gY29kZWdlbl8xLl8gYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59O1xuY29uc3QgZGVmID0ge1xuICAgIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0IH0gPSBjeHQ7XG4gICAgICAgIGNvbnN0IHsgb25lT2YgfSA9IHBhcmVudFNjaGVtYTtcbiAgICAgICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKTtcbiAgICAgICAgaWYgKHNjaGVtYS5tYXBwaW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAoIW9uZU9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKTtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgY29kZWdlbl8xLl8gYCR7ZGF0YX0ke2NvZGVnZW5fMS5nZXRQcm9wZXJ0eSh0YWdOYW1lKX1gKTtcbiAgICAgICAgZ2VuLmlmKGNvZGVnZW5fMS5fIGB0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLCAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSwgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZSB9KSk7XG4gICAgICAgIGN4dC5vayh2YWxpZCk7XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKCk7XG4gICAgICAgICAgICBnZW4uaWYoZmFsc2UpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgZ2VuLmVsc2VJZihjb2RlZ2VuXzEuXyBgJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW4uZWxzZSgpO1xuICAgICAgICAgICAgY3h0LmVycm9yKGZhbHNlLCB7IGRpc2NyRXJyb3I6IHR5cGVzXzEuRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWUgfSk7XG4gICAgICAgICAgICBnZW4uZW5kSWYoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wKSB7XG4gICAgICAgICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpO1xuICAgICAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7IGtleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcCB9LCBfdmFsaWQpO1xuICAgICAgICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgY29kZWdlbl8xLk5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIF92YWxpZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nID0ge307XG4gICAgICAgICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSk7XG4gICAgICAgICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaCA9IG9uZU9mW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BTY2ggPSAoX2EgPSBzY2gucHJvcGVydGllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3RhZ05hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogb25lT2Ygc2NoZW1hcyBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKTtcbiAgICAgICAgICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFnUmVxdWlyZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICByZXR1cm4gb25lT2ZNYXBwaW5nO1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoeyByZXF1aXJlZCB9KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlR2VuID0gZXhwb3J0cy5OYW1lID0gZXhwb3J0cy5uaWwgPSBleHBvcnRzLnN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5fID0gZXhwb3J0cy5LZXl3b3JkQ3h0ID0gdm9pZCAwO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRyYWZ0N18xID0gcmVxdWlyZShcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3JfMSA9IHJlcXVpcmUoXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCIpO1xuY29uc3QgZHJhZnQ3TWV0YVNjaGVtYSA9IHJlcXVpcmUoXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiKTtcbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl07XG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIjtcbmNsYXNzIEFqdiBleHRlbmRzIGNvcmVfMS5kZWZhdWx0IHtcbiAgICBfYWRkVm9jYWJ1bGFyaWVzKCkge1xuICAgICAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKCk7XG4gICAgICAgIGRyYWZ0N18xLmRlZmF1bHQuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKVxuICAgICAgICAgICAgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3JfMS5kZWZhdWx0KTtcbiAgICB9XG4gICAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCkge1xuICAgICAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMubWV0YSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgICAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYTtcbiAgICAgICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gICAgfVxuICAgIGRlZmF1bHRNZXRhKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICAgICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEFqdjtcbnZhciB2YWxpZGF0ZV8xID0gcmVxdWlyZShcIi4vY29tcGlsZS92YWxpZGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIktleXdvcmRDeHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlXzEuS2V5d29yZEN4dDsgfSB9KTtcbnZhciBjb2RlZ2VuXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvZGVnZW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlZ2VuXzEuXzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0clwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0cmluZ2lmeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLnN0cmluZ2lmeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5pbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLm5pbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvZGVnZW5fMS5OYW1lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29kZUdlblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29kZWdlbl8xLkNvZGVHZW47IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hanYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZm9ybWF0c18xID0gcmVxdWlyZShcIi4vZm9ybWF0c1wiKTtcbmNvbnN0IGxpbWl0XzEgPSByZXF1aXJlKFwiLi9saW1pdFwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBmdWxsTmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZ1bGxGb3JtYXRzXCIpO1xuY29uc3QgZmFzdE5hbWUgPSBuZXcgY29kZWdlbl8xLk5hbWUoXCJmYXN0Rm9ybWF0c1wiKTtcbmNvbnN0IGZvcm1hdHNQbHVnaW4gPSAoYWp2LCBvcHRzID0geyBrZXl3b3JkczogdHJ1ZSB9KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICAgICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWUpO1xuICAgICAgICByZXR1cm4gYWp2O1xuICAgIH1cbiAgICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPSBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zvcm1hdHNfMS5mYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Zvcm1hdHNfMS5mdWxsRm9ybWF0cywgZnVsbE5hbWVdO1xuICAgIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0c18xLmZvcm1hdE5hbWVzO1xuICAgIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKTtcbiAgICBpZiAob3B0cy5rZXl3b3JkcylcbiAgICAgICAgbGltaXRfMS5kZWZhdWx0KGFqdik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lLCBtb2RlID0gXCJmdWxsXCIpID0+IHtcbiAgICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmb3JtYXRzXzEuZmFzdEZvcm1hdHMgOiBmb3JtYXRzXzEuZnVsbEZvcm1hdHM7XG4gICAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV07XG4gICAgaWYgKCFmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYCk7XG4gICAgcmV0dXJuIGY7XG59O1xuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZzLCBleHBvcnROYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBfYjtcbiAgICAoX2EgPSAoX2IgPSBhanYub3B0cy5jb2RlKS5mb3JtYXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoX2IuZm9ybWF0cyA9IGNvZGVnZW5fMS5fIGByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gKTtcbiAgICBmb3IgKGNvbnN0IGYgb2YgbGlzdClcbiAgICAgICAgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZm9ybWF0c1BsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY29weVByb3BlcnR5ID0gKHRvLCBmcm9tLCBwcm9wZXJ0eSwgaWdub3JlTm9uQ29uZmlndXJhYmxlKSA9PiB7XG5cdC8vIGBGdW5jdGlvbiNsZW5ndGhgIHNob3VsZCByZWZsZWN0IHRoZSBwYXJhbWV0ZXJzIG9mIGB0b2Agbm90IGBmcm9tYCBzaW5jZSB3ZSBrZWVwIGl0cyBib2R5LlxuXHQvLyBgRnVuY3Rpb24jcHJvdG90eXBlYCBpcyBub24td3JpdGFibGUgYW5kIG5vbi1jb25maWd1cmFibGUgc28gY2FuIG5ldmVyIGJlIG1vZGlmaWVkLlxuXHRpZiAocHJvcGVydHkgPT09ICdsZW5ndGgnIHx8IHByb3BlcnR5ID09PSAncHJvdG90eXBlJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGBGdW5jdGlvbiNhcmd1bWVudHNgIGFuZCBgRnVuY3Rpb24jY2FsbGVyYCBzaG91bGQgbm90IGJlIGNvcGllZC4gVGhleSB3ZXJlIHJlcG9ydGVkIHRvIGJlIHByZXNlbnQgaW4gYFJlZmxlY3Qub3duS2V5c2AgZm9yIHNvbWUgZGV2aWNlcyBpbiBSZWFjdCBOYXRpdmUgKCM0MSksIHNvIHdlIGV4cGxpY2l0bHkgaWdub3JlIHRoZW0gaGVyZS5cblx0aWYgKHByb3BlcnR5ID09PSAnYXJndW1lbnRzJyB8fCBwcm9wZXJ0eSA9PT0gJ2NhbGxlcicpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCB0b0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvLCBwcm9wZXJ0eSk7XG5cdGNvbnN0IGZyb21EZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCFjYW5Db3B5UHJvcGVydHkodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikgJiYgaWdub3JlTm9uQ29uZmlndXJhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wZXJ0eSwgZnJvbURlc2NyaXB0b3IpO1xufTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpYCB0aHJvd3MgaWYgdGhlIHByb3BlcnR5IGV4aXN0cywgaXMgbm90IGNvbmZpZ3VyYWJsZSBhbmQgZWl0aGVyOlxuLy8gIC0gb25lIGl0cyBkZXNjcmlwdG9ycyBpcyBjaGFuZ2VkXG4vLyAgLSBpdCBpcyBub24td3JpdGFibGUgYW5kIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5jb25zdCBjYW5Db3B5UHJvcGVydHkgPSBmdW5jdGlvbiAodG9EZXNjcmlwdG9yLCBmcm9tRGVzY3JpcHRvcikge1xuXHRyZXR1cm4gdG9EZXNjcmlwdG9yID09PSB1bmRlZmluZWQgfHwgdG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSB8fCAoXG5cdFx0dG9EZXNjcmlwdG9yLndyaXRhYmxlID09PSBmcm9tRGVzY3JpcHRvci53cml0YWJsZSAmJlxuXHRcdHRvRGVzY3JpcHRvci5lbnVtZXJhYmxlID09PSBmcm9tRGVzY3JpcHRvci5lbnVtZXJhYmxlICYmXG5cdFx0dG9EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9PT0gZnJvbURlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG5cdFx0KHRvRGVzY3JpcHRvci53cml0YWJsZSB8fCB0b0Rlc2NyaXB0b3IudmFsdWUgPT09IGZyb21EZXNjcmlwdG9yLnZhbHVlKVxuXHQpO1xufTtcblxuY29uc3QgY2hhbmdlUHJvdG90eXBlID0gKHRvLCBmcm9tKSA9PiB7XG5cdGNvbnN0IGZyb21Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG5cdGlmIChmcm9tUHJvdG90eXBlID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodG8pKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKHRvLCBmcm9tUHJvdG90eXBlKTtcbn07XG5cbmNvbnN0IHdyYXBwZWRUb1N0cmluZyA9ICh3aXRoTmFtZSwgZnJvbUJvZHkpID0+IGAvKiBXcmFwcGVkICR7d2l0aE5hbWV9Ki9cXG4ke2Zyb21Cb2R5fWA7XG5cbmNvbnN0IHRvU3RyaW5nRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnKTtcbmNvbnN0IHRvU3RyaW5nTmFtZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nLCAnbmFtZScpO1xuXG4vLyBXZSBjYWxsIGBmcm9tLnRvU3RyaW5nKClgIGVhcmx5IChub3QgbGF6aWx5KSB0byBlbnN1cmUgYGZyb21gIGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbi8vIFdlIHVzZSBgYmluZCgpYCBpbnN0ZWFkIG9mIGEgY2xvc3VyZSBmb3IgdGhlIHNhbWUgcmVhc29uLlxuLy8gQ2FsbGluZyBgZnJvbS50b1N0cmluZygpYCBlYXJseSBhbHNvIGFsbG93cyBjYWNoaW5nIGl0IGluIGNhc2UgYHRvLnRvU3RyaW5nKClgIGlzIGNhbGxlZCBzZXZlcmFsIHRpbWVzLlxuY29uc3QgY2hhbmdlVG9TdHJpbmcgPSAodG8sIGZyb20sIG5hbWUpID0+IHtcblx0Y29uc3Qgd2l0aE5hbWUgPSBuYW1lID09PSAnJyA/ICcnIDogYHdpdGggJHtuYW1lLnRyaW0oKX0oKSBgO1xuXHRjb25zdCBuZXdUb1N0cmluZyA9IHdyYXBwZWRUb1N0cmluZy5iaW5kKG51bGwsIHdpdGhOYW1lLCBmcm9tLnRvU3RyaW5nKCkpO1xuXHQvLyBFbnN1cmUgYHRvLnRvU3RyaW5nLnRvU3RyaW5nYCBpcyBub24tZW51bWVyYWJsZSBhbmQgaGFzIHRoZSBzYW1lIGBzYW1lYFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3VG9TdHJpbmcsICduYW1lJywgdG9TdHJpbmdOYW1lKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCAndG9TdHJpbmcnLCB7Li4udG9TdHJpbmdEZXNjcmlwdG9yLCB2YWx1ZTogbmV3VG9TdHJpbmd9KTtcbn07XG5cbmNvbnN0IG1pbWljRm4gPSAodG8sIGZyb20sIHtpZ25vcmVOb25Db25maWd1cmFibGUgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCB7bmFtZX0gPSB0bztcblxuXHRmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJlZmxlY3Qub3duS2V5cyhmcm9tKSkge1xuXHRcdGNvcHlQcm9wZXJ0eSh0bywgZnJvbSwgcHJvcGVydHksIGlnbm9yZU5vbkNvbmZpZ3VyYWJsZSk7XG5cdH1cblxuXHRjaGFuZ2VQcm90b3R5cGUodG8sIGZyb20pO1xuXHRjaGFuZ2VUb1N0cmluZyh0bywgZnJvbSwgbmFtZSk7XG5cblx0cmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW1pY0ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGlucHV0RnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAodHlwZW9mIGlucHV0RnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiwgZ290IFxcYCR7dHlwZW9mIGlucHV0RnVuY3Rpb259XFxgYCk7XG5cdH1cblxuXHRjb25zdCB7XG5cdFx0d2FpdCA9IDAsXG5cdFx0YmVmb3JlID0gZmFsc2UsXG5cdFx0YWZ0ZXIgPSB0cnVlXG5cdH0gPSBvcHRpb25zO1xuXG5cdGlmICghYmVmb3JlICYmICFhZnRlcikge1xuXHRcdHRocm93IG5ldyBFcnJvcignQm90aCBgYmVmb3JlYCBhbmQgYGFmdGVyYCBhcmUgZmFsc2UsIGZ1bmN0aW9uIHdvdWxkblxcJ3QgYmUgY2FsbGVkLicpO1xuXHR9XG5cblx0bGV0IHRpbWVvdXQ7XG5cdGxldCByZXN1bHQ7XG5cblx0Y29uc3QgZGVib3VuY2VkRnVuY3Rpb24gPSBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuXG5cdFx0Y29uc3QgbGF0ZXIgPSAoKSA9PiB7XG5cdFx0XHR0aW1lb3V0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0cmVzdWx0ID0gaW5wdXRGdW5jdGlvbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHNfKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Y29uc3Qgc2hvdWxkQ2FsbE5vdyA9IGJlZm9yZSAmJiAhdGltZW91dDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXG5cdFx0aWYgKHNob3VsZENhbGxOb3cpIHtcblx0XHRcdHJlc3VsdCA9IGlucHV0RnVuY3Rpb24uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzXyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRtaW1pY0ZuKGRlYm91bmNlZEZ1bmN0aW9uLCBpbnB1dEZ1bmN0aW9uKTtcblxuXHRkZWJvdW5jZWRGdW5jdGlvbi5jYW5jZWwgPSAoKSA9PiB7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdHRpbWVvdXQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBkZWJvdW5jZWRGdW5jdGlvbjtcbn07XG4iLCIvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5jb25zdCBTRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJ1xuXG5jb25zdCBNQVhfTEVOR1RIID0gMjU2XG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOTAwNzE5OTI1NDc0MDk5MVxuXG4vLyBNYXggc2FmZSBzZWdtZW50IGxlbmd0aCBmb3IgY29lcmNpb24uXG5jb25zdCBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTVZFUl9TUEVDX1ZFUlNJT04sXG4gIE1BWF9MRU5HVEgsXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEhcbn1cbiIsImNvbnN0IGRlYnVnID0gKFxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiZcbiAgcHJvY2Vzcy5lbnYgJiZcbiAgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKVxuKSA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmVycm9yKCdTRU1WRVInLCAuLi5hcmdzKVxuICA6ICgpID0+IHt9XG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWdcbiIsImNvbnN0IHsgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuL2RlYnVnJylcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5jb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXVxuY29uc3Qgc3JjID0gZXhwb3J0cy5zcmMgPSBbXVxuY29uc3QgdCA9IGV4cG9ydHMudCA9IHt9XG5sZXQgUiA9IDBcblxuY29uc3QgY3JlYXRlVG9rZW4gPSAobmFtZSwgdmFsdWUsIGlzR2xvYmFsKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUisrXG4gIGRlYnVnKGluZGV4LCB2YWx1ZSlcbiAgdFtuYW1lXSA9IGluZGV4XG4gIHNyY1tpbmRleF0gPSB2YWx1ZVxuICByZVtpbmRleF0gPSBuZXcgUmVnRXhwKHZhbHVlLCBpc0dsb2JhbCA/ICdnJyA6IHVuZGVmaW5lZClcbn1cblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSJywgJzB8WzEtOV1cXFxcZConKVxuY3JlYXRlVG9rZW4oJ05VTUVSSUNJREVOVElGSUVSTE9PU0UnLCAnWzAtOV0rJylcblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxuY3JlYXRlVG9rZW4oJ05PTk5VTUVSSUNJREVOVElGSUVSJywgJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonKVxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ01BSU5WRVJTSU9OJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC5gICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgIGAoJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUl19KWApXG5cbmNyZWF0ZVRva2VuKCdNQUlOVkVSU0lPTkxPT1NFJywgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKVxuXG4vLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbmNyZWF0ZVRva2VuKCdQUkVSRUxFQVNFSURFTlRJRklFUicsIGAoPzoke3NyY1t0Lk5VTUVSSUNJREVOVElGSUVSXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSTE9PU0UnLCBgKD86JHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXVxufXwke3NyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXX0pYClcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG5jcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIGAoPzotKCR7c3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYClcblxuY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIGAoPzotPygke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdXG59KD86XFxcXC4ke3NyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG5jcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKVxuXG4vLyAjIyBCdWlsZCBNZXRhZGF0YVxuLy8gUGx1cyBzaWduLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBwZXJpb2Qtc2VwYXJhdGVkIGJ1aWxkIG1ldGFkYXRhXG4vLyBpZGVudGlmaWVycy5cblxuY3JlYXRlVG9rZW4oJ0JVSUxEJywgYCg/OlxcXFwrKCR7c3JjW3QuQlVJTERJREVOVElGSUVSXVxufSg/OlxcXFwuJHtzcmNbdC5CVUlMRElERU5USUZJRVJdfSkqKSlgKVxuXG4vLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cblxuLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuLy8gdGhlIHZlcnNpb24gc3RyaW5nIGFyZSBjYXB0dXJpbmcgZ3JvdXBzLiAgVGhlIGJ1aWxkIG1ldGFkYXRhIGlzIG5vdCBhXG4vLyBjYXB0dXJpbmcgZ3JvdXAsIGJlY2F1c2UgaXQgc2hvdWxkIG5vdCBldmVyIGJlIHVzZWQgaW4gdmVyc2lvblxuLy8gY29tcGFyaXNvbi5cblxuY3JlYXRlVG9rZW4oJ0ZVTExQTEFJTicsIGB2PyR7c3JjW3QuTUFJTlZFUlNJT05dXG59JHtzcmNbdC5QUkVSRUxFQVNFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignRlVMTCcsIGBeJHtzcmNbdC5GVUxMUExBSU5dfSRgKVxuXG4vLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4vLyBhbHNvLCAxLjAuMGFscGhhMSAocHJlcmVsZWFzZSB3aXRob3V0IHRoZSBoeXBoZW4pIHdoaWNoIGlzIHByZXR0eVxuLy8gY29tbW9uIGluIHRoZSBucG0gcmVnaXN0cnkuXG5jcmVhdGVUb2tlbignTE9PU0VQTEFJTicsIGBbdj1cXFxcc10qJHtzcmNbdC5NQUlOVkVSU0lPTkxPT1NFXVxufSR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0/JHtcbiAgc3JjW3QuQlVJTERdfT9gKVxuXG5jcmVhdGVUb2tlbignTE9PU0UnLCBgXiR7c3JjW3QuTE9PU0VQTEFJTl19JGApXG5cbmNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpXG5cbi8vIFNvbWV0aGluZyBsaWtlIFwiMi4qXCIgb3IgXCIxLjIueFwiLlxuLy8gTm90ZSB0aGF0IFwieC54XCIgaXMgYSB2YWxpZCB4UmFuZ2UgaWRlbnRpZmVyLCBtZWFuaW5nIFwiYW55IHZlcnNpb25cIlxuLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBgJHtzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18eHxYfFxcXFwqYClcbmNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSJywgYCR7c3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdfXx4fFh8XFxcXCpgKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBgW3Y9XFxcXHNdKigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJdfSlgICtcbiAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYCg/OlxcXFwuKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUl19KWAgK1xuICAgICAgICAgICAgICAgICAgIGAoPzoke3NyY1t0LlBSRVJFTEVBU0VdfSk/JHtcbiAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgYCk/KT9gKVxuXG5jcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIGBbdj1cXFxcc10qKCR7c3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKD86XFxcXC4oJHtzcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAoPzpcXFxcLigke3NyY1t0LlhSQU5HRUlERU5USUZJRVJMT09TRV19KWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCg/OiR7c3JjW3QuUFJFUkVMRUFTRUxPT1NFXX0pPyR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1t0LkJVSUxEXX0/YCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgKT8pP2ApXG5cbmNyZWF0ZVRva2VuKCdYUkFOR0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBgXiR7c3JjW3QuR1RMVF19XFxcXHMqJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0kYClcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG5jcmVhdGVUb2tlbignQ09FUkNFJywgYCR7JyhefFteXFxcXGRdKScgK1xuICAgICAgICAgICAgICAnKFxcXFxkezEsJ30ke01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEh9fSlgICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OlxcXFwuKFxcXFxkezEsJHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIfX0pKT9gICtcbiAgICAgICAgICAgICAgYCg/OiR8W15cXFxcZF0pYClcbmNyZWF0ZVRva2VuKCdDT0VSQ0VSVEwnLCBzcmNbdC5DT0VSQ0VdLCB0cnVlKVxuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxuY3JlYXRlVG9rZW4oJ0xPTkVUSUxERScsICcoPzp+Pj8pJylcblxuY3JlYXRlVG9rZW4oJ1RJTERFVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuTE9ORVRJTERFXX1cXFxccytgLCB0cnVlKVxuZXhwb3J0cy50aWxkZVRyaW1SZXBsYWNlID0gJyQxfidcblxuY3JlYXRlVG9rZW4oJ1RJTERFJywgYF4ke3NyY1t0LkxPTkVUSUxERV19JHtzcmNbdC5YUkFOR0VQTEFJTl19JGApXG5jcmVhdGVUb2tlbignVElMREVMT09TRScsIGBeJHtzcmNbdC5MT05FVElMREVdfSR7c3JjW3QuWFJBTkdFUExBSU5MT09TRV19JGApXG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5jcmVhdGVUb2tlbignTE9ORUNBUkVUJywgJyg/OlxcXFxeKScpXG5cbmNyZWF0ZVRva2VuKCdDQVJFVFRSSU0nLCBgKFxcXFxzKikke3NyY1t0LkxPTkVDQVJFVF19XFxcXHMrYCwgdHJ1ZSlcbmV4cG9ydHMuY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nXG5cbmNyZWF0ZVRva2VuKCdDQVJFVCcsIGBeJHtzcmNbdC5MT05FQ0FSRVRdfSR7c3JjW3QuWFJBTkdFUExBSU5dfSRgKVxuY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBgXiR7c3JjW3QuTE9ORUNBUkVUXX0ke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSRgKVxuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX0pJHxeJGApXG5jcmVhdGVUb2tlbignQ09NUEFSQVRPUicsIGBeJHtzcmNbdC5HVExUXX1cXFxccyooJHtzcmNbdC5GVUxMUExBSU5dfSkkfF4kYClcblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbmNyZWF0ZVRva2VuKCdDT01QQVJBVE9SVFJJTScsIGAoXFxcXHMqKSR7c3JjW3QuR1RMVF1cbn1cXFxccyooJHtzcmNbdC5MT09TRVBMQUlOXX18JHtzcmNbdC5YUkFOR0VQTEFJTl19KWAsIHRydWUpXG5leHBvcnRzLmNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG5jcmVhdGVUb2tlbignSFlQSEVOUkFOR0UnLCBgXlxcXFxzKigke3NyY1t0LlhSQU5HRVBMQUlOXX0pYCArXG4gICAgICAgICAgICAgICAgICAgYFxcXFxzKy1cXFxccytgICtcbiAgICAgICAgICAgICAgICAgICBgKCR7c3JjW3QuWFJBTkdFUExBSU5dfSlgICtcbiAgICAgICAgICAgICAgICAgICBgXFxcXHMqJGApXG5cbmNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRUxPT1NFJywgYF5cXFxccyooJHtzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXX0pYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgXFxcXHMrLVxcXFxzK2AgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCgke3NyY1t0LlhSQU5HRVBMQUlOTE9PU0VdfSlgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBcXFxccyokYClcblxuLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuY3JlYXRlVG9rZW4oJ1NUQVInLCAnKDx8Pik/PT9cXFxccypcXFxcKicpXG4vLyA+PTAuMC4wIGlzIGxpa2UgYSBzdGFyXG5jcmVhdGVUb2tlbignR1RFMCcsICdeXFxcXHMqPj1cXFxccyowXFwuMFxcLjBcXFxccyokJylcbmNyZWF0ZVRva2VuKCdHVEUwUFJFJywgJ15cXFxccyo+PVxcXFxzKjBcXC4wXFwuMC0wXFxcXHMqJCcpXG4iLCIvLyBwYXJzZSBvdXQganVzdCB0aGUgb3B0aW9ucyB3ZSBjYXJlIGFib3V0IHNvIHdlIGFsd2F5cyBnZXQgYSBjb25zaXN0ZW50XG4vLyBvYmogd2l0aCBrZXlzIGluIGEgY29uc2lzdGVudCBvcmRlci5cbmNvbnN0IG9wdHMgPSBbJ2luY2x1ZGVQcmVyZWxlYXNlJywgJ2xvb3NlJywgJ3J0bCddXG5jb25zdCBwYXJzZU9wdGlvbnMgPSBvcHRpb25zID0+XG4gICFvcHRpb25zID8ge31cbiAgOiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IGxvb3NlOiB0cnVlIH1cbiAgOiBvcHRzLmZpbHRlcihrID0+IG9wdGlvbnNba10pLnJlZHVjZSgob3B0aW9ucywgaykgPT4ge1xuICAgIG9wdGlvbnNba10gPSB0cnVlXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfSwge30pXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlT3B0aW9uc1xuIiwiY29uc3QgbnVtZXJpYyA9IC9eWzAtOV0rJC9cbmNvbnN0IGNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiB7XG4gIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSlcbiAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKVxuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2FcbiAgICBiID0gK2JcbiAgfVxuXG4gIHJldHVybiBhID09PSBiID8gMFxuICAgIDogKGFudW0gJiYgIWJudW0pID8gLTFcbiAgICA6IChibnVtICYmICFhbnVtKSA/IDFcbiAgICA6IGEgPCBiID8gLTFcbiAgICA6IDFcbn1cblxuY29uc3QgcmNvbXBhcmVJZGVudGlmaWVycyA9IChhLCBiKSA9PiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBhcmVJZGVudGlmaWVycyxcbiAgcmNvbXBhcmVJZGVudGlmaWVyc1xufVxuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCB7IE1BWF9MRU5HVEgsIE1BWF9TQUZFX0lOVEVHRVIgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgeyBjb21wYXJlSWRlbnRpZmllcnMgfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2lkZW50aWZpZXJzJylcbmNsYXNzIFNlbVZlciB7XG4gIGNvbnN0cnVjdG9yICh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgIGlmICh2ZXJzaW9uLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiZcbiAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgcmV0dXJuIHZlcnNpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb25cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke3ZlcnNpb259YClcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke01BWF9MRU5HVEh9IGNoYXJhY3RlcnNgXG4gICAgICApXG4gICAgfVxuXG4gICAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2VcbiAgICAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHJlbGV2YW50IGZvciB2ZXJzaW9ucywgYnV0IGtlZXAgaXQgc28gdGhhdCB3ZVxuICAgIC8vIGRvbid0IHJ1biBpbnRvIHRyb3VibGUgcGFzc2luZyB0aGlzLm9wdGlvbnMgYXJvdW5kLlxuICAgIHRoaXMuaW5jbHVkZVByZXJlbGVhc2UgPSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2VcblxuICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKVxuXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cblxuICAgIHRoaXMucmF3ID0gdmVyc2lvblxuXG4gICAgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcbiAgICB0aGlzLm1ham9yID0gK21bMV1cbiAgICB0aGlzLm1pbm9yID0gK21bMl1cbiAgICB0aGlzLnBhdGNoID0gK21bM11cblxuICAgIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJylcbiAgICB9XG5cbiAgICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWlub3IgdmVyc2lvbicpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGF0Y2ggPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuICAgIH1cblxuICAgIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICAgIGlmICghbVs0XSkge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChpZCkpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSAraWRcbiAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIG51bVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXVxuICAgIHRoaXMuZm9ybWF0KClcbiAgfVxuXG4gIGZvcm1hdCAoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YFxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZlcnNpb24gKz0gYC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKCcuJyl9YFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52ZXJzaW9uXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvblxuICB9XG5cbiAgY29tcGFyZSAob3RoZXIpIHtcbiAgICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpXG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucylcbiAgICB9XG5cbiAgICBpZiAob3RoZXIudmVyc2lvbiA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpXG4gIH1cblxuICBjb21wYXJlTWFpbiAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5taW5vciwgb3RoZXIubWlub3IpIHx8XG4gICAgICBjb21wYXJlSWRlbnRpZmllcnModGhpcy5wYXRjaCwgb3RoZXIucGF0Y2gpXG4gICAgKVxuICB9XG5cbiAgY29tcGFyZVByZSAob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKVxuICAgIH1cblxuICAgIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBsZXQgaSA9IDBcbiAgICBkbyB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcmVyZWxlYXNlW2ldXG4gICAgICBjb25zdCBiID0gb3RoZXIucHJlcmVsZWFzZVtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgY29tcGFyZUJ1aWxkIChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpXG4gICAgfVxuXG4gICAgbGV0IGkgPSAwXG4gICAgZG8ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuYnVpbGRbaV1cbiAgICAgIGNvbnN0IGIgPSBvdGhlci5idWlsZFtpXVxuICAgICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpXG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpXG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpKVxuICB9XG5cbiAgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuICAvLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG4gIGluYyAocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAocmVsZWFzZSkge1xuICAgICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMFxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLm1pbm9yID0gMFxuICAgICAgICB0aGlzLm1ham9yKytcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMubWlub3IrK1xuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbHJlYWR5IGEgcHJlcmVsZWFzZSwgaXQgd2lsbCBidW1wIHRvIHRoZSBuZXh0IHZlcnNpb25cbiAgICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDBcbiAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAgIC8vIHByZXBhdGNoLlxuICAgICAgY2FzZSAncHJlcmVsZWFzZSc6XG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnbWFqb3InOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5taW5vciAhPT0gMCB8fFxuICAgICAgICAgIHRoaXMucGF0Y2ggIT09IDAgfHxcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMubWFqb3IrK1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWlub3IgPSAwXG4gICAgICAgIHRoaXMucGF0Y2ggPSAwXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtaW5vcic6XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAvLyAxLjIuMC01IGJ1bXBzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLm1pbm9yKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gMFxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnBhdGNoKytcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXVxuICAgICAgICBicmVha1xuICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgIC8vIDEuMC4wICdwcmUnIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFswXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aFxuICAgICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrXG4gICAgICAgICAgICAgIGkgPSAtMlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRpZG4ndCBpbmNyZW1lbnQgYW55dGhpbmdcbiAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtyZWxlYXNlfWApXG4gICAgfVxuICAgIHRoaXMuZm9ybWF0KClcbiAgICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZW1WZXJcbiIsImNvbnN0IHtNQVhfTEVOR1RIfSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2NvbnN0YW50cycpXG5jb25zdCB7IHJlLCB0IH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5cbmNvbnN0IHBhcnNlT3B0aW9ucyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3BhcnNlLW9wdGlvbnMnKVxuY29uc3QgcGFyc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpXG5cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICByZXR1cm4gdmVyc2lvblxuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCB2YWxpZCA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHYgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGxcbn1cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRcbiIsImNvbnN0IHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpXG5jb25zdCBjbGVhbiA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHMgPSBwYXJzZSh2ZXJzaW9uLnRyaW0oKS5yZXBsYWNlKC9eWz12XSsvLCAnJyksIG9wdGlvbnMpXG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBjbGVhblxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuXG5jb25zdCBpbmMgPSAodmVyc2lvbiwgcmVsZWFzZSwgb3B0aW9ucywgaWRlbnRpZmllcikgPT4ge1xuICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucykuaW5jKHJlbGVhc2UsIGlkZW50aWZpZXIpLnZlcnNpb25cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluY1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZSA9IChhLCBiLCBsb29zZSkgPT5cbiAgbmV3IFNlbVZlcihhLCBsb29zZSkuY29tcGFyZShuZXcgU2VtVmVyKGIsIGxvb3NlKSlcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMFxubW9kdWxlLmV4cG9ydHMgPSBlcVxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IGVxID0gcmVxdWlyZSgnLi9lcScpXG5cbmNvbnN0IGRpZmYgPSAodmVyc2lvbjEsIHZlcnNpb24yKSA9PiB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2MSA9IHBhcnNlKHZlcnNpb24xKVxuICAgIGNvbnN0IHYyID0gcGFyc2UodmVyc2lvbjIpXG4gICAgY29uc3QgaGFzUHJlID0gdjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGhcbiAgICBjb25zdCBwcmVmaXggPSBoYXNQcmUgPyAncHJlJyA6ICcnXG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGhhc1ByZSA/ICdwcmVyZWxlYXNlJyA6ICcnXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdjEpIHtcbiAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICBpZiAodjFba2V5XSAhPT0gdjJba2V5XSkge1xuICAgICAgICAgIHJldHVybiBwcmVmaXggKyBrZXlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdCAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZGlmZlxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgbWFqb3IgPSAoYSwgbG9vc2UpID0+IG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yXG5tb2R1bGUuZXhwb3J0cyA9IG1ham9yXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBtaW5vciA9IChhLCBsb29zZSkgPT4gbmV3IFNlbVZlcihhLCBsb29zZSkubWlub3Jcbm1vZHVsZS5leHBvcnRzID0gbWlub3JcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IHBhdGNoID0gKGEsIGxvb3NlKSA9PiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5wYXRjaFxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaFxuIiwiY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHByZXJlbGVhc2UgPSAodmVyc2lvbiwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKVxuICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGgpID8gcGFyc2VkLnByZXJlbGVhc2UgOiBudWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHByZXJlbGVhc2VcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgcmNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYiwgYSwgbG9vc2UpXG5tb2R1bGUuZXhwb3J0cyA9IHJjb21wYXJlXG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGNvbXBhcmVMb29zZSA9IChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIHRydWUpXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVMb29zZVxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgY29tcGFyZUJ1aWxkID0gKGEsIGIsIGxvb3NlKSA9PiB7XG4gIGNvbnN0IHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSlcbiAgY29uc3QgdmVyc2lvbkIgPSBuZXcgU2VtVmVyKGIsIGxvb3NlKVxuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQnVpbGRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCBzb3J0ID0gKGxpc3QsIGxvb3NlKSA9PiBsaXN0LnNvcnQoKGEsIGIpID0+IGNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSkpXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRcbiIsImNvbnN0IGNvbXBhcmVCdWlsZCA9IHJlcXVpcmUoJy4vY29tcGFyZS1idWlsZCcpXG5jb25zdCByc29ydCA9IChsaXN0LCBsb29zZSkgPT4gbGlzdC5zb3J0KChhLCBiKSA9PiBjb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpKVxubW9kdWxlLmV4cG9ydHMgPSByc29ydFxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBndCA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0XG4iLCJjb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi9jb21wYXJlJylcbmNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDBcbm1vZHVsZS5leHBvcnRzID0gbHRcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgbmVxID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMFxubW9kdWxlLmV4cG9ydHMgPSBuZXFcbiIsImNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuL2NvbXBhcmUnKVxuY29uc3QgZ3RlID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+PSAwXG5tb2R1bGUuZXhwb3J0cyA9IGd0ZVxuIiwiY29uc3QgY29tcGFyZSA9IHJlcXVpcmUoJy4vY29tcGFyZScpXG5jb25zdCBsdGUgPSAoYSwgYiwgbG9vc2UpID0+IGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDBcbm1vZHVsZS5leHBvcnRzID0gbHRlXG4iLCJjb25zdCBlcSA9IHJlcXVpcmUoJy4vZXEnKVxuY29uc3QgbmVxID0gcmVxdWlyZSgnLi9uZXEnKVxuY29uc3QgZ3QgPSByZXF1aXJlKCcuL2d0JylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4vZ3RlJylcbmNvbnN0IGx0ID0gcmVxdWlyZSgnLi9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuL2x0ZScpXG5cbmNvbnN0IGNtcCA9IChhLCBvcCwgYiwgbG9vc2UpID0+IHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKVxuICAgICAgICBhID0gYS52ZXJzaW9uXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKVxuICAgICAgICBiID0gYi52ZXJzaW9uXG4gICAgICByZXR1cm4gYSA9PT0gYlxuXG4gICAgY2FzZSAnIT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpXG4gICAgICAgIGEgPSBhLnZlcnNpb25cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ29iamVjdCcpXG4gICAgICAgIGIgPSBiLnZlcnNpb25cbiAgICAgIHJldHVybiBhICE9PSBiXG5cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJz0nOlxuICAgIGNhc2UgJz09JzpcbiAgICAgIHJldHVybiBlcShhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc+JzpcbiAgICAgIHJldHVybiBndChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJz49JzpcbiAgICAgIHJldHVybiBndGUoYSwgYiwgbG9vc2UpXG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSlcblxuICAgIGNhc2UgJzw9JzpcbiAgICAgIHJldHVybiBsdGUoYSwgYiwgbG9vc2UpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtvcH1gKVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNtcFxuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHtyZSwgdH0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGNvZXJjZSA9ICh2ZXJzaW9uLCBvcHRpb25zKSA9PiB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgcmV0dXJuIHZlcnNpb25cbiAgfVxuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHtcbiAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pXG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSByaWdodC1tb3N0IGNvZXJjaWJsZSBzdHJpbmcgdGhhdCBkb2VzIG5vdCBzaGFyZVxuICAgIC8vIGEgdGVybWludXMgd2l0aCBhIG1vcmUgbGVmdC13YXJkIGNvZXJjaWJsZSBzdHJpbmcuXG4gICAgLy8gRWcsICcxLjIuMy40JyB3YW50cyB0byBjb2VyY2UgJzIuMy40Jywgbm90ICczLjQnIG9yICc0J1xuICAgIC8vXG4gICAgLy8gV2FsayB0aHJvdWdoIHRoZSBzdHJpbmcgY2hlY2tpbmcgd2l0aCBhIC9nIHJlZ2V4cFxuICAgIC8vIE1hbnVhbGx5IHNldCB0aGUgaW5kZXggc28gYXMgdG8gcGljayB1cCBvdmVybGFwcGluZyBtYXRjaGVzLlxuICAgIC8vIFN0b3Agd2hlbiB3ZSBnZXQgYSBtYXRjaCB0aGF0IGVuZHMgYXQgdGhlIHN0cmluZyBlbmQsIHNpbmNlIG5vXG4gICAgLy8gY29lcmNpYmxlIHN0cmluZyBjYW4gYmUgbW9yZSByaWdodC13YXJkIHdpdGhvdXQgdGhlIHNhbWUgdGVybWludXMuXG4gICAgbGV0IG5leHRcbiAgICB3aGlsZSAoKG5leHQgPSByZVt0LkNPRVJDRVJUTF0uZXhlYyh2ZXJzaW9uKSkgJiZcbiAgICAgICAgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCAhPT0gdmVyc2lvbi5sZW5ndGgpXG4gICAgKSB7XG4gICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dFxuICAgICAgfVxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoXG4gICAgfVxuICAgIC8vIGxlYXZlIGl0IGluIGEgY2xlYW4gc3RhdGVcbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTFcbiAgfVxuXG4gIGlmIChtYXRjaCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBwYXJzZShgJHttYXRjaFsyXX0uJHttYXRjaFszXSB8fCAnMCd9LiR7bWF0Y2hbNF0gfHwgJzAnfWAsIG9wdGlvbnMpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvZXJjZVxuIiwiLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIFJhbmdlIHtcbiAgY29uc3RydWN0b3IgKHJhbmdlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpIHtcbiAgICAgIGlmIChcbiAgICAgICAgcmFuZ2UubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJlxuICAgICAgICByYW5nZS5pbmNsdWRlUHJlcmVsZWFzZSA9PT0gISFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICAvLyBqdXN0IHB1dCBpdCBpbiB0aGUgc2V0IGFuZCByZXR1cm5cbiAgICAgIHRoaXMucmF3ID0gcmFuZ2UudmFsdWVcbiAgICAgIHRoaXMuc2V0ID0gW1tyYW5nZV1dXG4gICAgICB0aGlzLmZvcm1hdCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlXG4gICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gICAgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcbiAgICB0aGlzLnJhdyA9IHJhbmdlXG4gICAgdGhpcy5zZXQgPSByYW5nZVxuICAgICAgLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pXG4gICAgICAvLyBtYXAgdGhlIHJhbmdlIHRvIGEgMmQgYXJyYXkgb2YgY29tcGFyYXRvcnNcbiAgICAgIC5tYXAocmFuZ2UgPT4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSkpXG4gICAgICAvLyB0aHJvdyBvdXQgYW55IGNvbXBhcmF0b3IgbGlzdHMgdGhhdCBhcmUgZW1wdHlcbiAgICAgIC8vIHRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgaXQgd2FzIG5vdCBhIHZhbGlkIHJhbmdlLCB3aGljaCBpcyBhbGxvd2VkXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCBidXQgd2lsbCBzdGlsbCB0aHJvdyBpZiB0aGUgV0hPTEUgcmFuZ2UgaXMgaW52YWxpZC5cbiAgICAgIC5maWx0ZXIoYyA9PiBjLmxlbmd0aClcblxuICAgIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFNlbVZlciBSYW5nZTogJHtyYW5nZX1gKVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgYW55IHRoYXQgYXJlIG5vdCB0aGUgbnVsbCBzZXQsIHRocm93IG91dCBudWxsIHNldHMuXG4gICAgaWYgKHRoaXMuc2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIGtlZXAgdGhlIGZpcnN0IG9uZSwgaW4gY2FzZSB0aGV5J3JlIGFsbCBudWxsIHNldHNcbiAgICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5zZXRbMF1cbiAgICAgIHRoaXMuc2V0ID0gdGhpcy5zZXQuZmlsdGVyKGMgPT4gIWlzTnVsbFNldChjWzBdKSlcbiAgICAgIGlmICh0aGlzLnNldC5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuc2V0ID0gW2ZpcnN0XVxuICAgICAgZWxzZSBpZiAodGhpcy5zZXQubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFueSB0aGF0IGFyZSAqLCB0aGVuIHRoZSByYW5nZSBpcyBqdXN0ICpcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuc2V0KSB7XG4gICAgICAgICAgaWYgKGMubGVuZ3RoID09PSAxICYmIGlzQW55KGNbMF0pKSB7XG4gICAgICAgICAgICB0aGlzLnNldCA9IFtjXVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCgpXG4gIH1cblxuICBmb3JtYXQgKCkge1xuICAgIHRoaXMucmFuZ2UgPSB0aGlzLnNldFxuICAgICAgLm1hcCgoY29tcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbXBzLmpvaW4oJyAnKS50cmltKClcbiAgICAgIH0pXG4gICAgICAuam9pbignfHwnKVxuICAgICAgLnRyaW0oKVxuICAgIHJldHVybiB0aGlzLnJhbmdlXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VcbiAgfVxuXG4gIHBhcnNlUmFuZ2UgKHJhbmdlKSB7XG4gICAgcmFuZ2UgPSByYW5nZS50cmltKClcblxuICAgIC8vIG1lbW9pemUgcmFuZ2UgcGFyc2luZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgLy8gdGhpcyBpcyBhIHZlcnkgaG90IHBhdGgsIGFuZCBmdWxseSBkZXRlcm1pbmlzdGljLlxuICAgIGNvbnN0IG1lbW9PcHRzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5qb2luKCcsJylcbiAgICBjb25zdCBtZW1vS2V5ID0gYHBhcnNlUmFuZ2U6JHttZW1vT3B0c306JHtyYW5nZX1gXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KG1lbW9LZXkpXG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWRcblxuICAgIGNvbnN0IGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlXG4gICAgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG4gICAgY29uc3QgaHIgPSBsb29zZSA/IHJlW3QuSFlQSEVOUkFOR0VMT09TRV0gOiByZVt0LkhZUEhFTlJBTkdFXVxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSh0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKVxuICAgIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKVxuICAgIC8vIGA+IDEuMi4zIDwgMS4yLjVgID0+IGA+MS4yLjMgPDEuMi41YFxuICAgIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKVxuICAgIGRlYnVnKCdjb21wYXJhdG9yIHRyaW0nLCByYW5nZSwgcmVbdC5DT01QQVJBVE9SVFJJTV0pXG5cbiAgICAvLyBgfiAxLjIuM2AgPT4gYH4xLjIuM2BcbiAgICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbdC5USUxERVRSSU1dLCB0aWxkZVRyaW1SZXBsYWNlKVxuXG4gICAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gICAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ0FSRVRUUklNXSwgY2FyZXRUcmltUmVwbGFjZSlcblxuICAgIC8vIG5vcm1hbGl6ZSBzcGFjZXNcbiAgICByYW5nZSA9IHJhbmdlLnNwbGl0KC9cXHMrLykuam9pbignICcpXG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSB0cmltbWVkIGFuZFxuICAgIC8vIHJlYWR5IHRvIGJlIHNwbGl0IGludG8gY29tcGFyYXRvcnMuXG5cbiAgICBjb25zdCBjb21wUmUgPSBsb29zZSA/IHJlW3QuQ09NUEFSQVRPUkxPT1NFXSA6IHJlW3QuQ09NUEFSQVRPUl1cbiAgICBjb25zdCByYW5nZUxpc3QgPSByYW5nZVxuICAgICAgLnNwbGl0KCcgJylcbiAgICAgIC5tYXAoY29tcCA9PiBwYXJzZUNvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKSlcbiAgICAgIC5qb2luKCcgJylcbiAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAvLyA+PTAuMC4wIGlzIGVxdWl2YWxlbnQgdG8gKlxuICAgICAgLm1hcChjb21wID0+IHJlcGxhY2VHVEUwKGNvbXAsIHRoaXMub3B0aW9ucykpXG4gICAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgICAgLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2UgPyBjb21wID0+ICEhY29tcC5tYXRjaChjb21wUmUpIDogKCkgPT4gdHJ1ZSlcbiAgICAgIC5tYXAoY29tcCA9PiBuZXcgQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpKVxuXG4gICAgLy8gaWYgYW55IGNvbXBhcmF0b3JzIGFyZSB0aGUgbnVsbCBzZXQsIHRoZW4gcmVwbGFjZSB3aXRoIEpVU1QgbnVsbCBzZXRcbiAgICAvLyBpZiBtb3JlIHRoYW4gb25lIGNvbXBhcmF0b3IsIHJlbW92ZSBhbnkgKiBjb21wYXJhdG9yc1xuICAgIC8vIGFsc28sIGRvbid0IGluY2x1ZGUgdGhlIHNhbWUgY29tcGFyYXRvciBtb3JlIHRoYW4gb25jZVxuICAgIGNvbnN0IGwgPSByYW5nZUxpc3QubGVuZ3RoXG4gICAgY29uc3QgcmFuZ2VNYXAgPSBuZXcgTWFwKClcbiAgICBmb3IgKGNvbnN0IGNvbXAgb2YgcmFuZ2VMaXN0KSB7XG4gICAgICBpZiAoaXNOdWxsU2V0KGNvbXApKVxuICAgICAgICByZXR1cm4gW2NvbXBdXG4gICAgICByYW5nZU1hcC5zZXQoY29tcC52YWx1ZSwgY29tcClcbiAgICB9XG4gICAgaWYgKHJhbmdlTWFwLnNpemUgPiAxICYmIHJhbmdlTWFwLmhhcygnJykpXG4gICAgICByYW5nZU1hcC5kZWxldGUoJycpXG5cbiAgICBjb25zdCByZXN1bHQgPSBbLi4ucmFuZ2VNYXAudmFsdWVzKCldXG4gICAgY2FjaGUuc2V0KG1lbW9LZXksIHJlc3VsdClcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpbnRlcnNlY3RzIChyYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIFJhbmdlIGlzIHJlcXVpcmVkJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXQuc29tZSgodGhpc0NvbXBhcmF0b3JzKSA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc1NhdGlzZmlhYmxlKHRoaXNDb21wYXJhdG9ycywgb3B0aW9ucykgJiZcbiAgICAgICAgcmFuZ2Uuc2V0LnNvbWUoKHJhbmdlQ29tcGFyYXRvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJlxuICAgICAgICAgICAgdGhpc0NvbXBhcmF0b3JzLmV2ZXJ5KCh0aGlzQ29tcGFyYXRvcikgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VDb21wYXJhdG9ycy5ldmVyeSgocmFuZ2VDb21wYXJhdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmIEFOWSBvZiB0aGUgc2V0cyBtYXRjaCBBTEwgb2YgaXRzIGNvbXBhcmF0b3JzLCB0aGVuIHBhc3NcbiAgdGVzdCAodmVyc2lvbikge1xuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmVyc2lvbiA9IG5ldyBTZW1WZXIodmVyc2lvbiwgdGhpcy5vcHRpb25zKVxuICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRlc3RTZXQodGhpcy5zZXRbaV0sIHZlcnNpb24sIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUmFuZ2VcblxuY29uc3QgTFJVID0gcmVxdWlyZSgnbHJ1LWNhY2hlJylcbmNvbnN0IGNhY2hlID0gbmV3IExSVSh7IG1heDogMTAwMCB9KVxuXG5jb25zdCBwYXJzZU9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wYXJzZS1vcHRpb25zJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuL2NvbXBhcmF0b3InKVxuY29uc3QgZGVidWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9kZWJ1ZycpXG5jb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuL3NlbXZlcicpXG5jb25zdCB7XG4gIHJlLFxuICB0LFxuICBjb21wYXJhdG9yVHJpbVJlcGxhY2UsXG4gIHRpbGRlVHJpbVJlcGxhY2UsXG4gIGNhcmV0VHJpbVJlcGxhY2Vcbn0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9yZScpXG5cbmNvbnN0IGlzTnVsbFNldCA9IGMgPT4gYy52YWx1ZSA9PT0gJzwwLjAuMC0wJ1xuY29uc3QgaXNBbnkgPSBjID0+IGMudmFsdWUgPT09ICcnXG5cbi8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5jb25zdCBpc1NhdGlzZmlhYmxlID0gKGNvbXBhcmF0b3JzLCBvcHRpb25zKSA9PiB7XG4gIGxldCByZXN1bHQgPSB0cnVlXG4gIGNvbnN0IHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKVxuICBsZXQgdGVzdENvbXBhcmF0b3IgPSByZW1haW5pbmdDb21wYXJhdG9ycy5wb3AoKVxuXG4gIHdoaWxlIChyZXN1bHQgJiYgcmVtYWluaW5nQ29tcGFyYXRvcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0ID0gcmVtYWluaW5nQ29tcGFyYXRvcnMuZXZlcnkoKG90aGVyQ29tcGFyYXRvcikgPT4ge1xuICAgICAgcmV0dXJuIHRlc3RDb21wYXJhdG9yLmludGVyc2VjdHMob3RoZXJDb21wYXJhdG9yLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICB0ZXN0Q29tcGFyYXRvciA9IHJlbWFpbmluZ0NvbXBhcmF0b3JzLnBvcCgpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIGNvbXByaXNlZCBvZiB4cmFuZ2VzLCB0aWxkZXMsIHN0YXJzLCBhbmQgZ3RsdCdzIGF0IHRoaXMgcG9pbnQuXG4vLyBhbHJlYWR5IHJlcGxhY2VkIHRoZSBoeXBoZW4gcmFuZ2VzXG4vLyB0dXJuIGludG8gYSBzZXQgb2YgSlVTVCBjb21wYXJhdG9ycy5cbmNvbnN0IHBhcnNlQ29tcGFyYXRvciA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdjb21wJywgY29tcCwgb3B0aW9ucylcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ2NhcmV0JywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucylcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApXG4gIGNvbXAgPSByZXBsYWNlWFJhbmdlcyhjb21wLCBvcHRpb25zKVxuICBkZWJ1ZygneHJhbmdlJywgY29tcClcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKVxuICBkZWJ1Zygnc3RhcnMnLCBjb21wKVxuICByZXR1cm4gY29tcFxufVxuXG5jb25zdCBpc1ggPSBpZCA9PiAhaWQgfHwgaWQudG9Mb3dlckNhc2UoKSA9PT0gJ3gnIHx8IGlkID09PSAnKidcblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wLTBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0+ID49Mi4wLjAgPDIuMS4wLTBcbi8vIH4xLjIsIH4xLjIueCwgfj4xLjIsIH4+MS4yLnggLS0+ID49MS4yLjAgPDEuMy4wLTBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjAtMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tPiA+PTEuMi4wIDwxLjMuMC0wXG5jb25zdCByZXBsYWNlVGlsZGVzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZVRpbGRlID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV1cbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygndGlsZGUnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCA8JHsrTSArIDF9LjAuMC0wYFxuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wLTBcbiAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wIDwke019LiR7K20gKyAxfS4wLTBgXG4gICAgfSBlbHNlIGlmIChwcikge1xuICAgICAgZGVidWcoJ3JlcGxhY2VUaWxkZSBwcicsIHByKVxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB+MS4yLjMgPT0gPj0xLjIuMyA8MS4zLjAtMFxuICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgfSA8JHtNfS4keyttICsgMX0uMC0wYFxuICAgIH1cblxuICAgIGRlYnVnKCd0aWxkZSByZXR1cm4nLCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9KVxufVxuXG4vLyBeIC0tPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLT4gPj0yLjAuMCA8My4wLjAtMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMC0wXG4vLyBeMS4yLCBeMS4yLnggLS0+ID49MS4yLjAgPDIuMC4wLTBcbi8vIF4xLjIuMyAtLT4gPj0xLjIuMyA8Mi4wLjAtMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMC0wXG5jb25zdCByZXBsYWNlQ2FyZXRzID0gKGNvbXAsIG9wdGlvbnMpID0+XG4gIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKChjb21wKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcblxuY29uc3QgcmVwbGFjZUNhcmV0ID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ2NhcmV0JywgY29tcCwgb3B0aW9ucylcbiAgY29uc3QgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF1cbiAgY29uc3QgeiA9IG9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UgPyAnLTAnIDogJydcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCAoXywgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBfLCBNLCBtLCBwLCBwcilcbiAgICBsZXQgcmV0XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJ1xuICAgIH0gZWxzZSBpZiAoaXNYKG0pKSB7XG4gICAgICByZXQgPSBgPj0ke019LjAuMCR7en0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKGlzWChwKSkge1xuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4wJHt6fSA8JHsrTSArIDF9LjAuMC0wYFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcilcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJykge1xuICAgICAgICAgIHJldCA9IGA+PSR7TX0uJHttfS4ke3B9LSR7cHJcbiAgICAgICAgICB9IDwke019LiR7bX0uJHsrcCArIDF9LTBgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cH0tJHtwclxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdubyBwcicpXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHttfS4keytwICsgMX0tMGBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBgPj0ke019LiR7bX0uJHtwXG4gICAgICAgICAgfSR7en0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gYD49JHtNfS4ke219LiR7cFxuICAgICAgICB9IDwkeytNICsgMX0uMC4wLTBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0pXG59XG5cbmNvbnN0IHJlcGxhY2VYUmFuZ2VzID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoKGNvbXApID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKVxuICB9KS5qb2luKCcgJylcbn1cblxuY29uc3QgcmVwbGFjZVhSYW5nZSA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGNvbXAgPSBjb21wLnRyaW0oKVxuICBjb25zdCByID0gb3B0aW9ucy5sb29zZSA/IHJlW3QuWFJBTkdFTE9PU0VdIDogcmVbdC5YUkFOR0VdXG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgKHJldCwgZ3RsdCwgTSwgbSwgcCwgcHIpID0+IHtcbiAgICBkZWJ1ZygneFJhbmdlJywgY29tcCwgcmV0LCBndGx0LCBNLCBtLCBwLCBwcilcbiAgICBjb25zdCB4TSA9IGlzWChNKVxuICAgIGNvbnN0IHhtID0geE0gfHwgaXNYKG0pXG4gICAgY29uc3QgeHAgPSB4bSB8fCBpc1gocClcbiAgICBjb25zdCBhbnlYID0geHBcblxuICAgIGlmIChndGx0ID09PSAnPScgJiYgYW55WCkge1xuICAgICAgZ3RsdCA9ICcnXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgaW5jbHVkaW5nIHByZXJlbGVhc2VzIGluIHRoZSBtYXRjaCwgdGhlbiB3ZSBuZWVkXG4gICAgLy8gdG8gZml4IHRoaXMgdG8gLTAsIHRoZSBsb3dlc3QgcG9zc2libGUgcHJlcmVsZWFzZSB2YWx1ZVxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJ1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMC0wJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBmb3JiaWRkZW5cbiAgICAgICAgcmV0ID0gJyonXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMFxuICAgICAgfVxuICAgICAgcCA9IDBcblxuICAgICAgaWYgKGd0bHQgPT09ICc+Jykge1xuICAgICAgICAvLyA+MSA9PiA+PTIuMC4wXG4gICAgICAgIC8vID4xLjIgPT4gPj0xLjMuMFxuICAgICAgICBndGx0ID0gJz49J1xuICAgICAgICBpZiAoeG0pIHtcbiAgICAgICAgICBNID0gK00gKyAxXG4gICAgICAgICAgbSA9IDBcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgICBwID0gMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGd0bHQgPT09ICc8PScpIHtcbiAgICAgICAgLy8gPD0wLjcueCBpcyBhY3R1YWxseSA8MC44LjAsIHNpbmNlIGFueSAwLjcueCBzaG91bGRcbiAgICAgICAgLy8gcGFzcy4gIFNpbWlsYXJseSwgPD03LnggaXMgYWN0dWFsbHkgPDguMC4wLCBldGMuXG4gICAgICAgIGd0bHQgPSAnPCdcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0gPSArbSArIDFcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ3RsdCA9PT0gJzwnKVxuICAgICAgICBwciA9ICctMCdcblxuICAgICAgcmV0ID0gYCR7Z3RsdCArIE19LiR7bX0uJHtwfSR7cHJ9YFxuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9IGA+PSR7TX0uMC4wJHtwcn0gPCR7K00gKyAxfS4wLjAtMGBcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSBgPj0ke019LiR7bX0uMCR7cHJcbiAgICAgIH0gPCR7TX0uJHsrbSArIDF9LjAtMGBcbiAgICB9XG5cbiAgICBkZWJ1ZygneFJhbmdlIHJldHVybicsIHJldClcblxuICAgIHJldHVybiByZXRcbiAgfSlcbn1cblxuLy8gQmVjYXVzZSAqIGlzIEFORC1lZCB3aXRoIGV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgY29tcGFyYXRvcixcbi8vIGFuZCAnJyBtZWFucyBcImFueSB2ZXJzaW9uXCIsIGp1c3QgcmVtb3ZlIHRoZSAqcyBlbnRpcmVseS5cbmNvbnN0IHJlcGxhY2VTdGFycyA9IChjb21wLCBvcHRpb25zKSA9PiB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKVxuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpXG59XG5cbmNvbnN0IHJlcGxhY2VHVEUwID0gKGNvbXAsIG9wdGlvbnMpID0+IHtcbiAgZGVidWcoJ3JlcGxhY2VHVEUwJywgY29tcCwgb3B0aW9ucylcbiAgcmV0dXJuIGNvbXAudHJpbSgpXG4gICAgLnJlcGxhY2UocmVbb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/IHQuR1RFMFBSRSA6IHQuR1RFMF0sICcnKVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMC0wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjAtMFxuY29uc3QgaHlwaGVuUmVwbGFjZSA9IGluY1ByID0+ICgkMCxcbiAgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYixcbiAgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpID0+IHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJydcbiAgfSBlbHNlIGlmIChpc1goZm0pKSB7XG4gICAgZnJvbSA9IGA+PSR7Zk19LjAuMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGlzWChmcCkpIHtcbiAgICBmcm9tID0gYD49JHtmTX0uJHtmbX0uMCR7aW5jUHIgPyAnLTAnIDogJyd9YFxuICB9IGVsc2UgaWYgKGZwcikge1xuICAgIGZyb20gPSBgPj0ke2Zyb219YFxuICB9IGVsc2Uge1xuICAgIGZyb20gPSBgPj0ke2Zyb219JHtpbmNQciA/ICctMCcgOiAnJ31gXG4gIH1cblxuICBpZiAoaXNYKHRNKSkge1xuICAgIHRvID0gJydcbiAgfSBlbHNlIGlmIChpc1godG0pKSB7XG4gICAgdG8gPSBgPCR7K3RNICsgMX0uMC4wLTBgXG4gIH0gZWxzZSBpZiAoaXNYKHRwKSkge1xuICAgIHRvID0gYDwke3RNfS4keyt0bSArIDF9LjAtMGBcbiAgfSBlbHNlIGlmICh0cHIpIHtcbiAgICB0byA9IGA8PSR7dE19LiR7dG19LiR7dHB9LSR7dHByfWBcbiAgfSBlbHNlIGlmIChpbmNQcikge1xuICAgIHRvID0gYDwke3RNfS4ke3RtfS4keyt0cCArIDF9LTBgXG4gIH0gZWxzZSB7XG4gICAgdG8gPSBgPD0ke3RvfWBcbiAgfVxuXG4gIHJldHVybiAoYCR7ZnJvbX0gJHt0b31gKS50cmltKClcbn1cblxuY29uc3QgdGVzdFNldCA9IChzZXQsIHZlcnNpb24sIG9wdGlvbnMpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWJ1ZyhzZXRbaV0uc2VtdmVyKVxuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IENvbXBhcmF0b3IuQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2V0W2ldLnNlbXZlclxuICAgICAgICBpZiAoYWxsb3dlZC5tYWpvciA9PT0gdmVyc2lvbi5tYWpvciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5taW5vciA9PT0gdmVyc2lvbi5taW5vciAmJlxuICAgICAgICAgICAgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJjb25zdCBBTlkgPSBTeW1ib2woJ1NlbVZlciBBTlknKVxuLy8gaG9pc3RlZCBjbGFzcyBmb3IgY3ljbGljIGRlcGVuZGVuY3lcbmNsYXNzIENvbXBhcmF0b3Ige1xuICBzdGF0aWMgZ2V0IEFOWSAoKSB7XG4gICAgcmV0dXJuIEFOWVxuICB9XG4gIGNvbnN0cnVjdG9yIChjb21wLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKVxuXG4gICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICAgIHJldHVybiBjb21wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wID0gY29tcC52YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlYnVnKCdjb21wYXJhdG9yJywgY29tcCwgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZVxuICAgIHRoaXMucGFyc2UoY29tcClcblxuICAgIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3BlcmF0b3IgKyB0aGlzLnNlbXZlci52ZXJzaW9uXG4gICAgfVxuXG4gICAgZGVidWcoJ2NvbXAnLCB0aGlzKVxuICB9XG5cbiAgcGFyc2UgKGNvbXApIHtcbiAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLmxvb3NlID8gcmVbdC5DT01QQVJBVE9STE9PU0VdIDogcmVbdC5DT01QQVJBVE9SXVxuICAgIGNvbnN0IG0gPSBjb21wLm1hdGNoKHIpXG5cbiAgICBpZiAoIW0pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgY29tcGFyYXRvcjogJHtjb21wfWApXG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvciA9IG1bMV0gIT09IHVuZGVmaW5lZCA/IG1bMV0gOiAnJ1xuICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICAgIHRoaXMub3BlcmF0b3IgPSAnJ1xuICAgIH1cblxuICAgIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICAgIGlmICghbVsyXSkge1xuICAgICAgdGhpcy5zZW12ZXIgPSBBTllcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW12ZXIgPSBuZXcgU2VtVmVyKG1bMl0sIHRoaXMub3B0aW9ucy5sb29zZSlcbiAgICB9XG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVcbiAgfVxuXG4gIHRlc3QgKHZlcnNpb24pIHtcbiAgICBkZWJ1ZygnQ29tcGFyYXRvci50ZXN0JywgdmVyc2lvbiwgdGhpcy5vcHRpb25zLmxvb3NlKVxuXG4gICAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkgfHwgdmVyc2lvbiA9PT0gQU5ZKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucylcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGludGVyc2VjdHMgKGNvbXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgQ29tcGFyYXRvciBpcyByZXF1aXJlZCcpXG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucykudGVzdCh0aGlzLnZhbHVlKVxuICAgIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICAgIGlmIChjb21wLnZhbHVlID09PSAnJykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKS50ZXN0KGNvbXAuc2VtdmVyKVxuICAgIH1cblxuICAgIGNvbnN0IHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JylcbiAgICBjb25zdCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9XG4gICAgICAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpXG4gICAgY29uc3Qgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb25cbiAgICBjb25zdCBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmXG4gICAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPD0nKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKVxuICAgIGNvbnN0IG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID1cbiAgICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAgICAgKGNvbXAub3BlcmF0b3IgPT09ICc+PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJz4nKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNhbWVEaXJlY3Rpb25JbmNyZWFzaW5nIHx8XG4gICAgICBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgICAgKHNhbWVTZW1WZXIgJiYgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSkgfHxcbiAgICAgIG9wcG9zaXRlRGlyZWN0aW9uc0xlc3NUaGFuIHx8XG4gICAgICBvcHBvc2l0ZURpcmVjdGlvbnNHcmVhdGVyVGhhblxuICAgIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhcmF0b3JcblxuY29uc3QgcGFyc2VPcHRpb25zID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcGFyc2Utb3B0aW9ucycpXG5jb25zdCB7cmUsIHR9ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWwvcmUnKVxuY29uc3QgY21wID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NtcCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJy4uL2ludGVybmFsL2RlYnVnJylcbmNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4vc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi9yYW5nZScpXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbilcbn1cbm1vZHVsZS5leHBvcnRzID0gc2F0aXNmaWVzXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5jb25zdCB0b0NvbXBhcmF0b3JzID0gKHJhbmdlLCBvcHRpb25zKSA9PlxuICBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnNldFxuICAgIC5tYXAoY29tcCA9PiBjb21wLm1hcChjID0+IGMudmFsdWUpLmpvaW4oJyAnKS50cmltKCkuc3BsaXQoJyAnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB0b0NvbXBhcmF0b3JzXG4iLCJjb25zdCBTZW1WZXIgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3NlbXZlcicpXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuXG5jb25zdCBtYXhTYXRpc2Z5aW5nID0gKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykgPT4ge1xuICBsZXQgbWF4ID0gbnVsbFxuICBsZXQgbWF4U1YgPSBudWxsXG4gIGxldCByYW5nZU9iaiA9IG51bGxcbiAgdHJ5IHtcbiAgICByYW5nZU9iaiA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZlcnNpb25zLmZvckVhY2goKHYpID0+IHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHZcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBtYXhcbn1cbm1vZHVsZS5leHBvcnRzID0gbWF4U2F0aXNmeWluZ1xuIiwiY29uc3QgU2VtVmVyID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9zZW12ZXInKVxuY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IG1pblNhdGlzZnlpbmcgPSAodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSA9PiB7XG4gIGxldCBtaW4gPSBudWxsXG4gIGxldCBtaW5TViA9IG51bGxcbiAgbGV0IHJhbmdlT2JqID0gbnVsbFxuICB0cnkge1xuICAgIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmVyc2lvbnMuZm9yRWFjaCgodikgPT4ge1xuICAgIGlmIChyYW5nZU9iai50ZXN0KHYpKSB7XG4gICAgICAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1pbiB8fCBtaW5TVi5jb21wYXJlKHYpID09PSAxKSB7XG4gICAgICAgIC8vIGNvbXBhcmUobWluLCB2LCB0cnVlKVxuICAgICAgICBtaW4gPSB2XG4gICAgICAgIG1pblNWID0gbmV3IFNlbVZlcihtaW4sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluXG59XG5tb2R1bGUuZXhwb3J0cyA9IG1pblNhdGlzZnlpbmdcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IFJhbmdlID0gcmVxdWlyZSgnLi4vY2xhc3Nlcy9yYW5nZScpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5cbmNvbnN0IG1pblZlcnNpb24gPSAocmFuZ2UsIGxvb3NlKSA9PiB7XG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBsb29zZSlcblxuICBsZXQgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAnKVxuICBpZiAocmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlclxuICB9XG5cbiAgbWludmVyID0gbmV3IFNlbVZlcignMC4wLjAtMCcpXG4gIGlmIChyYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICBtaW52ZXIgPSBudWxsXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBzZXRNaW4gPSBudWxsXG4gICAgY29tcGFyYXRvcnMuZm9yRWFjaCgoY29tcGFyYXRvcikgPT4ge1xuICAgICAgLy8gQ2xvbmUgdG8gYXZvaWQgbWFuaXB1bGF0aW5nIHRoZSBjb21wYXJhdG9yJ3Mgc2VtdmVyIG9iamVjdC5cbiAgICAgIGNvbnN0IGNvbXB2ZXIgPSBuZXcgU2VtVmVyKGNvbXBhcmF0b3Iuc2VtdmVyLnZlcnNpb24pXG4gICAgICBzd2l0Y2ggKGNvbXBhcmF0b3Iub3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgaWYgKGNvbXB2ZXIucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbXB2ZXIucGF0Y2grK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KClcbiAgICAgICAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFzZXRNaW4gfHwgZ3QoY29tcHZlciwgc2V0TWluKSkge1xuICAgICAgICAgICAgc2V0TWluID0gY29tcHZlclxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgb3BlcmF0aW9uOiAke2NvbXBhcmF0b3Iub3BlcmF0b3J9YClcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzZXRNaW4gJiYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBzZXRNaW4pKSlcbiAgICAgIG1pbnZlciA9IHNldE1pblxuICB9XG5cbiAgaWYgKG1pbnZlciAmJiByYW5nZS50ZXN0KG1pbnZlcikpIHtcbiAgICByZXR1cm4gbWludmVyXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxubW9kdWxlLmV4cG9ydHMgPSBtaW5WZXJzaW9uXG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3QgdmFsaWRSYW5nZSA9IChyYW5nZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKidcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHZhbGlkUmFuZ2VcbiIsImNvbnN0IFNlbVZlciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvc2VtdmVyJylcbmNvbnN0IENvbXBhcmF0b3IgPSByZXF1aXJlKCcuLi9jbGFzc2VzL2NvbXBhcmF0b3InKVxuY29uc3Qge0FOWX0gPSBDb21wYXJhdG9yXG5jb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UnKVxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcycpXG5jb25zdCBndCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndCcpXG5jb25zdCBsdCA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9sdCcpXG5jb25zdCBsdGUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvbHRlJylcbmNvbnN0IGd0ZSA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucy9ndGUnKVxuXG5jb25zdCBvdXRzaWRlID0gKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSA9PiB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpXG4gIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKVxuXG4gIGxldCBndGZuLCBsdGVmbiwgbHRmbiwgY29tcCwgZWNvbXBcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3RcbiAgICAgIGx0ZWZuID0gbHRlXG4gICAgICBsdGZuID0gbHRcbiAgICAgIGNvbXAgPSAnPidcbiAgICAgIGVjb21wID0gJz49J1xuICAgICAgYnJlYWtcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdFxuICAgICAgbHRlZm4gPSBndGVcbiAgICAgIGx0Zm4gPSBndFxuICAgICAgY29tcCA9ICc8J1xuICAgICAgZWNvbXAgPSAnPD0nXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpXG4gIH1cblxuICAvLyBJZiBpdCBzYXRpc2ZpZXMgdGhlIHJhbmdlIGl0IGlzIG5vdCBvdXRzaWRlXG4gIGlmIChzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBGcm9tIG5vdyBvbiwgdmFyaWFibGUgdGVybXMgYXJlIGFzIGlmIHdlJ3JlIGluIFwiZ3RyXCIgbW9kZS5cbiAgLy8gYnV0IG5vdGUgdGhhdCBldmVyeXRoaW5nIGlzIGZsaXBwZWQgZm9yIHRoZSBcImx0clwiIGZ1bmN0aW9uLlxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV1cblxuICAgIGxldCBoaWdoID0gbnVsbFxuICAgIGxldCBsb3cgPSBudWxsXG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKChjb21wYXJhdG9yKSA9PiB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKVxuICAgICAgfVxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvclxuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3JcbiAgICAgIGlmIChndGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBoaWdoLnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgaGlnaCA9IGNvbXBhcmF0b3JcbiAgICAgIH0gZWxzZSBpZiAobHRmbihjb21wYXJhdG9yLnNlbXZlciwgbG93LnNlbXZlciwgb3B0aW9ucykpIHtcbiAgICAgICAgbG93ID0gY29tcGFyYXRvclxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcbiAgICBpZiAoaGlnaC5vcGVyYXRvciA9PT0gY29tcCB8fCBoaWdoLm9wZXJhdG9yID09PSBlY29tcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxvd2VzdCB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGFuIG9wZXJhdG9yIGFuZCBvdXIgdmVyc2lvblxuICAgIC8vIGlzIGxlc3MgdGhhbiBpdCB0aGVuIGl0IGlzbid0IGhpZ2hlciB0aGFuIHRoZSByYW5nZVxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmXG4gICAgICAgIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0c2lkZVxuIiwiLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuY29uc3Qgb3V0c2lkZSA9IHJlcXVpcmUoJy4vb3V0c2lkZScpXG5jb25zdCBndHIgPSAodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpID0+IG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucylcbm1vZHVsZS5leHBvcnRzID0gZ3RyXG4iLCJjb25zdCBvdXRzaWRlID0gcmVxdWlyZSgnLi9vdXRzaWRlJylcbi8vIERldGVybWluZSBpZiB2ZXJzaW9uIGlzIGxlc3MgdGhhbiBhbGwgdGhlIHZlcnNpb25zIHBvc3NpYmxlIGluIHRoZSByYW5nZVxuY29uc3QgbHRyID0gKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSA9PiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpXG5tb2R1bGUuZXhwb3J0cyA9IGx0clxuIiwiY29uc3QgUmFuZ2UgPSByZXF1aXJlKCcuLi9jbGFzc2VzL3JhbmdlJylcbmNvbnN0IGludGVyc2VjdHMgPSAocjEsIHIyLCBvcHRpb25zKSA9PiB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKVxuICByMiA9IG5ldyBSYW5nZShyMiwgb3B0aW9ucylcbiAgcmV0dXJuIHIxLmludGVyc2VjdHMocjIpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdHNcbiIsIi8vIGdpdmVuIGEgc2V0IG9mIHZlcnNpb25zIGFuZCBhIHJhbmdlLCBjcmVhdGUgYSBcInNpbXBsaWZpZWRcIiByYW5nZVxuLy8gdGhhdCBpbmNsdWRlcyB0aGUgc2FtZSB2ZXJzaW9ucyB0aGF0IHRoZSBvcmlnaW5hbCByYW5nZSBkb2VzXG4vLyBJZiB0aGUgb3JpZ2luYWwgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzaW1wbGlmaWVkIG9uZSwgcmV0dXJuIHRoYXQuXG5jb25zdCBzYXRpc2ZpZXMgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvc2F0aXNmaWVzLmpzJylcbmNvbnN0IGNvbXBhcmUgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMvY29tcGFyZS5qcycpXG5tb2R1bGUuZXhwb3J0cyA9ICh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc2V0ID0gW11cbiAgbGV0IG1pbiA9IG51bGxcbiAgbGV0IHByZXYgPSBudWxsXG4gIGNvbnN0IHYgPSB2ZXJzaW9ucy5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEsIGIsIG9wdGlvbnMpKVxuICBmb3IgKGNvbnN0IHZlcnNpb24gb2Ygdikge1xuICAgIGNvbnN0IGluY2x1ZGVkID0gc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKVxuICAgIGlmIChpbmNsdWRlZCkge1xuICAgICAgcHJldiA9IHZlcnNpb25cbiAgICAgIGlmICghbWluKVxuICAgICAgICBtaW4gPSB2ZXJzaW9uXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgIHNldC5wdXNoKFttaW4sIHByZXZdKVxuICAgICAgfVxuICAgICAgcHJldiA9IG51bGxcbiAgICAgIG1pbiA9IG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKG1pbilcbiAgICBzZXQucHVzaChbbWluLCBudWxsXSlcblxuICBjb25zdCByYW5nZXMgPSBbXVxuICBmb3IgKGNvbnN0IFttaW4sIG1heF0gb2Ygc2V0KSB7XG4gICAgaWYgKG1pbiA9PT0gbWF4KVxuICAgICAgcmFuZ2VzLnB1c2gobWluKVxuICAgIGVsc2UgaWYgKCFtYXggJiYgbWluID09PSB2WzBdKVxuICAgICAgcmFuZ2VzLnB1c2goJyonKVxuICAgIGVsc2UgaWYgKCFtYXgpXG4gICAgICByYW5nZXMucHVzaChgPj0ke21pbn1gKVxuICAgIGVsc2UgaWYgKG1pbiA9PT0gdlswXSlcbiAgICAgIHJhbmdlcy5wdXNoKGA8PSR7bWF4fWApXG4gICAgZWxzZVxuICAgICAgcmFuZ2VzLnB1c2goYCR7bWlufSAtICR7bWF4fWApXG4gIH1cbiAgY29uc3Qgc2ltcGxpZmllZCA9IHJhbmdlcy5qb2luKCcgfHwgJylcbiAgY29uc3Qgb3JpZ2luYWwgPSB0eXBlb2YgcmFuZ2UucmF3ID09PSAnc3RyaW5nJyA/IHJhbmdlLnJhdyA6IFN0cmluZyhyYW5nZSlcbiAgcmV0dXJuIHNpbXBsaWZpZWQubGVuZ3RoIDwgb3JpZ2luYWwubGVuZ3RoID8gc2ltcGxpZmllZCA6IHJhbmdlXG59XG4iLCJjb25zdCBSYW5nZSA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvcmFuZ2UuanMnKVxuY29uc3QgQ29tcGFyYXRvciA9IHJlcXVpcmUoJy4uL2NsYXNzZXMvY29tcGFyYXRvci5qcycpXG5jb25zdCB7IEFOWSB9ID0gQ29tcGFyYXRvclxuY29uc3Qgc2F0aXNmaWVzID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL3NhdGlzZmllcy5qcycpXG5jb25zdCBjb21wYXJlID0gcmVxdWlyZSgnLi4vZnVuY3Rpb25zL2NvbXBhcmUuanMnKVxuXG4vLyBDb21wbGV4IHJhbmdlIGByMSB8fCByMiB8fCAuLi5gIGlzIGEgc3Vic2V0IG9mIGBSMSB8fCBSMiB8fCAuLi5gIGlmZjpcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgaXMgYSBudWxsIHNldCwgT1Jcbi8vIC0gRXZlcnkgc2ltcGxlIHJhbmdlIGByMSwgcjIsIC4uLmAgd2hpY2ggaXMgbm90IGEgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2Zcbi8vICAgc29tZSBgUjEsIFIyLCAuLi5gXG4vL1xuLy8gU2ltcGxlIHJhbmdlIGBjMSBjMiAuLi5gIGlzIGEgc3Vic2V0IG9mIHNpbXBsZSByYW5nZSBgQzEgQzIgLi4uYCBpZmY6XG4vLyAtIElmIGMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBJZiBDIGlzIG9ubHkgdGhlIEFOWSBjb21wYXJhdG9yLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgaWYgaW4gcHJlcmVsZWFzZSBtb2RlLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBlbHNlIHJlcGxhY2UgYyB3aXRoIGBbPj0wLjAuMF1gXG4vLyAtIElmIEMgaXMgb25seSB0aGUgQU5ZIGNvbXBhcmF0b3Jcbi8vICAgLSBpZiBpbiBwcmVyZWxlYXNlIG1vZGUsIHJldHVybiB0cnVlXG4vLyAgIC0gZWxzZSByZXBsYWNlIEMgd2l0aCBgWz49MC4wLjBdYFxuLy8gLSBMZXQgRVEgYmUgdGhlIHNldCBvZiA9IGNvbXBhcmF0b3JzIGluIGNcbi8vIC0gSWYgRVEgaXMgbW9yZSB0aGFuIG9uZSwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gLSBMZXQgR1QgYmUgdGhlIGhpZ2hlc3QgPiBvciA+PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gTGV0IExUIGJlIHRoZSBsb3dlc3QgPCBvciA8PSBjb21wYXJhdG9yIGluIGNcbi8vIC0gSWYgR1QgYW5kIExULCBhbmQgR1Quc2VtdmVyID4gTFQuc2VtdmVyLCByZXR1cm4gdHJ1ZSAobnVsbCBzZXQpXG4vLyAtIElmIGFueSBDIGlzIGEgPSByYW5nZSwgYW5kIEdUIG9yIExUIGFyZSBzZXQsIHJldHVybiBmYWxzZVxuLy8gLSBJZiBFUVxuLy8gICAtIElmIEdULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBHVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIExULCBhbmQgRVEgZG9lcyBub3Qgc2F0aXNmeSBMVCwgcmV0dXJuIHRydWUgKG51bGwgc2V0KVxuLy8gICAtIElmIEVRIHNhdGlzZmllcyBldmVyeSBDLCByZXR1cm4gdHJ1ZVxuLy8gICAtIEVsc2UgcmV0dXJuIGZhbHNlXG4vLyAtIElmIEdUXG4vLyAgIC0gSWYgR1Quc2VtdmVyIGlzIGxvd2VyIHRoYW4gYW55ID4gb3IgPj0gY29tcCBpbiBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVCBpcyA+PSwgYW5kIEdULnNlbXZlciBkb2VzIG5vdCBzYXRpc2Z5IGV2ZXJ5IEMsIHJldHVybiBmYWxzZVxuLy8gICAtIElmIEdULnNlbXZlciBoYXMgYSBwcmVyZWxlYXNlLCBhbmQgbm90IGluIHByZXJlbGVhc2UgbW9kZVxuLy8gICAgIC0gSWYgbm8gQyBoYXMgYSBwcmVyZWxlYXNlIGFuZCB0aGUgR1Quc2VtdmVyIHR1cGxlLCByZXR1cm4gZmFsc2Vcbi8vIC0gSWYgTFRcbi8vICAgLSBJZiBMVC5zZW12ZXIgaXMgZ3JlYXRlciB0aGFuIGFueSA8IG9yIDw9IGNvbXAgaW4gQywgcmV0dXJuIGZhbHNlXG4vLyAgIC0gSWYgTFQgaXMgPD0sIGFuZCBMVC5zZW12ZXIgZG9lcyBub3Qgc2F0aXNmeSBldmVyeSBDLCByZXR1cm4gZmFsc2Vcbi8vICAgLSBJZiBHVC5zZW12ZXIgaGFzIGEgcHJlcmVsZWFzZSwgYW5kIG5vdCBpbiBwcmVyZWxlYXNlIG1vZGVcbi8vICAgICAtIElmIG5vIEMgaGFzIGEgcHJlcmVsZWFzZSBhbmQgdGhlIExULnNlbXZlciB0dXBsZSwgcmV0dXJuIGZhbHNlXG4vLyAtIEVsc2UgcmV0dXJuIHRydWVcblxuY29uc3Qgc3Vic2V0ID0gKHN1YiwgZG9tLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgc3ViID0gbmV3IFJhbmdlKHN1Yiwgb3B0aW9ucylcbiAgZG9tID0gbmV3IFJhbmdlKGRvbSwgb3B0aW9ucylcbiAgbGV0IHNhd05vbk51bGwgPSBmYWxzZVxuXG4gIE9VVEVSOiBmb3IgKGNvbnN0IHNpbXBsZVN1YiBvZiBzdWIuc2V0KSB7XG4gICAgZm9yIChjb25zdCBzaW1wbGVEb20gb2YgZG9tLnNldCkge1xuICAgICAgY29uc3QgaXNTdWIgPSBzaW1wbGVTdWJzZXQoc2ltcGxlU3ViLCBzaW1wbGVEb20sIG9wdGlvbnMpXG4gICAgICBzYXdOb25OdWxsID0gc2F3Tm9uTnVsbCB8fCBpc1N1YiAhPT0gbnVsbFxuICAgICAgaWYgKGlzU3ViKVxuICAgICAgICBjb250aW51ZSBPVVRFUlxuICAgIH1cbiAgICAvLyB0aGUgbnVsbCBzZXQgaXMgYSBzdWJzZXQgb2YgZXZlcnl0aGluZywgYnV0IG51bGwgc2ltcGxlIHJhbmdlcyBpblxuICAgIC8vIGEgY29tcGxleCByYW5nZSBzaG91bGQgYmUgaWdub3JlZC4gIHNvIGlmIHdlIHNhdyBhIG5vbi1udWxsIHJhbmdlLFxuICAgIC8vIHRoZW4gd2Uga25vdyB0aGlzIGlzbid0IGEgc3Vic2V0LCBidXQgaWYgRVZFUlkgc2ltcGxlIHJhbmdlIHdhcyBudWxsLFxuICAgIC8vIHRoZW4gaXQgaXMgYSBzdWJzZXQuXG4gICAgaWYgKHNhd05vbk51bGwpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBzaW1wbGVTdWJzZXQgPSAoc3ViLCBkb20sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHN1YiA9PT0gZG9tKVxuICAgIHJldHVybiB0cnVlXG5cbiAgaWYgKHN1Yi5sZW5ndGggPT09IDEgJiYgc3ViWzBdLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgaWYgKGRvbS5sZW5ndGggPT09IDEgJiYgZG9tWzBdLnNlbXZlciA9PT0gQU5ZKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICBlbHNlIGlmIChvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKVxuICAgICAgc3ViID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMC0wJykgXVxuICAgIGVsc2VcbiAgICAgIHN1YiA9IFsgbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKSBdXG4gIH1cblxuICBpZiAoZG9tLmxlbmd0aCA9PT0gMSAmJiBkb21bMF0uc2VtdmVyID09PSBBTlkpIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZWxzZVxuICAgICAgZG9tID0gWyBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpIF1cbiAgfVxuXG4gIGNvbnN0IGVxU2V0ID0gbmV3IFNldCgpXG4gIGxldCBndCwgbHRcbiAgZm9yIChjb25zdCBjIG9mIHN1Yikge1xuICAgIGlmIChjLm9wZXJhdG9yID09PSAnPicgfHwgYy5vcGVyYXRvciA9PT0gJz49JylcbiAgICAgIGd0ID0gaGlnaGVyR1QoZ3QsIGMsIG9wdGlvbnMpXG4gICAgZWxzZSBpZiAoYy5vcGVyYXRvciA9PT0gJzwnIHx8IGMub3BlcmF0b3IgPT09ICc8PScpXG4gICAgICBsdCA9IGxvd2VyTFQobHQsIGMsIG9wdGlvbnMpXG4gICAgZWxzZVxuICAgICAgZXFTZXQuYWRkKGMuc2VtdmVyKVxuICB9XG5cbiAgaWYgKGVxU2V0LnNpemUgPiAxKVxuICAgIHJldHVybiBudWxsXG5cbiAgbGV0IGd0bHRDb21wXG4gIGlmIChndCAmJiBsdCkge1xuICAgIGd0bHRDb21wID0gY29tcGFyZShndC5zZW12ZXIsIGx0LnNlbXZlciwgb3B0aW9ucylcbiAgICBpZiAoZ3RsdENvbXAgPiAwKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICBlbHNlIGlmIChndGx0Q29tcCA9PT0gMCAmJiAoZ3Qub3BlcmF0b3IgIT09ICc+PScgfHwgbHQub3BlcmF0b3IgIT09ICc8PScpKVxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIHdpbGwgaXRlcmF0ZSBvbmUgb3IgemVybyB0aW1lc1xuICBmb3IgKGNvbnN0IGVxIG9mIGVxU2V0KSB7XG4gICAgaWYgKGd0ICYmICFzYXRpc2ZpZXMoZXEsIFN0cmluZyhndCksIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGlmIChsdCAmJiAhc2F0aXNmaWVzKGVxLCBTdHJpbmcobHQpLCBvcHRpb25zKSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBmb3IgKGNvbnN0IGMgb2YgZG9tKSB7XG4gICAgICBpZiAoIXNhdGlzZmllcyhlcSwgU3RyaW5nKGMpLCBvcHRpb25zKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBoaWdoZXIsIGxvd2VyXG4gIGxldCBoYXNEb21MVCwgaGFzRG9tR1RcbiAgLy8gaWYgdGhlIHN1YnNldCBoYXMgYSBwcmVyZWxlYXNlLCB3ZSBuZWVkIGEgY29tcGFyYXRvciBpbiB0aGUgc3VwZXJzZXRcbiAgLy8gd2l0aCB0aGUgc2FtZSB0dXBsZSBhbmQgYSBwcmVyZWxlYXNlLCBvciBpdCdzIG5vdCBhIHN1YnNldFxuICBsZXQgbmVlZERvbUxUUHJlID0gbHQgJiZcbiAgICAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSAmJlxuICAgIGx0LnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA/IGx0LnNlbXZlciA6IGZhbHNlXG4gIGxldCBuZWVkRG9tR1RQcmUgPSBndCAmJlxuICAgICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlICYmXG4gICAgZ3Quc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID8gZ3Quc2VtdmVyIDogZmFsc2VcbiAgLy8gZXhjZXB0aW9uOiA8MS4yLjMtMCBpcyB0aGUgc2FtZSBhcyA8MS4yLjNcbiAgaWYgKG5lZWREb21MVFByZSAmJiBuZWVkRG9tTFRQcmUucHJlcmVsZWFzZS5sZW5ndGggPT09IDEgJiZcbiAgICAgIGx0Lm9wZXJhdG9yID09PSAnPCcgJiYgbmVlZERvbUxUUHJlLnByZXJlbGVhc2VbMF0gPT09IDApIHtcbiAgICBuZWVkRG9tTFRQcmUgPSBmYWxzZVxuICB9XG5cbiAgZm9yIChjb25zdCBjIG9mIGRvbSkge1xuICAgIGhhc0RvbUdUID0gaGFzRG9tR1QgfHwgYy5vcGVyYXRvciA9PT0gJz4nIHx8IGMub3BlcmF0b3IgPT09ICc+PSdcbiAgICBoYXNEb21MVCA9IGhhc0RvbUxUIHx8IGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nXG4gICAgaWYgKGd0KSB7XG4gICAgICBpZiAobmVlZERvbUdUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUdUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUdUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUdUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUdUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc+JyB8fCBjLm9wZXJhdG9yID09PSAnPj0nKSB7XG4gICAgICAgIGhpZ2hlciA9IGhpZ2hlckdUKGd0LCBjLCBvcHRpb25zKVxuICAgICAgICBpZiAoaGlnaGVyID09PSBjICYmIGhpZ2hlciAhPT0gZ3QpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKGd0Lm9wZXJhdG9yID09PSAnPj0nICYmICFzYXRpc2ZpZXMoZ3Quc2VtdmVyLCBTdHJpbmcoYyksIG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGx0KSB7XG4gICAgICBpZiAobmVlZERvbUxUUHJlKSB7XG4gICAgICAgIGlmIChjLnNlbXZlci5wcmVyZWxlYXNlICYmIGMuc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICBjLnNlbXZlci5tYWpvciA9PT0gbmVlZERvbUxUUHJlLm1ham9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5taW5vciA9PT0gbmVlZERvbUxUUHJlLm1pbm9yICYmXG4gICAgICAgICAgICBjLnNlbXZlci5wYXRjaCA9PT0gbmVlZERvbUxUUHJlLnBhdGNoKSB7XG4gICAgICAgICAgbmVlZERvbUxUUHJlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGMub3BlcmF0b3IgPT09ICc8JyB8fCBjLm9wZXJhdG9yID09PSAnPD0nKSB7XG4gICAgICAgIGxvd2VyID0gbG93ZXJMVChsdCwgYywgb3B0aW9ucylcbiAgICAgICAgaWYgKGxvd2VyID09PSBjICYmIGxvd2VyICE9PSBsdClcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAobHQub3BlcmF0b3IgPT09ICc8PScgJiYgIXNhdGlzZmllcyhsdC5zZW12ZXIsIFN0cmluZyhjKSwgb3B0aW9ucykpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWMub3BlcmF0b3IgJiYgKGx0IHx8IGd0KSAmJiBndGx0Q29tcCAhPT0gMClcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gaWYgdGhlcmUgd2FzIGEgPCBvciA+LCBhbmQgbm90aGluZyBpbiB0aGUgZG9tLCB0aGVuIG11c3QgYmUgZmFsc2VcbiAgLy8gVU5MRVNTIGl0IHdhcyBsaW1pdGVkIGJ5IGFub3RoZXIgcmFuZ2UgaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgLy8gRWcsID4xLjAuMCA8MS4wLjEgaXMgc3RpbGwgYSBzdWJzZXQgb2YgPDIuMC4wXG4gIGlmIChndCAmJiBoYXNEb21MVCAmJiAhbHQgJiYgZ3RsdENvbXAgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgaWYgKGx0ICYmIGhhc0RvbUdUICYmICFndCAmJiBndGx0Q29tcCAhPT0gMClcbiAgICByZXR1cm4gZmFsc2VcblxuICAvLyB3ZSBuZWVkZWQgYSBwcmVyZWxlYXNlIHJhbmdlIGluIGEgc3BlY2lmaWMgdHVwbGUsIGJ1dCBkaWRuJ3QgZ2V0IG9uZVxuICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBzdWJzZXQuICBlZyA+PTEuMi4zLXByZSBpcyBub3QgYSBzdWJzZXQgb2YgPj0xLjAuMCxcbiAgLy8gYmVjYXVzZSBpdCBpbmNsdWRlcyBwcmVyZWxlYXNlcyBpbiB0aGUgMS4yLjMgdHVwbGVcbiAgaWYgKG5lZWREb21HVFByZSB8fCBuZWVkRG9tTFRQcmUpXG4gICAgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gPj0xLjIuMyBpcyBsb3dlciB0aGFuID4xLjIuM1xuY29uc3QgaGlnaGVyR1QgPSAoYSwgYiwgb3B0aW9ucykgPT4ge1xuICBpZiAoIWEpXG4gICAgcmV0dXJuIGJcbiAgY29uc3QgY29tcCA9IGNvbXBhcmUoYS5zZW12ZXIsIGIuc2VtdmVyLCBvcHRpb25zKVxuICByZXR1cm4gY29tcCA+IDAgPyBhXG4gICAgOiBjb21wIDwgMCA/IGJcbiAgICA6IGIub3BlcmF0b3IgPT09ICc+JyAmJiBhLm9wZXJhdG9yID09PSAnPj0nID8gYlxuICAgIDogYVxufVxuXG4vLyA8PTEuMi4zIGlzIGhpZ2hlciB0aGFuIDwxLjIuM1xuY29uc3QgbG93ZXJMVCA9IChhLCBiLCBvcHRpb25zKSA9PiB7XG4gIGlmICghYSlcbiAgICByZXR1cm4gYlxuICBjb25zdCBjb21wID0gY29tcGFyZShhLnNlbXZlciwgYi5zZW12ZXIsIG9wdGlvbnMpXG4gIHJldHVybiBjb21wIDwgMCA/IGFcbiAgICA6IGNvbXAgPiAwID8gYlxuICAgIDogYi5vcGVyYXRvciA9PT0gJzwnICYmIGEub3BlcmF0b3IgPT09ICc8PScgPyBiXG4gICAgOiBhXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3Vic2V0XG4iLCIvLyBqdXN0IHByZS1sb2FkIGFsbCB0aGUgc3R1ZmYgdGhhdCBpbmRleC5qcyBsYXppbHkgZXhwb3J0c1xuY29uc3QgaW50ZXJuYWxSZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcmUnKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlOiBpbnRlcm5hbFJlLnJlLFxuICBzcmM6IGludGVybmFsUmUuc3JjLFxuICB0b2tlbnM6IGludGVybmFsUmUudCxcbiAgU0VNVkVSX1NQRUNfVkVSU0lPTjogcmVxdWlyZSgnLi9pbnRlcm5hbC9jb25zdGFudHMnKS5TRU1WRVJfU1BFQ19WRVJTSU9OLFxuICBTZW1WZXI6IHJlcXVpcmUoJy4vY2xhc3Nlcy9zZW12ZXInKSxcbiAgY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykuY29tcGFyZUlkZW50aWZpZXJzLFxuICByY29tcGFyZUlkZW50aWZpZXJzOiByZXF1aXJlKCcuL2ludGVybmFsL2lkZW50aWZpZXJzJykucmNvbXBhcmVJZGVudGlmaWVycyxcbiAgcGFyc2U6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3BhcnNlJyksXG4gIHZhbGlkOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy92YWxpZCcpLFxuICBjbGVhbjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY2xlYW4nKSxcbiAgaW5jOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9pbmMnKSxcbiAgZGlmZjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZGlmZicpLFxuICBtYWpvcjogcmVxdWlyZSgnLi9mdW5jdGlvbnMvbWFqb3InKSxcbiAgbWlub3I6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL21pbm9yJyksXG4gIHBhdGNoOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wYXRjaCcpLFxuICBwcmVyZWxlYXNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9wcmVyZWxlYXNlJyksXG4gIGNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUnKSxcbiAgcmNvbXBhcmU6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3Jjb21wYXJlJyksXG4gIGNvbXBhcmVMb29zZTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvY29tcGFyZS1sb29zZScpLFxuICBjb21wYXJlQnVpbGQ6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2NvbXBhcmUtYnVpbGQnKSxcbiAgc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvc29ydCcpLFxuICByc29ydDogcmVxdWlyZSgnLi9mdW5jdGlvbnMvcnNvcnQnKSxcbiAgZ3Q6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL2d0JyksXG4gIGx0OiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdCcpLFxuICBlcTogcmVxdWlyZSgnLi9mdW5jdGlvbnMvZXEnKSxcbiAgbmVxOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9uZXEnKSxcbiAgZ3RlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9ndGUnKSxcbiAgbHRlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9sdGUnKSxcbiAgY21wOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jbXAnKSxcbiAgY29lcmNlOiByZXF1aXJlKCcuL2Z1bmN0aW9ucy9jb2VyY2UnKSxcbiAgQ29tcGFyYXRvcjogcmVxdWlyZSgnLi9jbGFzc2VzL2NvbXBhcmF0b3InKSxcbiAgUmFuZ2U6IHJlcXVpcmUoJy4vY2xhc3Nlcy9yYW5nZScpLFxuICBzYXRpc2ZpZXM6IHJlcXVpcmUoJy4vZnVuY3Rpb25zL3NhdGlzZmllcycpLFxuICB0b0NvbXBhcmF0b3JzOiByZXF1aXJlKCcuL3Jhbmdlcy90by1jb21wYXJhdG9ycycpLFxuICBtYXhTYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9tYXgtc2F0aXNmeWluZycpLFxuICBtaW5TYXRpc2Z5aW5nOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tc2F0aXNmeWluZycpLFxuICBtaW5WZXJzaW9uOiByZXF1aXJlKCcuL3Jhbmdlcy9taW4tdmVyc2lvbicpLFxuICB2YWxpZFJhbmdlOiByZXF1aXJlKCcuL3Jhbmdlcy92YWxpZCcpLFxuICBvdXRzaWRlOiByZXF1aXJlKCcuL3Jhbmdlcy9vdXRzaWRlJyksXG4gIGd0cjogcmVxdWlyZSgnLi9yYW5nZXMvZ3RyJyksXG4gIGx0cjogcmVxdWlyZSgnLi9yYW5nZXMvbHRyJyksXG4gIGludGVyc2VjdHM6IHJlcXVpcmUoJy4vcmFuZ2VzL2ludGVyc2VjdHMnKSxcbiAgc2ltcGxpZnlSYW5nZTogcmVxdWlyZSgnLi9yYW5nZXMvc2ltcGxpZnknKSxcbiAgc3Vic2V0OiByZXF1aXJlKCcuL3Jhbmdlcy9zdWJzZXQnKSxcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1pbWljRm4gPSByZXF1aXJlKCdtaW1pYy1mbicpO1xuXG5jb25zdCBjYWxsZWRGdW5jdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBvbmV0aW1lID0gKGZ1bmN0aW9uXywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmICh0eXBlb2YgZnVuY3Rpb25fICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBmdW5jdGlvbicpO1xuXHR9XG5cblx0bGV0IHJldHVyblZhbHVlO1xuXHRsZXQgY2FsbENvdW50ID0gMDtcblx0Y29uc3QgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25fLmRpc3BsYXlOYW1lIHx8IGZ1bmN0aW9uXy5uYW1lIHx8ICc8YW5vbnltb3VzPic7XG5cblx0Y29uc3Qgb25ldGltZSA9IGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG5cdFx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCArK2NhbGxDb3VudCk7XG5cblx0XHRpZiAoY2FsbENvdW50ID09PSAxKSB7XG5cdFx0XHRyZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKTtcblx0XHRcdGZ1bmN0aW9uXyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnRocm93ID09PSB0cnVlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25OYW1lfVxcYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZWApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRtaW1pY0ZuKG9uZXRpbWUsIGZ1bmN0aW9uXyk7XG5cdGNhbGxlZEZ1bmN0aW9ucy5zZXQob25ldGltZSwgY2FsbENvdW50KTtcblxuXHRyZXR1cm4gb25ldGltZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gb25ldGltZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gb25ldGltZTtcblxubW9kdWxlLmV4cG9ydHMuY2FsbENvdW50ID0gZnVuY3Rpb25fID0+IHtcblx0aWYgKCFjYWxsZWRGdW5jdGlvbnMuaGFzKGZ1bmN0aW9uXykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFRoZSBnaXZlbiBmdW5jdGlvbiBcXGAke2Z1bmN0aW9uXy5uYW1lfVxcYCBpcyBub3Qgd3JhcHBlZCBieSB0aGUgXFxgb25ldGltZVxcYCBwYWNrYWdlYCk7XG5cdH1cblxuXHRyZXR1cm4gY2FsbGVkRnVuY3Rpb25zLmdldChmdW5jdGlvbl8pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9hLCBfYjtcbnZhciBfQ29uZl92YWxpZGF0b3IsIF9Db25mX2VuY3J5cHRpb25LZXksIF9Db25mX29wdGlvbnMsIF9Db25mX2RlZmF1bHRWYWx1ZXM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkb3RQcm9wID0gcmVxdWlyZShcImRvdC1wcm9wXCIpO1xuY29uc3QgcGtnVXAgPSByZXF1aXJlKFwicGtnLXVwXCIpO1xuY29uc3QgZW52UGF0aHMgPSByZXF1aXJlKFwiZW52LXBhdGhzXCIpO1xuY29uc3QgYXRvbWljYWxseSA9IHJlcXVpcmUoXCJhdG9taWNhbGx5XCIpO1xuY29uc3QgYWp2XzEgPSByZXF1aXJlKFwiYWp2XCIpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IHJlcXVpcmUoXCJhanYtZm9ybWF0c1wiKTtcbmNvbnN0IGRlYm91bmNlRm4gPSByZXF1aXJlKFwiZGVib3VuY2UtZm5cIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoXCJvbmV0aW1lXCIpO1xuY29uc3QgZW5jcnlwdGlvbkFsZ29yaXRobSA9ICdhZXMtMjU2LWNiYyc7XG5jb25zdCBjcmVhdGVQbGFpbk9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5jb25zdCBpc0V4aXN0ID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4gZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGw7XG59O1xubGV0IHBhcmVudERpciA9ICcnO1xudHJ5IHtcbiAgICAvLyBQcmV2ZW50IGNhY2hpbmcgb2YgdGhpcyBtb2R1bGUgc28gbW9kdWxlLnBhcmVudCBpcyBhbHdheXMgYWNjdXJhdGUuXG4gICAgLy8gTm90ZTogVGhpcyB0cmljayB3b24ndCB3b3JrIHdpdGggRVNNIG9yIGluc2lkZSBhIHdlYndvcmtlclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICBkZWxldGUgcmVxdWlyZS5jYWNoZVtfX2ZpbGVuYW1lXTtcbiAgICBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoKF9iID0gKF9hID0gbW9kdWxlLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbGVuYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnLicpO1xufVxuY2F0Y2ggKF9jKSB7IH1cbmNvbnN0IGNoZWNrVmFsdWVUeXBlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBub25Kc29uVHlwZXMgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3VuZGVmaW5lZCcsXG4gICAgICAgICdzeW1ib2wnLFxuICAgICAgICAnZnVuY3Rpb24nXG4gICAgXSk7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAobm9uSnNvblR5cGVzLmhhcyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTZXR0aW5nIGEgdmFsdWUgb2YgdHlwZSBcXGAke3R5cGV9XFxgIGZvciBrZXkgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIGFzIGl0J3Mgbm90IHN1cHBvcnRlZCBieSBKU09OYCk7XG4gICAgfVxufTtcbmNvbnN0IElOVEVSTkFMX0tFWSA9ICdfX2ludGVybmFsX18nO1xuY29uc3QgTUlHUkFUSU9OX0tFWSA9IGAke0lOVEVSTkFMX0tFWX0ubWlncmF0aW9ucy52ZXJzaW9uYDtcbmNsYXNzIENvbmYge1xuICAgIGNvbnN0cnVjdG9yKHBhcnRpYWxPcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfQ29uZl92YWxpZGF0b3Iuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2VuY3J5cHRpb25LZXkuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX29wdGlvbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Db25mX2RlZmF1bHRWYWx1ZXMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSB2YWx1ZSA9PiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc2VyaWFsaXplID0gdmFsdWUgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHVuZGVmaW5lZCwgJ1xcdCcpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgY29uZmlnTmFtZTogJ2NvbmZpZycsXG4gICAgICAgICAgICBmaWxlRXh0ZW5zaW9uOiAnanNvbicsXG4gICAgICAgICAgICBwcm9qZWN0U3VmZml4OiAnbm9kZWpzJyxcbiAgICAgICAgICAgIGNsZWFySW52YWxpZENvbmZpZzogZmFsc2UsXG4gICAgICAgICAgICBhY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRpYWxPcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldFBhY2thZ2VEYXRhID0gb25ldGltZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlUGF0aCA9IHBrZ1VwLnN5bmMoeyBjd2Q6IHBhcmVudERpciB9KTtcbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgcmVxdWlyZWAgYmVjYXVzZSBvZiBXZWJwYWNrIGJlaW5nIGFubm95aW5nOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTk2XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlRGF0YSA9IHBhY2thZ2VQYXRoICYmIEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhY2thZ2VQYXRoLCAndXRmOCcpKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrYWdlRGF0YSAhPT0gbnVsbCAmJiBwYWNrYWdlRGF0YSAhPT0gdm9pZCAwID8gcGFja2FnZURhdGEgOiB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5jd2QpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdE5hbWUgPSBnZXRQYWNrYWdlRGF0YSgpLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgbmFtZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdE5hbWVgIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY3dkID0gZW52UGF0aHMob3B0aW9ucy5wcm9qZWN0TmFtZSwgeyBzdWZmaXg6IG9wdGlvbnMucHJvamVjdFN1ZmZpeCB9KS5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBvcHRpb25zLCBcImZcIik7XG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgYHNjaGVtYWAgb3B0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWp2ID0gbmV3IGFqdl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFsbEVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1c2VEZWZhdWx0czogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhanZfZm9ybWF0c18xLmRlZmF1bHQoYWp2KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBvcHRpb25zLnNjaGVtYVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBhanYuY29tcGlsZShzY2hlbWEpLCBcImZcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmRlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIilba2V5XSA9IHZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKSxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmRlZmF1bHRzXG4gICAgICAgICAgICB9LCBcImZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemUgPSBvcHRpb25zLnNlcmlhbGl6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kZXNlcmlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVzZXJpYWxpemUgPSBvcHRpb25zLmRlc2VyaWFsaXplO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Db25mX2VuY3J5cHRpb25LZXksIG9wdGlvbnMuZW5jcnlwdGlvbktleSwgXCJmXCIpO1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gb3B0aW9ucy5maWxlRXh0ZW5zaW9uID8gYC4ke29wdGlvbnMuZmlsZUV4dGVuc2lvbn1gIDogJyc7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgYCR7KF9hID0gb3B0aW9ucy5jb25maWdOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnY29uZmlnJ30ke2ZpbGVFeHRlbnNpb259YCk7XG4gICAgICAgIGNvbnN0IGZpbGVTdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQbGFpbk9iamVjdCgpLCBvcHRpb25zLmRlZmF1bHRzLCBmaWxlU3RvcmUpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZShzdG9yZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKGZpbGVTdG9yZSwgc3RvcmUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLndhdGNoKSB7XG4gICAgICAgICAgICB0aGlzLl93YXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1pZ3JhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvamVjdFZlcnNpb24gPSBnZXRQYWNrYWdlRGF0YSgpLnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucHJvamVjdFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QgdmVyc2lvbiBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIFBsZWFzZSBzcGVjaWZ5IHRoZSBgcHJvamVjdFZlcnNpb25gIG9wdGlvbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21pZ3JhdGUob3B0aW9ucy5taWdyYXRpb25zLCBvcHRpb25zLnByb2plY3RWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ga2V5IGluIHN0b3JlID8gc3RvcmVba2V5XSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBrZXlcXGAgdG8gYmUgb2YgdHlwZSBcXGBzdHJpbmdcXGAgb3IgXFxgb2JqZWN0XFxgLCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2UgYGRlbGV0ZSgpYCB0byBjbGVhciB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGFpbnNSZXNlcnZlZEtleShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQbGVhc2UgZG9uJ3QgdXNlIHRoZSAke0lOVEVSTkFMX0tFWX0ga2V5LCBhcyBpdCdzIHVzZWQgdG8gbWFuYWdlIHRoaXMgbW9kdWxlIGludGVybmFsIG9wZXJhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2V0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNoZWNrVmFsdWVUeXBlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IGtleTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayBpZiBhbiBpdGVtIGV4aXN0cy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGNoZWNrLlxuICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuYWNjZXNzUHJvcGVydGllc0J5RG90Tm90YXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb3RQcm9wLmhhcyh0aGlzLnN0b3JlLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5zdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzZXQgaXRlbXMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIGFzIGRlZmluZWQgYnkgdGhlIGBkZWZhdWx0c2Agb3IgYHNjaGVtYWAgb3B0aW9uLlxuXG4gICAgQHNlZSBgY2xlYXIoKWAgdG8gcmVzZXQgYWxsIGl0ZW1zLlxuXG4gICAgQHBhcmFtIGtleXMgLSBUaGUga2V5cyBvZiB0aGUgaXRlbXMgdG8gcmVzZXQuXG4gICAgKi9cbiAgICByZXNldCguLi5rZXlzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGlmIChpc0V4aXN0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZGVmYXVsdFZhbHVlcywgXCJmXCIpW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX2RlZmF1bHRWYWx1ZXMsIFwiZlwiKVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgYW4gaXRlbS5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIGRlbGV0ZS5cbiAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfb3B0aW9ucywgXCJmXCIpLmFjY2Vzc1Byb3BlcnRpZXNCeURvdE5vdGF0aW9uKSB7XG4gICAgICAgICAgICBkb3RQcm9wLmRlbGV0ZShzdG9yZSwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGVcbiAgICAgICAgICAgIGRlbGV0ZSBzdG9yZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIGFsbCBpdGVtcy5cblxuICAgIFRoaXMgcmVzZXRzIGtub3duIGl0ZW1zIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLCBpZiBkZWZpbmVkIGJ5IHRoZSBgZGVmYXVsdHNgIG9yIGBzY2hlbWFgIG9wdGlvbi5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9kZWZhdWx0VmFsdWVzLCBcImZcIikpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgV2F0Y2hlcyB0aGUgZ2l2ZW4gYGtleWAsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBrZXkgLSBUaGUga2V5IHdvIHdhdGNoLlxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRDaGFuZ2Uoa2V5LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGtleVxcYCB0byBiZSBvZiB0eXBlIFxcYHN0cmluZ1xcYCwgZ290ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjYWxsYmFja1xcYCB0byBiZSBvZiB0eXBlIFxcYGZ1bmN0aW9uXFxgLCBnb3QgJHt0eXBlb2YgY2FsbGJhY2t9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNoYW5nZSgoKSA9PiB0aGlzLmdldChrZXkpLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdhdGNoZXMgdGhlIHdob2xlIGNvbmZpZyBvYmplY3QsIGNhbGxpbmcgYGNhbGxiYWNrYCBvbiBhbnkgY2hhbmdlcy5cblxuICAgIEBwYXJhbSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gYW55IGNoYW5nZXMuIFdoZW4gYSBga2V5YCBpcyBmaXJzdCBzZXQgYG9sZFZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLCBhbmQgd2hlbiBhIGtleSBpcyBkZWxldGVkIGBuZXdWYWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAgICBAcmV0dXJucyBBIGZ1bmN0aW9uLCB0aGF0IHdoZW4gY2FsbGVkLCB3aWxsIHVuc3Vic2NyaWJlLlxuICAgICovXG4gICAgb25EaWRBbnlDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgY2FsbGJhY2tcXGAgdG8gYmUgb2YgdHlwZSBcXGBmdW5jdGlvblxcYCwgZ290ICR7dHlwZW9mIGNhbGxiYWNrfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDaGFuZ2UoKCkgPT4gdGhpcy5zdG9yZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RvcmUpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IHN0b3JlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyh0aGlzLnBhdGgsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpID8gbnVsbCA6ICd1dGY4Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhU3RyaW5nID0gdGhpcy5fZW5jcnlwdERhdGEoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5fZGVzZXJpYWxpemUoZGF0YVN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0ZShkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNyZWF0ZVBsYWluT2JqZWN0KCksIGRlc2VyaWFsaXplZERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVBsYWluT2JqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9vcHRpb25zLCBcImZcIikuY2xlYXJJbnZhbGlkQ29uZmlnICYmIGVycm9yLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUGxhaW5PYmplY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBzdG9yZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVEaXJlY3RvcnkoKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGUodmFsdWUpO1xuICAgICAgICB0aGlzLl93cml0ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgIH1cbiAgICAqWyhfQ29uZl92YWxpZGF0b3IgPSBuZXcgV2Vha01hcCgpLCBfQ29uZl9lbmNyeXB0aW9uS2V5ID0gbmV3IFdlYWtNYXAoKSwgX0NvbmZfb3B0aW9ucyA9IG5ldyBXZWFrTWFwKCksIF9Db25mX2RlZmF1bHRWYWx1ZXMgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdG9yZSkpIHtcbiAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jcnlwdERhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbiBpbml0aWFsaXphdGlvbiB2ZWN0b3IgaGFzIGJlZW4gdXNlZCB0byBlbmNyeXB0IHRoZSBkYXRhXG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5zbGljZSgxNiwgMTcpLnRvU3RyaW5nKCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBkYXRhLnNsaWNlKDAsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihlbmNyeXB0aW9uQWxnb3JpdGhtLCBwYXNzd29yZCwgaW5pdGlhbGl6YXRpb25WZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW2RlY2lwaGVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhLnNsaWNlKDE3KSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKGVuY3J5cHRpb25BbGdvcml0aG0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfZW5jcnlwdGlvbktleSwgXCJmXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtkZWNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBkZWNpcGhlci5maW5hbCgpXSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikgeyB9XG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9oYW5kbGVDaGFuZ2UoZ2V0dGVyLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0RlZXBTdHJpY3RFcXVhbChuZXdWYWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmV2ZW50cy5yZW1vdmVMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH1cbiAgICBfdmFsaWRhdGUoZGF0YSkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWxpZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgICAgaWYgKHZhbGlkIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX3ZhbGlkYXRvciwgXCJmXCIpLmVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0NvbmZfdmFsaWRhdG9yLCBcImZcIikuZXJyb3JzXG4gICAgICAgICAgICAubWFwKCh7IGluc3RhbmNlUGF0aCwgbWVzc2FnZSA9ICcnIH0pID0+IGBcXGAke2luc3RhbmNlUGF0aC5zbGljZSgxKX1cXGAgJHttZXNzYWdlfWApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpZyBzY2hlbWEgdmlvbGF0aW9uOiAnICsgZXJyb3JzLmpvaW4oJzsgJykpO1xuICAgIH1cbiAgICBfZW5zdXJlRGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGRpcmVjdG9yeSBleGlzdHMgYXMgaXQgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBmcy5ta2RpclN5bmMocGF0aC5kaXJuYW1lKHRoaXMucGF0aCksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfd3JpdGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxpemF0aW9uVmVjdG9yID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3N3b3JkID0gY3J5cHRvLnBia2RmMlN5bmMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQ29uZl9lbmNyeXB0aW9uS2V5LCBcImZcIiksIGluaXRpYWxpemF0aW9uVmVjdG9yLnRvU3RyaW5nKCksIDEwMDAwLCAzMiwgJ3NoYTUxMicpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGVuY3J5cHRpb25BbGdvcml0aG0sIHBhc3N3b3JkLCBpbml0aWFsaXphdGlvblZlY3Rvcik7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsIEJ1ZmZlci5mcm9tKCc6JyksIGNpcGhlci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLCBjaXBoZXIuZmluYWwoKV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBDb25mIGJlaW5nIHBhY2thZ2VkIGluIGEgVWJ1bnR1IFNuYXAgYXBwLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9jb25mL3B1bGwvODJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LlNOQVApIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy5wYXRoLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXRvbWljYWxseS53cml0ZUZpbGVTeW5jKHRoaXMucGF0aCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZWxlY3Ryb24tc3RvcmUvaXNzdWVzLzEwNlxuICAgICAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBvbiBXaW5kb3dzLCB3ZSB3aWxsIGdldCBhbiBFWERFViBlcnJvciB3aGVuIGF0b21pYyB3cml0aW5nXG4gICAgICAgICAgICAgICAgLy8gKGV2ZW4gdGhvdWdoIHRvIHRoZSBzYW1lIGRpcmVjdG9yeSksIHNvIHdlIGZhbGwgYmFjayB0byBub24gYXRvbWljIHdyaXRlXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICdFWERFVicpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0aGlzLnBhdGgsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF93YXRjaCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlRGlyZWN0b3J5KCk7XG4gICAgICAgIGlmICghZnMuZXhpc3RzU3luYyh0aGlzLnBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShjcmVhdGVQbGFpbk9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgICAgICAgZnMud2F0Y2godGhpcy5wYXRoLCB7IHBlcnNpc3RlbnQ6IGZhbHNlIH0sIGRlYm91bmNlRm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE9uIExpbnV4IGFuZCBXaW5kb3dzLCB3cml0aW5nIHRvIHRoZSBjb25maWcgZmlsZSBlbWl0cyBhIGByZW5hbWVgIGV2ZW50LCBzbyB3ZSBza2lwIGNoZWNraW5nIHRoZSBldmVudCB0eXBlLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfSwgeyB3YWl0OiAxMDAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnMud2F0Y2hGaWxlKHRoaXMucGF0aCwgeyBwZXJzaXN0ZW50OiBmYWxzZSB9LCBkZWJvdW5jZUZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgICAgIH0sIHsgd2FpdDogNTAwMCB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX21pZ3JhdGUobWlncmF0aW9ucywgdmVyc2lvblRvTWlncmF0ZSkge1xuICAgICAgICBsZXQgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24gPSB0aGlzLl9nZXQoTUlHUkFUSU9OX0tFWSwgJzAuMC4wJyk7XG4gICAgICAgIGNvbnN0IG5ld2VyVmVyc2lvbnMgPSBPYmplY3Qua2V5cyhtaWdyYXRpb25zKVxuICAgICAgICAgICAgLmZpbHRlcihjYW5kaWRhdGVWZXJzaW9uID0+IHRoaXMuX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpKTtcbiAgICAgICAgbGV0IHN0b3JlQmFja3VwID0geyAuLi50aGlzLnN0b3JlIH07XG4gICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiBuZXdlclZlcnNpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZ3JhdGlvbiA9IG1pZ3JhdGlvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgbWlncmF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldChNSUdSQVRJT05fS0VZLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgc3RvcmVCYWNrdXAgPSB7IC4uLnRoaXMuc3RvcmUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZUJhY2t1cDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyB0aGUgbWlncmF0aW9uISBDaGFuZ2VzIGFwcGxpZWQgdG8gdGhlIHN0b3JlIHVudGlsIHRoaXMgZmFpbGVkIG1pZ3JhdGlvbiB3aWxsIGJlIHJlc3RvcmVkLiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSB8fCAhc2VtdmVyLmVxKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCB2ZXJzaW9uVG9NaWdyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0KE1JR1JBVElPTl9LRVksIHZlcnNpb25Ub01pZ3JhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb250YWluc1Jlc2VydmVkS2V5KGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnNLZXkgPSBPYmplY3Qua2V5cyhrZXkpWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnNLZXkgPT09IElOVEVSTkFMX0tFWSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Db25mX29wdGlvbnMsIFwiZlwiKS5hY2Nlc3NQcm9wZXJ0aWVzQnlEb3ROb3RhdGlvbikge1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKGAke0lOVEVSTkFMX0tFWX0uYCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9pc1ZlcnNpb25JblJhbmdlRm9ybWF0KHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlbXZlci5jbGVhbih2ZXJzaW9uKSA9PT0gbnVsbDtcbiAgICB9XG4gICAgX3Nob3VsZFBlcmZvcm1NaWdyYXRpb24oY2FuZGlkYXRlVmVyc2lvbiwgcHJldmlvdXNNaWdyYXRlZFZlcnNpb24sIHZlcnNpb25Ub01pZ3JhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVmVyc2lvbkluUmFuZ2VGb3JtYXQoY2FuZGlkYXRlVmVyc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01pZ3JhdGVkVmVyc2lvbiAhPT0gJzAuMC4wJyAmJiBzZW12ZXIuc2F0aXNmaWVzKHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uLCBjYW5kaWRhdGVWZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZW12ZXIuc2F0aXNmaWVzKHZlcnNpb25Ub01pZ3JhdGUsIGNhbmRpZGF0ZVZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIubHRlKGNhbmRpZGF0ZVZlcnNpb24sIHByZXZpb3VzTWlncmF0ZWRWZXJzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW12ZXIuZ3QoY2FuZGlkYXRlVmVyc2lvbiwgdmVyc2lvblRvTWlncmF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gZG90UHJvcC5nZXQodGhpcy5zdG9yZSwga2V5LCBkZWZhdWx0VmFsdWUpO1xuICAgIH1cbiAgICBfc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyBzdG9yZSB9ID0gdGhpcztcbiAgICAgICAgZG90UHJvcC5zZXQoc3RvcmUsIGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbi8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IENvbmY7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZjtcbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7YXBwLCBpcGNNYWluLCBpcGNSZW5kZXJlciwgc2hlbGx9ID0gcmVxdWlyZSgnZWxlY3Ryb24nKTtcbmNvbnN0IENvbmYgPSByZXF1aXJlKCdjb25mJyk7XG5cbmxldCBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbi8vIFNldCB1cCB0aGUgYGlwY01haW5gIGhhbmRsZXIgZm9yIGNvbW11bmljYXRpb24gYmV0d2VlbiByZW5kZXJlciBhbmQgbWFpbiBwcm9jZXNzLlxuY29uc3QgaW5pdERhdGFMaXN0ZW5lciA9ICgpID0+IHtcblx0aWYgKCFpcGNNYWluIHx8ICFhcHApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0VsZWN0cm9uIFN0b3JlOiBZb3UgbmVlZCB0byBjYWxsIGAuaW5pdFJlbmRlcmVyKClgIGZyb20gdGhlIG1haW4gcHJvY2Vzcy4nKTtcblx0fVxuXG5cdGNvbnN0IGFwcERhdGEgPSB7XG5cdFx0ZGVmYXVsdEN3ZDogYXBwLmdldFBhdGgoJ3VzZXJEYXRhJyksXG5cdFx0YXBwVmVyc2lvbjogYXBwLmdldFZlcnNpb24oKVxuXHR9O1xuXG5cdGlmIChpc0luaXRpYWxpemVkKSB7XG5cdFx0cmV0dXJuIGFwcERhdGE7XG5cdH1cblxuXHRpcGNNYWluLm9uKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScsIGV2ZW50ID0+IHtcblx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGFwcERhdGE7XG5cdH0pO1xuXG5cdGlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG5cdHJldHVybiBhcHBEYXRhO1xufTtcblxuY2xhc3MgRWxlY3Ryb25TdG9yZSBleHRlbmRzIENvbmYge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0bGV0IGRlZmF1bHRDd2Q7XG5cdFx0bGV0IGFwcFZlcnNpb247XG5cblx0XHQvLyBJZiB3ZSBhcmUgaW4gdGhlIHJlbmRlcmVyIHByb2Nlc3MsIHdlIGNvbW11bmljYXRlIHdpdGggdGhlIG1haW4gcHJvY2Vzc1xuXHRcdC8vIHRvIGdldCB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgdGhlIG1vZHVsZSBvdGhlcndpc2UsIHdlIHB1bGwgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxuXHRcdGlmIChpcGNSZW5kZXJlcikge1xuXHRcdFx0Y29uc3QgYXBwRGF0YSA9IGlwY1JlbmRlcmVyLnNlbmRTeW5jKCdlbGVjdHJvbi1zdG9yZS1nZXQtZGF0YScpO1xuXG5cdFx0XHRpZiAoIWFwcERhdGEpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFbGVjdHJvbiBTdG9yZTogWW91IG5lZWQgdG8gY2FsbCBgLmluaXRSZW5kZXJlcigpYCBmcm9tIHRoZSBtYWluIHByb2Nlc3MuJyk7XG5cdFx0XHR9XG5cblx0XHRcdCh7ZGVmYXVsdEN3ZCwgYXBwVmVyc2lvbn0gPSBhcHBEYXRhKTtcblx0XHR9IGVsc2UgaWYgKGlwY01haW4gJiYgYXBwKSB7XG5cdFx0XHQoe2RlZmF1bHRDd2QsIGFwcFZlcnNpb259ID0gaW5pdERhdGFMaXN0ZW5lcigpKTtcblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0bmFtZTogJ2NvbmZpZycsXG5cdFx0XHQuLi5vcHRpb25zXG5cdFx0fTtcblxuXHRcdGlmICghb3B0aW9ucy5wcm9qZWN0VmVyc2lvbikge1xuXHRcdFx0b3B0aW9ucy5wcm9qZWN0VmVyc2lvbiA9IGFwcFZlcnNpb247XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuY3dkKSB7XG5cdFx0XHRvcHRpb25zLmN3ZCA9IHBhdGguaXNBYnNvbHV0ZShvcHRpb25zLmN3ZCkgPyBvcHRpb25zLmN3ZCA6IHBhdGguam9pbihkZWZhdWx0Q3dkLCBvcHRpb25zLmN3ZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuY3dkID0gZGVmYXVsdEN3ZDtcblx0XHR9XG5cblx0XHRvcHRpb25zLmNvbmZpZ05hbWUgPSBvcHRpb25zLm5hbWU7XG5cdFx0ZGVsZXRlIG9wdGlvbnMubmFtZTtcblxuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHR9XG5cblx0c3RhdGljIGluaXRSZW5kZXJlcigpIHtcblx0XHRpbml0RGF0YUxpc3RlbmVyKCk7XG5cdH1cblxuXHRvcGVuSW5FZGl0b3IoKSB7XG5cdFx0c2hlbGwub3BlblBhdGgodGhpcy5wYXRoKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZWN0cm9uU3RvcmU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1zcGFjZXMtYW5kLXRhYnMgKi9cbmltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0bm90ZXM6IHtcblx0XHR0eXBlOiAnb2JqZWN0JyxcbiAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgJ1tBLVphLXowLTlfLV0nOiB7XG4gICAgICBcdHR5cGU6ICdvYmplY3QnLFxuICAgICAgXHRwcm9wZXJ0aWVzOiB7XG4gICAgICBcdFx0aWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0dGl0bGU6IHsgdHlwZTogJ3N0cmluZycsIGRlZmF1bHQ6ICcnIH0sXG4gICAgICBcdFx0Y29udGVudDogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogeyB0eXBlOiAnZG9jJywgY29udGVudDogW10gfSB9LFxuICAgICAgXHRcdGxhYmVsczogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9LFxuICAgICAgXHRcdGNyZWF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdHVwZGF0ZWRBdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogRGF0ZS5ub3coKSB9LFxuICAgICAgXHRcdGlzQm9va21hcmtlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICBcdFx0aXNBcmNoaXZlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgICAgbGFzdEN1cnNvclBvc2l0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgICBcdH0sXG4gICAgICB9LFxuICAgIH0sXG5cdH0sXG4gIGxhYmVsczoge1xuICAgIHR5cGU6ICdhcnJheScsXG4gIH0sXG59O1xuXG5jb25zdCBzdG9yZSA9IG5ldyBTdG9yZSh7XG5cdHNjaGVtYSxcbiAgZW5jcnlwdGlvbktleTogaW1wb3J0Lm1ldGEuZW52LlZJVEVfRU5DUllQVF9LRVksXG59KTtcblxuLy8gc3RvcmUub25EaWRDaGFuZ2UoJ25vdGVzJywgKHZhbHVlKSA9PiB7XG4vLyAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbi8vIH0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdG9yZTtcbiIsImltcG9ydCBTdG9yZSBmcm9tICdlbGVjdHJvbi1zdG9yZSc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICdlbGVjdHJvbic7XG5cbmNvbnN0IHNjaGVtYSA9IHtcblx0ZGF0YURpcjoge1xuXHRcdHR5cGU6ICdzdHJpbmcnLFxuXHRcdGRlZmF1bHQ6IGFwcC5nZXRQYXRoKCd1c2VyRGF0YScpLFxuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0b3JlKHsgbmFtZTogJ3NldHRpbmdzJywgc2NoZW1hLCBlbmNyeXB0aW9uS2V5OiBwcm9jZXNzLmVudi5WSVRFX0VOQ1JZUFRfS0VZIH0pO1xuIiwiaW1wb3J0IGRhdGEgZnJvbSAnLi9tb2R1bGVzL2RhdGEuc3RvcmUnO1xuaW1wb3J0IHNldHRpbmdzIGZyb20gJy4vbW9kdWxlcy9zZXR0aW5ncy5zdG9yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0ZGF0YSxcblx0c2V0dGluZ3MsXG59O1xuIiwiaW1wb3J0IHsgYXBwLCBCcm93c2VyV2luZG93LCBkaWFsb2csIHByb3RvY29sLCBuYXRpdmVUaGVtZSwgc2hlbGwgfSBmcm9tICdlbGVjdHJvbic7XG5pbXBvcnQgeyBpcGNNYWluIH0gZnJvbSAnZWxlY3Ryb24tYmV0dGVyLWlwYyc7XG5pbXBvcnQgeyBqb2luLCBub3JtYWxpemUgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IFVSTCB9IGZyb20gJ3VybCc7XG5pbXBvcnQgeyByZW1vdmUsIHJlYWRKc29uLCBlbnN1cmVEaXIsIGNvcHksIG91dHB1dEpzb24sIHBhdGhFeGlzdHNTeW5jIH0gZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHsgYXV0b1VwZGF0ZXIgfSBmcm9tICdlbGVjdHJvbi11cGRhdGVyJztcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJztcblxuY29uc3QgaXNTaW5nbGVJbnN0YW5jZSA9IGFwcC5yZXF1ZXN0U2luZ2xlSW5zdGFuY2VMb2NrKCk7XG5cbmlmICghaXNTaW5nbGVJbnN0YW5jZSkge1xuICBhcHAucXVpdCgpO1xuICBwcm9jZXNzLmV4aXQoMCk7XG59XG5cbmFwcC5kaXNhYmxlSGFyZHdhcmVBY2NlbGVyYXRpb24oKTtcblxuLyoqXG4gKiBXb3JrYXJvdW5kIGZvciBUeXBlU2NyaXB0IGJ1Z1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzQxNDY4I2lzc3VlY29tbWVudC03Mjc1NDM0MDBcbiAqL1xuY29uc3QgZW52ID0gaW1wb3J0Lm1ldGEuZW52O1xuXG5cbi8vIEluc3RhbGwgXCJWdWUuanMgZGV2dG9vbHNcIlxuaWYgKGVudi5NT0RFID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gIGFwcC53aGVuUmVhZHkoKVxuICAgIC50aGVuKCgpID0+IGltcG9ydCgnZWxlY3Ryb24tZGV2dG9vbHMtaW5zdGFsbGVyJykpXG4gICAgLnRoZW4oKHtkZWZhdWx0OiBpbnN0YWxsRXh0ZW5zaW9uLCBWVUVKUzNfREVWVE9PTFN9KSA9PiBpbnN0YWxsRXh0ZW5zaW9uKFZVRUpTM19ERVZUT09MUywge1xuICAgICAgbG9hZEV4dGVuc2lvbk9wdGlvbnM6IHtcbiAgICAgICAgYWxsb3dGaWxlQWNjZXNzOiB0cnVlLFxuICAgICAgfSxcbiAgICB9KSlcbiAgICAuY2F0Y2goZSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgaW5zdGFsbCBleHRlbnNpb246JywgZSkpO1xufVxuXG5sZXQgbWFpbldpbmRvdyA9IG51bGw7XG5cbmNvbnN0IGNyZWF0ZVdpbmRvdyA9IGFzeW5jICgpID0+IHtcbiAgbWFpbldpbmRvdyA9IG5ldyBCcm93c2VyV2luZG93KHtcbiAgICBzaG93OiBmYWxzZSwgLy8gVXNlICdyZWFkeS10by1zaG93JyBldmVudCB0byBzaG93IHdpbmRvd1xuICAgIHdpZHRoOiA5NTAsXG4gICAgaGVpZ2h0OiA2MDAsXG4gICAgd2ViUHJlZmVyZW5jZXM6IHtcbiAgICAgIHByZWxvYWQ6IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vcHJlbG9hZC9kaXN0L2luZGV4LmNqcycpLFxuICAgICAgY29udGV4dElzb2xhdGlvbjogZW52Lk1PREUgIT09ICd0ZXN0JywgICAvLyBTcGVjdHJvbiB0ZXN0cyBjYW4ndCB3b3JrIHdpdGggY29udGV4dElzb2xhdGlvbjogdHJ1ZVxuICAgICAgZW5hYmxlUmVtb3RlTW9kdWxlOiBlbnYuTU9ERSA9PT0gJ3Rlc3QnLCAvLyBTcGVjdHJvbiB0ZXN0cyBjYW4ndCB3b3JrIHdpdGggZW5hYmxlUmVtb3RlTW9kdWxlOiBmYWxzZVxuICAgIH0sXG4gIH0pO1xuXG4gIG1haW5XaW5kb3cuc2V0TWVudUJhclZpc2liaWxpdHkoZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBJZiB5b3UgaW5zdGFsbCBgc2hvdzogdHJ1ZWAgdGhlbiBpdCBjYW4gY2F1c2UgaXNzdWVzIHdoZW4gdHJ5aW5nIHRvIGNsb3NlIHRoZSB3aW5kb3cuXG4gICAqIFVzZSBgc2hvdzogZmFsc2VgIGFuZCBsaXN0ZW5lciBldmVudHMgYHJlYWR5LXRvLXNob3dgIHRvIGZpeCB0aGVzZSBpc3N1ZXMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2lzc3Vlcy8yNTAxMlxuICAgKi9cbiAgbWFpbldpbmRvdy5vbigncmVhZHktdG8tc2hvdycsICgpID0+IHtcbiAgICBtYWluV2luZG93Py5zaG93KCk7XG5cbiAgICBpZiAoZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIG1haW5XaW5kb3c/LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdXRvVXBkYXRlci5jaGVja0ZvclVwZGF0ZXNBbmROb3RpZnkoKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1haW5XaW5kb3c/LndlYkNvbnRlbnRzLm9uKCduZXctd2luZG93JywgZnVuY3Rpb24oZXZlbnQsIHVybCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ25vdGU6Ly8nKSkgcmV0dXJuO1xuXG4gICAgc2hlbGwub3BlbkV4dGVybmFsKHVybCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBVUkwgZm9yIG1haW4gd2luZG93LlxuICAgKiBWaXRlIGRldiBzZXJ2ZXIgZm9yIGRldmVsb3BtZW50LlxuICAgKiBgZmlsZTovLy4uL3JlbmRlcmVyL2luZGV4Lmh0bWxgIGZvciBwcm9kdWN0aW9uIGFuZCB0ZXN0XG4gICAqL1xuICBjb25zdCBwYWdlVXJsID0gZW52Lk1PREUgPT09ICdkZXZlbG9wbWVudCdcbiAgICA/IGVudi5WSVRFX0RFVl9TRVJWRVJfVVJMXG4gICAgOiBuZXcgVVJMKCcuLi9yZW5kZXJlci9kaXN0L2luZGV4Lmh0bWwnLCAnZmlsZTovLycgKyBfX2Rpcm5hbWUpLnRvU3RyaW5nKCk7XG5cblxuICBhd2FpdCBtYWluV2luZG93LmxvYWRVUkwocGFnZVVybCk7XG59O1xuXG5cbmFwcC5vbignc2Vjb25kLWluc3RhbmNlJywgKCkgPT4ge1xuICAvLyBTb21lb25lIHRyaWVkIHRvIHJ1biBhIHNlY29uZCBpbnN0YW5jZSwgd2Ugc2hvdWxkIGZvY3VzIG91ciB3aW5kb3cuXG4gIGlmIChtYWluV2luZG93KSB7XG4gICAgaWYgKG1haW5XaW5kb3cuaXNNaW5pbWl6ZWQoKSkgbWFpbldpbmRvdy5yZXN0b3JlKCk7XG4gICAgbWFpbldpbmRvdy5mb2N1cygpO1xuICB9XG59KTtcblxuXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ2RhcndpbicpIHtcbiAgICBhcHAucXVpdCgpO1xuICB9XG59KTtcblxuXG5hcHAud2hlblJlYWR5KClcbiAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgIHByb3RvY29sLnJlZ2lzdGVyRmlsZVByb3RvY29sKCdhc3NldHMnLCAocmVxdWVzdCwgY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QudXJsLnN1YnN0cig5KTtcblxuICAgICAgY29uc3QgZGlyID0gc3RvcmUuc2V0dGluZ3MuZ2V0KCdkYXRhRGlyJyk7XG4gICAgICBjb25zdCBpbWdQYXRoID0gYCR7ZGlyfS9ub3Rlcy1hc3NldHMvJHt1cmx9YDtcblxuICAgICAgY2FsbGJhY2soeyBwYXRoOiBub3JtYWxpemUoaW1nUGF0aCkgfSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBlbnN1cmVEaXIoam9pbihhcHAuZ2V0UGF0aCgndXNlckRhdGEnKSwgJ25vdGVzLWFzc2V0cycpKTtcbiAgICBhd2FpdCBjcmVhdGVXaW5kb3coKTtcbiAgfSlcbiAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgY3JlYXRlIHdpbmRvdzonLCBlKSk7XG5cblxuLy8gQXV0by11cGRhdGVzXG5pZiAoZW52LlBST0QpIHtcbiAgYXBwLndoZW5SZWFkeSgpXG4gICAgLnRoZW4oKCkgPT4gaW1wb3J0KCdlbGVjdHJvbi11cGRhdGVyJykpXG4gICAgLnRoZW4oKHsgYXV0b1VwZGF0ZXIgfSkgPT4gYXV0b1VwZGF0ZXIuY2hlY2tGb3JVcGRhdGVzQW5kTm90aWZ5KCkpXG4gICAgLmNhdGNoKChlKSA9PiBjb25zb2xlLmVycm9yKCdGYWlsZWQgY2hlY2sgdXBkYXRlczonLCBlKSk7XG59XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2FwcDppbmZvJywgKCkgPT4gKHtcbiAgbmFtZTogYXBwLmdldE5hbWUoKSxcbiAgdmVyc2lvbjogYXBwLmdldFZlcnNpb24oKSxcbn0pKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm9wZW4nLCAocHJvcHMpID0+IGRpYWxvZy5zaG93T3BlbkRpYWxvZyhwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOm1lc3NhZ2UnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93TWVzc2FnZUJveChwcm9wcykpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZGlhbG9nOnNhdmUnLCAocHJvcHMpID0+IGRpYWxvZy5zaG93U2F2ZURpYWxvZyhwcm9wcykpO1xuXG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczpjb3B5JywgKHsgcGF0aCwgZGVzdCB9KSA9PiBjb3B5KHBhdGgsIGRlc3QpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOm91dHB1dC1qc29uJywgKHsgcGF0aCwgZGF0YSB9KSA9PiBvdXRwdXRKc29uKHBhdGgsIGRhdGEpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnJlYWQtanNvbicsIChwYXRoKSA9PiByZWFkSnNvbihwYXRoKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdmczplbnN1cmVEaXInLCAocGF0aCkgPT4gZW5zdXJlRGlyKHBhdGgpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2ZzOnBhdGhFeGlzdHMnLCAocGF0aCkgPT4gcGF0aEV4aXN0c1N5bmMocGF0aCkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignZnM6cmVtb3ZlJywgKHBhdGgpID0+IHJlbW92ZShwYXRoKSk7XG5cbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ2hlbHBlcjpyZWxhdW5jaCcsIChvcHRpb25zID0ge30pID0+IHtcbiAgYXBwLnJlbGF1bmNoKHsgYXJnczogcHJvY2Vzcy5hcmd2LnNsaWNlKDEpLmNvbmNhdChbJy0tcmVsYXVuY2gnXSksIC4uLm9wdGlvbnMgfSk7XG4gIGFwcC5leGl0KDApO1xufSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdoZWxwZXI6Z2V0LXBhdGgnLCAobmFtZSkgPT4gYXBwLmdldFBhdGgobmFtZSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignaGVscGVyOmlzLWRhcmstdGhlbWUnLCAoKSA9PiBuYXRpdmVUaGVtZS5zaG91bGRVc2VEYXJrQ29sb3JzKTtcblxuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpzdG9yZScsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uc3RvcmUpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpyZXBsYWNlJywgKHsgbmFtZSwgZGF0YSB9KSA9PiAoc3RvcmVbbmFtZV0uc3RvcmUgPSBkYXRhKSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmdldCcsICh7IG5hbWUsIGtleSwgZGVmIH0pID0+IHN0b3JlW25hbWVdPy5nZXQoa2V5LCBkZWYpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6c2V0JywgKHsgbmFtZSwga2V5LCB2YWx1ZSB9KSA9PiBzdG9yZVtuYW1lXT8uc2V0KGtleSwgdmFsdWUpKTtcbmlwY01haW4uYW5zd2VyUmVuZGVyZXIoJ3N0b3JhZ2U6ZGVsZXRlJywgKHsgbmFtZSwga2V5IH0pID0+IHN0b3JlW25hbWVdPy5kZWxldGUoa2V5KSk7XG5pcGNNYWluLmFuc3dlclJlbmRlcmVyKCdzdG9yYWdlOmhhcycsICh7IG5hbWUsIGtleSB9KSA9PiBzdG9yZVtuYW1lXT8uaGFzKGtleSkpO1xuaXBjTWFpbi5hbnN3ZXJSZW5kZXJlcignc3RvcmFnZTpjbGVhcicsIChuYW1lKSA9PiBzdG9yZVtuYW1lXT8uY2xlYXIoKSk7XG4iXSwibmFtZXMiOlsic2VyaWFsaXplRXJyb3IiLCJkZXNlcmlhbGl6ZUVycm9yIiwiZWxlY3Ryb24iLCJyZXF1aXJlJCQwIiwicmVxdWlyZSQkMSIsInV0aWwiLCJyZXF1aXJlJCQyIiwiaXBjUmVuZGVyZXIiLCJpcGMiLCJpcGNNYWluIiwibWFpbiIsImNvbnN0YW50cyIsInBvbHlmaWxscyIsInBhdGNoIiwibGVnYWN5IiwiY2xvbmUiLCJmcyIsInJlcXVpcmUkJDMiLCJyZXF1aXJlJCQ0IiwiZGVidWciLCJnbG9iYWwiLCJyZXF1aXJlJCQ1IiwicGF0aCIsInUiLCJta2RpcnMiLCJ1dGltZXNNaWxsaXMiLCJ1dGltZXNNaWxsaXNTeW5jIiwiZ2V0U3RhdHMiLCJhcmVJZGVudGljYWwiLCJzdGF0IiwibWtkaXJzU3luYyIsIm9uRGlyIiwib25GaWxlIiwib25MaW5rIiwiY29weUZpbGUiLCJtYXlDb3B5RmlsZSIsInNldERlc3RNb2RlIiwiZmlsZUlzTm90V3JpdGFibGUiLCJtYWtlRmlsZVdyaXRhYmxlIiwic2V0RGVzdFRpbWVzdGFtcHMiLCJta0RpckFuZENvcHkiLCJjb3B5RGlyIiwiY29weURpckl0ZW0iLCJzdGFydENvcHkiLCJjb3B5TGluayIsImNvcHlTeW5jIiwicGF0aEV4aXN0cyIsImNvcHkiLCJkZWZhdWx0cyIsInJpbXJhZiIsInJlbW92ZSIsInJlbW92ZVN5bmMiLCJta2RpciIsImZpbGUiLCJsaW5rIiwic3ltbGlua1BhdGhzIiwic3ltbGlua1BhdGhzU3luYyIsInN5bWxpbmtUeXBlIiwic3ltbGlua1R5cGVTeW5jIiwicmVxdWlyZSQkNiIsInJlcXVpcmUkJDciLCJzeW1saW5rIiwic3RyaW5naWZ5Iiwic3RyaXBCb20iLCJyZWFkRmlsZSIsIndyaXRlRmlsZSIsImpzb25maWxlIiwicmVhZEZpbGVTeW5jIiwid3JpdGVGaWxlU3luYyIsImpzb25GaWxlIiwib3V0cHV0RmlsZSIsIm91dHB1dEZpbGVTeW5jIiwianNvbiIsImlzUGFyZW50Um9vdCIsImRvUmVuYW1lIiwicmVuYW1lIiwibW92ZUFjcm9zc0RldmljZSIsIm1vdmVTeW5jIiwibW92ZSIsInJlcXVpcmUkJDgiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQxMSIsIkNhbmNlbGxhdGlvblRva2VuXzEiLCJldmVudHNfMSIsInBhcnNlIiwiY29tbW9uIiwiUHJvZ3Jlc3NDYWxsYmFja1RyYW5zZm9ybV8xIiwic3RyZWFtXzEiLCJjcnlwdG9fMSIsImRlYnVnXzEiLCJmc18xIiwidXJsXzEiLCJpbmRleF8xIiwiWUFNTEV4Y2VwdGlvbiIsIm1ha2VTbmlwcGV0IiwidHlwZSIsIlR5cGUiLCJTY2hlbWEiLCJzY2hlbWEiLCJjb3JlIiwiX2hhc093blByb3BlcnR5IiwiX3RvU3RyaW5nIiwiREVGQVVMVF9TQ0hFTUEiLCJTdGF0ZSIsInJlcXVpcmUkJDEyIiwiU0VNVkVSX1NQRUNfVkVSU0lPTiIsIk1BWF9MRU5HVEgiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSCIsIm9wdHMiLCJwYXJzZU9wdGlvbnMiLCJwYXJzZU9wdGlvbnNfMSIsIm51bWVyaWMiLCJjb21wYXJlSWRlbnRpZmllcnMiLCJyY29tcGFyZUlkZW50aWZpZXJzIiwiaWRlbnRpZmllcnMiLCJyZSIsInQiLCJTZW1WZXIiLCJzZW12ZXIiLCJwYXJzZV8xIiwidmFsaWQiLCJ2YWxpZF8xIiwiY2xlYW4iLCJjbGVhbl8xIiwiaW5jIiwiaW5jXzEiLCJjb21wYXJlIiwiY29tcGFyZV8xIiwiZXEiLCJlcV8xIiwiZGlmZiIsImRpZmZfMSIsIm1ham9yIiwibWFqb3JfMSIsIm1pbm9yIiwibWlub3JfMSIsInBhdGNoXzEiLCJwcmVyZWxlYXNlIiwicHJlcmVsZWFzZV8xIiwicmNvbXBhcmUiLCJyY29tcGFyZV8xIiwiY29tcGFyZUxvb3NlIiwiY29tcGFyZUxvb3NlXzEiLCJjb21wYXJlQnVpbGQiLCJjb21wYXJlQnVpbGRfMSIsInNvcnQiLCJzb3J0XzEiLCJyc29ydCIsInJzb3J0XzEiLCJndCIsImd0XzEiLCJsdCIsImx0XzEiLCJuZXEiLCJuZXFfMSIsImd0ZSIsImd0ZV8xIiwibHRlIiwibHRlXzEiLCJjbXAiLCJjbXBfMSIsImNvZXJjZSIsImNvZXJjZV8xIiwiWWFsbGlzdCIsIlJhbmdlIiwiQ29tcGFyYXRvciIsImlzTnVsbFNldCIsImlzQW55IiwiY2FjaGUiLCJoeXBoZW5SZXBsYWNlIiwiY29tcGFyYXRvclRyaW1SZXBsYWNlIiwidGlsZGVUcmltUmVwbGFjZSIsImNhcmV0VHJpbVJlcGxhY2UiLCJwYXJzZUNvbXBhcmF0b3IiLCJyZXBsYWNlR1RFMCIsImlzU2F0aXNmaWFibGUiLCJ0ZXN0U2V0IiwicmFuZ2UiLCJMUlUiLCJyZXBsYWNlQ2FyZXRzIiwicmVwbGFjZVRpbGRlcyIsInJlcGxhY2VYUmFuZ2VzIiwicmVwbGFjZVN0YXJzIiwiaXNYIiwicmVwbGFjZVRpbGRlIiwicmVwbGFjZUNhcmV0IiwicmVwbGFjZVhSYW5nZSIsIkFOWSIsImNvbXBhcmF0b3IiLCJzYXRpc2ZpZXMiLCJzYXRpc2ZpZXNfMSIsInRvQ29tcGFyYXRvcnMiLCJ0b0NvbXBhcmF0b3JzXzEiLCJtYXhTYXRpc2Z5aW5nIiwibWF4U2F0aXNmeWluZ18xIiwibWluU2F0aXNmeWluZyIsIm1pblNhdGlzZnlpbmdfMSIsIm1pblZlcnNpb24iLCJtaW5WZXJzaW9uXzEiLCJ2YWxpZFJhbmdlIiwib3V0c2lkZSIsIm91dHNpZGVfMSIsImd0ciIsImd0cl8xIiwibHRyIiwibHRyXzEiLCJpbnRlcnNlY3RzIiwiaW50ZXJzZWN0c18xIiwic2ltcGxpZnkiLCJzdWJzZXQiLCJzaW1wbGVTdWJzZXQiLCJoaWdoZXJHVCIsImxvd2VyTFQiLCJzdWJzZXRfMSIsImludGVybmFsUmUiLCJyZXF1aXJlJCQxMyIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTUiLCJyZXF1aXJlJCQxNiIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTgiLCJyZXF1aXJlJCQxOSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMjEiLCJyZXF1aXJlJCQyMiIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjQiLCJyZXF1aXJlJCQyNSIsInJlcXVpcmUkJDI2IiwicmVxdWlyZSQkMjciLCJyZXF1aXJlJCQyOCIsInJlcXVpcmUkJDI5IiwicmVxdWlyZSQkMzAiLCJyZXF1aXJlJCQzMSIsInJlcXVpcmUkJDMyIiwicmVxdWlyZSQkMzMiLCJyZXF1aXJlJCQzNCIsInJlcXVpcmUkJDM1IiwicmVxdWlyZSQkMzYiLCJyZXF1aXJlJCQzNyIsInJlcXVpcmUkJDM4IiwicmVxdWlyZSQkMzkiLCJyZXF1aXJlJCQ0MCIsIkRvd25sb2FkZWRVcGRhdGVIZWxwZXJfMSIsImZzX2V4dHJhXzEiLCJFbGVjdHJvbkFwcEFkYXB0ZXJfMSIsIlN5bWJvbCIsImVzY2FwZVJlZ0V4cCIsIlByb3ZpZGVyXzEiLCJidWlsZGVyX3V0aWxfcnVudGltZV8xIiwianNfeWFtbF8xIiwidXRpbF8xIiwiR2VuZXJpY1Byb3ZpZGVyXzEiLCJCaW50cmF5UHJvdmlkZXJfMSIsIkdpdEh1YlByb3ZpZGVyXzEiLCJLZXlnZW5Qcm92aWRlcl8xIiwiUHJpdmF0ZUdpdEh1YlByb3ZpZGVyXzEiLCJBcHBVcGRhdGVyXzEiLCJtYWluXzEiLCJCYXNlVXBkYXRlcl8xIiwiRGF0YVNwbGl0dGVyXzEiLCJkb3dubG9hZFBsYW5CdWlsZGVyXzEiLCJQcm9ncmVzc0RpZmZlcmVudGlhbERvd25sb2FkQ2FsbGJhY2tUcmFuc2Zvcm1fMSIsIkRpZmZlcmVudGlhbERvd25sb2FkZXJfMSIsIkZpbGVXaXRoRW1iZWRkZWRCbG9ja01hcERpZmZlcmVudGlhbERvd25sb2FkZXJfMSIsInpsaWJfMSIsIkFwcEltYWdlVXBkYXRlcl8xIiwiY2hpbGRfcHJvY2Vzc18xIiwiTWFjVXBkYXRlcl8xIiwiR2VuZXJpY0RpZmZlcmVudGlhbERvd25sb2FkZXJfMSIsIm9zIiwiTnNpc1VwZGF0ZXJfMSIsImlzT2JqIiwicGF0aEV4aXN0c01vZHVsZSIsInBUcnkiLCJwVHJ5TW9kdWxlIiwicExpbWl0IiwicExpbWl0TW9kdWxlIiwicExvY2F0ZSIsImxvY2F0ZVBhdGhNb2R1bGUiLCJmaW5kVXBNb2R1bGUiLCJwa2dVcE1vZHVsZSIsImVudiIsImVudlBhdGhzTW9kdWxlIiwiY29uc3RzXzEiLCJkaXN0IiwibmFtZXNfMSIsImNvZGVnZW5fMSIsImVycm9yc18xIiwiY29kZV8xIiwidHJhdmVyc2UiLCJqc29uU2NoZW1hVHJhdmVyc2VNb2R1bGUiLCJ0aGlzIiwicmVzb2x2ZSIsImVxdWFsIiwiVVJJIiwiZGF0YVR5cGVfMSIsInJlc29sdmVfMSIsInZhbGlkYXRlXzEiLCJkZWYiLCJjb3JlXzEiLCJlcnJvciIsInVjczJsZW5ndGhfMSIsImVxdWFsXzEiLCJ2YWxpZGF0aW9uXzEiLCJpdGVtc18xIiwiYWRkaXRpb25hbEl0ZW1zXzEiLCJwcm9wZXJ0aWVzIiwiYWRkaXRpb25hbFByb3BlcnRpZXNfMSIsImZvcm1hdCIsImZvcm1hdF8yIiwiZm9ybWF0XzEiLCJtaW1pY0ZuIiwibWltaWNGbk1vZHVsZSIsIm9uZXRpbWVNb2R1bGUiLCJkb3RQcm9wIiwicGtnVXAiLCJkZWJvdW5jZUZuIiwic3RvcmUiLCJTdG9yZSIsImFwcCIsImRhdGEiLCJCcm93c2VyV2luZG93Iiwiam9pbiIsInNoZWxsIiwicHJvdG9jb2wiLCJub3JtYWxpemUiLCJlbnN1cmVEaXIiLCJkaWFsb2ciLCJvdXRwdXRKc29uIiwicmVhZEpzb24iLCJwYXRoRXhpc3RzU3luYyIsIm5hdGl2ZVRoZW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsdUJBQXVCLE1BQU07QUFBQSxFQUM1QixZQUFZLFNBQVM7QUFDcEIsVUFBTSxTQUFTLHFCQUFxQjtBQUNwQyxXQUFPLGVBQWUsTUFBTSxRQUFRO0FBQUEsTUFDbkMsT0FBTztBQUFBLE1BQ1AsY0FBYztBQUFBLE1BQ2QsVUFBVTtBQUFBO0FBR1gsUUFBSSxNQUFNLG1CQUFtQjtBQUM1QixZQUFNLGtCQUFrQixNQUFNO0FBQUE7QUFBQTtBQUFBLFNBSXpCLHFCQUFxQixTQUFTO0FBQ3BDLFFBQUk7QUFDSCxhQUFPLEtBQUssVUFBVTtBQUFBLFlBQ3JCO0FBQ0QsYUFBTyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBS2pCLE1BQU0sbUJBQW1CO0FBQUEsRUFDeEIsRUFBQyxVQUFVLFFBQVEsWUFBWTtBQUFBLEVBQy9CLEVBQUMsVUFBVSxXQUFXLFlBQVk7QUFBQSxFQUNsQyxFQUFDLFVBQVUsU0FBUyxZQUFZO0FBQUEsRUFDaEMsRUFBQyxVQUFVLFFBQVEsWUFBWTtBQUFBO0FBR2hDLE1BQU0sV0FBVyxPQUFPO0FBRXhCLE1BQU0sU0FBUyxVQUFRO0FBQ3RCLE9BQUssWUFBWTtBQUNqQixRQUFNLFFBQU8sS0FBSztBQUNsQixTQUFPLEtBQUs7QUFDWixTQUFPO0FBQUE7QUFHUixNQUFNLGtCQUFrQixDQUFDO0FBQUEsRUFDeEI7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLE1BQ0s7QUFDTCxRQUFNLEtBQUssT0FBUSxPQUFNLFFBQVEsUUFBUSxLQUFLO0FBRTlDLE9BQUssS0FBSztBQUVWLE1BQUksU0FB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QUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxXQUFXO0FBQUEsTUFDWCxRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxPQUFPO0FBQUEsTUFDUCxXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxXQUFXO0FBQUEsTUFDWCxRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxPQUFPO0FBQUEsTUFDUCxXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxZQUFZO0FBQUEsTUFDWixTQUFTO0FBQUEsTUFDVCxPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxXQUFXO0FBQUEsTUFDWCxRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixVQUFVO0FBQUEsTUFDVixRQUFRO0FBQUEsTUFDUixRQUFRO0FBQUEsTUFDUixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixTQUFTO0FBQUE7QUFHWCxXQUFPLEtBQUssS0FBSSxVQUFVLFFB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
